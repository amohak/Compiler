Created by PLY version 3.8 (http://www.dabeaz.com/ply)

Unused terminals:

    KEYWORD_DEFINE
    KEYWORD_PACKAGE
    COMMENT
    KEYWORD_BREAK
    KEYWORD_YIELD
    KEYWORD_PRIVATE
    KEYWORD_IMPORT
    KEYWORD_OFDIM
    KEYWORD_EXTENDS
    COMMENT_END
    COMMENT_BEGIN
    KEYWORD_THIS
    KEYWORD_WITH
    KEYWORD_TYPE
    KEYWORD_PROTECTED
    KEYWORD_OVERRIDE

Grammar

Rule 0     S' -> ProgramStructure
Rule 1     ProgramStructure -> ProgramStructure class_and_objects
Rule 2     ProgramStructure -> class_and_objects
Rule 3     class_and_objects -> SingletonObject
Rule 4     class_and_objects -> class_declaration
Rule 5     SingletonObject -> ObjectDeclare block
Rule 6     ObjectDeclare -> KEYWORD_OBJECT IDENTIFIER
Rule 7     block -> start_scope block_statements_opt end_scope
Rule 8     start_scope -> BLOCKBEGIN
Rule 9     end_scope -> BLOCKEND
Rule 10    block_statements_opt -> block_statements
Rule 11    block_statements_opt -> empty
Rule 12    block_statements -> block_statement
Rule 13    block_statements -> block_statements marker block_statement
Rule 14    block_statement -> local_variable_declaration_statement
Rule 15    block_statement -> statement
Rule 16    block_statement -> class_declaration
Rule 17    block_statement -> SingletonObject
Rule 18    block_statement -> method_declaration
Rule 19    expression -> assignment_expression
Rule 20    expression_optional -> expression
Rule 21    expression_optional -> empty
Rule 22    assignment_expression -> assignment
Rule 23    assignment_expression -> conditional_or_expression
Rule 24    assignment_expression -> method_invocation
Rule 25    assignment -> valid_variable assignment_operator assignment_expression
Rule 26    valid_variable -> name
Rule 27    valid_variable -> array_access
Rule 28    array_access -> name dimension
Rule 29    dimension -> LBRAC expression RBRAC
Rule 30    assignment_operator -> ASOP
Rule 31    assignment_operator -> TIMES_ASSIGN
Rule 32    assignment_operator -> DIVIDE_ASSIGN
Rule 33    assignment_operator -> REMAINDER_ASSIGN
Rule 34    assignment_operator -> PLUS_ASSIGN
Rule 35    assignment_operator -> MINUS_ASSIGN
Rule 36    assignment_operator -> LSHIFT_ASSIGN
Rule 37    assignment_operator -> RSHIFT_ASSIGN
Rule 38    assignment_operator -> AND_ASSIGN
Rule 39    assignment_operator -> OR_ASSIGN
Rule 40    assignment_operator -> XOR_ASSIGN
Rule 41    marker -> empty
Rule 42    narker -> empty
Rule 43    conditional_or_expression -> conditional_and_expression
Rule 44    conditional_or_expression -> conditional_or_expression OR marker conditional_and_expression
Rule 45    conditional_and_expression -> inclusive_or_expression
Rule 46    conditional_and_expression -> conditional_and_expression AND marker inclusive_or_expression
Rule 47    inclusive_or_expression -> exclusive_or_expression
Rule 48    inclusive_or_expression -> inclusive_or_expression OR_BITWISE exclusive_or_expression
Rule 49    exclusive_or_expression -> and_expression
Rule 50    exclusive_or_expression -> exclusive_or_expression XOR and_expression
Rule 51    and_expression -> equality_expression
Rule 52    and_expression -> and_expression AND_BITWISE equality_expression
Rule 53    equality_expression -> relational_expression
Rule 54    equality_expression -> equality_expression EQUAL relational_expression
Rule 55    equality_expression -> equality_expression NEQUAL relational_expression
Rule 56    relational_expression -> shift_expression
Rule 57    relational_expression -> relational_expression GREATER shift_expression
Rule 58    relational_expression -> relational_expression LESS shift_expression
Rule 59    relational_expression -> relational_expression GEQ shift_expression
Rule 60    relational_expression -> relational_expression LEQ shift_expression
Rule 61    shift_expression -> additive_expression
Rule 62    shift_expression -> shift_expression LSHIFT additive_expression
Rule 63    shift_expression -> shift_expression RSHIFT additive_expression
Rule 64    additive_expression -> multiplicative_expression
Rule 65    additive_expression -> additive_expression PLUS multiplicative_expression
Rule 66    additive_expression -> additive_expression MINUS multiplicative_expression
Rule 67    multiplicative_expression -> unary_expression
Rule 68    multiplicative_expression -> multiplicative_expression TIMES unary_expression
Rule 69    multiplicative_expression -> multiplicative_expression DIVIDE unary_expression
Rule 70    multiplicative_expression -> multiplicative_expression REMAINDER unary_expression
Rule 71    unary_expression -> PLUS unary_expression
Rule 72    unary_expression -> MINUS unary_expression
Rule 73    unary_expression -> unary_expression_not_plus_minus
Rule 74    unary_expression_not_plus_minus -> base_variable_set
Rule 75    unary_expression_not_plus_minus -> TILDA unary_expression
Rule 76    unary_expression_not_plus_minus -> cast_expression
Rule 77    unary_expression_not_plus_minus -> NOT unary_expression
Rule 78    base_variable_set -> variable_literal
Rule 79    base_variable_set -> LPAREN expression RPAREN
Rule 80    variable_literal -> valid_variable
Rule 81    variable_literal -> primary
Rule 82    cast_expression -> LPAREN primitive_type RPAREN unary_expression
Rule 83    primary -> literal
Rule 84    primary -> method_invocation
Rule 85    literal -> int_float
Rule 86    literal -> c_literal
Rule 87    c_literal -> CHAR
Rule 88    c_literal -> STRING
Rule 89    c_literal -> KEYWORD_NULL
Rule 90    c_literal -> BOOL_CONSTT
Rule 91    c_literal -> BOOL_CONSTF
Rule 92    int_float -> DOUBLE_NUMBER
Rule 93    int_float -> INT_NUMBER
Rule 94    method_invocation -> name LPAREN argument_list_opt RPAREN
Rule 95    argument_list_opt -> argument_list
Rule 96    argument_list_opt -> empty
Rule 97    argument_list -> expression
Rule 98    argument_list -> argument_list COMMA expression
Rule 99    declaration_keyword -> KEYWORD_VAR
Rule 100   declaration_keyword -> KEYWORD_VAL
Rule 101   local_variable_declaration_statement -> local_variable_declaration TERMINATOR
Rule 102   local_variable_declaration -> declaration_keyword variable_declaration_body
Rule 103   variable_declaration_initializer -> expression
Rule 104   variable_declaration_initializer -> array_initializer
Rule 105   variable_declaration_initializer -> class_initializer
Rule 106   variable_argument_list -> variable_declaration_initializer
Rule 107   variable_argument_list -> variable_argument_list COMMA variable_declaration_initializer
Rule 108   variable_declaration_body -> identifiers COLON type ASOP variable_declaration_initializer
Rule 109   identifiers -> identifiers COMMA IDENTIFIER
Rule 110   identifiers -> IDENTIFIER
Rule 111   variable_list -> variable_declarator_id
Rule 112   variable_list -> variable_list COMMA variable_declarator_id
Rule 113   variable_dec -> IDENTIFIER type_opt
Rule 114   expr_opt -> ASOP variable_declaration_initializer
Rule 115   expr_opt -> empty
Rule 116   variable_declarator_id -> IDENTIFIER COLON type
Rule 117   fun_variable_declarator_id -> IDENTIFIER COLON type
Rule 118   type -> primitive_type
Rule 119   type -> reference_type
Rule 120   primitive_type -> TYPE_INT
Rule 121   primitive_type -> TYPE_DOUBLE
Rule 122   primitive_type -> TYPE_CHAR
Rule 123   primitive_type -> TYPE_STRING
Rule 124   primitive_type -> TYPE_BOOLEAN
Rule 125   primitive_type -> TYPE_VOID
Rule 126   reference_type -> class_data_type
Rule 127   reference_type -> array_data_type
Rule 128   class_data_type -> name
Rule 129   array_data_type -> KEYWORD_ARRAY LBRAC TYPE_INT RBRAC
Rule 130   name -> simple_name
Rule 131   name -> qualified_name
Rule 132   simple_name -> IDENTIFIER
Rule 133   qualified_name -> name INST simple_name
Rule 134   array_initializer -> KEYWORD_NEW KEYWORD_ARRAY LBRAC type RBRAC LPAREN conditional_or_expression RPAREN
Rule 135   array_initializer -> KEYWORD_ARRAY LBRAC type RBRAC LPAREN argument_list RPAREN
Rule 136   class_initializer -> KEYWORD_NEW name LPAREN argument_list_opt RPAREN
Rule 137   statement -> normal_statement marker
Rule 138   statement -> if_then_statement marker
Rule 139   statement -> if_then_else_statement marker
Rule 140   statement -> while_statement marker
Rule 141   statement -> do_while_statement marker
Rule 142   statement -> for_statement marker
Rule 143   normal_statement -> block marker
Rule 144   normal_statement -> expression_statement marker
Rule 145   normal_statement -> empty_statement marker
Rule 146   normal_statement -> return_statement marker
Rule 147   normal_statement -> switch_statement marker
Rule 148   expression_statement -> statement_expression TERMINATOR
Rule 149   statement_expression -> assignment
Rule 150   statement_expression -> method_invocation
Rule 151   if_then_statement -> KEYWORD_IF LPAREN expression RPAREN marker block
Rule 152   if_then_else_statement -> KEYWORD_IF LPAREN expression RPAREN marker if_then_else_intermediate narker KEYWORD_ELSE marker block
Rule 153   if_then_else_statement_precedence -> KEYWORD_IF LPAREN expression RPAREN marker if_then_else_intermediate narker KEYWORD_ELSE marker if_then_else_intermediate
Rule 154   if_then_else_intermediate -> normal_statement
Rule 155   if_then_else_intermediate -> if_then_else_statement_precedence
Rule 156   while_statement -> KEYWORD_WHILE LPAREN marker expression RPAREN marker block
Rule 157   do_while_statement -> KEYWORD_DO marker block KEYWORD_WHILE LPAREN marker expression RPAREN TERMINATOR
Rule 158   for_statement -> KEYWORD_FOR LPAREN for_update RPAREN marker block
Rule 159   for_update -> for_loop marker for_step_opts
Rule 160   for_loop -> IDENTIFIER CHOOSE expression for_untilTo marker expression
Rule 161   for_untilTo -> KEYWORD_UNTIL
Rule 162   for_untilTo -> KEYWORD_TO
Rule 163   for_step_opts -> KEYWORD_BY expression
Rule 164   for_step_opts -> empty
Rule 165   switch_statement -> expression KEYWORD_MATCH switch_block marker
Rule 166   switch_block -> BLOCKBEGIN BLOCKEND
Rule 167   switch_block -> BLOCKBEGIN switch_block_statements BLOCKEND
Rule 168   switch_block_statements -> switch_block_statement marker
Rule 169   switch_block_statements -> switch_block_statements switch_block_statement marker
Rule 170   switch_block_statement -> switch_label narker marker block narker
Rule 171   switch_label -> KEYWORD_CASE expression FUNTYPE
Rule 172   empty_statement -> TERMINATOR
Rule 173   return_statement -> KEYWORD_RETURN expression_optional TERMINATOR
Rule 174   method_declaration -> method_header method_body
Rule 175   method_header -> method_header_name func_arg_start fun_params_opt RPAREN COLON method_return_type ASOP
Rule 176   func_arg_start -> LPAREN
Rule 177   fun_params_opt -> fun_params
Rule 178   fun_params_opt -> empty
Rule 179   fun_params -> fun_variable_declarator_id
Rule 180   fun_params -> fun_params COMMA fun_variable_declarator_id
Rule 181   method_return_type -> type
Rule 182   method_return_type -> TYPE_VOID
Rule 183   method_header_name -> KEYWORD_DEF IDENTIFIER
Rule 184   method_body -> method_start_scope block_statements_opt end_scope
Rule 185   method_start_scope -> BLOCKBEGIN
Rule 186   class_declaration -> class_header class_body
Rule 187   class_header -> KEYWORD_CLASS simple_name class_param_clause
Rule 188   class_param_clause -> func_arg_start class_params_opt RPAREN
Rule 189   class_params_opt -> class_params
Rule 190   class_params_opt -> empty
Rule 191   class_params -> class_param
Rule 192   class_params -> class_params COMMA class_param
Rule 193   class_param -> class_declaration_keyword_opt variable_declarator_id
Rule 194   class_declaration_keyword_opt -> declaration_keyword
Rule 195   class_declaration_keyword_opt -> empty
Rule 196   type_opt -> COLON type
Rule 197   type_opt -> empty
Rule 198   class_body -> class_body_start block_statements_opt end_scope
Rule 199   class_body_start -> BLOCKBEGIN
Rule 200   empty -> <empty>

Terminals, with rules where they appear

AND                  : 46
AND_ASSIGN           : 38
AND_BITWISE          : 52
ASOP                 : 30 108 114 175
BLOCKBEGIN           : 8 166 167 185 199
BLOCKEND             : 9 166 167
BOOL_CONSTF          : 91
BOOL_CONSTT          : 90
CHAR                 : 87
CHOOSE               : 160
COLON                : 108 116 117 175 196
COMMA                : 98 107 109 112 180 192
COMMENT              : 
COMMENT_BEGIN        : 
COMMENT_END          : 
DIVIDE               : 69
DIVIDE_ASSIGN        : 32
DOUBLE_NUMBER        : 92
EQUAL                : 54
FUNTYPE              : 171
GEQ                  : 59
GREATER              : 57
IDENTIFIER           : 6 109 110 113 116 117 132 160 183
INST                 : 133
INT_NUMBER           : 93
KEYWORD_ARRAY        : 129 134 135
KEYWORD_BREAK        : 
KEYWORD_BY           : 163
KEYWORD_CASE         : 171
KEYWORD_CLASS        : 187
KEYWORD_DEF          : 183
KEYWORD_DEFINE       : 
KEYWORD_DO           : 157
KEYWORD_ELSE         : 152 153
KEYWORD_EXTENDS      : 
KEYWORD_FOR          : 158
KEYWORD_IF           : 151 152 153
KEYWORD_IMPORT       : 
KEYWORD_MATCH        : 165
KEYWORD_NEW          : 134 136
KEYWORD_NULL         : 89
KEYWORD_OBJECT       : 6
KEYWORD_OFDIM        : 
KEYWORD_OVERRIDE     : 
KEYWORD_PACKAGE      : 
KEYWORD_PRIVATE      : 
KEYWORD_PROTECTED    : 
KEYWORD_RETURN       : 173
KEYWORD_THIS         : 
KEYWORD_TO           : 162
KEYWORD_TYPE         : 
KEYWORD_UNTIL        : 161
KEYWORD_VAL          : 100
KEYWORD_VAR          : 99
KEYWORD_WHILE        : 156 157
KEYWORD_WITH         : 
KEYWORD_YIELD        : 
LBRAC                : 29 129 134 135
LEQ                  : 60
LESS                 : 58
LPAREN               : 79 82 94 134 135 136 151 152 153 156 157 158 176
LSHIFT               : 62
LSHIFT_ASSIGN        : 36
MINUS                : 66 72
MINUS_ASSIGN         : 35
NEQUAL               : 55
NOT                  : 77
OR                   : 44
OR_ASSIGN            : 39
OR_BITWISE           : 48
PLUS                 : 65 71
PLUS_ASSIGN          : 34
RBRAC                : 29 129 134 135
REMAINDER            : 70
REMAINDER_ASSIGN     : 33
RPAREN               : 79 82 94 134 135 136 151 152 153 156 157 158 175 188
RSHIFT               : 63
RSHIFT_ASSIGN        : 37
STRING               : 88
TERMINATOR           : 101 148 157 172 173
TILDA                : 75
TIMES                : 68
TIMES_ASSIGN         : 31
TYPE_BOOLEAN         : 124
TYPE_CHAR            : 122
TYPE_DOUBLE          : 121
TYPE_INT             : 120 129
TYPE_STRING          : 123
TYPE_VOID            : 125 182
XOR                  : 50
XOR_ASSIGN           : 40
error                : 

Nonterminals, with rules where they appear

ObjectDeclare        : 5
ProgramStructure     : 1 0
SingletonObject      : 3 17
additive_expression  : 61 62 63 65 66
and_expression       : 49 50 52
argument_list        : 95 98 135
argument_list_opt    : 94 136
array_access         : 27
array_data_type      : 127
array_initializer    : 104
assignment           : 22 149
assignment_expression : 19 25
assignment_operator  : 25
base_variable_set    : 74
block                : 5 143 151 152 156 157 158 170
block_statement      : 12 13
block_statements     : 10 13
block_statements_opt : 7 184 198
c_literal            : 86
cast_expression      : 76
class_and_objects    : 1 2
class_body           : 186
class_body_start     : 198
class_data_type      : 126
class_declaration    : 4 16
class_declaration_keyword_opt : 193
class_header         : 186
class_initializer    : 105
class_param          : 191 192
class_param_clause   : 187
class_params         : 189 192
class_params_opt     : 188
conditional_and_expression : 43 44 46
conditional_or_expression : 23 44 134
declaration_keyword  : 102 194
dimension            : 28
do_while_statement   : 141
empty                : 11 21 41 42 96 115 164 178 190 195 197
empty_statement      : 145
end_scope            : 7 184 198
equality_expression  : 51 52 54 55
exclusive_or_expression : 47 48 50
expr_opt             : 
expression           : 20 29 79 97 98 103 151 152 153 156 157 160 160 163 165 171
expression_optional  : 173
expression_statement : 144
for_loop             : 159
for_statement        : 142
for_step_opts        : 159
for_untilTo          : 160
for_update           : 158
fun_params           : 177 180
fun_params_opt       : 175
fun_variable_declarator_id : 179 180
func_arg_start       : 175 188
identifiers          : 108 109
if_then_else_intermediate : 152 153 153
if_then_else_statement : 139
if_then_else_statement_precedence : 155
if_then_statement    : 138
inclusive_or_expression : 45 46 48
int_float            : 85
literal              : 83
local_variable_declaration : 101
local_variable_declaration_statement : 14
marker               : 13 44 46 137 138 139 140 141 142 143 144 145 146 147 151 152 152 153 153 156 156 157 157 158 159 160 165 168 169 170
method_body          : 174
method_declaration   : 18
method_header        : 174
method_header_name   : 175
method_invocation    : 24 84 150
method_return_type   : 175
method_start_scope   : 184
multiplicative_expression : 64 65 66 68 69 70
name                 : 26 28 94 128 133 136
narker               : 152 153 170 170
normal_statement     : 137 154
primary              : 81
primitive_type       : 82 118
qualified_name       : 131
reference_type       : 119
relational_expression : 53 54 55 57 58 59 60
return_statement     : 146
shift_expression     : 56 57 58 59 60 62 63
simple_name          : 130 133 187
start_scope          : 7
statement            : 15
statement_expression : 148
switch_block         : 165
switch_block_statement : 168 169
switch_block_statements : 167 169
switch_label         : 170
switch_statement     : 147
type                 : 108 116 117 134 135 181 196
type_opt             : 113
unary_expression     : 67 68 69 70 71 72 75 77 82
unary_expression_not_plus_minus : 73
valid_variable       : 25 80
variable_argument_list : 107
variable_dec         : 
variable_declaration_body : 102
variable_declaration_initializer : 106 107 108 114
variable_declarator_id : 111 112 193
variable_list        : 112
variable_literal     : 78
while_statement      : 140

Parsing method: LALR

state 0

    (0) S' -> . ProgramStructure
    (1) ProgramStructure -> . ProgramStructure class_and_objects
    (2) ProgramStructure -> . class_and_objects
    (3) class_and_objects -> . SingletonObject
    (4) class_and_objects -> . class_declaration
    (5) SingletonObject -> . ObjectDeclare block
    (186) class_declaration -> . class_header class_body
    (6) ObjectDeclare -> . KEYWORD_OBJECT IDENTIFIER
    (187) class_header -> . KEYWORD_CLASS simple_name class_param_clause

    KEYWORD_OBJECT  shift and go to state 8
    KEYWORD_CLASS   shift and go to state 1

    ProgramStructure               shift and go to state 2
    ObjectDeclare                  shift and go to state 3
    class_declaration              shift and go to state 4
    class_and_objects              shift and go to state 5
    SingletonObject                shift and go to state 6
    class_header                   shift and go to state 7

state 1

    (187) class_header -> KEYWORD_CLASS . simple_name class_param_clause
    (132) simple_name -> . IDENTIFIER

    IDENTIFIER      shift and go to state 9

    simple_name                    shift and go to state 10

state 2

    (0) S' -> ProgramStructure .
    (1) ProgramStructure -> ProgramStructure . class_and_objects
    (3) class_and_objects -> . SingletonObject
    (4) class_and_objects -> . class_declaration
    (5) SingletonObject -> . ObjectDeclare block
    (186) class_declaration -> . class_header class_body
    (6) ObjectDeclare -> . KEYWORD_OBJECT IDENTIFIER
    (187) class_header -> . KEYWORD_CLASS simple_name class_param_clause

    KEYWORD_OBJECT  shift and go to state 8
    KEYWORD_CLASS   shift and go to state 1

    ObjectDeclare                  shift and go to state 3
    class_declaration              shift and go to state 4
    class_and_objects              shift and go to state 11
    SingletonObject                shift and go to state 6
    class_header                   shift and go to state 7

state 3

    (5) SingletonObject -> ObjectDeclare . block
    (7) block -> . start_scope block_statements_opt end_scope
    (8) start_scope -> . BLOCKBEGIN

    BLOCKBEGIN      shift and go to state 12

    start_scope                    shift and go to state 13
    block                          shift and go to state 14

state 4

    (4) class_and_objects -> class_declaration .

    KEYWORD_OBJECT  reduce using rule 4 (class_and_objects -> class_declaration .)
    KEYWORD_CLASS   reduce using rule 4 (class_and_objects -> class_declaration .)
    $end            reduce using rule 4 (class_and_objects -> class_declaration .)


state 5

    (2) ProgramStructure -> class_and_objects .

    KEYWORD_OBJECT  reduce using rule 2 (ProgramStructure -> class_and_objects .)
    KEYWORD_CLASS   reduce using rule 2 (ProgramStructure -> class_and_objects .)
    $end            reduce using rule 2 (ProgramStructure -> class_and_objects .)


state 6

    (3) class_and_objects -> SingletonObject .

    KEYWORD_OBJECT  reduce using rule 3 (class_and_objects -> SingletonObject .)
    KEYWORD_CLASS   reduce using rule 3 (class_and_objects -> SingletonObject .)
    $end            reduce using rule 3 (class_and_objects -> SingletonObject .)


state 7

    (186) class_declaration -> class_header . class_body
    (198) class_body -> . class_body_start block_statements_opt end_scope
    (199) class_body_start -> . BLOCKBEGIN

    BLOCKBEGIN      shift and go to state 17

    class_body_start               shift and go to state 15
    class_body                     shift and go to state 16

state 8

    (6) ObjectDeclare -> KEYWORD_OBJECT . IDENTIFIER

    IDENTIFIER      shift and go to state 18


state 9

    (132) simple_name -> IDENTIFIER .

    INST            reduce using rule 132 (simple_name -> IDENTIFIER .)
    COMMA           reduce using rule 132 (simple_name -> IDENTIFIER .)
    RPAREN          reduce using rule 132 (simple_name -> IDENTIFIER .)
    LPAREN          reduce using rule 132 (simple_name -> IDENTIFIER .)
    LBRAC           reduce using rule 132 (simple_name -> IDENTIFIER .)
    TIMES           reduce using rule 132 (simple_name -> IDENTIFIER .)
    DIVIDE          reduce using rule 132 (simple_name -> IDENTIFIER .)
    REMAINDER       reduce using rule 132 (simple_name -> IDENTIFIER .)
    PLUS            reduce using rule 132 (simple_name -> IDENTIFIER .)
    MINUS           reduce using rule 132 (simple_name -> IDENTIFIER .)
    LSHIFT          reduce using rule 132 (simple_name -> IDENTIFIER .)
    RSHIFT          reduce using rule 132 (simple_name -> IDENTIFIER .)
    GREATER         reduce using rule 132 (simple_name -> IDENTIFIER .)
    LESS            reduce using rule 132 (simple_name -> IDENTIFIER .)
    GEQ             reduce using rule 132 (simple_name -> IDENTIFIER .)
    LEQ             reduce using rule 132 (simple_name -> IDENTIFIER .)
    EQUAL           reduce using rule 132 (simple_name -> IDENTIFIER .)
    NEQUAL          reduce using rule 132 (simple_name -> IDENTIFIER .)
    AND_BITWISE     reduce using rule 132 (simple_name -> IDENTIFIER .)
    XOR             reduce using rule 132 (simple_name -> IDENTIFIER .)
    OR_BITWISE      reduce using rule 132 (simple_name -> IDENTIFIER .)
    AND             reduce using rule 132 (simple_name -> IDENTIFIER .)
    OR              reduce using rule 132 (simple_name -> IDENTIFIER .)
    KEYWORD_MATCH   reduce using rule 132 (simple_name -> IDENTIFIER .)
    TERMINATOR      reduce using rule 132 (simple_name -> IDENTIFIER .)
    RBRAC           reduce using rule 132 (simple_name -> IDENTIFIER .)
    FUNTYPE         reduce using rule 132 (simple_name -> IDENTIFIER .)
    KEYWORD_UNTIL   reduce using rule 132 (simple_name -> IDENTIFIER .)
    KEYWORD_TO      reduce using rule 132 (simple_name -> IDENTIFIER .)
    KEYWORD_BY      reduce using rule 132 (simple_name -> IDENTIFIER .)
    ASOP            reduce using rule 132 (simple_name -> IDENTIFIER .)
    TIMES_ASSIGN    reduce using rule 132 (simple_name -> IDENTIFIER .)
    DIVIDE_ASSIGN   reduce using rule 132 (simple_name -> IDENTIFIER .)
    REMAINDER_ASSIGN reduce using rule 132 (simple_name -> IDENTIFIER .)
    PLUS_ASSIGN     reduce using rule 132 (simple_name -> IDENTIFIER .)
    MINUS_ASSIGN    reduce using rule 132 (simple_name -> IDENTIFIER .)
    LSHIFT_ASSIGN   reduce using rule 132 (simple_name -> IDENTIFIER .)
    RSHIFT_ASSIGN   reduce using rule 132 (simple_name -> IDENTIFIER .)
    AND_ASSIGN      reduce using rule 132 (simple_name -> IDENTIFIER .)
    OR_ASSIGN       reduce using rule 132 (simple_name -> IDENTIFIER .)
    XOR_ASSIGN      reduce using rule 132 (simple_name -> IDENTIFIER .)


state 10

    (187) class_header -> KEYWORD_CLASS simple_name . class_param_clause
    (188) class_param_clause -> . func_arg_start class_params_opt RPAREN
    (176) func_arg_start -> . LPAREN

    LPAREN          shift and go to state 21

    func_arg_start                 shift and go to state 19
    class_param_clause             shift and go to state 20

state 11

    (1) ProgramStructure -> ProgramStructure class_and_objects .

    KEYWORD_OBJECT  reduce using rule 1 (ProgramStructure -> ProgramStructure class_and_objects .)
    KEYWORD_CLASS   reduce using rule 1 (ProgramStructure -> ProgramStructure class_and_objects .)
    $end            reduce using rule 1 (ProgramStructure -> ProgramStructure class_and_objects .)


state 12

    (8) start_scope -> BLOCKBEGIN .

    KEYWORD_IF      reduce using rule 8 (start_scope -> BLOCKBEGIN .)
    KEYWORD_WHILE   reduce using rule 8 (start_scope -> BLOCKBEGIN .)
    KEYWORD_DO      reduce using rule 8 (start_scope -> BLOCKBEGIN .)
    KEYWORD_FOR     reduce using rule 8 (start_scope -> BLOCKBEGIN .)
    KEYWORD_CLASS   reduce using rule 8 (start_scope -> BLOCKBEGIN .)
    KEYWORD_OBJECT  reduce using rule 8 (start_scope -> BLOCKBEGIN .)
    KEYWORD_VAR     reduce using rule 8 (start_scope -> BLOCKBEGIN .)
    KEYWORD_VAL     reduce using rule 8 (start_scope -> BLOCKBEGIN .)
    TERMINATOR      reduce using rule 8 (start_scope -> BLOCKBEGIN .)
    KEYWORD_RETURN  reduce using rule 8 (start_scope -> BLOCKBEGIN .)
    KEYWORD_DEF     reduce using rule 8 (start_scope -> BLOCKBEGIN .)
    BLOCKBEGIN      reduce using rule 8 (start_scope -> BLOCKBEGIN .)
    IDENTIFIER      reduce using rule 8 (start_scope -> BLOCKBEGIN .)
    PLUS            reduce using rule 8 (start_scope -> BLOCKBEGIN .)
    MINUS           reduce using rule 8 (start_scope -> BLOCKBEGIN .)
    TILDA           reduce using rule 8 (start_scope -> BLOCKBEGIN .)
    NOT             reduce using rule 8 (start_scope -> BLOCKBEGIN .)
    LPAREN          reduce using rule 8 (start_scope -> BLOCKBEGIN .)
    DOUBLE_NUMBER   reduce using rule 8 (start_scope -> BLOCKBEGIN .)
    INT_NUMBER      reduce using rule 8 (start_scope -> BLOCKBEGIN .)
    CHAR            reduce using rule 8 (start_scope -> BLOCKBEGIN .)
    STRING          reduce using rule 8 (start_scope -> BLOCKBEGIN .)
    KEYWORD_NULL    reduce using rule 8 (start_scope -> BLOCKBEGIN .)
    BOOL_CONSTT     reduce using rule 8 (start_scope -> BLOCKBEGIN .)
    BOOL_CONSTF     reduce using rule 8 (start_scope -> BLOCKBEGIN .)
    BLOCKEND        reduce using rule 8 (start_scope -> BLOCKBEGIN .)


state 13

    (7) block -> start_scope . block_statements_opt end_scope
    (10) block_statements_opt -> . block_statements
    (11) block_statements_opt -> . empty
    (12) block_statements -> . block_statement
    (13) block_statements -> . block_statements marker block_statement
    (200) empty -> .
    (14) block_statement -> . local_variable_declaration_statement
    (15) block_statement -> . statement
    (16) block_statement -> . class_declaration
    (17) block_statement -> . SingletonObject
    (18) block_statement -> . method_declaration
    (101) local_variable_declaration_statement -> . local_variable_declaration TERMINATOR
    (137) statement -> . normal_statement marker
    (138) statement -> . if_then_statement marker
    (139) statement -> . if_then_else_statement marker
    (140) statement -> . while_statement marker
    (141) statement -> . do_while_statement marker
    (142) statement -> . for_statement marker
    (186) class_declaration -> . class_header class_body
    (5) SingletonObject -> . ObjectDeclare block
    (174) method_declaration -> . method_header method_body
    (102) local_variable_declaration -> . declaration_keyword variable_declaration_body
    (143) normal_statement -> . block marker
    (144) normal_statement -> . expression_statement marker
    (145) normal_statement -> . empty_statement marker
    (146) normal_statement -> . return_statement marker
    (147) normal_statement -> . switch_statement marker
    (151) if_then_statement -> . KEYWORD_IF LPAREN expression RPAREN marker block
    (152) if_then_else_statement -> . KEYWORD_IF LPAREN expression RPAREN marker if_then_else_intermediate narker KEYWORD_ELSE marker block
    (156) while_statement -> . KEYWORD_WHILE LPAREN marker expression RPAREN marker block
    (157) do_while_statement -> . KEYWORD_DO marker block KEYWORD_WHILE LPAREN marker expression RPAREN TERMINATOR
    (158) for_statement -> . KEYWORD_FOR LPAREN for_update RPAREN marker block
    (187) class_header -> . KEYWORD_CLASS simple_name class_param_clause
    (6) ObjectDeclare -> . KEYWORD_OBJECT IDENTIFIER
    (175) method_header -> . method_header_name func_arg_start fun_params_opt RPAREN COLON method_return_type ASOP
    (99) declaration_keyword -> . KEYWORD_VAR
    (100) declaration_keyword -> . KEYWORD_VAL
    (7) block -> . start_scope block_statements_opt end_scope
    (148) expression_statement -> . statement_expression TERMINATOR
    (172) empty_statement -> . TERMINATOR
    (173) return_statement -> . KEYWORD_RETURN expression_optional TERMINATOR
    (165) switch_statement -> . expression KEYWORD_MATCH switch_block marker
    (183) method_header_name -> . KEYWORD_DEF IDENTIFIER
    (8) start_scope -> . BLOCKBEGIN
    (149) statement_expression -> . assignment
    (150) statement_expression -> . method_invocation
    (19) expression -> . assignment_expression
    (25) assignment -> . valid_variable assignment_operator assignment_expression
    (94) method_invocation -> . name LPAREN argument_list_opt RPAREN
    (22) assignment_expression -> . assignment
    (23) assignment_expression -> . conditional_or_expression
    (24) assignment_expression -> . method_invocation
    (26) valid_variable -> . name
    (27) valid_variable -> . array_access
    (130) name -> . simple_name
    (131) name -> . qualified_name
    (43) conditional_or_expression -> . conditional_and_expression
    (44) conditional_or_expression -> . conditional_or_expression OR marker conditional_and_expression
    (28) array_access -> . name dimension
    (132) simple_name -> . IDENTIFIER
    (133) qualified_name -> . name INST simple_name
    (45) conditional_and_expression -> . inclusive_or_expression
    (46) conditional_and_expression -> . conditional_and_expression AND marker inclusive_or_expression
    (47) inclusive_or_expression -> . exclusive_or_expression
    (48) inclusive_or_expression -> . inclusive_or_expression OR_BITWISE exclusive_or_expression
    (49) exclusive_or_expression -> . and_expression
    (50) exclusive_or_expression -> . exclusive_or_expression XOR and_expression
    (51) and_expression -> . equality_expression
    (52) and_expression -> . and_expression AND_BITWISE equality_expression
    (53) equality_expression -> . relational_expression
    (54) equality_expression -> . equality_expression EQUAL relational_expression
    (55) equality_expression -> . equality_expression NEQUAL relational_expression
    (56) relational_expression -> . shift_expression
    (57) relational_expression -> . relational_expression GREATER shift_expression
    (58) relational_expression -> . relational_expression LESS shift_expression
    (59) relational_expression -> . relational_expression GEQ shift_expression
    (60) relational_expression -> . relational_expression LEQ shift_expression
    (61) shift_expression -> . additive_expression
    (62) shift_expression -> . shift_expression LSHIFT additive_expression
    (63) shift_expression -> . shift_expression RSHIFT additive_expression
    (64) additive_expression -> . multiplicative_expression
    (65) additive_expression -> . additive_expression PLUS multiplicative_expression
    (66) additive_expression -> . additive_expression MINUS multiplicative_expression
    (67) multiplicative_expression -> . unary_expression
    (68) multiplicative_expression -> . multiplicative_expression TIMES unary_expression
    (69) multiplicative_expression -> . multiplicative_expression DIVIDE unary_expression
    (70) multiplicative_expression -> . multiplicative_expression REMAINDER unary_expression
    (71) unary_expression -> . PLUS unary_expression
    (72) unary_expression -> . MINUS unary_expression
    (73) unary_expression -> . unary_expression_not_plus_minus
    (74) unary_expression_not_plus_minus -> . base_variable_set
    (75) unary_expression_not_plus_minus -> . TILDA unary_expression
    (76) unary_expression_not_plus_minus -> . cast_expression
    (77) unary_expression_not_plus_minus -> . NOT unary_expression
    (78) base_variable_set -> . variable_literal
    (79) base_variable_set -> . LPAREN expression RPAREN
    (82) cast_expression -> . LPAREN primitive_type RPAREN unary_expression
    (80) variable_literal -> . valid_variable
    (81) variable_literal -> . primary
    (83) primary -> . literal
    (84) primary -> . method_invocation
    (85) literal -> . int_float
    (86) literal -> . c_literal
    (92) int_float -> . DOUBLE_NUMBER
    (93) int_float -> . INT_NUMBER
    (87) c_literal -> . CHAR
    (88) c_literal -> . STRING
    (89) c_literal -> . KEYWORD_NULL
    (90) c_literal -> . BOOL_CONSTT
    (91) c_literal -> . BOOL_CONSTF

    BLOCKEND        reduce using rule 200 (empty -> .)
    KEYWORD_IF      shift and go to state 78
    KEYWORD_WHILE   shift and go to state 44
    KEYWORD_DO      shift and go to state 95
    KEYWORD_FOR     shift and go to state 94
    KEYWORD_CLASS   shift and go to state 1
    KEYWORD_OBJECT  shift and go to state 8
    KEYWORD_VAR     shift and go to state 47
    KEYWORD_VAL     shift and go to state 48
    TERMINATOR      shift and go to state 49
    KEYWORD_RETURN  shift and go to state 64
    KEYWORD_DEF     shift and go to state 76
    BLOCKBEGIN      shift and go to state 12
    IDENTIFIER      shift and go to state 9
    PLUS            shift and go to state 31
    MINUS           shift and go to state 24
    TILDA           shift and go to state 68
    NOT             shift and go to state 53
    LPAREN          shift and go to state 91
    DOUBLE_NUMBER   shift and go to state 28
    INT_NUMBER      shift and go to state 39
    CHAR            shift and go to state 59
    STRING          shift and go to state 72
    KEYWORD_NULL    shift and go to state 61
    BOOL_CONSTT     shift and go to state 30
    BOOL_CONSTF     shift and go to state 25

    expression_statement           shift and go to state 22
    unary_expression               shift and go to state 40
    exclusive_or_expression        shift and go to state 57
    normal_statement               shift and go to state 83
    ObjectDeclare                  shift and go to state 3
    primary                        shift and go to state 58
    declaration_keyword            shift and go to state 74
    if_then_statement              shift and go to state 60
    array_access                   shift and go to state 23
    switch_statement               shift and go to state 42
    simple_name                    shift and go to state 63
    block_statements_opt           shift and go to state 26
    qualified_name                 shift and go to state 75
    base_variable_set              shift and go to state 85
    inclusive_or_expression        shift and go to state 27
    method_declaration             shift and go to state 65
    cast_expression                shift and go to state 77
    block_statement                shift and go to state 66
    return_statement               shift and go to state 86
    while_statement                shift and go to state 29
    unary_expression_not_plus_minus shift and go to state 41
    and_expression                 shift and go to state 84
    statement                      shift and go to state 70
    c_literal                      shift and go to state 90
    statement_expression           shift and go to state 32
    method_invocation              shift and go to state 71
    conditional_or_expression      shift and go to state 43
    empty                          shift and go to state 73
    relational_expression          shift and go to state 69
    block_statements               shift and go to state 87
    for_statement                  shift and go to state 33
    local_variable_declaration_statement shift and go to state 34
    do_while_statement             shift and go to state 45
    int_float                      shift and go to state 35
    assignment                     shift and go to state 89
    multiplicative_expression      shift and go to state 46
    literal                        shift and go to state 67
    additive_expression            shift and go to state 62
    SingletonObject                shift and go to state 36
    start_scope                    shift and go to state 13
    method_header_name             shift and go to state 37
    class_header                   shift and go to state 7
    shift_expression               shift and go to state 50
    equality_expression            shift and go to state 79
    variable_literal               shift and go to state 51
    name                           shift and go to state 38
    assignment_expression          shift and go to state 88
    valid_variable                 shift and go to state 92
    method_header                  shift and go to state 80
    empty_statement                shift and go to state 81
    class_declaration              shift and go to state 93
    local_variable_declaration     shift and go to state 82
    expression                     shift and go to state 54
    conditional_and_expression     shift and go to state 52
    block                          shift and go to state 55
    if_then_else_statement         shift and go to state 56

state 14

    (5) SingletonObject -> ObjectDeclare block .

    KEYWORD_OBJECT  reduce using rule 5 (SingletonObject -> ObjectDeclare block .)
    KEYWORD_CLASS   reduce using rule 5 (SingletonObject -> ObjectDeclare block .)
    $end            reduce using rule 5 (SingletonObject -> ObjectDeclare block .)
    KEYWORD_IF      reduce using rule 5 (SingletonObject -> ObjectDeclare block .)
    KEYWORD_WHILE   reduce using rule 5 (SingletonObject -> ObjectDeclare block .)
    KEYWORD_DO      reduce using rule 5 (SingletonObject -> ObjectDeclare block .)
    KEYWORD_FOR     reduce using rule 5 (SingletonObject -> ObjectDeclare block .)
    KEYWORD_VAR     reduce using rule 5 (SingletonObject -> ObjectDeclare block .)
    KEYWORD_VAL     reduce using rule 5 (SingletonObject -> ObjectDeclare block .)
    TERMINATOR      reduce using rule 5 (SingletonObject -> ObjectDeclare block .)
    KEYWORD_RETURN  reduce using rule 5 (SingletonObject -> ObjectDeclare block .)
    KEYWORD_DEF     reduce using rule 5 (SingletonObject -> ObjectDeclare block .)
    BLOCKBEGIN      reduce using rule 5 (SingletonObject -> ObjectDeclare block .)
    IDENTIFIER      reduce using rule 5 (SingletonObject -> ObjectDeclare block .)
    PLUS            reduce using rule 5 (SingletonObject -> ObjectDeclare block .)
    MINUS           reduce using rule 5 (SingletonObject -> ObjectDeclare block .)
    TILDA           reduce using rule 5 (SingletonObject -> ObjectDeclare block .)
    NOT             reduce using rule 5 (SingletonObject -> ObjectDeclare block .)
    LPAREN          reduce using rule 5 (SingletonObject -> ObjectDeclare block .)
    DOUBLE_NUMBER   reduce using rule 5 (SingletonObject -> ObjectDeclare block .)
    INT_NUMBER      reduce using rule 5 (SingletonObject -> ObjectDeclare block .)
    CHAR            reduce using rule 5 (SingletonObject -> ObjectDeclare block .)
    STRING          reduce using rule 5 (SingletonObject -> ObjectDeclare block .)
    KEYWORD_NULL    reduce using rule 5 (SingletonObject -> ObjectDeclare block .)
    BOOL_CONSTT     reduce using rule 5 (SingletonObject -> ObjectDeclare block .)
    BOOL_CONSTF     reduce using rule 5 (SingletonObject -> ObjectDeclare block .)
    BLOCKEND        reduce using rule 5 (SingletonObject -> ObjectDeclare block .)


state 15

    (198) class_body -> class_body_start . block_statements_opt end_scope
    (10) block_statements_opt -> . block_statements
    (11) block_statements_opt -> . empty
    (12) block_statements -> . block_statement
    (13) block_statements -> . block_statements marker block_statement
    (200) empty -> .
    (14) block_statement -> . local_variable_declaration_statement
    (15) block_statement -> . statement
    (16) block_statement -> . class_declaration
    (17) block_statement -> . SingletonObject
    (18) block_statement -> . method_declaration
    (101) local_variable_declaration_statement -> . local_variable_declaration TERMINATOR
    (137) statement -> . normal_statement marker
    (138) statement -> . if_then_statement marker
    (139) statement -> . if_then_else_statement marker
    (140) statement -> . while_statement marker
    (141) statement -> . do_while_statement marker
    (142) statement -> . for_statement marker
    (186) class_declaration -> . class_header class_body
    (5) SingletonObject -> . ObjectDeclare block
    (174) method_declaration -> . method_header method_body
    (102) local_variable_declaration -> . declaration_keyword variable_declaration_body
    (143) normal_statement -> . block marker
    (144) normal_statement -> . expression_statement marker
    (145) normal_statement -> . empty_statement marker
    (146) normal_statement -> . return_statement marker
    (147) normal_statement -> . switch_statement marker
    (151) if_then_statement -> . KEYWORD_IF LPAREN expression RPAREN marker block
    (152) if_then_else_statement -> . KEYWORD_IF LPAREN expression RPAREN marker if_then_else_intermediate narker KEYWORD_ELSE marker block
    (156) while_statement -> . KEYWORD_WHILE LPAREN marker expression RPAREN marker block
    (157) do_while_statement -> . KEYWORD_DO marker block KEYWORD_WHILE LPAREN marker expression RPAREN TERMINATOR
    (158) for_statement -> . KEYWORD_FOR LPAREN for_update RPAREN marker block
    (187) class_header -> . KEYWORD_CLASS simple_name class_param_clause
    (6) ObjectDeclare -> . KEYWORD_OBJECT IDENTIFIER
    (175) method_header -> . method_header_name func_arg_start fun_params_opt RPAREN COLON method_return_type ASOP
    (99) declaration_keyword -> . KEYWORD_VAR
    (100) declaration_keyword -> . KEYWORD_VAL
    (7) block -> . start_scope block_statements_opt end_scope
    (148) expression_statement -> . statement_expression TERMINATOR
    (172) empty_statement -> . TERMINATOR
    (173) return_statement -> . KEYWORD_RETURN expression_optional TERMINATOR
    (165) switch_statement -> . expression KEYWORD_MATCH switch_block marker
    (183) method_header_name -> . KEYWORD_DEF IDENTIFIER
    (8) start_scope -> . BLOCKBEGIN
    (149) statement_expression -> . assignment
    (150) statement_expression -> . method_invocation
    (19) expression -> . assignment_expression
    (25) assignment -> . valid_variable assignment_operator assignment_expression
    (94) method_invocation -> . name LPAREN argument_list_opt RPAREN
    (22) assignment_expression -> . assignment
    (23) assignment_expression -> . conditional_or_expression
    (24) assignment_expression -> . method_invocation
    (26) valid_variable -> . name
    (27) valid_variable -> . array_access
    (130) name -> . simple_name
    (131) name -> . qualified_name
    (43) conditional_or_expression -> . conditional_and_expression
    (44) conditional_or_expression -> . conditional_or_expression OR marker conditional_and_expression
    (28) array_access -> . name dimension
    (132) simple_name -> . IDENTIFIER
    (133) qualified_name -> . name INST simple_name
    (45) conditional_and_expression -> . inclusive_or_expression
    (46) conditional_and_expression -> . conditional_and_expression AND marker inclusive_or_expression
    (47) inclusive_or_expression -> . exclusive_or_expression
    (48) inclusive_or_expression -> . inclusive_or_expression OR_BITWISE exclusive_or_expression
    (49) exclusive_or_expression -> . and_expression
    (50) exclusive_or_expression -> . exclusive_or_expression XOR and_expression
    (51) and_expression -> . equality_expression
    (52) and_expression -> . and_expression AND_BITWISE equality_expression
    (53) equality_expression -> . relational_expression
    (54) equality_expression -> . equality_expression EQUAL relational_expression
    (55) equality_expression -> . equality_expression NEQUAL relational_expression
    (56) relational_expression -> . shift_expression
    (57) relational_expression -> . relational_expression GREATER shift_expression
    (58) relational_expression -> . relational_expression LESS shift_expression
    (59) relational_expression -> . relational_expression GEQ shift_expression
    (60) relational_expression -> . relational_expression LEQ shift_expression
    (61) shift_expression -> . additive_expression
    (62) shift_expression -> . shift_expression LSHIFT additive_expression
    (63) shift_expression -> . shift_expression RSHIFT additive_expression
    (64) additive_expression -> . multiplicative_expression
    (65) additive_expression -> . additive_expression PLUS multiplicative_expression
    (66) additive_expression -> . additive_expression MINUS multiplicative_expression
    (67) multiplicative_expression -> . unary_expression
    (68) multiplicative_expression -> . multiplicative_expression TIMES unary_expression
    (69) multiplicative_expression -> . multiplicative_expression DIVIDE unary_expression
    (70) multiplicative_expression -> . multiplicative_expression REMAINDER unary_expression
    (71) unary_expression -> . PLUS unary_expression
    (72) unary_expression -> . MINUS unary_expression
    (73) unary_expression -> . unary_expression_not_plus_minus
    (74) unary_expression_not_plus_minus -> . base_variable_set
    (75) unary_expression_not_plus_minus -> . TILDA unary_expression
    (76) unary_expression_not_plus_minus -> . cast_expression
    (77) unary_expression_not_plus_minus -> . NOT unary_expression
    (78) base_variable_set -> . variable_literal
    (79) base_variable_set -> . LPAREN expression RPAREN
    (82) cast_expression -> . LPAREN primitive_type RPAREN unary_expression
    (80) variable_literal -> . valid_variable
    (81) variable_literal -> . primary
    (83) primary -> . literal
    (84) primary -> . method_invocation
    (85) literal -> . int_float
    (86) literal -> . c_literal
    (92) int_float -> . DOUBLE_NUMBER
    (93) int_float -> . INT_NUMBER
    (87) c_literal -> . CHAR
    (88) c_literal -> . STRING
    (89) c_literal -> . KEYWORD_NULL
    (90) c_literal -> . BOOL_CONSTT
    (91) c_literal -> . BOOL_CONSTF

    BLOCKEND        reduce using rule 200 (empty -> .)
    KEYWORD_IF      shift and go to state 78
    KEYWORD_WHILE   shift and go to state 44
    KEYWORD_DO      shift and go to state 95
    KEYWORD_FOR     shift and go to state 94
    KEYWORD_CLASS   shift and go to state 1
    KEYWORD_OBJECT  shift and go to state 8
    KEYWORD_VAR     shift and go to state 47
    KEYWORD_VAL     shift and go to state 48
    TERMINATOR      shift and go to state 49
    KEYWORD_RETURN  shift and go to state 64
    KEYWORD_DEF     shift and go to state 76
    BLOCKBEGIN      shift and go to state 12
    IDENTIFIER      shift and go to state 9
    PLUS            shift and go to state 31
    MINUS           shift and go to state 24
    TILDA           shift and go to state 68
    NOT             shift and go to state 53
    LPAREN          shift and go to state 91
    DOUBLE_NUMBER   shift and go to state 28
    INT_NUMBER      shift and go to state 39
    CHAR            shift and go to state 59
    STRING          shift and go to state 72
    KEYWORD_NULL    shift and go to state 61
    BOOL_CONSTT     shift and go to state 30
    BOOL_CONSTF     shift and go to state 25

    expression_statement           shift and go to state 22
    unary_expression               shift and go to state 40
    exclusive_or_expression        shift and go to state 57
    normal_statement               shift and go to state 83
    ObjectDeclare                  shift and go to state 3
    primary                        shift and go to state 58
    declaration_keyword            shift and go to state 74
    if_then_statement              shift and go to state 60
    array_access                   shift and go to state 23
    switch_statement               shift and go to state 42
    simple_name                    shift and go to state 63
    block_statements_opt           shift and go to state 96
    conditional_and_expression     shift and go to state 52
    qualified_name                 shift and go to state 75
    base_variable_set              shift and go to state 85
    inclusive_or_expression        shift and go to state 27
    method_declaration             shift and go to state 65
    cast_expression                shift and go to state 77
    block_statement                shift and go to state 66
    return_statement               shift and go to state 86
    while_statement                shift and go to state 29
    unary_expression_not_plus_minus shift and go to state 41
    and_expression                 shift and go to state 84
    statement                      shift and go to state 70
    c_literal                      shift and go to state 90
    statement_expression           shift and go to state 32
    method_invocation              shift and go to state 71
    conditional_or_expression      shift and go to state 43
    empty                          shift and go to state 73
    relational_expression          shift and go to state 69
    block_statements               shift and go to state 87
    for_statement                  shift and go to state 33
    local_variable_declaration_statement shift and go to state 34
    do_while_statement             shift and go to state 45
    int_float                      shift and go to state 35
    assignment                     shift and go to state 89
    multiplicative_expression      shift and go to state 46
    literal                        shift and go to state 67
    additive_expression            shift and go to state 62
    SingletonObject                shift and go to state 36
    start_scope                    shift and go to state 13
    method_header_name             shift and go to state 37
    class_header                   shift and go to state 7
    shift_expression               shift and go to state 50
    equality_expression            shift and go to state 79
    variable_literal               shift and go to state 51
    name                           shift and go to state 38
    valid_variable                 shift and go to state 92
    method_header                  shift and go to state 80
    empty_statement                shift and go to state 81
    class_declaration              shift and go to state 93
    local_variable_declaration     shift and go to state 82
    expression                     shift and go to state 54
    assignment_expression          shift and go to state 88
    block                          shift and go to state 55
    if_then_else_statement         shift and go to state 56

state 16

    (186) class_declaration -> class_header class_body .

    KEYWORD_OBJECT  reduce using rule 186 (class_declaration -> class_header class_body .)
    KEYWORD_CLASS   reduce using rule 186 (class_declaration -> class_header class_body .)
    $end            reduce using rule 186 (class_declaration -> class_header class_body .)
    KEYWORD_IF      reduce using rule 186 (class_declaration -> class_header class_body .)
    KEYWORD_WHILE   reduce using rule 186 (class_declaration -> class_header class_body .)
    KEYWORD_DO      reduce using rule 186 (class_declaration -> class_header class_body .)
    KEYWORD_FOR     reduce using rule 186 (class_declaration -> class_header class_body .)
    KEYWORD_VAR     reduce using rule 186 (class_declaration -> class_header class_body .)
    KEYWORD_VAL     reduce using rule 186 (class_declaration -> class_header class_body .)
    TERMINATOR      reduce using rule 186 (class_declaration -> class_header class_body .)
    KEYWORD_RETURN  reduce using rule 186 (class_declaration -> class_header class_body .)
    KEYWORD_DEF     reduce using rule 186 (class_declaration -> class_header class_body .)
    BLOCKBEGIN      reduce using rule 186 (class_declaration -> class_header class_body .)
    IDENTIFIER      reduce using rule 186 (class_declaration -> class_header class_body .)
    PLUS            reduce using rule 186 (class_declaration -> class_header class_body .)
    MINUS           reduce using rule 186 (class_declaration -> class_header class_body .)
    TILDA           reduce using rule 186 (class_declaration -> class_header class_body .)
    NOT             reduce using rule 186 (class_declaration -> class_header class_body .)
    LPAREN          reduce using rule 186 (class_declaration -> class_header class_body .)
    DOUBLE_NUMBER   reduce using rule 186 (class_declaration -> class_header class_body .)
    INT_NUMBER      reduce using rule 186 (class_declaration -> class_header class_body .)
    CHAR            reduce using rule 186 (class_declaration -> class_header class_body .)
    STRING          reduce using rule 186 (class_declaration -> class_header class_body .)
    KEYWORD_NULL    reduce using rule 186 (class_declaration -> class_header class_body .)
    BOOL_CONSTT     reduce using rule 186 (class_declaration -> class_header class_body .)
    BOOL_CONSTF     reduce using rule 186 (class_declaration -> class_header class_body .)
    BLOCKEND        reduce using rule 186 (class_declaration -> class_header class_body .)


state 17

    (199) class_body_start -> BLOCKBEGIN .

    KEYWORD_IF      reduce using rule 199 (class_body_start -> BLOCKBEGIN .)
    KEYWORD_WHILE   reduce using rule 199 (class_body_start -> BLOCKBEGIN .)
    KEYWORD_DO      reduce using rule 199 (class_body_start -> BLOCKBEGIN .)
    KEYWORD_FOR     reduce using rule 199 (class_body_start -> BLOCKBEGIN .)
    KEYWORD_CLASS   reduce using rule 199 (class_body_start -> BLOCKBEGIN .)
    KEYWORD_OBJECT  reduce using rule 199 (class_body_start -> BLOCKBEGIN .)
    KEYWORD_VAR     reduce using rule 199 (class_body_start -> BLOCKBEGIN .)
    KEYWORD_VAL     reduce using rule 199 (class_body_start -> BLOCKBEGIN .)
    TERMINATOR      reduce using rule 199 (class_body_start -> BLOCKBEGIN .)
    KEYWORD_RETURN  reduce using rule 199 (class_body_start -> BLOCKBEGIN .)
    KEYWORD_DEF     reduce using rule 199 (class_body_start -> BLOCKBEGIN .)
    BLOCKBEGIN      reduce using rule 199 (class_body_start -> BLOCKBEGIN .)
    IDENTIFIER      reduce using rule 199 (class_body_start -> BLOCKBEGIN .)
    PLUS            reduce using rule 199 (class_body_start -> BLOCKBEGIN .)
    MINUS           reduce using rule 199 (class_body_start -> BLOCKBEGIN .)
    TILDA           reduce using rule 199 (class_body_start -> BLOCKBEGIN .)
    NOT             reduce using rule 199 (class_body_start -> BLOCKBEGIN .)
    LPAREN          reduce using rule 199 (class_body_start -> BLOCKBEGIN .)
    DOUBLE_NUMBER   reduce using rule 199 (class_body_start -> BLOCKBEGIN .)
    INT_NUMBER      reduce using rule 199 (class_body_start -> BLOCKBEGIN .)
    CHAR            reduce using rule 199 (class_body_start -> BLOCKBEGIN .)
    STRING          reduce using rule 199 (class_body_start -> BLOCKBEGIN .)
    KEYWORD_NULL    reduce using rule 199 (class_body_start -> BLOCKBEGIN .)
    BOOL_CONSTT     reduce using rule 199 (class_body_start -> BLOCKBEGIN .)
    BOOL_CONSTF     reduce using rule 199 (class_body_start -> BLOCKBEGIN .)
    BLOCKEND        reduce using rule 199 (class_body_start -> BLOCKBEGIN .)


state 18

    (6) ObjectDeclare -> KEYWORD_OBJECT IDENTIFIER .

    BLOCKBEGIN      reduce using rule 6 (ObjectDeclare -> KEYWORD_OBJECT IDENTIFIER .)


state 19

    (188) class_param_clause -> func_arg_start . class_params_opt RPAREN
    (189) class_params_opt -> . class_params
    (190) class_params_opt -> . empty
    (191) class_params -> . class_param
    (192) class_params -> . class_params COMMA class_param
    (200) empty -> .
    (193) class_param -> . class_declaration_keyword_opt variable_declarator_id
    (194) class_declaration_keyword_opt -> . declaration_keyword
    (195) class_declaration_keyword_opt -> . empty
    (99) declaration_keyword -> . KEYWORD_VAR
    (100) declaration_keyword -> . KEYWORD_VAL

    RPAREN          reduce using rule 200 (empty -> .)
    IDENTIFIER      reduce using rule 200 (empty -> .)
    KEYWORD_VAR     shift and go to state 47
    KEYWORD_VAL     shift and go to state 48

    class_params_opt               shift and go to state 97
    declaration_keyword            shift and go to state 98
    class_param                    shift and go to state 99
    class_params                   shift and go to state 100
    empty                          shift and go to state 102
    class_declaration_keyword_opt  shift and go to state 101

state 20

    (187) class_header -> KEYWORD_CLASS simple_name class_param_clause .

    BLOCKBEGIN      reduce using rule 187 (class_header -> KEYWORD_CLASS simple_name class_param_clause .)


state 21

    (176) func_arg_start -> LPAREN .

    KEYWORD_VAR     reduce using rule 176 (func_arg_start -> LPAREN .)
    KEYWORD_VAL     reduce using rule 176 (func_arg_start -> LPAREN .)
    RPAREN          reduce using rule 176 (func_arg_start -> LPAREN .)
    IDENTIFIER      reduce using rule 176 (func_arg_start -> LPAREN .)


state 22

    (144) normal_statement -> expression_statement . marker
    (41) marker -> . empty
    (200) empty -> .

    KEYWORD_IF      reduce using rule 200 (empty -> .)
    KEYWORD_WHILE   reduce using rule 200 (empty -> .)
    KEYWORD_DO      reduce using rule 200 (empty -> .)
    KEYWORD_FOR     reduce using rule 200 (empty -> .)
    KEYWORD_CLASS   reduce using rule 200 (empty -> .)
    KEYWORD_OBJECT  reduce using rule 200 (empty -> .)
    KEYWORD_VAR     reduce using rule 200 (empty -> .)
    KEYWORD_VAL     reduce using rule 200 (empty -> .)
    TERMINATOR      reduce using rule 200 (empty -> .)
    KEYWORD_RETURN  reduce using rule 200 (empty -> .)
    KEYWORD_DEF     reduce using rule 200 (empty -> .)
    BLOCKBEGIN      reduce using rule 200 (empty -> .)
    IDENTIFIER      reduce using rule 200 (empty -> .)
    PLUS            reduce using rule 200 (empty -> .)
    MINUS           reduce using rule 200 (empty -> .)
    TILDA           reduce using rule 200 (empty -> .)
    NOT             reduce using rule 200 (empty -> .)
    LPAREN          reduce using rule 200 (empty -> .)
    DOUBLE_NUMBER   reduce using rule 200 (empty -> .)
    INT_NUMBER      reduce using rule 200 (empty -> .)
    CHAR            reduce using rule 200 (empty -> .)
    STRING          reduce using rule 200 (empty -> .)
    KEYWORD_NULL    reduce using rule 200 (empty -> .)
    BOOL_CONSTT     reduce using rule 200 (empty -> .)
    BOOL_CONSTF     reduce using rule 200 (empty -> .)
    BLOCKEND        reduce using rule 200 (empty -> .)
    KEYWORD_ELSE    reduce using rule 200 (empty -> .)

    marker                         shift and go to state 103
    empty                          shift and go to state 104

state 23

    (27) valid_variable -> array_access .

    ASOP            reduce using rule 27 (valid_variable -> array_access .)
    TIMES_ASSIGN    reduce using rule 27 (valid_variable -> array_access .)
    DIVIDE_ASSIGN   reduce using rule 27 (valid_variable -> array_access .)
    REMAINDER_ASSIGN reduce using rule 27 (valid_variable -> array_access .)
    PLUS_ASSIGN     reduce using rule 27 (valid_variable -> array_access .)
    MINUS_ASSIGN    reduce using rule 27 (valid_variable -> array_access .)
    LSHIFT_ASSIGN   reduce using rule 27 (valid_variable -> array_access .)
    RSHIFT_ASSIGN   reduce using rule 27 (valid_variable -> array_access .)
    AND_ASSIGN      reduce using rule 27 (valid_variable -> array_access .)
    OR_ASSIGN       reduce using rule 27 (valid_variable -> array_access .)
    XOR_ASSIGN      reduce using rule 27 (valid_variable -> array_access .)
    TIMES           reduce using rule 27 (valid_variable -> array_access .)
    DIVIDE          reduce using rule 27 (valid_variable -> array_access .)
    REMAINDER       reduce using rule 27 (valid_variable -> array_access .)
    PLUS            reduce using rule 27 (valid_variable -> array_access .)
    MINUS           reduce using rule 27 (valid_variable -> array_access .)
    LSHIFT          reduce using rule 27 (valid_variable -> array_access .)
    RSHIFT          reduce using rule 27 (valid_variable -> array_access .)
    GREATER         reduce using rule 27 (valid_variable -> array_access .)
    LESS            reduce using rule 27 (valid_variable -> array_access .)
    GEQ             reduce using rule 27 (valid_variable -> array_access .)
    LEQ             reduce using rule 27 (valid_variable -> array_access .)
    EQUAL           reduce using rule 27 (valid_variable -> array_access .)
    NEQUAL          reduce using rule 27 (valid_variable -> array_access .)
    AND_BITWISE     reduce using rule 27 (valid_variable -> array_access .)
    XOR             reduce using rule 27 (valid_variable -> array_access .)
    OR_BITWISE      reduce using rule 27 (valid_variable -> array_access .)
    AND             reduce using rule 27 (valid_variable -> array_access .)
    OR              reduce using rule 27 (valid_variable -> array_access .)
    TERMINATOR      reduce using rule 27 (valid_variable -> array_access .)
    KEYWORD_MATCH   reduce using rule 27 (valid_variable -> array_access .)
    RPAREN          reduce using rule 27 (valid_variable -> array_access .)
    RBRAC           reduce using rule 27 (valid_variable -> array_access .)
    COMMA           reduce using rule 27 (valid_variable -> array_access .)
    FUNTYPE         reduce using rule 27 (valid_variable -> array_access .)
    KEYWORD_UNTIL   reduce using rule 27 (valid_variable -> array_access .)
    KEYWORD_TO      reduce using rule 27 (valid_variable -> array_access .)
    KEYWORD_BY      reduce using rule 27 (valid_variable -> array_access .)


state 24

    (72) unary_expression -> MINUS . unary_expression
    (71) unary_expression -> . PLUS unary_expression
    (72) unary_expression -> . MINUS unary_expression
    (73) unary_expression -> . unary_expression_not_plus_minus
    (74) unary_expression_not_plus_minus -> . base_variable_set
    (75) unary_expression_not_plus_minus -> . TILDA unary_expression
    (76) unary_expression_not_plus_minus -> . cast_expression
    (77) unary_expression_not_plus_minus -> . NOT unary_expression
    (78) base_variable_set -> . variable_literal
    (79) base_variable_set -> . LPAREN expression RPAREN
    (82) cast_expression -> . LPAREN primitive_type RPAREN unary_expression
    (80) variable_literal -> . valid_variable
    (81) variable_literal -> . primary
    (26) valid_variable -> . name
    (27) valid_variable -> . array_access
    (83) primary -> . literal
    (84) primary -> . method_invocation
    (130) name -> . simple_name
    (131) name -> . qualified_name
    (28) array_access -> . name dimension
    (85) literal -> . int_float
    (86) literal -> . c_literal
    (94) method_invocation -> . name LPAREN argument_list_opt RPAREN
    (132) simple_name -> . IDENTIFIER
    (133) qualified_name -> . name INST simple_name
    (92) int_float -> . DOUBLE_NUMBER
    (93) int_float -> . INT_NUMBER
    (87) c_literal -> . CHAR
    (88) c_literal -> . STRING
    (89) c_literal -> . KEYWORD_NULL
    (90) c_literal -> . BOOL_CONSTT
    (91) c_literal -> . BOOL_CONSTF

    PLUS            shift and go to state 31
    MINUS           shift and go to state 24
    TILDA           shift and go to state 68
    NOT             shift and go to state 53
    LPAREN          shift and go to state 91
    IDENTIFIER      shift and go to state 9
    DOUBLE_NUMBER   shift and go to state 28
    INT_NUMBER      shift and go to state 39
    CHAR            shift and go to state 59
    STRING          shift and go to state 72
    KEYWORD_NULL    shift and go to state 61
    BOOL_CONSTT     shift and go to state 30
    BOOL_CONSTF     shift and go to state 25

    qualified_name                 shift and go to state 75
    int_float                      shift and go to state 35
    c_literal                      shift and go to state 90
    variable_literal               shift and go to state 51
    unary_expression               shift and go to state 105
    base_variable_set              shift and go to state 85
    valid_variable                 shift and go to state 106
    array_access                   shift and go to state 23
    primary                        shift and go to state 58
    unary_expression_not_plus_minus shift and go to state 41
    literal                        shift and go to state 67
    method_invocation              shift and go to state 107
    cast_expression                shift and go to state 77
    simple_name                    shift and go to state 63
    name                           shift and go to state 108

state 25

    (91) c_literal -> BOOL_CONSTF .

    TIMES           reduce using rule 91 (c_literal -> BOOL_CONSTF .)
    DIVIDE          reduce using rule 91 (c_literal -> BOOL_CONSTF .)
    REMAINDER       reduce using rule 91 (c_literal -> BOOL_CONSTF .)
    PLUS            reduce using rule 91 (c_literal -> BOOL_CONSTF .)
    MINUS           reduce using rule 91 (c_literal -> BOOL_CONSTF .)
    LSHIFT          reduce using rule 91 (c_literal -> BOOL_CONSTF .)
    RSHIFT          reduce using rule 91 (c_literal -> BOOL_CONSTF .)
    GREATER         reduce using rule 91 (c_literal -> BOOL_CONSTF .)
    LESS            reduce using rule 91 (c_literal -> BOOL_CONSTF .)
    GEQ             reduce using rule 91 (c_literal -> BOOL_CONSTF .)
    LEQ             reduce using rule 91 (c_literal -> BOOL_CONSTF .)
    EQUAL           reduce using rule 91 (c_literal -> BOOL_CONSTF .)
    NEQUAL          reduce using rule 91 (c_literal -> BOOL_CONSTF .)
    AND_BITWISE     reduce using rule 91 (c_literal -> BOOL_CONSTF .)
    XOR             reduce using rule 91 (c_literal -> BOOL_CONSTF .)
    OR_BITWISE      reduce using rule 91 (c_literal -> BOOL_CONSTF .)
    AND             reduce using rule 91 (c_literal -> BOOL_CONSTF .)
    OR              reduce using rule 91 (c_literal -> BOOL_CONSTF .)
    KEYWORD_MATCH   reduce using rule 91 (c_literal -> BOOL_CONSTF .)
    TERMINATOR      reduce using rule 91 (c_literal -> BOOL_CONSTF .)
    RPAREN          reduce using rule 91 (c_literal -> BOOL_CONSTF .)
    RBRAC           reduce using rule 91 (c_literal -> BOOL_CONSTF .)
    COMMA           reduce using rule 91 (c_literal -> BOOL_CONSTF .)
    FUNTYPE         reduce using rule 91 (c_literal -> BOOL_CONSTF .)
    KEYWORD_UNTIL   reduce using rule 91 (c_literal -> BOOL_CONSTF .)
    KEYWORD_TO      reduce using rule 91 (c_literal -> BOOL_CONSTF .)
    KEYWORD_BY      reduce using rule 91 (c_literal -> BOOL_CONSTF .)


state 26

    (7) block -> start_scope block_statements_opt . end_scope
    (9) end_scope -> . BLOCKEND

    BLOCKEND        shift and go to state 109

    end_scope                      shift and go to state 110

state 27

    (45) conditional_and_expression -> inclusive_or_expression .
    (48) inclusive_or_expression -> inclusive_or_expression . OR_BITWISE exclusive_or_expression

    AND             reduce using rule 45 (conditional_and_expression -> inclusive_or_expression .)
    OR              reduce using rule 45 (conditional_and_expression -> inclusive_or_expression .)
    RPAREN          reduce using rule 45 (conditional_and_expression -> inclusive_or_expression .)
    KEYWORD_MATCH   reduce using rule 45 (conditional_and_expression -> inclusive_or_expression .)
    TERMINATOR      reduce using rule 45 (conditional_and_expression -> inclusive_or_expression .)
    RBRAC           reduce using rule 45 (conditional_and_expression -> inclusive_or_expression .)
    COMMA           reduce using rule 45 (conditional_and_expression -> inclusive_or_expression .)
    FUNTYPE         reduce using rule 45 (conditional_and_expression -> inclusive_or_expression .)
    KEYWORD_UNTIL   reduce using rule 45 (conditional_and_expression -> inclusive_or_expression .)
    KEYWORD_TO      reduce using rule 45 (conditional_and_expression -> inclusive_or_expression .)
    KEYWORD_BY      reduce using rule 45 (conditional_and_expression -> inclusive_or_expression .)
    OR_BITWISE      shift and go to state 111


state 28

    (92) int_float -> DOUBLE_NUMBER .

    TIMES           reduce using rule 92 (int_float -> DOUBLE_NUMBER .)
    DIVIDE          reduce using rule 92 (int_float -> DOUBLE_NUMBER .)
    REMAINDER       reduce using rule 92 (int_float -> DOUBLE_NUMBER .)
    PLUS            reduce using rule 92 (int_float -> DOUBLE_NUMBER .)
    MINUS           reduce using rule 92 (int_float -> DOUBLE_NUMBER .)
    LSHIFT          reduce using rule 92 (int_float -> DOUBLE_NUMBER .)
    RSHIFT          reduce using rule 92 (int_float -> DOUBLE_NUMBER .)
    GREATER         reduce using rule 92 (int_float -> DOUBLE_NUMBER .)
    LESS            reduce using rule 92 (int_float -> DOUBLE_NUMBER .)
    GEQ             reduce using rule 92 (int_float -> DOUBLE_NUMBER .)
    LEQ             reduce using rule 92 (int_float -> DOUBLE_NUMBER .)
    EQUAL           reduce using rule 92 (int_float -> DOUBLE_NUMBER .)
    NEQUAL          reduce using rule 92 (int_float -> DOUBLE_NUMBER .)
    AND_BITWISE     reduce using rule 92 (int_float -> DOUBLE_NUMBER .)
    XOR             reduce using rule 92 (int_float -> DOUBLE_NUMBER .)
    OR_BITWISE      reduce using rule 92 (int_float -> DOUBLE_NUMBER .)
    AND             reduce using rule 92 (int_float -> DOUBLE_NUMBER .)
    OR              reduce using rule 92 (int_float -> DOUBLE_NUMBER .)
    KEYWORD_MATCH   reduce using rule 92 (int_float -> DOUBLE_NUMBER .)
    TERMINATOR      reduce using rule 92 (int_float -> DOUBLE_NUMBER .)
    RPAREN          reduce using rule 92 (int_float -> DOUBLE_NUMBER .)
    RBRAC           reduce using rule 92 (int_float -> DOUBLE_NUMBER .)
    COMMA           reduce using rule 92 (int_float -> DOUBLE_NUMBER .)
    FUNTYPE         reduce using rule 92 (int_float -> DOUBLE_NUMBER .)
    KEYWORD_UNTIL   reduce using rule 92 (int_float -> DOUBLE_NUMBER .)
    KEYWORD_TO      reduce using rule 92 (int_float -> DOUBLE_NUMBER .)
    KEYWORD_BY      reduce using rule 92 (int_float -> DOUBLE_NUMBER .)


state 29

    (140) statement -> while_statement . marker
    (41) marker -> . empty
    (200) empty -> .

    KEYWORD_IF      reduce using rule 200 (empty -> .)
    KEYWORD_WHILE   reduce using rule 200 (empty -> .)
    KEYWORD_DO      reduce using rule 200 (empty -> .)
    KEYWORD_FOR     reduce using rule 200 (empty -> .)
    KEYWORD_CLASS   reduce using rule 200 (empty -> .)
    KEYWORD_OBJECT  reduce using rule 200 (empty -> .)
    KEYWORD_VAR     reduce using rule 200 (empty -> .)
    KEYWORD_VAL     reduce using rule 200 (empty -> .)
    TERMINATOR      reduce using rule 200 (empty -> .)
    KEYWORD_RETURN  reduce using rule 200 (empty -> .)
    KEYWORD_DEF     reduce using rule 200 (empty -> .)
    BLOCKBEGIN      reduce using rule 200 (empty -> .)
    IDENTIFIER      reduce using rule 200 (empty -> .)
    PLUS            reduce using rule 200 (empty -> .)
    MINUS           reduce using rule 200 (empty -> .)
    TILDA           reduce using rule 200 (empty -> .)
    NOT             reduce using rule 200 (empty -> .)
    LPAREN          reduce using rule 200 (empty -> .)
    DOUBLE_NUMBER   reduce using rule 200 (empty -> .)
    INT_NUMBER      reduce using rule 200 (empty -> .)
    CHAR            reduce using rule 200 (empty -> .)
    STRING          reduce using rule 200 (empty -> .)
    KEYWORD_NULL    reduce using rule 200 (empty -> .)
    BOOL_CONSTT     reduce using rule 200 (empty -> .)
    BOOL_CONSTF     reduce using rule 200 (empty -> .)
    BLOCKEND        reduce using rule 200 (empty -> .)

    marker                         shift and go to state 112
    empty                          shift and go to state 104

state 30

    (90) c_literal -> BOOL_CONSTT .

    TIMES           reduce using rule 90 (c_literal -> BOOL_CONSTT .)
    DIVIDE          reduce using rule 90 (c_literal -> BOOL_CONSTT .)
    REMAINDER       reduce using rule 90 (c_literal -> BOOL_CONSTT .)
    PLUS            reduce using rule 90 (c_literal -> BOOL_CONSTT .)
    MINUS           reduce using rule 90 (c_literal -> BOOL_CONSTT .)
    LSHIFT          reduce using rule 90 (c_literal -> BOOL_CONSTT .)
    RSHIFT          reduce using rule 90 (c_literal -> BOOL_CONSTT .)
    GREATER         reduce using rule 90 (c_literal -> BOOL_CONSTT .)
    LESS            reduce using rule 90 (c_literal -> BOOL_CONSTT .)
    GEQ             reduce using rule 90 (c_literal -> BOOL_CONSTT .)
    LEQ             reduce using rule 90 (c_literal -> BOOL_CONSTT .)
    EQUAL           reduce using rule 90 (c_literal -> BOOL_CONSTT .)
    NEQUAL          reduce using rule 90 (c_literal -> BOOL_CONSTT .)
    AND_BITWISE     reduce using rule 90 (c_literal -> BOOL_CONSTT .)
    XOR             reduce using rule 90 (c_literal -> BOOL_CONSTT .)
    OR_BITWISE      reduce using rule 90 (c_literal -> BOOL_CONSTT .)
    AND             reduce using rule 90 (c_literal -> BOOL_CONSTT .)
    OR              reduce using rule 90 (c_literal -> BOOL_CONSTT .)
    KEYWORD_MATCH   reduce using rule 90 (c_literal -> BOOL_CONSTT .)
    TERMINATOR      reduce using rule 90 (c_literal -> BOOL_CONSTT .)
    RPAREN          reduce using rule 90 (c_literal -> BOOL_CONSTT .)
    RBRAC           reduce using rule 90 (c_literal -> BOOL_CONSTT .)
    COMMA           reduce using rule 90 (c_literal -> BOOL_CONSTT .)
    FUNTYPE         reduce using rule 90 (c_literal -> BOOL_CONSTT .)
    KEYWORD_UNTIL   reduce using rule 90 (c_literal -> BOOL_CONSTT .)
    KEYWORD_TO      reduce using rule 90 (c_literal -> BOOL_CONSTT .)
    KEYWORD_BY      reduce using rule 90 (c_literal -> BOOL_CONSTT .)


state 31

    (71) unary_expression -> PLUS . unary_expression
    (71) unary_expression -> . PLUS unary_expression
    (72) unary_expression -> . MINUS unary_expression
    (73) unary_expression -> . unary_expression_not_plus_minus
    (74) unary_expression_not_plus_minus -> . base_variable_set
    (75) unary_expression_not_plus_minus -> . TILDA unary_expression
    (76) unary_expression_not_plus_minus -> . cast_expression
    (77) unary_expression_not_plus_minus -> . NOT unary_expression
    (78) base_variable_set -> . variable_literal
    (79) base_variable_set -> . LPAREN expression RPAREN
    (82) cast_expression -> . LPAREN primitive_type RPAREN unary_expression
    (80) variable_literal -> . valid_variable
    (81) variable_literal -> . primary
    (26) valid_variable -> . name
    (27) valid_variable -> . array_access
    (83) primary -> . literal
    (84) primary -> . method_invocation
    (130) name -> . simple_name
    (131) name -> . qualified_name
    (28) array_access -> . name dimension
    (85) literal -> . int_float
    (86) literal -> . c_literal
    (94) method_invocation -> . name LPAREN argument_list_opt RPAREN
    (132) simple_name -> . IDENTIFIER
    (133) qualified_name -> . name INST simple_name
    (92) int_float -> . DOUBLE_NUMBER
    (93) int_float -> . INT_NUMBER
    (87) c_literal -> . CHAR
    (88) c_literal -> . STRING
    (89) c_literal -> . KEYWORD_NULL
    (90) c_literal -> . BOOL_CONSTT
    (91) c_literal -> . BOOL_CONSTF

    PLUS            shift and go to state 31
    MINUS           shift and go to state 24
    TILDA           shift and go to state 68
    NOT             shift and go to state 53
    LPAREN          shift and go to state 91
    IDENTIFIER      shift and go to state 9
    DOUBLE_NUMBER   shift and go to state 28
    INT_NUMBER      shift and go to state 39
    CHAR            shift and go to state 59
    STRING          shift and go to state 72
    KEYWORD_NULL    shift and go to state 61
    BOOL_CONSTT     shift and go to state 30
    BOOL_CONSTF     shift and go to state 25

    qualified_name                 shift and go to state 75
    int_float                      shift and go to state 35
    c_literal                      shift and go to state 90
    variable_literal               shift and go to state 51
    unary_expression               shift and go to state 113
    base_variable_set              shift and go to state 85
    valid_variable                 shift and go to state 106
    array_access                   shift and go to state 23
    primary                        shift and go to state 58
    unary_expression_not_plus_minus shift and go to state 41
    literal                        shift and go to state 67
    method_invocation              shift and go to state 107
    cast_expression                shift and go to state 77
    simple_name                    shift and go to state 63
    name                           shift and go to state 108

state 32

    (148) expression_statement -> statement_expression . TERMINATOR

    TERMINATOR      shift and go to state 114


state 33

    (142) statement -> for_statement . marker
    (41) marker -> . empty
    (200) empty -> .

    KEYWORD_IF      reduce using rule 200 (empty -> .)
    KEYWORD_WHILE   reduce using rule 200 (empty -> .)
    KEYWORD_DO      reduce using rule 200 (empty -> .)
    KEYWORD_FOR     reduce using rule 200 (empty -> .)
    KEYWORD_CLASS   reduce using rule 200 (empty -> .)
    KEYWORD_OBJECT  reduce using rule 200 (empty -> .)
    KEYWORD_VAR     reduce using rule 200 (empty -> .)
    KEYWORD_VAL     reduce using rule 200 (empty -> .)
    TERMINATOR      reduce using rule 200 (empty -> .)
    KEYWORD_RETURN  reduce using rule 200 (empty -> .)
    KEYWORD_DEF     reduce using rule 200 (empty -> .)
    BLOCKBEGIN      reduce using rule 200 (empty -> .)
    IDENTIFIER      reduce using rule 200 (empty -> .)
    PLUS            reduce using rule 200 (empty -> .)
    MINUS           reduce using rule 200 (empty -> .)
    TILDA           reduce using rule 200 (empty -> .)
    NOT             reduce using rule 200 (empty -> .)
    LPAREN          reduce using rule 200 (empty -> .)
    DOUBLE_NUMBER   reduce using rule 200 (empty -> .)
    INT_NUMBER      reduce using rule 200 (empty -> .)
    CHAR            reduce using rule 200 (empty -> .)
    STRING          reduce using rule 200 (empty -> .)
    KEYWORD_NULL    reduce using rule 200 (empty -> .)
    BOOL_CONSTT     reduce using rule 200 (empty -> .)
    BOOL_CONSTF     reduce using rule 200 (empty -> .)
    BLOCKEND        reduce using rule 200 (empty -> .)

    marker                         shift and go to state 115
    empty                          shift and go to state 104

state 34

    (14) block_statement -> local_variable_declaration_statement .

    KEYWORD_IF      reduce using rule 14 (block_statement -> local_variable_declaration_statement .)
    KEYWORD_WHILE   reduce using rule 14 (block_statement -> local_variable_declaration_statement .)
    KEYWORD_DO      reduce using rule 14 (block_statement -> local_variable_declaration_statement .)
    KEYWORD_FOR     reduce using rule 14 (block_statement -> local_variable_declaration_statement .)
    KEYWORD_CLASS   reduce using rule 14 (block_statement -> local_variable_declaration_statement .)
    KEYWORD_OBJECT  reduce using rule 14 (block_statement -> local_variable_declaration_statement .)
    KEYWORD_VAR     reduce using rule 14 (block_statement -> local_variable_declaration_statement .)
    KEYWORD_VAL     reduce using rule 14 (block_statement -> local_variable_declaration_statement .)
    TERMINATOR      reduce using rule 14 (block_statement -> local_variable_declaration_statement .)
    KEYWORD_RETURN  reduce using rule 14 (block_statement -> local_variable_declaration_statement .)
    KEYWORD_DEF     reduce using rule 14 (block_statement -> local_variable_declaration_statement .)
    BLOCKBEGIN      reduce using rule 14 (block_statement -> local_variable_declaration_statement .)
    IDENTIFIER      reduce using rule 14 (block_statement -> local_variable_declaration_statement .)
    PLUS            reduce using rule 14 (block_statement -> local_variable_declaration_statement .)
    MINUS           reduce using rule 14 (block_statement -> local_variable_declaration_statement .)
    TILDA           reduce using rule 14 (block_statement -> local_variable_declaration_statement .)
    NOT             reduce using rule 14 (block_statement -> local_variable_declaration_statement .)
    LPAREN          reduce using rule 14 (block_statement -> local_variable_declaration_statement .)
    DOUBLE_NUMBER   reduce using rule 14 (block_statement -> local_variable_declaration_statement .)
    INT_NUMBER      reduce using rule 14 (block_statement -> local_variable_declaration_statement .)
    CHAR            reduce using rule 14 (block_statement -> local_variable_declaration_statement .)
    STRING          reduce using rule 14 (block_statement -> local_variable_declaration_statement .)
    KEYWORD_NULL    reduce using rule 14 (block_statement -> local_variable_declaration_statement .)
    BOOL_CONSTT     reduce using rule 14 (block_statement -> local_variable_declaration_statement .)
    BOOL_CONSTF     reduce using rule 14 (block_statement -> local_variable_declaration_statement .)
    BLOCKEND        reduce using rule 14 (block_statement -> local_variable_declaration_statement .)


state 35

    (85) literal -> int_float .

    TIMES           reduce using rule 85 (literal -> int_float .)
    DIVIDE          reduce using rule 85 (literal -> int_float .)
    REMAINDER       reduce using rule 85 (literal -> int_float .)
    PLUS            reduce using rule 85 (literal -> int_float .)
    MINUS           reduce using rule 85 (literal -> int_float .)
    LSHIFT          reduce using rule 85 (literal -> int_float .)
    RSHIFT          reduce using rule 85 (literal -> int_float .)
    GREATER         reduce using rule 85 (literal -> int_float .)
    LESS            reduce using rule 85 (literal -> int_float .)
    GEQ             reduce using rule 85 (literal -> int_float .)
    LEQ             reduce using rule 85 (literal -> int_float .)
    EQUAL           reduce using rule 85 (literal -> int_float .)
    NEQUAL          reduce using rule 85 (literal -> int_float .)
    AND_BITWISE     reduce using rule 85 (literal -> int_float .)
    XOR             reduce using rule 85 (literal -> int_float .)
    OR_BITWISE      reduce using rule 85 (literal -> int_float .)
    AND             reduce using rule 85 (literal -> int_float .)
    OR              reduce using rule 85 (literal -> int_float .)
    COMMA           reduce using rule 85 (literal -> int_float .)
    RPAREN          reduce using rule 85 (literal -> int_float .)
    KEYWORD_MATCH   reduce using rule 85 (literal -> int_float .)
    TERMINATOR      reduce using rule 85 (literal -> int_float .)
    RBRAC           reduce using rule 85 (literal -> int_float .)
    FUNTYPE         reduce using rule 85 (literal -> int_float .)
    KEYWORD_UNTIL   reduce using rule 85 (literal -> int_float .)
    KEYWORD_TO      reduce using rule 85 (literal -> int_float .)
    KEYWORD_BY      reduce using rule 85 (literal -> int_float .)


state 36

    (17) block_statement -> SingletonObject .

    KEYWORD_IF      reduce using rule 17 (block_statement -> SingletonObject .)
    KEYWORD_WHILE   reduce using rule 17 (block_statement -> SingletonObject .)
    KEYWORD_DO      reduce using rule 17 (block_statement -> SingletonObject .)
    KEYWORD_FOR     reduce using rule 17 (block_statement -> SingletonObject .)
    KEYWORD_CLASS   reduce using rule 17 (block_statement -> SingletonObject .)
    KEYWORD_OBJECT  reduce using rule 17 (block_statement -> SingletonObject .)
    KEYWORD_VAR     reduce using rule 17 (block_statement -> SingletonObject .)
    KEYWORD_VAL     reduce using rule 17 (block_statement -> SingletonObject .)
    TERMINATOR      reduce using rule 17 (block_statement -> SingletonObject .)
    KEYWORD_RETURN  reduce using rule 17 (block_statement -> SingletonObject .)
    KEYWORD_DEF     reduce using rule 17 (block_statement -> SingletonObject .)
    BLOCKBEGIN      reduce using rule 17 (block_statement -> SingletonObject .)
    IDENTIFIER      reduce using rule 17 (block_statement -> SingletonObject .)
    PLUS            reduce using rule 17 (block_statement -> SingletonObject .)
    MINUS           reduce using rule 17 (block_statement -> SingletonObject .)
    TILDA           reduce using rule 17 (block_statement -> SingletonObject .)
    NOT             reduce using rule 17 (block_statement -> SingletonObject .)
    LPAREN          reduce using rule 17 (block_statement -> SingletonObject .)
    DOUBLE_NUMBER   reduce using rule 17 (block_statement -> SingletonObject .)
    INT_NUMBER      reduce using rule 17 (block_statement -> SingletonObject .)
    CHAR            reduce using rule 17 (block_statement -> SingletonObject .)
    STRING          reduce using rule 17 (block_statement -> SingletonObject .)
    KEYWORD_NULL    reduce using rule 17 (block_statement -> SingletonObject .)
    BOOL_CONSTT     reduce using rule 17 (block_statement -> SingletonObject .)
    BOOL_CONSTF     reduce using rule 17 (block_statement -> SingletonObject .)
    BLOCKEND        reduce using rule 17 (block_statement -> SingletonObject .)


state 37

    (175) method_header -> method_header_name . func_arg_start fun_params_opt RPAREN COLON method_return_type ASOP
    (176) func_arg_start -> . LPAREN

    LPAREN          shift and go to state 21

    func_arg_start                 shift and go to state 116

state 38

    (94) method_invocation -> name . LPAREN argument_list_opt RPAREN
    (26) valid_variable -> name .
    (28) array_access -> name . dimension
    (133) qualified_name -> name . INST simple_name
    (29) dimension -> . LBRAC expression RBRAC

    LPAREN          shift and go to state 119
    ASOP            reduce using rule 26 (valid_variable -> name .)
    TIMES_ASSIGN    reduce using rule 26 (valid_variable -> name .)
    DIVIDE_ASSIGN   reduce using rule 26 (valid_variable -> name .)
    REMAINDER_ASSIGN reduce using rule 26 (valid_variable -> name .)
    PLUS_ASSIGN     reduce using rule 26 (valid_variable -> name .)
    MINUS_ASSIGN    reduce using rule 26 (valid_variable -> name .)
    LSHIFT_ASSIGN   reduce using rule 26 (valid_variable -> name .)
    RSHIFT_ASSIGN   reduce using rule 26 (valid_variable -> name .)
    AND_ASSIGN      reduce using rule 26 (valid_variable -> name .)
    OR_ASSIGN       reduce using rule 26 (valid_variable -> name .)
    XOR_ASSIGN      reduce using rule 26 (valid_variable -> name .)
    TIMES           reduce using rule 26 (valid_variable -> name .)
    DIVIDE          reduce using rule 26 (valid_variable -> name .)
    REMAINDER       reduce using rule 26 (valid_variable -> name .)
    PLUS            reduce using rule 26 (valid_variable -> name .)
    MINUS           reduce using rule 26 (valid_variable -> name .)
    LSHIFT          reduce using rule 26 (valid_variable -> name .)
    RSHIFT          reduce using rule 26 (valid_variable -> name .)
    GREATER         reduce using rule 26 (valid_variable -> name .)
    LESS            reduce using rule 26 (valid_variable -> name .)
    GEQ             reduce using rule 26 (valid_variable -> name .)
    LEQ             reduce using rule 26 (valid_variable -> name .)
    EQUAL           reduce using rule 26 (valid_variable -> name .)
    NEQUAL          reduce using rule 26 (valid_variable -> name .)
    AND_BITWISE     reduce using rule 26 (valid_variable -> name .)
    XOR             reduce using rule 26 (valid_variable -> name .)
    OR_BITWISE      reduce using rule 26 (valid_variable -> name .)
    AND             reduce using rule 26 (valid_variable -> name .)
    OR              reduce using rule 26 (valid_variable -> name .)
    TERMINATOR      reduce using rule 26 (valid_variable -> name .)
    KEYWORD_MATCH   reduce using rule 26 (valid_variable -> name .)
    COMMA           reduce using rule 26 (valid_variable -> name .)
    RPAREN          reduce using rule 26 (valid_variable -> name .)
    KEYWORD_BY      reduce using rule 26 (valid_variable -> name .)
    FUNTYPE         reduce using rule 26 (valid_variable -> name .)
    KEYWORD_UNTIL   reduce using rule 26 (valid_variable -> name .)
    KEYWORD_TO      reduce using rule 26 (valid_variable -> name .)
    RBRAC           reduce using rule 26 (valid_variable -> name .)
    INST            shift and go to state 118
    LBRAC           shift and go to state 117

    dimension                      shift and go to state 120

state 39

    (93) int_float -> INT_NUMBER .

    TIMES           reduce using rule 93 (int_float -> INT_NUMBER .)
    DIVIDE          reduce using rule 93 (int_float -> INT_NUMBER .)
    REMAINDER       reduce using rule 93 (int_float -> INT_NUMBER .)
    PLUS            reduce using rule 93 (int_float -> INT_NUMBER .)
    MINUS           reduce using rule 93 (int_float -> INT_NUMBER .)
    LSHIFT          reduce using rule 93 (int_float -> INT_NUMBER .)
    RSHIFT          reduce using rule 93 (int_float -> INT_NUMBER .)
    GREATER         reduce using rule 93 (int_float -> INT_NUMBER .)
    LESS            reduce using rule 93 (int_float -> INT_NUMBER .)
    GEQ             reduce using rule 93 (int_float -> INT_NUMBER .)
    LEQ             reduce using rule 93 (int_float -> INT_NUMBER .)
    EQUAL           reduce using rule 93 (int_float -> INT_NUMBER .)
    NEQUAL          reduce using rule 93 (int_float -> INT_NUMBER .)
    AND_BITWISE     reduce using rule 93 (int_float -> INT_NUMBER .)
    XOR             reduce using rule 93 (int_float -> INT_NUMBER .)
    OR_BITWISE      reduce using rule 93 (int_float -> INT_NUMBER .)
    AND             reduce using rule 93 (int_float -> INT_NUMBER .)
    OR              reduce using rule 93 (int_float -> INT_NUMBER .)
    KEYWORD_MATCH   reduce using rule 93 (int_float -> INT_NUMBER .)
    TERMINATOR      reduce using rule 93 (int_float -> INT_NUMBER .)
    RPAREN          reduce using rule 93 (int_float -> INT_NUMBER .)
    RBRAC           reduce using rule 93 (int_float -> INT_NUMBER .)
    COMMA           reduce using rule 93 (int_float -> INT_NUMBER .)
    FUNTYPE         reduce using rule 93 (int_float -> INT_NUMBER .)
    KEYWORD_UNTIL   reduce using rule 93 (int_float -> INT_NUMBER .)
    KEYWORD_TO      reduce using rule 93 (int_float -> INT_NUMBER .)
    KEYWORD_BY      reduce using rule 93 (int_float -> INT_NUMBER .)


state 40

    (67) multiplicative_expression -> unary_expression .

    TIMES           reduce using rule 67 (multiplicative_expression -> unary_expression .)
    DIVIDE          reduce using rule 67 (multiplicative_expression -> unary_expression .)
    REMAINDER       reduce using rule 67 (multiplicative_expression -> unary_expression .)
    PLUS            reduce using rule 67 (multiplicative_expression -> unary_expression .)
    MINUS           reduce using rule 67 (multiplicative_expression -> unary_expression .)
    LSHIFT          reduce using rule 67 (multiplicative_expression -> unary_expression .)
    RSHIFT          reduce using rule 67 (multiplicative_expression -> unary_expression .)
    GREATER         reduce using rule 67 (multiplicative_expression -> unary_expression .)
    LESS            reduce using rule 67 (multiplicative_expression -> unary_expression .)
    GEQ             reduce using rule 67 (multiplicative_expression -> unary_expression .)
    LEQ             reduce using rule 67 (multiplicative_expression -> unary_expression .)
    EQUAL           reduce using rule 67 (multiplicative_expression -> unary_expression .)
    NEQUAL          reduce using rule 67 (multiplicative_expression -> unary_expression .)
    AND_BITWISE     reduce using rule 67 (multiplicative_expression -> unary_expression .)
    XOR             reduce using rule 67 (multiplicative_expression -> unary_expression .)
    OR_BITWISE      reduce using rule 67 (multiplicative_expression -> unary_expression .)
    AND             reduce using rule 67 (multiplicative_expression -> unary_expression .)
    OR              reduce using rule 67 (multiplicative_expression -> unary_expression .)
    FUNTYPE         reduce using rule 67 (multiplicative_expression -> unary_expression .)
    KEYWORD_MATCH   reduce using rule 67 (multiplicative_expression -> unary_expression .)
    COMMA           reduce using rule 67 (multiplicative_expression -> unary_expression .)
    RPAREN          reduce using rule 67 (multiplicative_expression -> unary_expression .)
    TERMINATOR      reduce using rule 67 (multiplicative_expression -> unary_expression .)
    RBRAC           reduce using rule 67 (multiplicative_expression -> unary_expression .)
    KEYWORD_UNTIL   reduce using rule 67 (multiplicative_expression -> unary_expression .)
    KEYWORD_TO      reduce using rule 67 (multiplicative_expression -> unary_expression .)
    KEYWORD_BY      reduce using rule 67 (multiplicative_expression -> unary_expression .)


state 41

    (73) unary_expression -> unary_expression_not_plus_minus .

    TIMES           reduce using rule 73 (unary_expression -> unary_expression_not_plus_minus .)
    DIVIDE          reduce using rule 73 (unary_expression -> unary_expression_not_plus_minus .)
    REMAINDER       reduce using rule 73 (unary_expression -> unary_expression_not_plus_minus .)
    PLUS            reduce using rule 73 (unary_expression -> unary_expression_not_plus_minus .)
    MINUS           reduce using rule 73 (unary_expression -> unary_expression_not_plus_minus .)
    LSHIFT          reduce using rule 73 (unary_expression -> unary_expression_not_plus_minus .)
    RSHIFT          reduce using rule 73 (unary_expression -> unary_expression_not_plus_minus .)
    GREATER         reduce using rule 73 (unary_expression -> unary_expression_not_plus_minus .)
    LESS            reduce using rule 73 (unary_expression -> unary_expression_not_plus_minus .)
    GEQ             reduce using rule 73 (unary_expression -> unary_expression_not_plus_minus .)
    LEQ             reduce using rule 73 (unary_expression -> unary_expression_not_plus_minus .)
    EQUAL           reduce using rule 73 (unary_expression -> unary_expression_not_plus_minus .)
    NEQUAL          reduce using rule 73 (unary_expression -> unary_expression_not_plus_minus .)
    AND_BITWISE     reduce using rule 73 (unary_expression -> unary_expression_not_plus_minus .)
    XOR             reduce using rule 73 (unary_expression -> unary_expression_not_plus_minus .)
    OR_BITWISE      reduce using rule 73 (unary_expression -> unary_expression_not_plus_minus .)
    AND             reduce using rule 73 (unary_expression -> unary_expression_not_plus_minus .)
    OR              reduce using rule 73 (unary_expression -> unary_expression_not_plus_minus .)
    TERMINATOR      reduce using rule 73 (unary_expression -> unary_expression_not_plus_minus .)
    KEYWORD_MATCH   reduce using rule 73 (unary_expression -> unary_expression_not_plus_minus .)
    RPAREN          reduce using rule 73 (unary_expression -> unary_expression_not_plus_minus .)
    RBRAC           reduce using rule 73 (unary_expression -> unary_expression_not_plus_minus .)
    COMMA           reduce using rule 73 (unary_expression -> unary_expression_not_plus_minus .)
    FUNTYPE         reduce using rule 73 (unary_expression -> unary_expression_not_plus_minus .)
    KEYWORD_UNTIL   reduce using rule 73 (unary_expression -> unary_expression_not_plus_minus .)
    KEYWORD_TO      reduce using rule 73 (unary_expression -> unary_expression_not_plus_minus .)
    KEYWORD_BY      reduce using rule 73 (unary_expression -> unary_expression_not_plus_minus .)


state 42

    (147) normal_statement -> switch_statement . marker
    (41) marker -> . empty
    (200) empty -> .

    KEYWORD_IF      reduce using rule 200 (empty -> .)
    KEYWORD_WHILE   reduce using rule 200 (empty -> .)
    KEYWORD_DO      reduce using rule 200 (empty -> .)
    KEYWORD_FOR     reduce using rule 200 (empty -> .)
    KEYWORD_CLASS   reduce using rule 200 (empty -> .)
    KEYWORD_OBJECT  reduce using rule 200 (empty -> .)
    KEYWORD_VAR     reduce using rule 200 (empty -> .)
    KEYWORD_VAL     reduce using rule 200 (empty -> .)
    TERMINATOR      reduce using rule 200 (empty -> .)
    KEYWORD_RETURN  reduce using rule 200 (empty -> .)
    KEYWORD_DEF     reduce using rule 200 (empty -> .)
    BLOCKBEGIN      reduce using rule 200 (empty -> .)
    IDENTIFIER      reduce using rule 200 (empty -> .)
    PLUS            reduce using rule 200 (empty -> .)
    MINUS           reduce using rule 200 (empty -> .)
    TILDA           reduce using rule 200 (empty -> .)
    NOT             reduce using rule 200 (empty -> .)
    LPAREN          reduce using rule 200 (empty -> .)
    DOUBLE_NUMBER   reduce using rule 200 (empty -> .)
    INT_NUMBER      reduce using rule 200 (empty -> .)
    CHAR            reduce using rule 200 (empty -> .)
    STRING          reduce using rule 200 (empty -> .)
    KEYWORD_NULL    reduce using rule 200 (empty -> .)
    BOOL_CONSTT     reduce using rule 200 (empty -> .)
    BOOL_CONSTF     reduce using rule 200 (empty -> .)
    BLOCKEND        reduce using rule 200 (empty -> .)
    KEYWORD_ELSE    reduce using rule 200 (empty -> .)

    marker                         shift and go to state 121
    empty                          shift and go to state 104

state 43

    (23) assignment_expression -> conditional_or_expression .
    (44) conditional_or_expression -> conditional_or_expression . OR marker conditional_and_expression

    KEYWORD_MATCH   reduce using rule 23 (assignment_expression -> conditional_or_expression .)
    TERMINATOR      reduce using rule 23 (assignment_expression -> conditional_or_expression .)
    RBRAC           reduce using rule 23 (assignment_expression -> conditional_or_expression .)
    RPAREN          reduce using rule 23 (assignment_expression -> conditional_or_expression .)
    COMMA           reduce using rule 23 (assignment_expression -> conditional_or_expression .)
    FUNTYPE         reduce using rule 23 (assignment_expression -> conditional_or_expression .)
    KEYWORD_UNTIL   reduce using rule 23 (assignment_expression -> conditional_or_expression .)
    KEYWORD_TO      reduce using rule 23 (assignment_expression -> conditional_or_expression .)
    KEYWORD_BY      reduce using rule 23 (assignment_expression -> conditional_or_expression .)
    OR              shift and go to state 122


state 44

    (156) while_statement -> KEYWORD_WHILE . LPAREN marker expression RPAREN marker block

    LPAREN          shift and go to state 123


state 45

    (141) statement -> do_while_statement . marker
    (41) marker -> . empty
    (200) empty -> .

    KEYWORD_IF      reduce using rule 200 (empty -> .)
    KEYWORD_WHILE   reduce using rule 200 (empty -> .)
    KEYWORD_DO      reduce using rule 200 (empty -> .)
    KEYWORD_FOR     reduce using rule 200 (empty -> .)
    KEYWORD_CLASS   reduce using rule 200 (empty -> .)
    KEYWORD_OBJECT  reduce using rule 200 (empty -> .)
    KEYWORD_VAR     reduce using rule 200 (empty -> .)
    KEYWORD_VAL     reduce using rule 200 (empty -> .)
    TERMINATOR      reduce using rule 200 (empty -> .)
    KEYWORD_RETURN  reduce using rule 200 (empty -> .)
    KEYWORD_DEF     reduce using rule 200 (empty -> .)
    BLOCKBEGIN      reduce using rule 200 (empty -> .)
    IDENTIFIER      reduce using rule 200 (empty -> .)
    PLUS            reduce using rule 200 (empty -> .)
    MINUS           reduce using rule 200 (empty -> .)
    TILDA           reduce using rule 200 (empty -> .)
    NOT             reduce using rule 200 (empty -> .)
    LPAREN          reduce using rule 200 (empty -> .)
    DOUBLE_NUMBER   reduce using rule 200 (empty -> .)
    INT_NUMBER      reduce using rule 200 (empty -> .)
    CHAR            reduce using rule 200 (empty -> .)
    STRING          reduce using rule 200 (empty -> .)
    KEYWORD_NULL    reduce using rule 200 (empty -> .)
    BOOL_CONSTT     reduce using rule 200 (empty -> .)
    BOOL_CONSTF     reduce using rule 200 (empty -> .)
    BLOCKEND        reduce using rule 200 (empty -> .)

    marker                         shift and go to state 124
    empty                          shift and go to state 104

state 46

    (64) additive_expression -> multiplicative_expression .
    (68) multiplicative_expression -> multiplicative_expression . TIMES unary_expression
    (69) multiplicative_expression -> multiplicative_expression . DIVIDE unary_expression
    (70) multiplicative_expression -> multiplicative_expression . REMAINDER unary_expression

    PLUS            reduce using rule 64 (additive_expression -> multiplicative_expression .)
    MINUS           reduce using rule 64 (additive_expression -> multiplicative_expression .)
    LSHIFT          reduce using rule 64 (additive_expression -> multiplicative_expression .)
    RSHIFT          reduce using rule 64 (additive_expression -> multiplicative_expression .)
    GREATER         reduce using rule 64 (additive_expression -> multiplicative_expression .)
    LESS            reduce using rule 64 (additive_expression -> multiplicative_expression .)
    GEQ             reduce using rule 64 (additive_expression -> multiplicative_expression .)
    LEQ             reduce using rule 64 (additive_expression -> multiplicative_expression .)
    EQUAL           reduce using rule 64 (additive_expression -> multiplicative_expression .)
    NEQUAL          reduce using rule 64 (additive_expression -> multiplicative_expression .)
    AND_BITWISE     reduce using rule 64 (additive_expression -> multiplicative_expression .)
    XOR             reduce using rule 64 (additive_expression -> multiplicative_expression .)
    OR_BITWISE      reduce using rule 64 (additive_expression -> multiplicative_expression .)
    AND             reduce using rule 64 (additive_expression -> multiplicative_expression .)
    OR              reduce using rule 64 (additive_expression -> multiplicative_expression .)
    COMMA           reduce using rule 64 (additive_expression -> multiplicative_expression .)
    RPAREN          reduce using rule 64 (additive_expression -> multiplicative_expression .)
    KEYWORD_MATCH   reduce using rule 64 (additive_expression -> multiplicative_expression .)
    TERMINATOR      reduce using rule 64 (additive_expression -> multiplicative_expression .)
    RBRAC           reduce using rule 64 (additive_expression -> multiplicative_expression .)
    FUNTYPE         reduce using rule 64 (additive_expression -> multiplicative_expression .)
    KEYWORD_UNTIL   reduce using rule 64 (additive_expression -> multiplicative_expression .)
    KEYWORD_TO      reduce using rule 64 (additive_expression -> multiplicative_expression .)
    KEYWORD_BY      reduce using rule 64 (additive_expression -> multiplicative_expression .)
    TIMES           shift and go to state 127
    DIVIDE          shift and go to state 126
    REMAINDER       shift and go to state 125


state 47

    (99) declaration_keyword -> KEYWORD_VAR .

    IDENTIFIER      reduce using rule 99 (declaration_keyword -> KEYWORD_VAR .)


state 48

    (100) declaration_keyword -> KEYWORD_VAL .

    IDENTIFIER      reduce using rule 100 (declaration_keyword -> KEYWORD_VAL .)


state 49

    (172) empty_statement -> TERMINATOR .

    KEYWORD_IF      reduce using rule 172 (empty_statement -> TERMINATOR .)
    KEYWORD_WHILE   reduce using rule 172 (empty_statement -> TERMINATOR .)
    KEYWORD_DO      reduce using rule 172 (empty_statement -> TERMINATOR .)
    KEYWORD_FOR     reduce using rule 172 (empty_statement -> TERMINATOR .)
    KEYWORD_CLASS   reduce using rule 172 (empty_statement -> TERMINATOR .)
    KEYWORD_OBJECT  reduce using rule 172 (empty_statement -> TERMINATOR .)
    KEYWORD_VAR     reduce using rule 172 (empty_statement -> TERMINATOR .)
    KEYWORD_VAL     reduce using rule 172 (empty_statement -> TERMINATOR .)
    TERMINATOR      reduce using rule 172 (empty_statement -> TERMINATOR .)
    KEYWORD_RETURN  reduce using rule 172 (empty_statement -> TERMINATOR .)
    KEYWORD_DEF     reduce using rule 172 (empty_statement -> TERMINATOR .)
    BLOCKBEGIN      reduce using rule 172 (empty_statement -> TERMINATOR .)
    IDENTIFIER      reduce using rule 172 (empty_statement -> TERMINATOR .)
    PLUS            reduce using rule 172 (empty_statement -> TERMINATOR .)
    MINUS           reduce using rule 172 (empty_statement -> TERMINATOR .)
    TILDA           reduce using rule 172 (empty_statement -> TERMINATOR .)
    NOT             reduce using rule 172 (empty_statement -> TERMINATOR .)
    LPAREN          reduce using rule 172 (empty_statement -> TERMINATOR .)
    DOUBLE_NUMBER   reduce using rule 172 (empty_statement -> TERMINATOR .)
    INT_NUMBER      reduce using rule 172 (empty_statement -> TERMINATOR .)
    CHAR            reduce using rule 172 (empty_statement -> TERMINATOR .)
    STRING          reduce using rule 172 (empty_statement -> TERMINATOR .)
    KEYWORD_NULL    reduce using rule 172 (empty_statement -> TERMINATOR .)
    BOOL_CONSTT     reduce using rule 172 (empty_statement -> TERMINATOR .)
    BOOL_CONSTF     reduce using rule 172 (empty_statement -> TERMINATOR .)
    BLOCKEND        reduce using rule 172 (empty_statement -> TERMINATOR .)
    KEYWORD_ELSE    reduce using rule 172 (empty_statement -> TERMINATOR .)


state 50

    (56) relational_expression -> shift_expression .
    (62) shift_expression -> shift_expression . LSHIFT additive_expression
    (63) shift_expression -> shift_expression . RSHIFT additive_expression

    GREATER         reduce using rule 56 (relational_expression -> shift_expression .)
    LESS            reduce using rule 56 (relational_expression -> shift_expression .)
    GEQ             reduce using rule 56 (relational_expression -> shift_expression .)
    LEQ             reduce using rule 56 (relational_expression -> shift_expression .)
    EQUAL           reduce using rule 56 (relational_expression -> shift_expression .)
    NEQUAL          reduce using rule 56 (relational_expression -> shift_expression .)
    AND_BITWISE     reduce using rule 56 (relational_expression -> shift_expression .)
    XOR             reduce using rule 56 (relational_expression -> shift_expression .)
    OR_BITWISE      reduce using rule 56 (relational_expression -> shift_expression .)
    AND             reduce using rule 56 (relational_expression -> shift_expression .)
    OR              reduce using rule 56 (relational_expression -> shift_expression .)
    RPAREN          reduce using rule 56 (relational_expression -> shift_expression .)
    TERMINATOR      reduce using rule 56 (relational_expression -> shift_expression .)
    KEYWORD_MATCH   reduce using rule 56 (relational_expression -> shift_expression .)
    RBRAC           reduce using rule 56 (relational_expression -> shift_expression .)
    COMMA           reduce using rule 56 (relational_expression -> shift_expression .)
    FUNTYPE         reduce using rule 56 (relational_expression -> shift_expression .)
    KEYWORD_UNTIL   reduce using rule 56 (relational_expression -> shift_expression .)
    KEYWORD_TO      reduce using rule 56 (relational_expression -> shift_expression .)
    KEYWORD_BY      reduce using rule 56 (relational_expression -> shift_expression .)
    LSHIFT          shift and go to state 129
    RSHIFT          shift and go to state 128


state 51

    (78) base_variable_set -> variable_literal .

    TIMES           reduce using rule 78 (base_variable_set -> variable_literal .)
    DIVIDE          reduce using rule 78 (base_variable_set -> variable_literal .)
    REMAINDER       reduce using rule 78 (base_variable_set -> variable_literal .)
    PLUS            reduce using rule 78 (base_variable_set -> variable_literal .)
    MINUS           reduce using rule 78 (base_variable_set -> variable_literal .)
    LSHIFT          reduce using rule 78 (base_variable_set -> variable_literal .)
    RSHIFT          reduce using rule 78 (base_variable_set -> variable_literal .)
    GREATER         reduce using rule 78 (base_variable_set -> variable_literal .)
    LESS            reduce using rule 78 (base_variable_set -> variable_literal .)
    GEQ             reduce using rule 78 (base_variable_set -> variable_literal .)
    LEQ             reduce using rule 78 (base_variable_set -> variable_literal .)
    EQUAL           reduce using rule 78 (base_variable_set -> variable_literal .)
    NEQUAL          reduce using rule 78 (base_variable_set -> variable_literal .)
    AND_BITWISE     reduce using rule 78 (base_variable_set -> variable_literal .)
    XOR             reduce using rule 78 (base_variable_set -> variable_literal .)
    OR_BITWISE      reduce using rule 78 (base_variable_set -> variable_literal .)
    AND             reduce using rule 78 (base_variable_set -> variable_literal .)
    OR              reduce using rule 78 (base_variable_set -> variable_literal .)
    KEYWORD_UNTIL   reduce using rule 78 (base_variable_set -> variable_literal .)
    KEYWORD_TO      reduce using rule 78 (base_variable_set -> variable_literal .)
    RPAREN          reduce using rule 78 (base_variable_set -> variable_literal .)
    TERMINATOR      reduce using rule 78 (base_variable_set -> variable_literal .)
    KEYWORD_MATCH   reduce using rule 78 (base_variable_set -> variable_literal .)
    RBRAC           reduce using rule 78 (base_variable_set -> variable_literal .)
    COMMA           reduce using rule 78 (base_variable_set -> variable_literal .)
    FUNTYPE         reduce using rule 78 (base_variable_set -> variable_literal .)
    KEYWORD_BY      reduce using rule 78 (base_variable_set -> variable_literal .)


state 52

    (43) conditional_or_expression -> conditional_and_expression .
    (46) conditional_and_expression -> conditional_and_expression . AND marker inclusive_or_expression

    OR              reduce using rule 43 (conditional_or_expression -> conditional_and_expression .)
    KEYWORD_MATCH   reduce using rule 43 (conditional_or_expression -> conditional_and_expression .)
    RPAREN          reduce using rule 43 (conditional_or_expression -> conditional_and_expression .)
    COMMA           reduce using rule 43 (conditional_or_expression -> conditional_and_expression .)
    KEYWORD_BY      reduce using rule 43 (conditional_or_expression -> conditional_and_expression .)
    KEYWORD_UNTIL   reduce using rule 43 (conditional_or_expression -> conditional_and_expression .)
    KEYWORD_TO      reduce using rule 43 (conditional_or_expression -> conditional_and_expression .)
    RBRAC           reduce using rule 43 (conditional_or_expression -> conditional_and_expression .)
    TERMINATOR      reduce using rule 43 (conditional_or_expression -> conditional_and_expression .)
    FUNTYPE         reduce using rule 43 (conditional_or_expression -> conditional_and_expression .)
    AND             shift and go to state 130


state 53

    (77) unary_expression_not_plus_minus -> NOT . unary_expression
    (71) unary_expression -> . PLUS unary_expression
    (72) unary_expression -> . MINUS unary_expression
    (73) unary_expression -> . unary_expression_not_plus_minus
    (74) unary_expression_not_plus_minus -> . base_variable_set
    (75) unary_expression_not_plus_minus -> . TILDA unary_expression
    (76) unary_expression_not_plus_minus -> . cast_expression
    (77) unary_expression_not_plus_minus -> . NOT unary_expression
    (78) base_variable_set -> . variable_literal
    (79) base_variable_set -> . LPAREN expression RPAREN
    (82) cast_expression -> . LPAREN primitive_type RPAREN unary_expression
    (80) variable_literal -> . valid_variable
    (81) variable_literal -> . primary
    (26) valid_variable -> . name
    (27) valid_variable -> . array_access
    (83) primary -> . literal
    (84) primary -> . method_invocation
    (130) name -> . simple_name
    (131) name -> . qualified_name
    (28) array_access -> . name dimension
    (85) literal -> . int_float
    (86) literal -> . c_literal
    (94) method_invocation -> . name LPAREN argument_list_opt RPAREN
    (132) simple_name -> . IDENTIFIER
    (133) qualified_name -> . name INST simple_name
    (92) int_float -> . DOUBLE_NUMBER
    (93) int_float -> . INT_NUMBER
    (87) c_literal -> . CHAR
    (88) c_literal -> . STRING
    (89) c_literal -> . KEYWORD_NULL
    (90) c_literal -> . BOOL_CONSTT
    (91) c_literal -> . BOOL_CONSTF

    PLUS            shift and go to state 31
    MINUS           shift and go to state 24
    TILDA           shift and go to state 68
    NOT             shift and go to state 53
    LPAREN          shift and go to state 91
    IDENTIFIER      shift and go to state 9
    DOUBLE_NUMBER   shift and go to state 28
    INT_NUMBER      shift and go to state 39
    CHAR            shift and go to state 59
    STRING          shift and go to state 72
    KEYWORD_NULL    shift and go to state 61
    BOOL_CONSTT     shift and go to state 30
    BOOL_CONSTF     shift and go to state 25

    qualified_name                 shift and go to state 75
    int_float                      shift and go to state 35
    c_literal                      shift and go to state 90
    variable_literal               shift and go to state 51
    unary_expression               shift and go to state 131
    base_variable_set              shift and go to state 85
    valid_variable                 shift and go to state 106
    array_access                   shift and go to state 23
    primary                        shift and go to state 58
    unary_expression_not_plus_minus shift and go to state 41
    literal                        shift and go to state 67
    method_invocation              shift and go to state 107
    cast_expression                shift and go to state 77
    simple_name                    shift and go to state 63
    name                           shift and go to state 108

state 54

    (165) switch_statement -> expression . KEYWORD_MATCH switch_block marker

    KEYWORD_MATCH   shift and go to state 132


state 55

    (143) normal_statement -> block . marker
    (41) marker -> . empty
    (200) empty -> .

    KEYWORD_IF      reduce using rule 200 (empty -> .)
    KEYWORD_WHILE   reduce using rule 200 (empty -> .)
    KEYWORD_DO      reduce using rule 200 (empty -> .)
    KEYWORD_FOR     reduce using rule 200 (empty -> .)
    KEYWORD_CLASS   reduce using rule 200 (empty -> .)
    KEYWORD_OBJECT  reduce using rule 200 (empty -> .)
    KEYWORD_VAR     reduce using rule 200 (empty -> .)
    KEYWORD_VAL     reduce using rule 200 (empty -> .)
    TERMINATOR      reduce using rule 200 (empty -> .)
    KEYWORD_RETURN  reduce using rule 200 (empty -> .)
    KEYWORD_DEF     reduce using rule 200 (empty -> .)
    BLOCKBEGIN      reduce using rule 200 (empty -> .)
    IDENTIFIER      reduce using rule 200 (empty -> .)
    PLUS            reduce using rule 200 (empty -> .)
    MINUS           reduce using rule 200 (empty -> .)
    TILDA           reduce using rule 200 (empty -> .)
    NOT             reduce using rule 200 (empty -> .)
    LPAREN          reduce using rule 200 (empty -> .)
    DOUBLE_NUMBER   reduce using rule 200 (empty -> .)
    INT_NUMBER      reduce using rule 200 (empty -> .)
    CHAR            reduce using rule 200 (empty -> .)
    STRING          reduce using rule 200 (empty -> .)
    KEYWORD_NULL    reduce using rule 200 (empty -> .)
    BOOL_CONSTT     reduce using rule 200 (empty -> .)
    BOOL_CONSTF     reduce using rule 200 (empty -> .)
    BLOCKEND        reduce using rule 200 (empty -> .)
    KEYWORD_ELSE    reduce using rule 200 (empty -> .)

    marker                         shift and go to state 133
    empty                          shift and go to state 104

state 56

    (139) statement -> if_then_else_statement . marker
    (41) marker -> . empty
    (200) empty -> .

    KEYWORD_IF      reduce using rule 200 (empty -> .)
    KEYWORD_WHILE   reduce using rule 200 (empty -> .)
    KEYWORD_DO      reduce using rule 200 (empty -> .)
    KEYWORD_FOR     reduce using rule 200 (empty -> .)
    KEYWORD_CLASS   reduce using rule 200 (empty -> .)
    KEYWORD_OBJECT  reduce using rule 200 (empty -> .)
    KEYWORD_VAR     reduce using rule 200 (empty -> .)
    KEYWORD_VAL     reduce using rule 200 (empty -> .)
    TERMINATOR      reduce using rule 200 (empty -> .)
    KEYWORD_RETURN  reduce using rule 200 (empty -> .)
    KEYWORD_DEF     reduce using rule 200 (empty -> .)
    BLOCKBEGIN      reduce using rule 200 (empty -> .)
    IDENTIFIER      reduce using rule 200 (empty -> .)
    PLUS            reduce using rule 200 (empty -> .)
    MINUS           reduce using rule 200 (empty -> .)
    TILDA           reduce using rule 200 (empty -> .)
    NOT             reduce using rule 200 (empty -> .)
    LPAREN          reduce using rule 200 (empty -> .)
    DOUBLE_NUMBER   reduce using rule 200 (empty -> .)
    INT_NUMBER      reduce using rule 200 (empty -> .)
    CHAR            reduce using rule 200 (empty -> .)
    STRING          reduce using rule 200 (empty -> .)
    KEYWORD_NULL    reduce using rule 200 (empty -> .)
    BOOL_CONSTT     reduce using rule 200 (empty -> .)
    BOOL_CONSTF     reduce using rule 200 (empty -> .)
    BLOCKEND        reduce using rule 200 (empty -> .)

    marker                         shift and go to state 134
    empty                          shift and go to state 104

state 57

    (47) inclusive_or_expression -> exclusive_or_expression .
    (50) exclusive_or_expression -> exclusive_or_expression . XOR and_expression

    OR_BITWISE      reduce using rule 47 (inclusive_or_expression -> exclusive_or_expression .)
    AND             reduce using rule 47 (inclusive_or_expression -> exclusive_or_expression .)
    OR              reduce using rule 47 (inclusive_or_expression -> exclusive_or_expression .)
    TERMINATOR      reduce using rule 47 (inclusive_or_expression -> exclusive_or_expression .)
    KEYWORD_MATCH   reduce using rule 47 (inclusive_or_expression -> exclusive_or_expression .)
    COMMA           reduce using rule 47 (inclusive_or_expression -> exclusive_or_expression .)
    RPAREN          reduce using rule 47 (inclusive_or_expression -> exclusive_or_expression .)
    FUNTYPE         reduce using rule 47 (inclusive_or_expression -> exclusive_or_expression .)
    RBRAC           reduce using rule 47 (inclusive_or_expression -> exclusive_or_expression .)
    KEYWORD_UNTIL   reduce using rule 47 (inclusive_or_expression -> exclusive_or_expression .)
    KEYWORD_TO      reduce using rule 47 (inclusive_or_expression -> exclusive_or_expression .)
    KEYWORD_BY      reduce using rule 47 (inclusive_or_expression -> exclusive_or_expression .)
    XOR             shift and go to state 135


state 58

    (81) variable_literal -> primary .

    TIMES           reduce using rule 81 (variable_literal -> primary .)
    DIVIDE          reduce using rule 81 (variable_literal -> primary .)
    REMAINDER       reduce using rule 81 (variable_literal -> primary .)
    PLUS            reduce using rule 81 (variable_literal -> primary .)
    MINUS           reduce using rule 81 (variable_literal -> primary .)
    LSHIFT          reduce using rule 81 (variable_literal -> primary .)
    RSHIFT          reduce using rule 81 (variable_literal -> primary .)
    GREATER         reduce using rule 81 (variable_literal -> primary .)
    LESS            reduce using rule 81 (variable_literal -> primary .)
    GEQ             reduce using rule 81 (variable_literal -> primary .)
    LEQ             reduce using rule 81 (variable_literal -> primary .)
    EQUAL           reduce using rule 81 (variable_literal -> primary .)
    NEQUAL          reduce using rule 81 (variable_literal -> primary .)
    AND_BITWISE     reduce using rule 81 (variable_literal -> primary .)
    XOR             reduce using rule 81 (variable_literal -> primary .)
    OR_BITWISE      reduce using rule 81 (variable_literal -> primary .)
    AND             reduce using rule 81 (variable_literal -> primary .)
    OR              reduce using rule 81 (variable_literal -> primary .)
    KEYWORD_MATCH   reduce using rule 81 (variable_literal -> primary .)
    TERMINATOR      reduce using rule 81 (variable_literal -> primary .)
    RPAREN          reduce using rule 81 (variable_literal -> primary .)
    RBRAC           reduce using rule 81 (variable_literal -> primary .)
    COMMA           reduce using rule 81 (variable_literal -> primary .)
    FUNTYPE         reduce using rule 81 (variable_literal -> primary .)
    KEYWORD_UNTIL   reduce using rule 81 (variable_literal -> primary .)
    KEYWORD_TO      reduce using rule 81 (variable_literal -> primary .)
    KEYWORD_BY      reduce using rule 81 (variable_literal -> primary .)


state 59

    (87) c_literal -> CHAR .

    TIMES           reduce using rule 87 (c_literal -> CHAR .)
    DIVIDE          reduce using rule 87 (c_literal -> CHAR .)
    REMAINDER       reduce using rule 87 (c_literal -> CHAR .)
    PLUS            reduce using rule 87 (c_literal -> CHAR .)
    MINUS           reduce using rule 87 (c_literal -> CHAR .)
    LSHIFT          reduce using rule 87 (c_literal -> CHAR .)
    RSHIFT          reduce using rule 87 (c_literal -> CHAR .)
    GREATER         reduce using rule 87 (c_literal -> CHAR .)
    LESS            reduce using rule 87 (c_literal -> CHAR .)
    GEQ             reduce using rule 87 (c_literal -> CHAR .)
    LEQ             reduce using rule 87 (c_literal -> CHAR .)
    EQUAL           reduce using rule 87 (c_literal -> CHAR .)
    NEQUAL          reduce using rule 87 (c_literal -> CHAR .)
    AND_BITWISE     reduce using rule 87 (c_literal -> CHAR .)
    XOR             reduce using rule 87 (c_literal -> CHAR .)
    OR_BITWISE      reduce using rule 87 (c_literal -> CHAR .)
    AND             reduce using rule 87 (c_literal -> CHAR .)
    OR              reduce using rule 87 (c_literal -> CHAR .)
    KEYWORD_MATCH   reduce using rule 87 (c_literal -> CHAR .)
    TERMINATOR      reduce using rule 87 (c_literal -> CHAR .)
    RPAREN          reduce using rule 87 (c_literal -> CHAR .)
    RBRAC           reduce using rule 87 (c_literal -> CHAR .)
    COMMA           reduce using rule 87 (c_literal -> CHAR .)
    FUNTYPE         reduce using rule 87 (c_literal -> CHAR .)
    KEYWORD_UNTIL   reduce using rule 87 (c_literal -> CHAR .)
    KEYWORD_TO      reduce using rule 87 (c_literal -> CHAR .)
    KEYWORD_BY      reduce using rule 87 (c_literal -> CHAR .)


state 60

    (138) statement -> if_then_statement . marker
    (41) marker -> . empty
    (200) empty -> .

    KEYWORD_IF      reduce using rule 200 (empty -> .)
    KEYWORD_WHILE   reduce using rule 200 (empty -> .)
    KEYWORD_DO      reduce using rule 200 (empty -> .)
    KEYWORD_FOR     reduce using rule 200 (empty -> .)
    KEYWORD_CLASS   reduce using rule 200 (empty -> .)
    KEYWORD_OBJECT  reduce using rule 200 (empty -> .)
    KEYWORD_VAR     reduce using rule 200 (empty -> .)
    KEYWORD_VAL     reduce using rule 200 (empty -> .)
    TERMINATOR      reduce using rule 200 (empty -> .)
    KEYWORD_RETURN  reduce using rule 200 (empty -> .)
    KEYWORD_DEF     reduce using rule 200 (empty -> .)
    BLOCKBEGIN      reduce using rule 200 (empty -> .)
    IDENTIFIER      reduce using rule 200 (empty -> .)
    PLUS            reduce using rule 200 (empty -> .)
    MINUS           reduce using rule 200 (empty -> .)
    TILDA           reduce using rule 200 (empty -> .)
    NOT             reduce using rule 200 (empty -> .)
    LPAREN          reduce using rule 200 (empty -> .)
    DOUBLE_NUMBER   reduce using rule 200 (empty -> .)
    INT_NUMBER      reduce using rule 200 (empty -> .)
    CHAR            reduce using rule 200 (empty -> .)
    STRING          reduce using rule 200 (empty -> .)
    KEYWORD_NULL    reduce using rule 200 (empty -> .)
    BOOL_CONSTT     reduce using rule 200 (empty -> .)
    BOOL_CONSTF     reduce using rule 200 (empty -> .)
    BLOCKEND        reduce using rule 200 (empty -> .)

    marker                         shift and go to state 136
    empty                          shift and go to state 104

state 61

    (89) c_literal -> KEYWORD_NULL .

    TIMES           reduce using rule 89 (c_literal -> KEYWORD_NULL .)
    DIVIDE          reduce using rule 89 (c_literal -> KEYWORD_NULL .)
    REMAINDER       reduce using rule 89 (c_literal -> KEYWORD_NULL .)
    PLUS            reduce using rule 89 (c_literal -> KEYWORD_NULL .)
    MINUS           reduce using rule 89 (c_literal -> KEYWORD_NULL .)
    LSHIFT          reduce using rule 89 (c_literal -> KEYWORD_NULL .)
    RSHIFT          reduce using rule 89 (c_literal -> KEYWORD_NULL .)
    GREATER         reduce using rule 89 (c_literal -> KEYWORD_NULL .)
    LESS            reduce using rule 89 (c_literal -> KEYWORD_NULL .)
    GEQ             reduce using rule 89 (c_literal -> KEYWORD_NULL .)
    LEQ             reduce using rule 89 (c_literal -> KEYWORD_NULL .)
    EQUAL           reduce using rule 89 (c_literal -> KEYWORD_NULL .)
    NEQUAL          reduce using rule 89 (c_literal -> KEYWORD_NULL .)
    AND_BITWISE     reduce using rule 89 (c_literal -> KEYWORD_NULL .)
    XOR             reduce using rule 89 (c_literal -> KEYWORD_NULL .)
    OR_BITWISE      reduce using rule 89 (c_literal -> KEYWORD_NULL .)
    AND             reduce using rule 89 (c_literal -> KEYWORD_NULL .)
    OR              reduce using rule 89 (c_literal -> KEYWORD_NULL .)
    KEYWORD_MATCH   reduce using rule 89 (c_literal -> KEYWORD_NULL .)
    TERMINATOR      reduce using rule 89 (c_literal -> KEYWORD_NULL .)
    RPAREN          reduce using rule 89 (c_literal -> KEYWORD_NULL .)
    RBRAC           reduce using rule 89 (c_literal -> KEYWORD_NULL .)
    COMMA           reduce using rule 89 (c_literal -> KEYWORD_NULL .)
    FUNTYPE         reduce using rule 89 (c_literal -> KEYWORD_NULL .)
    KEYWORD_UNTIL   reduce using rule 89 (c_literal -> KEYWORD_NULL .)
    KEYWORD_TO      reduce using rule 89 (c_literal -> KEYWORD_NULL .)
    KEYWORD_BY      reduce using rule 89 (c_literal -> KEYWORD_NULL .)


state 62

    (61) shift_expression -> additive_expression .
    (65) additive_expression -> additive_expression . PLUS multiplicative_expression
    (66) additive_expression -> additive_expression . MINUS multiplicative_expression

    LSHIFT          reduce using rule 61 (shift_expression -> additive_expression .)
    RSHIFT          reduce using rule 61 (shift_expression -> additive_expression .)
    GREATER         reduce using rule 61 (shift_expression -> additive_expression .)
    LESS            reduce using rule 61 (shift_expression -> additive_expression .)
    GEQ             reduce using rule 61 (shift_expression -> additive_expression .)
    LEQ             reduce using rule 61 (shift_expression -> additive_expression .)
    EQUAL           reduce using rule 61 (shift_expression -> additive_expression .)
    NEQUAL          reduce using rule 61 (shift_expression -> additive_expression .)
    AND_BITWISE     reduce using rule 61 (shift_expression -> additive_expression .)
    XOR             reduce using rule 61 (shift_expression -> additive_expression .)
    OR_BITWISE      reduce using rule 61 (shift_expression -> additive_expression .)
    AND             reduce using rule 61 (shift_expression -> additive_expression .)
    OR              reduce using rule 61 (shift_expression -> additive_expression .)
    COMMA           reduce using rule 61 (shift_expression -> additive_expression .)
    RPAREN          reduce using rule 61 (shift_expression -> additive_expression .)
    KEYWORD_MATCH   reduce using rule 61 (shift_expression -> additive_expression .)
    TERMINATOR      reduce using rule 61 (shift_expression -> additive_expression .)
    RBRAC           reduce using rule 61 (shift_expression -> additive_expression .)
    FUNTYPE         reduce using rule 61 (shift_expression -> additive_expression .)
    KEYWORD_UNTIL   reduce using rule 61 (shift_expression -> additive_expression .)
    KEYWORD_TO      reduce using rule 61 (shift_expression -> additive_expression .)
    KEYWORD_BY      reduce using rule 61 (shift_expression -> additive_expression .)
    PLUS            shift and go to state 137
    MINUS           shift and go to state 138


state 63

    (130) name -> simple_name .

    LPAREN          reduce using rule 130 (name -> simple_name .)
    INST            reduce using rule 130 (name -> simple_name .)
    LBRAC           reduce using rule 130 (name -> simple_name .)
    ASOP            reduce using rule 130 (name -> simple_name .)
    TIMES_ASSIGN    reduce using rule 130 (name -> simple_name .)
    DIVIDE_ASSIGN   reduce using rule 130 (name -> simple_name .)
    REMAINDER_ASSIGN reduce using rule 130 (name -> simple_name .)
    PLUS_ASSIGN     reduce using rule 130 (name -> simple_name .)
    MINUS_ASSIGN    reduce using rule 130 (name -> simple_name .)
    LSHIFT_ASSIGN   reduce using rule 130 (name -> simple_name .)
    RSHIFT_ASSIGN   reduce using rule 130 (name -> simple_name .)
    AND_ASSIGN      reduce using rule 130 (name -> simple_name .)
    OR_ASSIGN       reduce using rule 130 (name -> simple_name .)
    XOR_ASSIGN      reduce using rule 130 (name -> simple_name .)
    TIMES           reduce using rule 130 (name -> simple_name .)
    DIVIDE          reduce using rule 130 (name -> simple_name .)
    REMAINDER       reduce using rule 130 (name -> simple_name .)
    PLUS            reduce using rule 130 (name -> simple_name .)
    MINUS           reduce using rule 130 (name -> simple_name .)
    LSHIFT          reduce using rule 130 (name -> simple_name .)
    RSHIFT          reduce using rule 130 (name -> simple_name .)
    GREATER         reduce using rule 130 (name -> simple_name .)
    LESS            reduce using rule 130 (name -> simple_name .)
    GEQ             reduce using rule 130 (name -> simple_name .)
    LEQ             reduce using rule 130 (name -> simple_name .)
    EQUAL           reduce using rule 130 (name -> simple_name .)
    NEQUAL          reduce using rule 130 (name -> simple_name .)
    AND_BITWISE     reduce using rule 130 (name -> simple_name .)
    XOR             reduce using rule 130 (name -> simple_name .)
    OR_BITWISE      reduce using rule 130 (name -> simple_name .)
    AND             reduce using rule 130 (name -> simple_name .)
    OR              reduce using rule 130 (name -> simple_name .)
    KEYWORD_UNTIL   reduce using rule 130 (name -> simple_name .)
    KEYWORD_TO      reduce using rule 130 (name -> simple_name .)
    RPAREN          reduce using rule 130 (name -> simple_name .)
    KEYWORD_MATCH   reduce using rule 130 (name -> simple_name .)
    TERMINATOR      reduce using rule 130 (name -> simple_name .)
    RBRAC           reduce using rule 130 (name -> simple_name .)
    COMMA           reduce using rule 130 (name -> simple_name .)
    FUNTYPE         reduce using rule 130 (name -> simple_name .)
    KEYWORD_BY      reduce using rule 130 (name -> simple_name .)


state 64

    (173) return_statement -> KEYWORD_RETURN . expression_optional TERMINATOR
    (20) expression_optional -> . expression
    (21) expression_optional -> . empty
    (19) expression -> . assignment_expression
    (200) empty -> .
    (22) assignment_expression -> . assignment
    (23) assignment_expression -> . conditional_or_expression
    (24) assignment_expression -> . method_invocation
    (25) assignment -> . valid_variable assignment_operator assignment_expression
    (43) conditional_or_expression -> . conditional_and_expression
    (44) conditional_or_expression -> . conditional_or_expression OR marker conditional_and_expression
    (94) method_invocation -> . name LPAREN argument_list_opt RPAREN
    (26) valid_variable -> . name
    (27) valid_variable -> . array_access
    (45) conditional_and_expression -> . inclusive_or_expression
    (46) conditional_and_expression -> . conditional_and_expression AND marker inclusive_or_expression
    (130) name -> . simple_name
    (131) name -> . qualified_name
    (28) array_access -> . name dimension
    (47) inclusive_or_expression -> . exclusive_or_expression
    (48) inclusive_or_expression -> . inclusive_or_expression OR_BITWISE exclusive_or_expression
    (132) simple_name -> . IDENTIFIER
    (133) qualified_name -> . name INST simple_name
    (49) exclusive_or_expression -> . and_expression
    (50) exclusive_or_expression -> . exclusive_or_expression XOR and_expression
    (51) and_expression -> . equality_expression
    (52) and_expression -> . and_expression AND_BITWISE equality_expression
    (53) equality_expression -> . relational_expression
    (54) equality_expression -> . equality_expression EQUAL relational_expression
    (55) equality_expression -> . equality_expression NEQUAL relational_expression
    (56) relational_expression -> . shift_expression
    (57) relational_expression -> . relational_expression GREATER shift_expression
    (58) relational_expression -> . relational_expression LESS shift_expression
    (59) relational_expression -> . relational_expression GEQ shift_expression
    (60) relational_expression -> . relational_expression LEQ shift_expression
    (61) shift_expression -> . additive_expression
    (62) shift_expression -> . shift_expression LSHIFT additive_expression
    (63) shift_expression -> . shift_expression RSHIFT additive_expression
    (64) additive_expression -> . multiplicative_expression
    (65) additive_expression -> . additive_expression PLUS multiplicative_expression
    (66) additive_expression -> . additive_expression MINUS multiplicative_expression
    (67) multiplicative_expression -> . unary_expression
    (68) multiplicative_expression -> . multiplicative_expression TIMES unary_expression
    (69) multiplicative_expression -> . multiplicative_expression DIVIDE unary_expression
    (70) multiplicative_expression -> . multiplicative_expression REMAINDER unary_expression
    (71) unary_expression -> . PLUS unary_expression
    (72) unary_expression -> . MINUS unary_expression
    (73) unary_expression -> . unary_expression_not_plus_minus
    (74) unary_expression_not_plus_minus -> . base_variable_set
    (75) unary_expression_not_plus_minus -> . TILDA unary_expression
    (76) unary_expression_not_plus_minus -> . cast_expression
    (77) unary_expression_not_plus_minus -> . NOT unary_expression
    (78) base_variable_set -> . variable_literal
    (79) base_variable_set -> . LPAREN expression RPAREN
    (82) cast_expression -> . LPAREN primitive_type RPAREN unary_expression
    (80) variable_literal -> . valid_variable
    (81) variable_literal -> . primary
    (83) primary -> . literal
    (84) primary -> . method_invocation
    (85) literal -> . int_float
    (86) literal -> . c_literal
    (92) int_float -> . DOUBLE_NUMBER
    (93) int_float -> . INT_NUMBER
    (87) c_literal -> . CHAR
    (88) c_literal -> . STRING
    (89) c_literal -> . KEYWORD_NULL
    (90) c_literal -> . BOOL_CONSTT
    (91) c_literal -> . BOOL_CONSTF

    TERMINATOR      reduce using rule 200 (empty -> .)
    IDENTIFIER      shift and go to state 9
    PLUS            shift and go to state 31
    MINUS           shift and go to state 24
    TILDA           shift and go to state 68
    NOT             shift and go to state 53
    LPAREN          shift and go to state 91
    DOUBLE_NUMBER   shift and go to state 28
    INT_NUMBER      shift and go to state 39
    CHAR            shift and go to state 59
    STRING          shift and go to state 72
    KEYWORD_NULL    shift and go to state 61
    BOOL_CONSTT     shift and go to state 30
    BOOL_CONSTF     shift and go to state 25

    unary_expression               shift and go to state 40
    exclusive_or_expression        shift and go to state 57
    primary                        shift and go to state 58
    unary_expression_not_plus_minus shift and go to state 41
    array_access                   shift and go to state 23
    and_expression                 shift and go to state 84
    simple_name                    shift and go to state 63
    c_literal                      shift and go to state 90
    expression_optional            shift and go to state 141
    base_variable_set              shift and go to state 85
    valid_variable                 shift and go to state 92
    inclusive_or_expression        shift and go to state 27
    literal                        shift and go to state 67
    relational_expression          shift and go to state 69
    method_invocation              shift and go to state 139
    conditional_or_expression      shift and go to state 43
    empty                          shift and go to state 140
    assignment_expression          shift and go to state 88
    qualified_name                 shift and go to state 75
    assignment                     shift and go to state 142
    multiplicative_expression      shift and go to state 46
    additive_expression            shift and go to state 62
    cast_expression                shift and go to state 77
    shift_expression               shift and go to state 50
    equality_expression            shift and go to state 79
    int_float                      shift and go to state 35
    variable_literal               shift and go to state 51
    name                           shift and go to state 38
    expression                     shift and go to state 143
    conditional_and_expression     shift and go to state 52

state 65

    (18) block_statement -> method_declaration .

    KEYWORD_IF      reduce using rule 18 (block_statement -> method_declaration .)
    KEYWORD_WHILE   reduce using rule 18 (block_statement -> method_declaration .)
    KEYWORD_DO      reduce using rule 18 (block_statement -> method_declaration .)
    KEYWORD_FOR     reduce using rule 18 (block_statement -> method_declaration .)
    KEYWORD_CLASS   reduce using rule 18 (block_statement -> method_declaration .)
    KEYWORD_OBJECT  reduce using rule 18 (block_statement -> method_declaration .)
    KEYWORD_VAR     reduce using rule 18 (block_statement -> method_declaration .)
    KEYWORD_VAL     reduce using rule 18 (block_statement -> method_declaration .)
    TERMINATOR      reduce using rule 18 (block_statement -> method_declaration .)
    KEYWORD_RETURN  reduce using rule 18 (block_statement -> method_declaration .)
    KEYWORD_DEF     reduce using rule 18 (block_statement -> method_declaration .)
    BLOCKBEGIN      reduce using rule 18 (block_statement -> method_declaration .)
    IDENTIFIER      reduce using rule 18 (block_statement -> method_declaration .)
    PLUS            reduce using rule 18 (block_statement -> method_declaration .)
    MINUS           reduce using rule 18 (block_statement -> method_declaration .)
    TILDA           reduce using rule 18 (block_statement -> method_declaration .)
    NOT             reduce using rule 18 (block_statement -> method_declaration .)
    LPAREN          reduce using rule 18 (block_statement -> method_declaration .)
    DOUBLE_NUMBER   reduce using rule 18 (block_statement -> method_declaration .)
    INT_NUMBER      reduce using rule 18 (block_statement -> method_declaration .)
    CHAR            reduce using rule 18 (block_statement -> method_declaration .)
    STRING          reduce using rule 18 (block_statement -> method_declaration .)
    KEYWORD_NULL    reduce using rule 18 (block_statement -> method_declaration .)
    BOOL_CONSTT     reduce using rule 18 (block_statement -> method_declaration .)
    BOOL_CONSTF     reduce using rule 18 (block_statement -> method_declaration .)
    BLOCKEND        reduce using rule 18 (block_statement -> method_declaration .)


state 66

    (12) block_statements -> block_statement .

    KEYWORD_IF      reduce using rule 12 (block_statements -> block_statement .)
    KEYWORD_WHILE   reduce using rule 12 (block_statements -> block_statement .)
    KEYWORD_DO      reduce using rule 12 (block_statements -> block_statement .)
    KEYWORD_FOR     reduce using rule 12 (block_statements -> block_statement .)
    KEYWORD_CLASS   reduce using rule 12 (block_statements -> block_statement .)
    KEYWORD_OBJECT  reduce using rule 12 (block_statements -> block_statement .)
    KEYWORD_VAR     reduce using rule 12 (block_statements -> block_statement .)
    KEYWORD_VAL     reduce using rule 12 (block_statements -> block_statement .)
    TERMINATOR      reduce using rule 12 (block_statements -> block_statement .)
    KEYWORD_RETURN  reduce using rule 12 (block_statements -> block_statement .)
    KEYWORD_DEF     reduce using rule 12 (block_statements -> block_statement .)
    BLOCKBEGIN      reduce using rule 12 (block_statements -> block_statement .)
    IDENTIFIER      reduce using rule 12 (block_statements -> block_statement .)
    PLUS            reduce using rule 12 (block_statements -> block_statement .)
    MINUS           reduce using rule 12 (block_statements -> block_statement .)
    TILDA           reduce using rule 12 (block_statements -> block_statement .)
    NOT             reduce using rule 12 (block_statements -> block_statement .)
    LPAREN          reduce using rule 12 (block_statements -> block_statement .)
    DOUBLE_NUMBER   reduce using rule 12 (block_statements -> block_statement .)
    INT_NUMBER      reduce using rule 12 (block_statements -> block_statement .)
    CHAR            reduce using rule 12 (block_statements -> block_statement .)
    STRING          reduce using rule 12 (block_statements -> block_statement .)
    KEYWORD_NULL    reduce using rule 12 (block_statements -> block_statement .)
    BOOL_CONSTT     reduce using rule 12 (block_statements -> block_statement .)
    BOOL_CONSTF     reduce using rule 12 (block_statements -> block_statement .)
    BLOCKEND        reduce using rule 12 (block_statements -> block_statement .)


state 67

    (83) primary -> literal .

    TIMES           reduce using rule 83 (primary -> literal .)
    DIVIDE          reduce using rule 83 (primary -> literal .)
    REMAINDER       reduce using rule 83 (primary -> literal .)
    PLUS            reduce using rule 83 (primary -> literal .)
    MINUS           reduce using rule 83 (primary -> literal .)
    LSHIFT          reduce using rule 83 (primary -> literal .)
    RSHIFT          reduce using rule 83 (primary -> literal .)
    GREATER         reduce using rule 83 (primary -> literal .)
    LESS            reduce using rule 83 (primary -> literal .)
    GEQ             reduce using rule 83 (primary -> literal .)
    LEQ             reduce using rule 83 (primary -> literal .)
    EQUAL           reduce using rule 83 (primary -> literal .)
    NEQUAL          reduce using rule 83 (primary -> literal .)
    AND_BITWISE     reduce using rule 83 (primary -> literal .)
    XOR             reduce using rule 83 (primary -> literal .)
    OR_BITWISE      reduce using rule 83 (primary -> literal .)
    AND             reduce using rule 83 (primary -> literal .)
    OR              reduce using rule 83 (primary -> literal .)
    RPAREN          reduce using rule 83 (primary -> literal .)
    COMMA           reduce using rule 83 (primary -> literal .)
    KEYWORD_MATCH   reduce using rule 83 (primary -> literal .)
    TERMINATOR      reduce using rule 83 (primary -> literal .)
    RBRAC           reduce using rule 83 (primary -> literal .)
    FUNTYPE         reduce using rule 83 (primary -> literal .)
    KEYWORD_UNTIL   reduce using rule 83 (primary -> literal .)
    KEYWORD_TO      reduce using rule 83 (primary -> literal .)
    KEYWORD_BY      reduce using rule 83 (primary -> literal .)


state 68

    (75) unary_expression_not_plus_minus -> TILDA . unary_expression
    (71) unary_expression -> . PLUS unary_expression
    (72) unary_expression -> . MINUS unary_expression
    (73) unary_expression -> . unary_expression_not_plus_minus
    (74) unary_expression_not_plus_minus -> . base_variable_set
    (75) unary_expression_not_plus_minus -> . TILDA unary_expression
    (76) unary_expression_not_plus_minus -> . cast_expression
    (77) unary_expression_not_plus_minus -> . NOT unary_expression
    (78) base_variable_set -> . variable_literal
    (79) base_variable_set -> . LPAREN expression RPAREN
    (82) cast_expression -> . LPAREN primitive_type RPAREN unary_expression
    (80) variable_literal -> . valid_variable
    (81) variable_literal -> . primary
    (26) valid_variable -> . name
    (27) valid_variable -> . array_access
    (83) primary -> . literal
    (84) primary -> . method_invocation
    (130) name -> . simple_name
    (131) name -> . qualified_name
    (28) array_access -> . name dimension
    (85) literal -> . int_float
    (86) literal -> . c_literal
    (94) method_invocation -> . name LPAREN argument_list_opt RPAREN
    (132) simple_name -> . IDENTIFIER
    (133) qualified_name -> . name INST simple_name
    (92) int_float -> . DOUBLE_NUMBER
    (93) int_float -> . INT_NUMBER
    (87) c_literal -> . CHAR
    (88) c_literal -> . STRING
    (89) c_literal -> . KEYWORD_NULL
    (90) c_literal -> . BOOL_CONSTT
    (91) c_literal -> . BOOL_CONSTF

    PLUS            shift and go to state 31
    MINUS           shift and go to state 24
    TILDA           shift and go to state 68
    NOT             shift and go to state 53
    LPAREN          shift and go to state 91
    IDENTIFIER      shift and go to state 9
    DOUBLE_NUMBER   shift and go to state 28
    INT_NUMBER      shift and go to state 39
    CHAR            shift and go to state 59
    STRING          shift and go to state 72
    KEYWORD_NULL    shift and go to state 61
    BOOL_CONSTT     shift and go to state 30
    BOOL_CONSTF     shift and go to state 25

    qualified_name                 shift and go to state 75
    int_float                      shift and go to state 35
    c_literal                      shift and go to state 90
    variable_literal               shift and go to state 51
    unary_expression               shift and go to state 144
    base_variable_set              shift and go to state 85
    valid_variable                 shift and go to state 106
    array_access                   shift and go to state 23
    primary                        shift and go to state 58
    unary_expression_not_plus_minus shift and go to state 41
    literal                        shift and go to state 67
    method_invocation              shift and go to state 107
    cast_expression                shift and go to state 77
    simple_name                    shift and go to state 63
    name                           shift and go to state 108

state 69

    (53) equality_expression -> relational_expression .
    (57) relational_expression -> relational_expression . GREATER shift_expression
    (58) relational_expression -> relational_expression . LESS shift_expression
    (59) relational_expression -> relational_expression . GEQ shift_expression
    (60) relational_expression -> relational_expression . LEQ shift_expression

    EQUAL           reduce using rule 53 (equality_expression -> relational_expression .)
    NEQUAL          reduce using rule 53 (equality_expression -> relational_expression .)
    AND_BITWISE     reduce using rule 53 (equality_expression -> relational_expression .)
    XOR             reduce using rule 53 (equality_expression -> relational_expression .)
    OR_BITWISE      reduce using rule 53 (equality_expression -> relational_expression .)
    AND             reduce using rule 53 (equality_expression -> relational_expression .)
    OR              reduce using rule 53 (equality_expression -> relational_expression .)
    KEYWORD_UNTIL   reduce using rule 53 (equality_expression -> relational_expression .)
    KEYWORD_TO      reduce using rule 53 (equality_expression -> relational_expression .)
    KEYWORD_MATCH   reduce using rule 53 (equality_expression -> relational_expression .)
    RBRAC           reduce using rule 53 (equality_expression -> relational_expression .)
    RPAREN          reduce using rule 53 (equality_expression -> relational_expression .)
    COMMA           reduce using rule 53 (equality_expression -> relational_expression .)
    TERMINATOR      reduce using rule 53 (equality_expression -> relational_expression .)
    FUNTYPE         reduce using rule 53 (equality_expression -> relational_expression .)
    KEYWORD_BY      reduce using rule 53 (equality_expression -> relational_expression .)
    GREATER         shift and go to state 146
    LESS            shift and go to state 147
    GEQ             shift and go to state 145
    LEQ             shift and go to state 148


state 70

    (15) block_statement -> statement .

    KEYWORD_IF      reduce using rule 15 (block_statement -> statement .)
    KEYWORD_WHILE   reduce using rule 15 (block_statement -> statement .)
    KEYWORD_DO      reduce using rule 15 (block_statement -> statement .)
    KEYWORD_FOR     reduce using rule 15 (block_statement -> statement .)
    KEYWORD_CLASS   reduce using rule 15 (block_statement -> statement .)
    KEYWORD_OBJECT  reduce using rule 15 (block_statement -> statement .)
    KEYWORD_VAR     reduce using rule 15 (block_statement -> statement .)
    KEYWORD_VAL     reduce using rule 15 (block_statement -> statement .)
    TERMINATOR      reduce using rule 15 (block_statement -> statement .)
    KEYWORD_RETURN  reduce using rule 15 (block_statement -> statement .)
    KEYWORD_DEF     reduce using rule 15 (block_statement -> statement .)
    BLOCKBEGIN      reduce using rule 15 (block_statement -> statement .)
    IDENTIFIER      reduce using rule 15 (block_statement -> statement .)
    PLUS            reduce using rule 15 (block_statement -> statement .)
    MINUS           reduce using rule 15 (block_statement -> statement .)
    TILDA           reduce using rule 15 (block_statement -> statement .)
    NOT             reduce using rule 15 (block_statement -> statement .)
    LPAREN          reduce using rule 15 (block_statement -> statement .)
    DOUBLE_NUMBER   reduce using rule 15 (block_statement -> statement .)
    INT_NUMBER      reduce using rule 15 (block_statement -> statement .)
    CHAR            reduce using rule 15 (block_statement -> statement .)
    STRING          reduce using rule 15 (block_statement -> statement .)
    KEYWORD_NULL    reduce using rule 15 (block_statement -> statement .)
    BOOL_CONSTT     reduce using rule 15 (block_statement -> statement .)
    BOOL_CONSTF     reduce using rule 15 (block_statement -> statement .)
    BLOCKEND        reduce using rule 15 (block_statement -> statement .)


state 71

    (150) statement_expression -> method_invocation .
    (24) assignment_expression -> method_invocation .
    (84) primary -> method_invocation .

  ! reduce/reduce conflict for KEYWORD_MATCH resolved using rule 24 (assignment_expression -> method_invocation .)
    TERMINATOR      reduce using rule 150 (statement_expression -> method_invocation .)
    KEYWORD_MATCH   reduce using rule 24 (assignment_expression -> method_invocation .)
    TIMES           reduce using rule 84 (primary -> method_invocation .)
    DIVIDE          reduce using rule 84 (primary -> method_invocation .)
    REMAINDER       reduce using rule 84 (primary -> method_invocation .)
    PLUS            reduce using rule 84 (primary -> method_invocation .)
    MINUS           reduce using rule 84 (primary -> method_invocation .)
    LSHIFT          reduce using rule 84 (primary -> method_invocation .)
    RSHIFT          reduce using rule 84 (primary -> method_invocation .)
    GREATER         reduce using rule 84 (primary -> method_invocation .)
    LESS            reduce using rule 84 (primary -> method_invocation .)
    GEQ             reduce using rule 84 (primary -> method_invocation .)
    LEQ             reduce using rule 84 (primary -> method_invocation .)
    EQUAL           reduce using rule 84 (primary -> method_invocation .)
    NEQUAL          reduce using rule 84 (primary -> method_invocation .)
    AND_BITWISE     reduce using rule 84 (primary -> method_invocation .)
    XOR             reduce using rule 84 (primary -> method_invocation .)
    OR_BITWISE      reduce using rule 84 (primary -> method_invocation .)
    AND             reduce using rule 84 (primary -> method_invocation .)
    OR              reduce using rule 84 (primary -> method_invocation .)

  ! KEYWORD_MATCH   [ reduce using rule 84 (primary -> method_invocation .) ]


state 72

    (88) c_literal -> STRING .

    TIMES           reduce using rule 88 (c_literal -> STRING .)
    DIVIDE          reduce using rule 88 (c_literal -> STRING .)
    REMAINDER       reduce using rule 88 (c_literal -> STRING .)
    PLUS            reduce using rule 88 (c_literal -> STRING .)
    MINUS           reduce using rule 88 (c_literal -> STRING .)
    LSHIFT          reduce using rule 88 (c_literal -> STRING .)
    RSHIFT          reduce using rule 88 (c_literal -> STRING .)
    GREATER         reduce using rule 88 (c_literal -> STRING .)
    LESS            reduce using rule 88 (c_literal -> STRING .)
    GEQ             reduce using rule 88 (c_literal -> STRING .)
    LEQ             reduce using rule 88 (c_literal -> STRING .)
    EQUAL           reduce using rule 88 (c_literal -> STRING .)
    NEQUAL          reduce using rule 88 (c_literal -> STRING .)
    AND_BITWISE     reduce using rule 88 (c_literal -> STRING .)
    XOR             reduce using rule 88 (c_literal -> STRING .)
    OR_BITWISE      reduce using rule 88 (c_literal -> STRING .)
    AND             reduce using rule 88 (c_literal -> STRING .)
    OR              reduce using rule 88 (c_literal -> STRING .)
    KEYWORD_MATCH   reduce using rule 88 (c_literal -> STRING .)
    TERMINATOR      reduce using rule 88 (c_literal -> STRING .)
    RPAREN          reduce using rule 88 (c_literal -> STRING .)
    RBRAC           reduce using rule 88 (c_literal -> STRING .)
    COMMA           reduce using rule 88 (c_literal -> STRING .)
    FUNTYPE         reduce using rule 88 (c_literal -> STRING .)
    KEYWORD_UNTIL   reduce using rule 88 (c_literal -> STRING .)
    KEYWORD_TO      reduce using rule 88 (c_literal -> STRING .)
    KEYWORD_BY      reduce using rule 88 (c_literal -> STRING .)


state 73

    (11) block_statements_opt -> empty .

    BLOCKEND        reduce using rule 11 (block_statements_opt -> empty .)


state 74

    (102) local_variable_declaration -> declaration_keyword . variable_declaration_body
    (108) variable_declaration_body -> . identifiers COLON type ASOP variable_declaration_initializer
    (109) identifiers -> . identifiers COMMA IDENTIFIER
    (110) identifiers -> . IDENTIFIER

    IDENTIFIER      shift and go to state 151

    variable_declaration_body      shift and go to state 149
    identifiers                    shift and go to state 150

state 75

    (131) name -> qualified_name .

    LPAREN          reduce using rule 131 (name -> qualified_name .)
    INST            reduce using rule 131 (name -> qualified_name .)
    LBRAC           reduce using rule 131 (name -> qualified_name .)
    ASOP            reduce using rule 131 (name -> qualified_name .)
    TIMES_ASSIGN    reduce using rule 131 (name -> qualified_name .)
    DIVIDE_ASSIGN   reduce using rule 131 (name -> qualified_name .)
    REMAINDER_ASSIGN reduce using rule 131 (name -> qualified_name .)
    PLUS_ASSIGN     reduce using rule 131 (name -> qualified_name .)
    MINUS_ASSIGN    reduce using rule 131 (name -> qualified_name .)
    LSHIFT_ASSIGN   reduce using rule 131 (name -> qualified_name .)
    RSHIFT_ASSIGN   reduce using rule 131 (name -> qualified_name .)
    AND_ASSIGN      reduce using rule 131 (name -> qualified_name .)
    OR_ASSIGN       reduce using rule 131 (name -> qualified_name .)
    XOR_ASSIGN      reduce using rule 131 (name -> qualified_name .)
    TIMES           reduce using rule 131 (name -> qualified_name .)
    DIVIDE          reduce using rule 131 (name -> qualified_name .)
    REMAINDER       reduce using rule 131 (name -> qualified_name .)
    PLUS            reduce using rule 131 (name -> qualified_name .)
    MINUS           reduce using rule 131 (name -> qualified_name .)
    LSHIFT          reduce using rule 131 (name -> qualified_name .)
    RSHIFT          reduce using rule 131 (name -> qualified_name .)
    GREATER         reduce using rule 131 (name -> qualified_name .)
    LESS            reduce using rule 131 (name -> qualified_name .)
    GEQ             reduce using rule 131 (name -> qualified_name .)
    LEQ             reduce using rule 131 (name -> qualified_name .)
    EQUAL           reduce using rule 131 (name -> qualified_name .)
    NEQUAL          reduce using rule 131 (name -> qualified_name .)
    AND_BITWISE     reduce using rule 131 (name -> qualified_name .)
    XOR             reduce using rule 131 (name -> qualified_name .)
    OR_BITWISE      reduce using rule 131 (name -> qualified_name .)
    AND             reduce using rule 131 (name -> qualified_name .)
    OR              reduce using rule 131 (name -> qualified_name .)
    KEYWORD_UNTIL   reduce using rule 131 (name -> qualified_name .)
    KEYWORD_TO      reduce using rule 131 (name -> qualified_name .)
    RPAREN          reduce using rule 131 (name -> qualified_name .)
    KEYWORD_MATCH   reduce using rule 131 (name -> qualified_name .)
    TERMINATOR      reduce using rule 131 (name -> qualified_name .)
    RBRAC           reduce using rule 131 (name -> qualified_name .)
    COMMA           reduce using rule 131 (name -> qualified_name .)
    FUNTYPE         reduce using rule 131 (name -> qualified_name .)
    KEYWORD_BY      reduce using rule 131 (name -> qualified_name .)


state 76

    (183) method_header_name -> KEYWORD_DEF . IDENTIFIER

    IDENTIFIER      shift and go to state 152


state 77

    (76) unary_expression_not_plus_minus -> cast_expression .

    TIMES           reduce using rule 76 (unary_expression_not_plus_minus -> cast_expression .)
    DIVIDE          reduce using rule 76 (unary_expression_not_plus_minus -> cast_expression .)
    REMAINDER       reduce using rule 76 (unary_expression_not_plus_minus -> cast_expression .)
    PLUS            reduce using rule 76 (unary_expression_not_plus_minus -> cast_expression .)
    MINUS           reduce using rule 76 (unary_expression_not_plus_minus -> cast_expression .)
    LSHIFT          reduce using rule 76 (unary_expression_not_plus_minus -> cast_expression .)
    RSHIFT          reduce using rule 76 (unary_expression_not_plus_minus -> cast_expression .)
    GREATER         reduce using rule 76 (unary_expression_not_plus_minus -> cast_expression .)
    LESS            reduce using rule 76 (unary_expression_not_plus_minus -> cast_expression .)
    GEQ             reduce using rule 76 (unary_expression_not_plus_minus -> cast_expression .)
    LEQ             reduce using rule 76 (unary_expression_not_plus_minus -> cast_expression .)
    EQUAL           reduce using rule 76 (unary_expression_not_plus_minus -> cast_expression .)
    NEQUAL          reduce using rule 76 (unary_expression_not_plus_minus -> cast_expression .)
    AND_BITWISE     reduce using rule 76 (unary_expression_not_plus_minus -> cast_expression .)
    XOR             reduce using rule 76 (unary_expression_not_plus_minus -> cast_expression .)
    OR_BITWISE      reduce using rule 76 (unary_expression_not_plus_minus -> cast_expression .)
    AND             reduce using rule 76 (unary_expression_not_plus_minus -> cast_expression .)
    OR              reduce using rule 76 (unary_expression_not_plus_minus -> cast_expression .)
    KEYWORD_MATCH   reduce using rule 76 (unary_expression_not_plus_minus -> cast_expression .)
    TERMINATOR      reduce using rule 76 (unary_expression_not_plus_minus -> cast_expression .)
    RPAREN          reduce using rule 76 (unary_expression_not_plus_minus -> cast_expression .)
    RBRAC           reduce using rule 76 (unary_expression_not_plus_minus -> cast_expression .)
    COMMA           reduce using rule 76 (unary_expression_not_plus_minus -> cast_expression .)
    FUNTYPE         reduce using rule 76 (unary_expression_not_plus_minus -> cast_expression .)
    KEYWORD_UNTIL   reduce using rule 76 (unary_expression_not_plus_minus -> cast_expression .)
    KEYWORD_TO      reduce using rule 76 (unary_expression_not_plus_minus -> cast_expression .)
    KEYWORD_BY      reduce using rule 76 (unary_expression_not_plus_minus -> cast_expression .)


state 78

    (151) if_then_statement -> KEYWORD_IF . LPAREN expression RPAREN marker block
    (152) if_then_else_statement -> KEYWORD_IF . LPAREN expression RPAREN marker if_then_else_intermediate narker KEYWORD_ELSE marker block

    LPAREN          shift and go to state 153


state 79

    (51) and_expression -> equality_expression .
    (54) equality_expression -> equality_expression . EQUAL relational_expression
    (55) equality_expression -> equality_expression . NEQUAL relational_expression

    AND_BITWISE     reduce using rule 51 (and_expression -> equality_expression .)
    XOR             reduce using rule 51 (and_expression -> equality_expression .)
    OR_BITWISE      reduce using rule 51 (and_expression -> equality_expression .)
    AND             reduce using rule 51 (and_expression -> equality_expression .)
    OR              reduce using rule 51 (and_expression -> equality_expression .)
    TERMINATOR      reduce using rule 51 (and_expression -> equality_expression .)
    KEYWORD_MATCH   reduce using rule 51 (and_expression -> equality_expression .)
    RPAREN          reduce using rule 51 (and_expression -> equality_expression .)
    RBRAC           reduce using rule 51 (and_expression -> equality_expression .)
    COMMA           reduce using rule 51 (and_expression -> equality_expression .)
    FUNTYPE         reduce using rule 51 (and_expression -> equality_expression .)
    KEYWORD_UNTIL   reduce using rule 51 (and_expression -> equality_expression .)
    KEYWORD_TO      reduce using rule 51 (and_expression -> equality_expression .)
    KEYWORD_BY      reduce using rule 51 (and_expression -> equality_expression .)
    EQUAL           shift and go to state 155
    NEQUAL          shift and go to state 154


state 80

    (174) method_declaration -> method_header . method_body
    (184) method_body -> . method_start_scope block_statements_opt end_scope
    (185) method_start_scope -> . BLOCKBEGIN

    BLOCKBEGIN      shift and go to state 158

    method_body                    shift and go to state 157
    method_start_scope             shift and go to state 156

state 81

    (145) normal_statement -> empty_statement . marker
    (41) marker -> . empty
    (200) empty -> .

    KEYWORD_IF      reduce using rule 200 (empty -> .)
    KEYWORD_WHILE   reduce using rule 200 (empty -> .)
    KEYWORD_DO      reduce using rule 200 (empty -> .)
    KEYWORD_FOR     reduce using rule 200 (empty -> .)
    KEYWORD_CLASS   reduce using rule 200 (empty -> .)
    KEYWORD_OBJECT  reduce using rule 200 (empty -> .)
    KEYWORD_VAR     reduce using rule 200 (empty -> .)
    KEYWORD_VAL     reduce using rule 200 (empty -> .)
    TERMINATOR      reduce using rule 200 (empty -> .)
    KEYWORD_RETURN  reduce using rule 200 (empty -> .)
    KEYWORD_DEF     reduce using rule 200 (empty -> .)
    BLOCKBEGIN      reduce using rule 200 (empty -> .)
    IDENTIFIER      reduce using rule 200 (empty -> .)
    PLUS            reduce using rule 200 (empty -> .)
    MINUS           reduce using rule 200 (empty -> .)
    TILDA           reduce using rule 200 (empty -> .)
    NOT             reduce using rule 200 (empty -> .)
    LPAREN          reduce using rule 200 (empty -> .)
    DOUBLE_NUMBER   reduce using rule 200 (empty -> .)
    INT_NUMBER      reduce using rule 200 (empty -> .)
    CHAR            reduce using rule 200 (empty -> .)
    STRING          reduce using rule 200 (empty -> .)
    KEYWORD_NULL    reduce using rule 200 (empty -> .)
    BOOL_CONSTT     reduce using rule 200 (empty -> .)
    BOOL_CONSTF     reduce using rule 200 (empty -> .)
    BLOCKEND        reduce using rule 200 (empty -> .)
    KEYWORD_ELSE    reduce using rule 200 (empty -> .)

    marker                         shift and go to state 159
    empty                          shift and go to state 104

state 82

    (101) local_variable_declaration_statement -> local_variable_declaration . TERMINATOR

    TERMINATOR      shift and go to state 160


state 83

    (137) statement -> normal_statement . marker
    (41) marker -> . empty
    (200) empty -> .

    KEYWORD_IF      reduce using rule 200 (empty -> .)
    KEYWORD_WHILE   reduce using rule 200 (empty -> .)
    KEYWORD_DO      reduce using rule 200 (empty -> .)
    KEYWORD_FOR     reduce using rule 200 (empty -> .)
    KEYWORD_CLASS   reduce using rule 200 (empty -> .)
    KEYWORD_OBJECT  reduce using rule 200 (empty -> .)
    KEYWORD_VAR     reduce using rule 200 (empty -> .)
    KEYWORD_VAL     reduce using rule 200 (empty -> .)
    TERMINATOR      reduce using rule 200 (empty -> .)
    KEYWORD_RETURN  reduce using rule 200 (empty -> .)
    KEYWORD_DEF     reduce using rule 200 (empty -> .)
    BLOCKBEGIN      reduce using rule 200 (empty -> .)
    IDENTIFIER      reduce using rule 200 (empty -> .)
    PLUS            reduce using rule 200 (empty -> .)
    MINUS           reduce using rule 200 (empty -> .)
    TILDA           reduce using rule 200 (empty -> .)
    NOT             reduce using rule 200 (empty -> .)
    LPAREN          reduce using rule 200 (empty -> .)
    DOUBLE_NUMBER   reduce using rule 200 (empty -> .)
    INT_NUMBER      reduce using rule 200 (empty -> .)
    CHAR            reduce using rule 200 (empty -> .)
    STRING          reduce using rule 200 (empty -> .)
    KEYWORD_NULL    reduce using rule 200 (empty -> .)
    BOOL_CONSTT     reduce using rule 200 (empty -> .)
    BOOL_CONSTF     reduce using rule 200 (empty -> .)
    BLOCKEND        reduce using rule 200 (empty -> .)

    marker                         shift and go to state 161
    empty                          shift and go to state 104

state 84

    (49) exclusive_or_expression -> and_expression .
    (52) and_expression -> and_expression . AND_BITWISE equality_expression

    XOR             reduce using rule 49 (exclusive_or_expression -> and_expression .)
    OR_BITWISE      reduce using rule 49 (exclusive_or_expression -> and_expression .)
    AND             reduce using rule 49 (exclusive_or_expression -> and_expression .)
    OR              reduce using rule 49 (exclusive_or_expression -> and_expression .)
    COMMA           reduce using rule 49 (exclusive_or_expression -> and_expression .)
    RPAREN          reduce using rule 49 (exclusive_or_expression -> and_expression .)
    TERMINATOR      reduce using rule 49 (exclusive_or_expression -> and_expression .)
    KEYWORD_MATCH   reduce using rule 49 (exclusive_or_expression -> and_expression .)
    RBRAC           reduce using rule 49 (exclusive_or_expression -> and_expression .)
    FUNTYPE         reduce using rule 49 (exclusive_or_expression -> and_expression .)
    KEYWORD_UNTIL   reduce using rule 49 (exclusive_or_expression -> and_expression .)
    KEYWORD_TO      reduce using rule 49 (exclusive_or_expression -> and_expression .)
    KEYWORD_BY      reduce using rule 49 (exclusive_or_expression -> and_expression .)
    AND_BITWISE     shift and go to state 162


state 85

    (74) unary_expression_not_plus_minus -> base_variable_set .

    TIMES           reduce using rule 74 (unary_expression_not_plus_minus -> base_variable_set .)
    DIVIDE          reduce using rule 74 (unary_expression_not_plus_minus -> base_variable_set .)
    REMAINDER       reduce using rule 74 (unary_expression_not_plus_minus -> base_variable_set .)
    PLUS            reduce using rule 74 (unary_expression_not_plus_minus -> base_variable_set .)
    MINUS           reduce using rule 74 (unary_expression_not_plus_minus -> base_variable_set .)
    LSHIFT          reduce using rule 74 (unary_expression_not_plus_minus -> base_variable_set .)
    RSHIFT          reduce using rule 74 (unary_expression_not_plus_minus -> base_variable_set .)
    GREATER         reduce using rule 74 (unary_expression_not_plus_minus -> base_variable_set .)
    LESS            reduce using rule 74 (unary_expression_not_plus_minus -> base_variable_set .)
    GEQ             reduce using rule 74 (unary_expression_not_plus_minus -> base_variable_set .)
    LEQ             reduce using rule 74 (unary_expression_not_plus_minus -> base_variable_set .)
    EQUAL           reduce using rule 74 (unary_expression_not_plus_minus -> base_variable_set .)
    NEQUAL          reduce using rule 74 (unary_expression_not_plus_minus -> base_variable_set .)
    AND_BITWISE     reduce using rule 74 (unary_expression_not_plus_minus -> base_variable_set .)
    XOR             reduce using rule 74 (unary_expression_not_plus_minus -> base_variable_set .)
    OR_BITWISE      reduce using rule 74 (unary_expression_not_plus_minus -> base_variable_set .)
    AND             reduce using rule 74 (unary_expression_not_plus_minus -> base_variable_set .)
    OR              reduce using rule 74 (unary_expression_not_plus_minus -> base_variable_set .)
    KEYWORD_MATCH   reduce using rule 74 (unary_expression_not_plus_minus -> base_variable_set .)
    TERMINATOR      reduce using rule 74 (unary_expression_not_plus_minus -> base_variable_set .)
    RPAREN          reduce using rule 74 (unary_expression_not_plus_minus -> base_variable_set .)
    RBRAC           reduce using rule 74 (unary_expression_not_plus_minus -> base_variable_set .)
    COMMA           reduce using rule 74 (unary_expression_not_plus_minus -> base_variable_set .)
    FUNTYPE         reduce using rule 74 (unary_expression_not_plus_minus -> base_variable_set .)
    KEYWORD_UNTIL   reduce using rule 74 (unary_expression_not_plus_minus -> base_variable_set .)
    KEYWORD_TO      reduce using rule 74 (unary_expression_not_plus_minus -> base_variable_set .)
    KEYWORD_BY      reduce using rule 74 (unary_expression_not_plus_minus -> base_variable_set .)


state 86

    (146) normal_statement -> return_statement . marker
    (41) marker -> . empty
    (200) empty -> .

    KEYWORD_IF      reduce using rule 200 (empty -> .)
    KEYWORD_WHILE   reduce using rule 200 (empty -> .)
    KEYWORD_DO      reduce using rule 200 (empty -> .)
    KEYWORD_FOR     reduce using rule 200 (empty -> .)
    KEYWORD_CLASS   reduce using rule 200 (empty -> .)
    KEYWORD_OBJECT  reduce using rule 200 (empty -> .)
    KEYWORD_VAR     reduce using rule 200 (empty -> .)
    KEYWORD_VAL     reduce using rule 200 (empty -> .)
    TERMINATOR      reduce using rule 200 (empty -> .)
    KEYWORD_RETURN  reduce using rule 200 (empty -> .)
    KEYWORD_DEF     reduce using rule 200 (empty -> .)
    BLOCKBEGIN      reduce using rule 200 (empty -> .)
    IDENTIFIER      reduce using rule 200 (empty -> .)
    PLUS            reduce using rule 200 (empty -> .)
    MINUS           reduce using rule 200 (empty -> .)
    TILDA           reduce using rule 200 (empty -> .)
    NOT             reduce using rule 200 (empty -> .)
    LPAREN          reduce using rule 200 (empty -> .)
    DOUBLE_NUMBER   reduce using rule 200 (empty -> .)
    INT_NUMBER      reduce using rule 200 (empty -> .)
    CHAR            reduce using rule 200 (empty -> .)
    STRING          reduce using rule 200 (empty -> .)
    KEYWORD_NULL    reduce using rule 200 (empty -> .)
    BOOL_CONSTT     reduce using rule 200 (empty -> .)
    BOOL_CONSTF     reduce using rule 200 (empty -> .)
    BLOCKEND        reduce using rule 200 (empty -> .)
    KEYWORD_ELSE    reduce using rule 200 (empty -> .)

    marker                         shift and go to state 163
    empty                          shift and go to state 104

state 87

    (10) block_statements_opt -> block_statements .
    (13) block_statements -> block_statements . marker block_statement
    (41) marker -> . empty
    (200) empty -> .

    BLOCKEND        reduce using rule 10 (block_statements_opt -> block_statements .)
    KEYWORD_IF      reduce using rule 200 (empty -> .)
    KEYWORD_WHILE   reduce using rule 200 (empty -> .)
    KEYWORD_DO      reduce using rule 200 (empty -> .)
    KEYWORD_FOR     reduce using rule 200 (empty -> .)
    KEYWORD_CLASS   reduce using rule 200 (empty -> .)
    KEYWORD_OBJECT  reduce using rule 200 (empty -> .)
    KEYWORD_VAR     reduce using rule 200 (empty -> .)
    KEYWORD_VAL     reduce using rule 200 (empty -> .)
    TERMINATOR      reduce using rule 200 (empty -> .)
    KEYWORD_RETURN  reduce using rule 200 (empty -> .)
    KEYWORD_DEF     reduce using rule 200 (empty -> .)
    BLOCKBEGIN      reduce using rule 200 (empty -> .)
    IDENTIFIER      reduce using rule 200 (empty -> .)
    PLUS            reduce using rule 200 (empty -> .)
    MINUS           reduce using rule 200 (empty -> .)
    TILDA           reduce using rule 200 (empty -> .)
    NOT             reduce using rule 200 (empty -> .)
    LPAREN          reduce using rule 200 (empty -> .)
    DOUBLE_NUMBER   reduce using rule 200 (empty -> .)
    INT_NUMBER      reduce using rule 200 (empty -> .)
    CHAR            reduce using rule 200 (empty -> .)
    STRING          reduce using rule 200 (empty -> .)
    KEYWORD_NULL    reduce using rule 200 (empty -> .)
    BOOL_CONSTT     reduce using rule 200 (empty -> .)
    BOOL_CONSTF     reduce using rule 200 (empty -> .)

    marker                         shift and go to state 164
    empty                          shift and go to state 104

state 88

    (19) expression -> assignment_expression .

    RPAREN          reduce using rule 19 (expression -> assignment_expression .)
    COMMA           reduce using rule 19 (expression -> assignment_expression .)
    KEYWORD_UNTIL   reduce using rule 19 (expression -> assignment_expression .)
    KEYWORD_TO      reduce using rule 19 (expression -> assignment_expression .)
    KEYWORD_MATCH   reduce using rule 19 (expression -> assignment_expression .)
    TERMINATOR      reduce using rule 19 (expression -> assignment_expression .)
    FUNTYPE         reduce using rule 19 (expression -> assignment_expression .)
    RBRAC           reduce using rule 19 (expression -> assignment_expression .)
    KEYWORD_BY      reduce using rule 19 (expression -> assignment_expression .)


state 89

    (149) statement_expression -> assignment .
    (22) assignment_expression -> assignment .

    TERMINATOR      reduce using rule 149 (statement_expression -> assignment .)
    KEYWORD_MATCH   reduce using rule 22 (assignment_expression -> assignment .)


state 90

    (86) literal -> c_literal .

    TIMES           reduce using rule 86 (literal -> c_literal .)
    DIVIDE          reduce using rule 86 (literal -> c_literal .)
    REMAINDER       reduce using rule 86 (literal -> c_literal .)
    PLUS            reduce using rule 86 (literal -> c_literal .)
    MINUS           reduce using rule 86 (literal -> c_literal .)
    LSHIFT          reduce using rule 86 (literal -> c_literal .)
    RSHIFT          reduce using rule 86 (literal -> c_literal .)
    GREATER         reduce using rule 86 (literal -> c_literal .)
    LESS            reduce using rule 86 (literal -> c_literal .)
    GEQ             reduce using rule 86 (literal -> c_literal .)
    LEQ             reduce using rule 86 (literal -> c_literal .)
    EQUAL           reduce using rule 86 (literal -> c_literal .)
    NEQUAL          reduce using rule 86 (literal -> c_literal .)
    AND_BITWISE     reduce using rule 86 (literal -> c_literal .)
    XOR             reduce using rule 86 (literal -> c_literal .)
    OR_BITWISE      reduce using rule 86 (literal -> c_literal .)
    AND             reduce using rule 86 (literal -> c_literal .)
    OR              reduce using rule 86 (literal -> c_literal .)
    COMMA           reduce using rule 86 (literal -> c_literal .)
    RPAREN          reduce using rule 86 (literal -> c_literal .)
    KEYWORD_MATCH   reduce using rule 86 (literal -> c_literal .)
    TERMINATOR      reduce using rule 86 (literal -> c_literal .)
    RBRAC           reduce using rule 86 (literal -> c_literal .)
    FUNTYPE         reduce using rule 86 (literal -> c_literal .)
    KEYWORD_UNTIL   reduce using rule 86 (literal -> c_literal .)
    KEYWORD_TO      reduce using rule 86 (literal -> c_literal .)
    KEYWORD_BY      reduce using rule 86 (literal -> c_literal .)


state 91

    (79) base_variable_set -> LPAREN . expression RPAREN
    (82) cast_expression -> LPAREN . primitive_type RPAREN unary_expression
    (19) expression -> . assignment_expression
    (120) primitive_type -> . TYPE_INT
    (121) primitive_type -> . TYPE_DOUBLE
    (122) primitive_type -> . TYPE_CHAR
    (123) primitive_type -> . TYPE_STRING
    (124) primitive_type -> . TYPE_BOOLEAN
    (125) primitive_type -> . TYPE_VOID
    (22) assignment_expression -> . assignment
    (23) assignment_expression -> . conditional_or_expression
    (24) assignment_expression -> . method_invocation
    (25) assignment -> . valid_variable assignment_operator assignment_expression
    (43) conditional_or_expression -> . conditional_and_expression
    (44) conditional_or_expression -> . conditional_or_expression OR marker conditional_and_expression
    (94) method_invocation -> . name LPAREN argument_list_opt RPAREN
    (26) valid_variable -> . name
    (27) valid_variable -> . array_access
    (45) conditional_and_expression -> . inclusive_or_expression
    (46) conditional_and_expression -> . conditional_and_expression AND marker inclusive_or_expression
    (130) name -> . simple_name
    (131) name -> . qualified_name
    (28) array_access -> . name dimension
    (47) inclusive_or_expression -> . exclusive_or_expression
    (48) inclusive_or_expression -> . inclusive_or_expression OR_BITWISE exclusive_or_expression
    (132) simple_name -> . IDENTIFIER
    (133) qualified_name -> . name INST simple_name
    (49) exclusive_or_expression -> . and_expression
    (50) exclusive_or_expression -> . exclusive_or_expression XOR and_expression
    (51) and_expression -> . equality_expression
    (52) and_expression -> . and_expression AND_BITWISE equality_expression
    (53) equality_expression -> . relational_expression
    (54) equality_expression -> . equality_expression EQUAL relational_expression
    (55) equality_expression -> . equality_expression NEQUAL relational_expression
    (56) relational_expression -> . shift_expression
    (57) relational_expression -> . relational_expression GREATER shift_expression
    (58) relational_expression -> . relational_expression LESS shift_expression
    (59) relational_expression -> . relational_expression GEQ shift_expression
    (60) relational_expression -> . relational_expression LEQ shift_expression
    (61) shift_expression -> . additive_expression
    (62) shift_expression -> . shift_expression LSHIFT additive_expression
    (63) shift_expression -> . shift_expression RSHIFT additive_expression
    (64) additive_expression -> . multiplicative_expression
    (65) additive_expression -> . additive_expression PLUS multiplicative_expression
    (66) additive_expression -> . additive_expression MINUS multiplicative_expression
    (67) multiplicative_expression -> . unary_expression
    (68) multiplicative_expression -> . multiplicative_expression TIMES unary_expression
    (69) multiplicative_expression -> . multiplicative_expression DIVIDE unary_expression
    (70) multiplicative_expression -> . multiplicative_expression REMAINDER unary_expression
    (71) unary_expression -> . PLUS unary_expression
    (72) unary_expression -> . MINUS unary_expression
    (73) unary_expression -> . unary_expression_not_plus_minus
    (74) unary_expression_not_plus_minus -> . base_variable_set
    (75) unary_expression_not_plus_minus -> . TILDA unary_expression
    (76) unary_expression_not_plus_minus -> . cast_expression
    (77) unary_expression_not_plus_minus -> . NOT unary_expression
    (78) base_variable_set -> . variable_literal
    (79) base_variable_set -> . LPAREN expression RPAREN
    (82) cast_expression -> . LPAREN primitive_type RPAREN unary_expression
    (80) variable_literal -> . valid_variable
    (81) variable_literal -> . primary
    (83) primary -> . literal
    (84) primary -> . method_invocation
    (85) literal -> . int_float
    (86) literal -> . c_literal
    (92) int_float -> . DOUBLE_NUMBER
    (93) int_float -> . INT_NUMBER
    (87) c_literal -> . CHAR
    (88) c_literal -> . STRING
    (89) c_literal -> . KEYWORD_NULL
    (90) c_literal -> . BOOL_CONSTT
    (91) c_literal -> . BOOL_CONSTF

    TYPE_INT        shift and go to state 165
    TYPE_DOUBLE     shift and go to state 171
    TYPE_CHAR       shift and go to state 167
    TYPE_STRING     shift and go to state 166
    TYPE_BOOLEAN    shift and go to state 170
    TYPE_VOID       shift and go to state 168
    IDENTIFIER      shift and go to state 9
    PLUS            shift and go to state 31
    MINUS           shift and go to state 24
    TILDA           shift and go to state 68
    NOT             shift and go to state 53
    LPAREN          shift and go to state 91
    DOUBLE_NUMBER   shift and go to state 28
    INT_NUMBER      shift and go to state 39
    CHAR            shift and go to state 59
    STRING          shift and go to state 72
    KEYWORD_NULL    shift and go to state 61
    BOOL_CONSTT     shift and go to state 30
    BOOL_CONSTF     shift and go to state 25

    unary_expression               shift and go to state 40
    exclusive_or_expression        shift and go to state 57
    primary                        shift and go to state 58
    unary_expression_not_plus_minus shift and go to state 41
    array_access                   shift and go to state 23
    and_expression                 shift and go to state 84
    simple_name                    shift and go to state 63
    c_literal                      shift and go to state 90
    base_variable_set              shift and go to state 85
    valid_variable                 shift and go to state 92
    inclusive_or_expression        shift and go to state 27
    primitive_type                 shift and go to state 169
    literal                        shift and go to state 67
    relational_expression          shift and go to state 69
    method_invocation              shift and go to state 139
    conditional_or_expression      shift and go to state 43
    assignment_expression          shift and go to state 88
    qualified_name                 shift and go to state 75
    assignment                     shift and go to state 142
    multiplicative_expression      shift and go to state 46
    additive_expression            shift and go to state 62
    cast_expression                shift and go to state 77
    shift_expression               shift and go to state 50
    equality_expression            shift and go to state 79
    int_float                      shift and go to state 35
    variable_literal               shift and go to state 51
    name                           shift and go to state 38
    expression                     shift and go to state 172
    conditional_and_expression     shift and go to state 52

state 92

    (25) assignment -> valid_variable . assignment_operator assignment_expression
    (80) variable_literal -> valid_variable .
    (30) assignment_operator -> . ASOP
    (31) assignment_operator -> . TIMES_ASSIGN
    (32) assignment_operator -> . DIVIDE_ASSIGN
    (33) assignment_operator -> . REMAINDER_ASSIGN
    (34) assignment_operator -> . PLUS_ASSIGN
    (35) assignment_operator -> . MINUS_ASSIGN
    (36) assignment_operator -> . LSHIFT_ASSIGN
    (37) assignment_operator -> . RSHIFT_ASSIGN
    (38) assignment_operator -> . AND_ASSIGN
    (39) assignment_operator -> . OR_ASSIGN
    (40) assignment_operator -> . XOR_ASSIGN

    TIMES           reduce using rule 80 (variable_literal -> valid_variable .)
    DIVIDE          reduce using rule 80 (variable_literal -> valid_variable .)
    REMAINDER       reduce using rule 80 (variable_literal -> valid_variable .)
    PLUS            reduce using rule 80 (variable_literal -> valid_variable .)
    MINUS           reduce using rule 80 (variable_literal -> valid_variable .)
    LSHIFT          reduce using rule 80 (variable_literal -> valid_variable .)
    RSHIFT          reduce using rule 80 (variable_literal -> valid_variable .)
    GREATER         reduce using rule 80 (variable_literal -> valid_variable .)
    LESS            reduce using rule 80 (variable_literal -> valid_variable .)
    GEQ             reduce using rule 80 (variable_literal -> valid_variable .)
    LEQ             reduce using rule 80 (variable_literal -> valid_variable .)
    EQUAL           reduce using rule 80 (variable_literal -> valid_variable .)
    NEQUAL          reduce using rule 80 (variable_literal -> valid_variable .)
    AND_BITWISE     reduce using rule 80 (variable_literal -> valid_variable .)
    XOR             reduce using rule 80 (variable_literal -> valid_variable .)
    OR_BITWISE      reduce using rule 80 (variable_literal -> valid_variable .)
    AND             reduce using rule 80 (variable_literal -> valid_variable .)
    OR              reduce using rule 80 (variable_literal -> valid_variable .)
    KEYWORD_MATCH   reduce using rule 80 (variable_literal -> valid_variable .)
    COMMA           reduce using rule 80 (variable_literal -> valid_variable .)
    RPAREN          reduce using rule 80 (variable_literal -> valid_variable .)
    RBRAC           reduce using rule 80 (variable_literal -> valid_variable .)
    TERMINATOR      reduce using rule 80 (variable_literal -> valid_variable .)
    FUNTYPE         reduce using rule 80 (variable_literal -> valid_variable .)
    KEYWORD_UNTIL   reduce using rule 80 (variable_literal -> valid_variable .)
    KEYWORD_TO      reduce using rule 80 (variable_literal -> valid_variable .)
    KEYWORD_BY      reduce using rule 80 (variable_literal -> valid_variable .)
    ASOP            shift and go to state 176
    TIMES_ASSIGN    shift and go to state 173
    DIVIDE_ASSIGN   shift and go to state 181
    REMAINDER_ASSIGN shift and go to state 177
    PLUS_ASSIGN     shift and go to state 183
    MINUS_ASSIGN    shift and go to state 175
    LSHIFT_ASSIGN   shift and go to state 179
    RSHIFT_ASSIGN   shift and go to state 174
    AND_ASSIGN      shift and go to state 180
    OR_ASSIGN       shift and go to state 178
    XOR_ASSIGN      shift and go to state 184

    assignment_operator            shift and go to state 182

state 93

    (16) block_statement -> class_declaration .

    KEYWORD_IF      reduce using rule 16 (block_statement -> class_declaration .)
    KEYWORD_WHILE   reduce using rule 16 (block_statement -> class_declaration .)
    KEYWORD_DO      reduce using rule 16 (block_statement -> class_declaration .)
    KEYWORD_FOR     reduce using rule 16 (block_statement -> class_declaration .)
    KEYWORD_CLASS   reduce using rule 16 (block_statement -> class_declaration .)
    KEYWORD_OBJECT  reduce using rule 16 (block_statement -> class_declaration .)
    KEYWORD_VAR     reduce using rule 16 (block_statement -> class_declaration .)
    KEYWORD_VAL     reduce using rule 16 (block_statement -> class_declaration .)
    TERMINATOR      reduce using rule 16 (block_statement -> class_declaration .)
    KEYWORD_RETURN  reduce using rule 16 (block_statement -> class_declaration .)
    KEYWORD_DEF     reduce using rule 16 (block_statement -> class_declaration .)
    BLOCKBEGIN      reduce using rule 16 (block_statement -> class_declaration .)
    IDENTIFIER      reduce using rule 16 (block_statement -> class_declaration .)
    PLUS            reduce using rule 16 (block_statement -> class_declaration .)
    MINUS           reduce using rule 16 (block_statement -> class_declaration .)
    TILDA           reduce using rule 16 (block_statement -> class_declaration .)
    NOT             reduce using rule 16 (block_statement -> class_declaration .)
    LPAREN          reduce using rule 16 (block_statement -> class_declaration .)
    DOUBLE_NUMBER   reduce using rule 16 (block_statement -> class_declaration .)
    INT_NUMBER      reduce using rule 16 (block_statement -> class_declaration .)
    CHAR            reduce using rule 16 (block_statement -> class_declaration .)
    STRING          reduce using rule 16 (block_statement -> class_declaration .)
    KEYWORD_NULL    reduce using rule 16 (block_statement -> class_declaration .)
    BOOL_CONSTT     reduce using rule 16 (block_statement -> class_declaration .)
    BOOL_CONSTF     reduce using rule 16 (block_statement -> class_declaration .)
    BLOCKEND        reduce using rule 16 (block_statement -> class_declaration .)


state 94

    (158) for_statement -> KEYWORD_FOR . LPAREN for_update RPAREN marker block

    LPAREN          shift and go to state 185


state 95

    (157) do_while_statement -> KEYWORD_DO . marker block KEYWORD_WHILE LPAREN marker expression RPAREN TERMINATOR
    (41) marker -> . empty
    (200) empty -> .

    BLOCKBEGIN      reduce using rule 200 (empty -> .)

    marker                         shift and go to state 186
    empty                          shift and go to state 104

state 96

    (198) class_body -> class_body_start block_statements_opt . end_scope
    (9) end_scope -> . BLOCKEND

    BLOCKEND        shift and go to state 109

    end_scope                      shift and go to state 187

state 97

    (188) class_param_clause -> func_arg_start class_params_opt . RPAREN

    RPAREN          shift and go to state 188


state 98

    (194) class_declaration_keyword_opt -> declaration_keyword .

    IDENTIFIER      reduce using rule 194 (class_declaration_keyword_opt -> declaration_keyword .)


state 99

    (191) class_params -> class_param .

    COMMA           reduce using rule 191 (class_params -> class_param .)
    RPAREN          reduce using rule 191 (class_params -> class_param .)


state 100

    (189) class_params_opt -> class_params .
    (192) class_params -> class_params . COMMA class_param

    RPAREN          reduce using rule 189 (class_params_opt -> class_params .)
    COMMA           shift and go to state 189


state 101

    (193) class_param -> class_declaration_keyword_opt . variable_declarator_id
    (116) variable_declarator_id -> . IDENTIFIER COLON type

    IDENTIFIER      shift and go to state 190

    variable_declarator_id         shift and go to state 191

state 102

    (190) class_params_opt -> empty .
    (195) class_declaration_keyword_opt -> empty .

    RPAREN          reduce using rule 190 (class_params_opt -> empty .)
    IDENTIFIER      reduce using rule 195 (class_declaration_keyword_opt -> empty .)


state 103

    (144) normal_statement -> expression_statement marker .

    KEYWORD_IF      reduce using rule 144 (normal_statement -> expression_statement marker .)
    KEYWORD_WHILE   reduce using rule 144 (normal_statement -> expression_statement marker .)
    KEYWORD_DO      reduce using rule 144 (normal_statement -> expression_statement marker .)
    KEYWORD_FOR     reduce using rule 144 (normal_statement -> expression_statement marker .)
    KEYWORD_CLASS   reduce using rule 144 (normal_statement -> expression_statement marker .)
    KEYWORD_OBJECT  reduce using rule 144 (normal_statement -> expression_statement marker .)
    KEYWORD_VAR     reduce using rule 144 (normal_statement -> expression_statement marker .)
    KEYWORD_VAL     reduce using rule 144 (normal_statement -> expression_statement marker .)
    TERMINATOR      reduce using rule 144 (normal_statement -> expression_statement marker .)
    KEYWORD_RETURN  reduce using rule 144 (normal_statement -> expression_statement marker .)
    KEYWORD_DEF     reduce using rule 144 (normal_statement -> expression_statement marker .)
    BLOCKBEGIN      reduce using rule 144 (normal_statement -> expression_statement marker .)
    IDENTIFIER      reduce using rule 144 (normal_statement -> expression_statement marker .)
    PLUS            reduce using rule 144 (normal_statement -> expression_statement marker .)
    MINUS           reduce using rule 144 (normal_statement -> expression_statement marker .)
    TILDA           reduce using rule 144 (normal_statement -> expression_statement marker .)
    NOT             reduce using rule 144 (normal_statement -> expression_statement marker .)
    LPAREN          reduce using rule 144 (normal_statement -> expression_statement marker .)
    DOUBLE_NUMBER   reduce using rule 144 (normal_statement -> expression_statement marker .)
    INT_NUMBER      reduce using rule 144 (normal_statement -> expression_statement marker .)
    CHAR            reduce using rule 144 (normal_statement -> expression_statement marker .)
    STRING          reduce using rule 144 (normal_statement -> expression_statement marker .)
    KEYWORD_NULL    reduce using rule 144 (normal_statement -> expression_statement marker .)
    BOOL_CONSTT     reduce using rule 144 (normal_statement -> expression_statement marker .)
    BOOL_CONSTF     reduce using rule 144 (normal_statement -> expression_statement marker .)
    BLOCKEND        reduce using rule 144 (normal_statement -> expression_statement marker .)
    KEYWORD_ELSE    reduce using rule 144 (normal_statement -> expression_statement marker .)


state 104

    (41) marker -> empty .

    BLOCKBEGIN      reduce using rule 41 (marker -> empty .)
    KEYWORD_IF      reduce using rule 41 (marker -> empty .)
    KEYWORD_WHILE   reduce using rule 41 (marker -> empty .)
    KEYWORD_DO      reduce using rule 41 (marker -> empty .)
    KEYWORD_FOR     reduce using rule 41 (marker -> empty .)
    KEYWORD_CLASS   reduce using rule 41 (marker -> empty .)
    KEYWORD_OBJECT  reduce using rule 41 (marker -> empty .)
    KEYWORD_VAR     reduce using rule 41 (marker -> empty .)
    KEYWORD_VAL     reduce using rule 41 (marker -> empty .)
    TERMINATOR      reduce using rule 41 (marker -> empty .)
    KEYWORD_RETURN  reduce using rule 41 (marker -> empty .)
    KEYWORD_DEF     reduce using rule 41 (marker -> empty .)
    IDENTIFIER      reduce using rule 41 (marker -> empty .)
    PLUS            reduce using rule 41 (marker -> empty .)
    MINUS           reduce using rule 41 (marker -> empty .)
    TILDA           reduce using rule 41 (marker -> empty .)
    NOT             reduce using rule 41 (marker -> empty .)
    LPAREN          reduce using rule 41 (marker -> empty .)
    DOUBLE_NUMBER   reduce using rule 41 (marker -> empty .)
    INT_NUMBER      reduce using rule 41 (marker -> empty .)
    CHAR            reduce using rule 41 (marker -> empty .)
    STRING          reduce using rule 41 (marker -> empty .)
    KEYWORD_NULL    reduce using rule 41 (marker -> empty .)
    BOOL_CONSTT     reduce using rule 41 (marker -> empty .)
    BOOL_CONSTF     reduce using rule 41 (marker -> empty .)
    BLOCKEND        reduce using rule 41 (marker -> empty .)
    KEYWORD_ELSE    reduce using rule 41 (marker -> empty .)
    KEYWORD_CASE    reduce using rule 41 (marker -> empty .)
    KEYWORD_BY      reduce using rule 41 (marker -> empty .)
    RPAREN          reduce using rule 41 (marker -> empty .)


state 105

    (72) unary_expression -> MINUS unary_expression .

    TIMES           reduce using rule 72 (unary_expression -> MINUS unary_expression .)
    DIVIDE          reduce using rule 72 (unary_expression -> MINUS unary_expression .)
    REMAINDER       reduce using rule 72 (unary_expression -> MINUS unary_expression .)
    PLUS            reduce using rule 72 (unary_expression -> MINUS unary_expression .)
    MINUS           reduce using rule 72 (unary_expression -> MINUS unary_expression .)
    LSHIFT          reduce using rule 72 (unary_expression -> MINUS unary_expression .)
    RSHIFT          reduce using rule 72 (unary_expression -> MINUS unary_expression .)
    GREATER         reduce using rule 72 (unary_expression -> MINUS unary_expression .)
    LESS            reduce using rule 72 (unary_expression -> MINUS unary_expression .)
    GEQ             reduce using rule 72 (unary_expression -> MINUS unary_expression .)
    LEQ             reduce using rule 72 (unary_expression -> MINUS unary_expression .)
    EQUAL           reduce using rule 72 (unary_expression -> MINUS unary_expression .)
    NEQUAL          reduce using rule 72 (unary_expression -> MINUS unary_expression .)
    AND_BITWISE     reduce using rule 72 (unary_expression -> MINUS unary_expression .)
    XOR             reduce using rule 72 (unary_expression -> MINUS unary_expression .)
    OR_BITWISE      reduce using rule 72 (unary_expression -> MINUS unary_expression .)
    AND             reduce using rule 72 (unary_expression -> MINUS unary_expression .)
    OR              reduce using rule 72 (unary_expression -> MINUS unary_expression .)
    TERMINATOR      reduce using rule 72 (unary_expression -> MINUS unary_expression .)
    KEYWORD_MATCH   reduce using rule 72 (unary_expression -> MINUS unary_expression .)
    RPAREN          reduce using rule 72 (unary_expression -> MINUS unary_expression .)
    RBRAC           reduce using rule 72 (unary_expression -> MINUS unary_expression .)
    COMMA           reduce using rule 72 (unary_expression -> MINUS unary_expression .)
    FUNTYPE         reduce using rule 72 (unary_expression -> MINUS unary_expression .)
    KEYWORD_UNTIL   reduce using rule 72 (unary_expression -> MINUS unary_expression .)
    KEYWORD_TO      reduce using rule 72 (unary_expression -> MINUS unary_expression .)
    KEYWORD_BY      reduce using rule 72 (unary_expression -> MINUS unary_expression .)


state 106

    (80) variable_literal -> valid_variable .

    TIMES           reduce using rule 80 (variable_literal -> valid_variable .)
    DIVIDE          reduce using rule 80 (variable_literal -> valid_variable .)
    REMAINDER       reduce using rule 80 (variable_literal -> valid_variable .)
    PLUS            reduce using rule 80 (variable_literal -> valid_variable .)
    MINUS           reduce using rule 80 (variable_literal -> valid_variable .)
    LSHIFT          reduce using rule 80 (variable_literal -> valid_variable .)
    RSHIFT          reduce using rule 80 (variable_literal -> valid_variable .)
    GREATER         reduce using rule 80 (variable_literal -> valid_variable .)
    LESS            reduce using rule 80 (variable_literal -> valid_variable .)
    GEQ             reduce using rule 80 (variable_literal -> valid_variable .)
    LEQ             reduce using rule 80 (variable_literal -> valid_variable .)
    EQUAL           reduce using rule 80 (variable_literal -> valid_variable .)
    NEQUAL          reduce using rule 80 (variable_literal -> valid_variable .)
    AND_BITWISE     reduce using rule 80 (variable_literal -> valid_variable .)
    XOR             reduce using rule 80 (variable_literal -> valid_variable .)
    OR_BITWISE      reduce using rule 80 (variable_literal -> valid_variable .)
    AND             reduce using rule 80 (variable_literal -> valid_variable .)
    OR              reduce using rule 80 (variable_literal -> valid_variable .)
    KEYWORD_MATCH   reduce using rule 80 (variable_literal -> valid_variable .)
    TERMINATOR      reduce using rule 80 (variable_literal -> valid_variable .)
    RPAREN          reduce using rule 80 (variable_literal -> valid_variable .)
    RBRAC           reduce using rule 80 (variable_literal -> valid_variable .)
    COMMA           reduce using rule 80 (variable_literal -> valid_variable .)
    FUNTYPE         reduce using rule 80 (variable_literal -> valid_variable .)
    KEYWORD_UNTIL   reduce using rule 80 (variable_literal -> valid_variable .)
    KEYWORD_TO      reduce using rule 80 (variable_literal -> valid_variable .)
    KEYWORD_BY      reduce using rule 80 (variable_literal -> valid_variable .)


state 107

    (84) primary -> method_invocation .

    TIMES           reduce using rule 84 (primary -> method_invocation .)
    DIVIDE          reduce using rule 84 (primary -> method_invocation .)
    REMAINDER       reduce using rule 84 (primary -> method_invocation .)
    PLUS            reduce using rule 84 (primary -> method_invocation .)
    MINUS           reduce using rule 84 (primary -> method_invocation .)
    LSHIFT          reduce using rule 84 (primary -> method_invocation .)
    RSHIFT          reduce using rule 84 (primary -> method_invocation .)
    GREATER         reduce using rule 84 (primary -> method_invocation .)
    LESS            reduce using rule 84 (primary -> method_invocation .)
    GEQ             reduce using rule 84 (primary -> method_invocation .)
    LEQ             reduce using rule 84 (primary -> method_invocation .)
    EQUAL           reduce using rule 84 (primary -> method_invocation .)
    NEQUAL          reduce using rule 84 (primary -> method_invocation .)
    AND_BITWISE     reduce using rule 84 (primary -> method_invocation .)
    XOR             reduce using rule 84 (primary -> method_invocation .)
    OR_BITWISE      reduce using rule 84 (primary -> method_invocation .)
    AND             reduce using rule 84 (primary -> method_invocation .)
    OR              reduce using rule 84 (primary -> method_invocation .)
    KEYWORD_MATCH   reduce using rule 84 (primary -> method_invocation .)
    TERMINATOR      reduce using rule 84 (primary -> method_invocation .)
    RPAREN          reduce using rule 84 (primary -> method_invocation .)
    RBRAC           reduce using rule 84 (primary -> method_invocation .)
    COMMA           reduce using rule 84 (primary -> method_invocation .)
    FUNTYPE         reduce using rule 84 (primary -> method_invocation .)
    KEYWORD_UNTIL   reduce using rule 84 (primary -> method_invocation .)
    KEYWORD_TO      reduce using rule 84 (primary -> method_invocation .)
    KEYWORD_BY      reduce using rule 84 (primary -> method_invocation .)


state 108

    (26) valid_variable -> name .
    (28) array_access -> name . dimension
    (94) method_invocation -> name . LPAREN argument_list_opt RPAREN
    (133) qualified_name -> name . INST simple_name
    (29) dimension -> . LBRAC expression RBRAC

    TIMES           reduce using rule 26 (valid_variable -> name .)
    DIVIDE          reduce using rule 26 (valid_variable -> name .)
    REMAINDER       reduce using rule 26 (valid_variable -> name .)
    PLUS            reduce using rule 26 (valid_variable -> name .)
    MINUS           reduce using rule 26 (valid_variable -> name .)
    LSHIFT          reduce using rule 26 (valid_variable -> name .)
    RSHIFT          reduce using rule 26 (valid_variable -> name .)
    GREATER         reduce using rule 26 (valid_variable -> name .)
    LESS            reduce using rule 26 (valid_variable -> name .)
    GEQ             reduce using rule 26 (valid_variable -> name .)
    LEQ             reduce using rule 26 (valid_variable -> name .)
    EQUAL           reduce using rule 26 (valid_variable -> name .)
    NEQUAL          reduce using rule 26 (valid_variable -> name .)
    AND_BITWISE     reduce using rule 26 (valid_variable -> name .)
    XOR             reduce using rule 26 (valid_variable -> name .)
    OR_BITWISE      reduce using rule 26 (valid_variable -> name .)
    AND             reduce using rule 26 (valid_variable -> name .)
    OR              reduce using rule 26 (valid_variable -> name .)
    KEYWORD_MATCH   reduce using rule 26 (valid_variable -> name .)
    TERMINATOR      reduce using rule 26 (valid_variable -> name .)
    RPAREN          reduce using rule 26 (valid_variable -> name .)
    RBRAC           reduce using rule 26 (valid_variable -> name .)
    COMMA           reduce using rule 26 (valid_variable -> name .)
    FUNTYPE         reduce using rule 26 (valid_variable -> name .)
    KEYWORD_UNTIL   reduce using rule 26 (valid_variable -> name .)
    KEYWORD_TO      reduce using rule 26 (valid_variable -> name .)
    KEYWORD_BY      reduce using rule 26 (valid_variable -> name .)
    LPAREN          shift and go to state 119
    INST            shift and go to state 118
    LBRAC           shift and go to state 117

    dimension                      shift and go to state 120

state 109

    (9) end_scope -> BLOCKEND .

    KEYWORD_OBJECT  reduce using rule 9 (end_scope -> BLOCKEND .)
    KEYWORD_CLASS   reduce using rule 9 (end_scope -> BLOCKEND .)
    $end            reduce using rule 9 (end_scope -> BLOCKEND .)
    KEYWORD_IF      reduce using rule 9 (end_scope -> BLOCKEND .)
    KEYWORD_WHILE   reduce using rule 9 (end_scope -> BLOCKEND .)
    KEYWORD_DO      reduce using rule 9 (end_scope -> BLOCKEND .)
    KEYWORD_FOR     reduce using rule 9 (end_scope -> BLOCKEND .)
    KEYWORD_VAR     reduce using rule 9 (end_scope -> BLOCKEND .)
    KEYWORD_VAL     reduce using rule 9 (end_scope -> BLOCKEND .)
    TERMINATOR      reduce using rule 9 (end_scope -> BLOCKEND .)
    KEYWORD_RETURN  reduce using rule 9 (end_scope -> BLOCKEND .)
    KEYWORD_DEF     reduce using rule 9 (end_scope -> BLOCKEND .)
    BLOCKBEGIN      reduce using rule 9 (end_scope -> BLOCKEND .)
    IDENTIFIER      reduce using rule 9 (end_scope -> BLOCKEND .)
    PLUS            reduce using rule 9 (end_scope -> BLOCKEND .)
    MINUS           reduce using rule 9 (end_scope -> BLOCKEND .)
    TILDA           reduce using rule 9 (end_scope -> BLOCKEND .)
    NOT             reduce using rule 9 (end_scope -> BLOCKEND .)
    LPAREN          reduce using rule 9 (end_scope -> BLOCKEND .)
    DOUBLE_NUMBER   reduce using rule 9 (end_scope -> BLOCKEND .)
    INT_NUMBER      reduce using rule 9 (end_scope -> BLOCKEND .)
    CHAR            reduce using rule 9 (end_scope -> BLOCKEND .)
    STRING          reduce using rule 9 (end_scope -> BLOCKEND .)
    KEYWORD_NULL    reduce using rule 9 (end_scope -> BLOCKEND .)
    BOOL_CONSTT     reduce using rule 9 (end_scope -> BLOCKEND .)
    BOOL_CONSTF     reduce using rule 9 (end_scope -> BLOCKEND .)
    BLOCKEND        reduce using rule 9 (end_scope -> BLOCKEND .)
    KEYWORD_ELSE    reduce using rule 9 (end_scope -> BLOCKEND .)
    KEYWORD_CASE    reduce using rule 9 (end_scope -> BLOCKEND .)


state 110

    (7) block -> start_scope block_statements_opt end_scope .

    KEYWORD_IF      reduce using rule 7 (block -> start_scope block_statements_opt end_scope .)
    KEYWORD_WHILE   reduce using rule 7 (block -> start_scope block_statements_opt end_scope .)
    KEYWORD_DO      reduce using rule 7 (block -> start_scope block_statements_opt end_scope .)
    KEYWORD_FOR     reduce using rule 7 (block -> start_scope block_statements_opt end_scope .)
    KEYWORD_CLASS   reduce using rule 7 (block -> start_scope block_statements_opt end_scope .)
    KEYWORD_OBJECT  reduce using rule 7 (block -> start_scope block_statements_opt end_scope .)
    KEYWORD_VAR     reduce using rule 7 (block -> start_scope block_statements_opt end_scope .)
    KEYWORD_VAL     reduce using rule 7 (block -> start_scope block_statements_opt end_scope .)
    TERMINATOR      reduce using rule 7 (block -> start_scope block_statements_opt end_scope .)
    KEYWORD_RETURN  reduce using rule 7 (block -> start_scope block_statements_opt end_scope .)
    KEYWORD_DEF     reduce using rule 7 (block -> start_scope block_statements_opt end_scope .)
    BLOCKBEGIN      reduce using rule 7 (block -> start_scope block_statements_opt end_scope .)
    IDENTIFIER      reduce using rule 7 (block -> start_scope block_statements_opt end_scope .)
    PLUS            reduce using rule 7 (block -> start_scope block_statements_opt end_scope .)
    MINUS           reduce using rule 7 (block -> start_scope block_statements_opt end_scope .)
    TILDA           reduce using rule 7 (block -> start_scope block_statements_opt end_scope .)
    NOT             reduce using rule 7 (block -> start_scope block_statements_opt end_scope .)
    LPAREN          reduce using rule 7 (block -> start_scope block_statements_opt end_scope .)
    DOUBLE_NUMBER   reduce using rule 7 (block -> start_scope block_statements_opt end_scope .)
    INT_NUMBER      reduce using rule 7 (block -> start_scope block_statements_opt end_scope .)
    CHAR            reduce using rule 7 (block -> start_scope block_statements_opt end_scope .)
    STRING          reduce using rule 7 (block -> start_scope block_statements_opt end_scope .)
    KEYWORD_NULL    reduce using rule 7 (block -> start_scope block_statements_opt end_scope .)
    BOOL_CONSTT     reduce using rule 7 (block -> start_scope block_statements_opt end_scope .)
    BOOL_CONSTF     reduce using rule 7 (block -> start_scope block_statements_opt end_scope .)
    BLOCKEND        reduce using rule 7 (block -> start_scope block_statements_opt end_scope .)
    $end            reduce using rule 7 (block -> start_scope block_statements_opt end_scope .)
    KEYWORD_ELSE    reduce using rule 7 (block -> start_scope block_statements_opt end_scope .)
    KEYWORD_CASE    reduce using rule 7 (block -> start_scope block_statements_opt end_scope .)


state 111

    (48) inclusive_or_expression -> inclusive_or_expression OR_BITWISE . exclusive_or_expression
    (49) exclusive_or_expression -> . and_expression
    (50) exclusive_or_expression -> . exclusive_or_expression XOR and_expression
    (51) and_expression -> . equality_expression
    (52) and_expression -> . and_expression AND_BITWISE equality_expression
    (53) equality_expression -> . relational_expression
    (54) equality_expression -> . equality_expression EQUAL relational_expression
    (55) equality_expression -> . equality_expression NEQUAL relational_expression
    (56) relational_expression -> . shift_expression
    (57) relational_expression -> . relational_expression GREATER shift_expression
    (58) relational_expression -> . relational_expression LESS shift_expression
    (59) relational_expression -> . relational_expression GEQ shift_expression
    (60) relational_expression -> . relational_expression LEQ shift_expression
    (61) shift_expression -> . additive_expression
    (62) shift_expression -> . shift_expression LSHIFT additive_expression
    (63) shift_expression -> . shift_expression RSHIFT additive_expression
    (64) additive_expression -> . multiplicative_expression
    (65) additive_expression -> . additive_expression PLUS multiplicative_expression
    (66) additive_expression -> . additive_expression MINUS multiplicative_expression
    (67) multiplicative_expression -> . unary_expression
    (68) multiplicative_expression -> . multiplicative_expression TIMES unary_expression
    (69) multiplicative_expression -> . multiplicative_expression DIVIDE unary_expression
    (70) multiplicative_expression -> . multiplicative_expression REMAINDER unary_expression
    (71) unary_expression -> . PLUS unary_expression
    (72) unary_expression -> . MINUS unary_expression
    (73) unary_expression -> . unary_expression_not_plus_minus
    (74) unary_expression_not_plus_minus -> . base_variable_set
    (75) unary_expression_not_plus_minus -> . TILDA unary_expression
    (76) unary_expression_not_plus_minus -> . cast_expression
    (77) unary_expression_not_plus_minus -> . NOT unary_expression
    (78) base_variable_set -> . variable_literal
    (79) base_variable_set -> . LPAREN expression RPAREN
    (82) cast_expression -> . LPAREN primitive_type RPAREN unary_expression
    (80) variable_literal -> . valid_variable
    (81) variable_literal -> . primary
    (26) valid_variable -> . name
    (27) valid_variable -> . array_access
    (83) primary -> . literal
    (84) primary -> . method_invocation
    (130) name -> . simple_name
    (131) name -> . qualified_name
    (28) array_access -> . name dimension
    (85) literal -> . int_float
    (86) literal -> . c_literal
    (94) method_invocation -> . name LPAREN argument_list_opt RPAREN
    (132) simple_name -> . IDENTIFIER
    (133) qualified_name -> . name INST simple_name
    (92) int_float -> . DOUBLE_NUMBER
    (93) int_float -> . INT_NUMBER
    (87) c_literal -> . CHAR
    (88) c_literal -> . STRING
    (89) c_literal -> . KEYWORD_NULL
    (90) c_literal -> . BOOL_CONSTT
    (91) c_literal -> . BOOL_CONSTF

    PLUS            shift and go to state 31
    MINUS           shift and go to state 24
    TILDA           shift and go to state 68
    NOT             shift and go to state 53
    LPAREN          shift and go to state 91
    IDENTIFIER      shift and go to state 9
    DOUBLE_NUMBER   shift and go to state 28
    INT_NUMBER      shift and go to state 39
    CHAR            shift and go to state 59
    STRING          shift and go to state 72
    KEYWORD_NULL    shift and go to state 61
    BOOL_CONSTT     shift and go to state 30
    BOOL_CONSTF     shift and go to state 25

    unary_expression               shift and go to state 40
    exclusive_or_expression        shift and go to state 192
    primary                        shift and go to state 58
    unary_expression_not_plus_minus shift and go to state 41
    array_access                   shift and go to state 23
    additive_expression            shift and go to state 62
    simple_name                    shift and go to state 63
    c_literal                      shift and go to state 90
    base_variable_set              shift and go to state 85
    valid_variable                 shift and go to state 106
    literal                        shift and go to state 67
    and_expression                 shift and go to state 84
    method_invocation              shift and go to state 107
    relational_expression          shift and go to state 69
    qualified_name                 shift and go to state 75
    multiplicative_expression      shift and go to state 46
    cast_expression                shift and go to state 77
    shift_expression               shift and go to state 50
    equality_expression            shift and go to state 79
    int_float                      shift and go to state 35
    variable_literal               shift and go to state 51
    name                           shift and go to state 108

state 112

    (140) statement -> while_statement marker .

    KEYWORD_IF      reduce using rule 140 (statement -> while_statement marker .)
    KEYWORD_WHILE   reduce using rule 140 (statement -> while_statement marker .)
    KEYWORD_DO      reduce using rule 140 (statement -> while_statement marker .)
    KEYWORD_FOR     reduce using rule 140 (statement -> while_statement marker .)
    KEYWORD_CLASS   reduce using rule 140 (statement -> while_statement marker .)
    KEYWORD_OBJECT  reduce using rule 140 (statement -> while_statement marker .)
    KEYWORD_VAR     reduce using rule 140 (statement -> while_statement marker .)
    KEYWORD_VAL     reduce using rule 140 (statement -> while_statement marker .)
    TERMINATOR      reduce using rule 140 (statement -> while_statement marker .)
    KEYWORD_RETURN  reduce using rule 140 (statement -> while_statement marker .)
    KEYWORD_DEF     reduce using rule 140 (statement -> while_statement marker .)
    BLOCKBEGIN      reduce using rule 140 (statement -> while_statement marker .)
    IDENTIFIER      reduce using rule 140 (statement -> while_statement marker .)
    PLUS            reduce using rule 140 (statement -> while_statement marker .)
    MINUS           reduce using rule 140 (statement -> while_statement marker .)
    TILDA           reduce using rule 140 (statement -> while_statement marker .)
    NOT             reduce using rule 140 (statement -> while_statement marker .)
    LPAREN          reduce using rule 140 (statement -> while_statement marker .)
    DOUBLE_NUMBER   reduce using rule 140 (statement -> while_statement marker .)
    INT_NUMBER      reduce using rule 140 (statement -> while_statement marker .)
    CHAR            reduce using rule 140 (statement -> while_statement marker .)
    STRING          reduce using rule 140 (statement -> while_statement marker .)
    KEYWORD_NULL    reduce using rule 140 (statement -> while_statement marker .)
    BOOL_CONSTT     reduce using rule 140 (statement -> while_statement marker .)
    BOOL_CONSTF     reduce using rule 140 (statement -> while_statement marker .)
    BLOCKEND        reduce using rule 140 (statement -> while_statement marker .)


state 113

    (71) unary_expression -> PLUS unary_expression .

    TIMES           reduce using rule 71 (unary_expression -> PLUS unary_expression .)
    DIVIDE          reduce using rule 71 (unary_expression -> PLUS unary_expression .)
    REMAINDER       reduce using rule 71 (unary_expression -> PLUS unary_expression .)
    PLUS            reduce using rule 71 (unary_expression -> PLUS unary_expression .)
    MINUS           reduce using rule 71 (unary_expression -> PLUS unary_expression .)
    LSHIFT          reduce using rule 71 (unary_expression -> PLUS unary_expression .)
    RSHIFT          reduce using rule 71 (unary_expression -> PLUS unary_expression .)
    GREATER         reduce using rule 71 (unary_expression -> PLUS unary_expression .)
    LESS            reduce using rule 71 (unary_expression -> PLUS unary_expression .)
    GEQ             reduce using rule 71 (unary_expression -> PLUS unary_expression .)
    LEQ             reduce using rule 71 (unary_expression -> PLUS unary_expression .)
    EQUAL           reduce using rule 71 (unary_expression -> PLUS unary_expression .)
    NEQUAL          reduce using rule 71 (unary_expression -> PLUS unary_expression .)
    AND_BITWISE     reduce using rule 71 (unary_expression -> PLUS unary_expression .)
    XOR             reduce using rule 71 (unary_expression -> PLUS unary_expression .)
    OR_BITWISE      reduce using rule 71 (unary_expression -> PLUS unary_expression .)
    AND             reduce using rule 71 (unary_expression -> PLUS unary_expression .)
    OR              reduce using rule 71 (unary_expression -> PLUS unary_expression .)
    TERMINATOR      reduce using rule 71 (unary_expression -> PLUS unary_expression .)
    KEYWORD_MATCH   reduce using rule 71 (unary_expression -> PLUS unary_expression .)
    RPAREN          reduce using rule 71 (unary_expression -> PLUS unary_expression .)
    RBRAC           reduce using rule 71 (unary_expression -> PLUS unary_expression .)
    COMMA           reduce using rule 71 (unary_expression -> PLUS unary_expression .)
    FUNTYPE         reduce using rule 71 (unary_expression -> PLUS unary_expression .)
    KEYWORD_UNTIL   reduce using rule 71 (unary_expression -> PLUS unary_expression .)
    KEYWORD_TO      reduce using rule 71 (unary_expression -> PLUS unary_expression .)
    KEYWORD_BY      reduce using rule 71 (unary_expression -> PLUS unary_expression .)


state 114

    (148) expression_statement -> statement_expression TERMINATOR .

    KEYWORD_ELSE    reduce using rule 148 (expression_statement -> statement_expression TERMINATOR .)
    KEYWORD_IF      reduce using rule 148 (expression_statement -> statement_expression TERMINATOR .)
    KEYWORD_WHILE   reduce using rule 148 (expression_statement -> statement_expression TERMINATOR .)
    KEYWORD_DO      reduce using rule 148 (expression_statement -> statement_expression TERMINATOR .)
    KEYWORD_FOR     reduce using rule 148 (expression_statement -> statement_expression TERMINATOR .)
    KEYWORD_CLASS   reduce using rule 148 (expression_statement -> statement_expression TERMINATOR .)
    KEYWORD_OBJECT  reduce using rule 148 (expression_statement -> statement_expression TERMINATOR .)
    KEYWORD_VAR     reduce using rule 148 (expression_statement -> statement_expression TERMINATOR .)
    KEYWORD_VAL     reduce using rule 148 (expression_statement -> statement_expression TERMINATOR .)
    TERMINATOR      reduce using rule 148 (expression_statement -> statement_expression TERMINATOR .)
    KEYWORD_RETURN  reduce using rule 148 (expression_statement -> statement_expression TERMINATOR .)
    KEYWORD_DEF     reduce using rule 148 (expression_statement -> statement_expression TERMINATOR .)
    BLOCKBEGIN      reduce using rule 148 (expression_statement -> statement_expression TERMINATOR .)
    IDENTIFIER      reduce using rule 148 (expression_statement -> statement_expression TERMINATOR .)
    PLUS            reduce using rule 148 (expression_statement -> statement_expression TERMINATOR .)
    MINUS           reduce using rule 148 (expression_statement -> statement_expression TERMINATOR .)
    TILDA           reduce using rule 148 (expression_statement -> statement_expression TERMINATOR .)
    NOT             reduce using rule 148 (expression_statement -> statement_expression TERMINATOR .)
    LPAREN          reduce using rule 148 (expression_statement -> statement_expression TERMINATOR .)
    DOUBLE_NUMBER   reduce using rule 148 (expression_statement -> statement_expression TERMINATOR .)
    INT_NUMBER      reduce using rule 148 (expression_statement -> statement_expression TERMINATOR .)
    CHAR            reduce using rule 148 (expression_statement -> statement_expression TERMINATOR .)
    STRING          reduce using rule 148 (expression_statement -> statement_expression TERMINATOR .)
    KEYWORD_NULL    reduce using rule 148 (expression_statement -> statement_expression TERMINATOR .)
    BOOL_CONSTT     reduce using rule 148 (expression_statement -> statement_expression TERMINATOR .)
    BOOL_CONSTF     reduce using rule 148 (expression_statement -> statement_expression TERMINATOR .)
    BLOCKEND        reduce using rule 148 (expression_statement -> statement_expression TERMINATOR .)


state 115

    (142) statement -> for_statement marker .

    KEYWORD_IF      reduce using rule 142 (statement -> for_statement marker .)
    KEYWORD_WHILE   reduce using rule 142 (statement -> for_statement marker .)
    KEYWORD_DO      reduce using rule 142 (statement -> for_statement marker .)
    KEYWORD_FOR     reduce using rule 142 (statement -> for_statement marker .)
    KEYWORD_CLASS   reduce using rule 142 (statement -> for_statement marker .)
    KEYWORD_OBJECT  reduce using rule 142 (statement -> for_statement marker .)
    KEYWORD_VAR     reduce using rule 142 (statement -> for_statement marker .)
    KEYWORD_VAL     reduce using rule 142 (statement -> for_statement marker .)
    TERMINATOR      reduce using rule 142 (statement -> for_statement marker .)
    KEYWORD_RETURN  reduce using rule 142 (statement -> for_statement marker .)
    KEYWORD_DEF     reduce using rule 142 (statement -> for_statement marker .)
    BLOCKBEGIN      reduce using rule 142 (statement -> for_statement marker .)
    IDENTIFIER      reduce using rule 142 (statement -> for_statement marker .)
    PLUS            reduce using rule 142 (statement -> for_statement marker .)
    MINUS           reduce using rule 142 (statement -> for_statement marker .)
    TILDA           reduce using rule 142 (statement -> for_statement marker .)
    NOT             reduce using rule 142 (statement -> for_statement marker .)
    LPAREN          reduce using rule 142 (statement -> for_statement marker .)
    DOUBLE_NUMBER   reduce using rule 142 (statement -> for_statement marker .)
    INT_NUMBER      reduce using rule 142 (statement -> for_statement marker .)
    CHAR            reduce using rule 142 (statement -> for_statement marker .)
    STRING          reduce using rule 142 (statement -> for_statement marker .)
    KEYWORD_NULL    reduce using rule 142 (statement -> for_statement marker .)
    BOOL_CONSTT     reduce using rule 142 (statement -> for_statement marker .)
    BOOL_CONSTF     reduce using rule 142 (statement -> for_statement marker .)
    BLOCKEND        reduce using rule 142 (statement -> for_statement marker .)


state 116

    (175) method_header -> method_header_name func_arg_start . fun_params_opt RPAREN COLON method_return_type ASOP
    (177) fun_params_opt -> . fun_params
    (178) fun_params_opt -> . empty
    (179) fun_params -> . fun_variable_declarator_id
    (180) fun_params -> . fun_params COMMA fun_variable_declarator_id
    (200) empty -> .
    (117) fun_variable_declarator_id -> . IDENTIFIER COLON type

    RPAREN          reduce using rule 200 (empty -> .)
    IDENTIFIER      shift and go to state 196

    fun_variable_declarator_id     shift and go to state 193
    fun_params_opt                 shift and go to state 194
    fun_params                     shift and go to state 195
    empty                          shift and go to state 197

state 117

    (29) dimension -> LBRAC . expression RBRAC
    (19) expression -> . assignment_expression
    (22) assignment_expression -> . assignment
    (23) assignment_expression -> . conditional_or_expression
    (24) assignment_expression -> . method_invocation
    (25) assignment -> . valid_variable assignment_operator assignment_expression
    (43) conditional_or_expression -> . conditional_and_expression
    (44) conditional_or_expression -> . conditional_or_expression OR marker conditional_and_expression
    (94) method_invocation -> . name LPAREN argument_list_opt RPAREN
    (26) valid_variable -> . name
    (27) valid_variable -> . array_access
    (45) conditional_and_expression -> . inclusive_or_expression
    (46) conditional_and_expression -> . conditional_and_expression AND marker inclusive_or_expression
    (130) name -> . simple_name
    (131) name -> . qualified_name
    (28) array_access -> . name dimension
    (47) inclusive_or_expression -> . exclusive_or_expression
    (48) inclusive_or_expression -> . inclusive_or_expression OR_BITWISE exclusive_or_expression
    (132) simple_name -> . IDENTIFIER
    (133) qualified_name -> . name INST simple_name
    (49) exclusive_or_expression -> . and_expression
    (50) exclusive_or_expression -> . exclusive_or_expression XOR and_expression
    (51) and_expression -> . equality_expression
    (52) and_expression -> . and_expression AND_BITWISE equality_expression
    (53) equality_expression -> . relational_expression
    (54) equality_expression -> . equality_expression EQUAL relational_expression
    (55) equality_expression -> . equality_expression NEQUAL relational_expression
    (56) relational_expression -> . shift_expression
    (57) relational_expression -> . relational_expression GREATER shift_expression
    (58) relational_expression -> . relational_expression LESS shift_expression
    (59) relational_expression -> . relational_expression GEQ shift_expression
    (60) relational_expression -> . relational_expression LEQ shift_expression
    (61) shift_expression -> . additive_expression
    (62) shift_expression -> . shift_expression LSHIFT additive_expression
    (63) shift_expression -> . shift_expression RSHIFT additive_expression
    (64) additive_expression -> . multiplicative_expression
    (65) additive_expression -> . additive_expression PLUS multiplicative_expression
    (66) additive_expression -> . additive_expression MINUS multiplicative_expression
    (67) multiplicative_expression -> . unary_expression
    (68) multiplicative_expression -> . multiplicative_expression TIMES unary_expression
    (69) multiplicative_expression -> . multiplicative_expression DIVIDE unary_expression
    (70) multiplicative_expression -> . multiplicative_expression REMAINDER unary_expression
    (71) unary_expression -> . PLUS unary_expression
    (72) unary_expression -> . MINUS unary_expression
    (73) unary_expression -> . unary_expression_not_plus_minus
    (74) unary_expression_not_plus_minus -> . base_variable_set
    (75) unary_expression_not_plus_minus -> . TILDA unary_expression
    (76) unary_expression_not_plus_minus -> . cast_expression
    (77) unary_expression_not_plus_minus -> . NOT unary_expression
    (78) base_variable_set -> . variable_literal
    (79) base_variable_set -> . LPAREN expression RPAREN
    (82) cast_expression -> . LPAREN primitive_type RPAREN unary_expression
    (80) variable_literal -> . valid_variable
    (81) variable_literal -> . primary
    (83) primary -> . literal
    (84) primary -> . method_invocation
    (85) literal -> . int_float
    (86) literal -> . c_literal
    (92) int_float -> . DOUBLE_NUMBER
    (93) int_float -> . INT_NUMBER
    (87) c_literal -> . CHAR
    (88) c_literal -> . STRING
    (89) c_literal -> . KEYWORD_NULL
    (90) c_literal -> . BOOL_CONSTT
    (91) c_literal -> . BOOL_CONSTF

    IDENTIFIER      shift and go to state 9
    PLUS            shift and go to state 31
    MINUS           shift and go to state 24
    TILDA           shift and go to state 68
    NOT             shift and go to state 53
    LPAREN          shift and go to state 91
    DOUBLE_NUMBER   shift and go to state 28
    INT_NUMBER      shift and go to state 39
    CHAR            shift and go to state 59
    STRING          shift and go to state 72
    KEYWORD_NULL    shift and go to state 61
    BOOL_CONSTT     shift and go to state 30
    BOOL_CONSTF     shift and go to state 25

    and_expression                 shift and go to state 84
    exclusive_or_expression        shift and go to state 57
    primary                        shift and go to state 58
    unary_expression_not_plus_minus shift and go to state 41
    array_access                   shift and go to state 23
    additive_expression            shift and go to state 62
    simple_name                    shift and go to state 63
    c_literal                      shift and go to state 90
    unary_expression               shift and go to state 40
    base_variable_set              shift and go to state 85
    valid_variable                 shift and go to state 92
    inclusive_or_expression        shift and go to state 27
    literal                        shift and go to state 67
    relational_expression          shift and go to state 69
    method_invocation              shift and go to state 139
    conditional_or_expression      shift and go to state 43
    assignment_expression          shift and go to state 88
    qualified_name                 shift and go to state 75
    assignment                     shift and go to state 142
    multiplicative_expression      shift and go to state 46
    cast_expression                shift and go to state 77
    shift_expression               shift and go to state 50
    equality_expression            shift and go to state 79
    int_float                      shift and go to state 35
    variable_literal               shift and go to state 51
    name                           shift and go to state 38
    expression                     shift and go to state 198
    conditional_and_expression     shift and go to state 52

state 118

    (133) qualified_name -> name INST . simple_name
    (132) simple_name -> . IDENTIFIER

    IDENTIFIER      shift and go to state 9

    simple_name                    shift and go to state 199

state 119

    (94) method_invocation -> name LPAREN . argument_list_opt RPAREN
    (95) argument_list_opt -> . argument_list
    (96) argument_list_opt -> . empty
    (97) argument_list -> . expression
    (98) argument_list -> . argument_list COMMA expression
    (200) empty -> .
    (19) expression -> . assignment_expression
    (22) assignment_expression -> . assignment
    (23) assignment_expression -> . conditional_or_expression
    (24) assignment_expression -> . method_invocation
    (25) assignment -> . valid_variable assignment_operator assignment_expression
    (43) conditional_or_expression -> . conditional_and_expression
    (44) conditional_or_expression -> . conditional_or_expression OR marker conditional_and_expression
    (94) method_invocation -> . name LPAREN argument_list_opt RPAREN
    (26) valid_variable -> . name
    (27) valid_variable -> . array_access
    (45) conditional_and_expression -> . inclusive_or_expression
    (46) conditional_and_expression -> . conditional_and_expression AND marker inclusive_or_expression
    (130) name -> . simple_name
    (131) name -> . qualified_name
    (28) array_access -> . name dimension
    (47) inclusive_or_expression -> . exclusive_or_expression
    (48) inclusive_or_expression -> . inclusive_or_expression OR_BITWISE exclusive_or_expression
    (132) simple_name -> . IDENTIFIER
    (133) qualified_name -> . name INST simple_name
    (49) exclusive_or_expression -> . and_expression
    (50) exclusive_or_expression -> . exclusive_or_expression XOR and_expression
    (51) and_expression -> . equality_expression
    (52) and_expression -> . and_expression AND_BITWISE equality_expression
    (53) equality_expression -> . relational_expression
    (54) equality_expression -> . equality_expression EQUAL relational_expression
    (55) equality_expression -> . equality_expression NEQUAL relational_expression
    (56) relational_expression -> . shift_expression
    (57) relational_expression -> . relational_expression GREATER shift_expression
    (58) relational_expression -> . relational_expression LESS shift_expression
    (59) relational_expression -> . relational_expression GEQ shift_expression
    (60) relational_expression -> . relational_expression LEQ shift_expression
    (61) shift_expression -> . additive_expression
    (62) shift_expression -> . shift_expression LSHIFT additive_expression
    (63) shift_expression -> . shift_expression RSHIFT additive_expression
    (64) additive_expression -> . multiplicative_expression
    (65) additive_expression -> . additive_expression PLUS multiplicative_expression
    (66) additive_expression -> . additive_expression MINUS multiplicative_expression
    (67) multiplicative_expression -> . unary_expression
    (68) multiplicative_expression -> . multiplicative_expression TIMES unary_expression
    (69) multiplicative_expression -> . multiplicative_expression DIVIDE unary_expression
    (70) multiplicative_expression -> . multiplicative_expression REMAINDER unary_expression
    (71) unary_expression -> . PLUS unary_expression
    (72) unary_expression -> . MINUS unary_expression
    (73) unary_expression -> . unary_expression_not_plus_minus
    (74) unary_expression_not_plus_minus -> . base_variable_set
    (75) unary_expression_not_plus_minus -> . TILDA unary_expression
    (76) unary_expression_not_plus_minus -> . cast_expression
    (77) unary_expression_not_plus_minus -> . NOT unary_expression
    (78) base_variable_set -> . variable_literal
    (79) base_variable_set -> . LPAREN expression RPAREN
    (82) cast_expression -> . LPAREN primitive_type RPAREN unary_expression
    (80) variable_literal -> . valid_variable
    (81) variable_literal -> . primary
    (83) primary -> . literal
    (84) primary -> . method_invocation
    (85) literal -> . int_float
    (86) literal -> . c_literal
    (92) int_float -> . DOUBLE_NUMBER
    (93) int_float -> . INT_NUMBER
    (87) c_literal -> . CHAR
    (88) c_literal -> . STRING
    (89) c_literal -> . KEYWORD_NULL
    (90) c_literal -> . BOOL_CONSTT
    (91) c_literal -> . BOOL_CONSTF

    RPAREN          reduce using rule 200 (empty -> .)
    IDENTIFIER      shift and go to state 9
    PLUS            shift and go to state 31
    MINUS           shift and go to state 24
    TILDA           shift and go to state 68
    NOT             shift and go to state 53
    LPAREN          shift and go to state 91
    DOUBLE_NUMBER   shift and go to state 28
    INT_NUMBER      shift and go to state 39
    CHAR            shift and go to state 59
    STRING          shift and go to state 72
    KEYWORD_NULL    shift and go to state 61
    BOOL_CONSTT     shift and go to state 30
    BOOL_CONSTF     shift and go to state 25

    unary_expression               shift and go to state 40
    exclusive_or_expression        shift and go to state 57
    primary                        shift and go to state 58
    unary_expression_not_plus_minus shift and go to state 41
    array_access                   shift and go to state 23
    and_expression                 shift and go to state 84
    simple_name                    shift and go to state 63
    c_literal                      shift and go to state 90
    base_variable_set              shift and go to state 85
    valid_variable                 shift and go to state 92
    inclusive_or_expression        shift and go to state 27
    literal                        shift and go to state 67
    relational_expression          shift and go to state 69
    method_invocation              shift and go to state 139
    conditional_or_expression      shift and go to state 43
    empty                          shift and go to state 201
    argument_list                  shift and go to state 200
    assignment_expression          shift and go to state 88
    qualified_name                 shift and go to state 75
    assignment                     shift and go to state 142
    multiplicative_expression      shift and go to state 46
    additive_expression            shift and go to state 62
    cast_expression                shift and go to state 77
    shift_expression               shift and go to state 50
    equality_expression            shift and go to state 79
    int_float                      shift and go to state 35
    variable_literal               shift and go to state 51
    name                           shift and go to state 38
    argument_list_opt              shift and go to state 202
    expression                     shift and go to state 203
    conditional_and_expression     shift and go to state 52

state 120

    (28) array_access -> name dimension .

    TIMES           reduce using rule 28 (array_access -> name dimension .)
    DIVIDE          reduce using rule 28 (array_access -> name dimension .)
    REMAINDER       reduce using rule 28 (array_access -> name dimension .)
    PLUS            reduce using rule 28 (array_access -> name dimension .)
    MINUS           reduce using rule 28 (array_access -> name dimension .)
    LSHIFT          reduce using rule 28 (array_access -> name dimension .)
    RSHIFT          reduce using rule 28 (array_access -> name dimension .)
    GREATER         reduce using rule 28 (array_access -> name dimension .)
    LESS            reduce using rule 28 (array_access -> name dimension .)
    GEQ             reduce using rule 28 (array_access -> name dimension .)
    LEQ             reduce using rule 28 (array_access -> name dimension .)
    EQUAL           reduce using rule 28 (array_access -> name dimension .)
    NEQUAL          reduce using rule 28 (array_access -> name dimension .)
    AND_BITWISE     reduce using rule 28 (array_access -> name dimension .)
    XOR             reduce using rule 28 (array_access -> name dimension .)
    OR_BITWISE      reduce using rule 28 (array_access -> name dimension .)
    AND             reduce using rule 28 (array_access -> name dimension .)
    OR              reduce using rule 28 (array_access -> name dimension .)
    KEYWORD_MATCH   reduce using rule 28 (array_access -> name dimension .)
    TERMINATOR      reduce using rule 28 (array_access -> name dimension .)
    RPAREN          reduce using rule 28 (array_access -> name dimension .)
    RBRAC           reduce using rule 28 (array_access -> name dimension .)
    COMMA           reduce using rule 28 (array_access -> name dimension .)
    FUNTYPE         reduce using rule 28 (array_access -> name dimension .)
    KEYWORD_UNTIL   reduce using rule 28 (array_access -> name dimension .)
    KEYWORD_TO      reduce using rule 28 (array_access -> name dimension .)
    KEYWORD_BY      reduce using rule 28 (array_access -> name dimension .)
    ASOP            reduce using rule 28 (array_access -> name dimension .)
    TIMES_ASSIGN    reduce using rule 28 (array_access -> name dimension .)
    DIVIDE_ASSIGN   reduce using rule 28 (array_access -> name dimension .)
    REMAINDER_ASSIGN reduce using rule 28 (array_access -> name dimension .)
    PLUS_ASSIGN     reduce using rule 28 (array_access -> name dimension .)
    MINUS_ASSIGN    reduce using rule 28 (array_access -> name dimension .)
    LSHIFT_ASSIGN   reduce using rule 28 (array_access -> name dimension .)
    RSHIFT_ASSIGN   reduce using rule 28 (array_access -> name dimension .)
    AND_ASSIGN      reduce using rule 28 (array_access -> name dimension .)
    OR_ASSIGN       reduce using rule 28 (array_access -> name dimension .)
    XOR_ASSIGN      reduce using rule 28 (array_access -> name dimension .)


state 121

    (147) normal_statement -> switch_statement marker .

    KEYWORD_IF      reduce using rule 147 (normal_statement -> switch_statement marker .)
    KEYWORD_WHILE   reduce using rule 147 (normal_statement -> switch_statement marker .)
    KEYWORD_DO      reduce using rule 147 (normal_statement -> switch_statement marker .)
    KEYWORD_FOR     reduce using rule 147 (normal_statement -> switch_statement marker .)
    KEYWORD_CLASS   reduce using rule 147 (normal_statement -> switch_statement marker .)
    KEYWORD_OBJECT  reduce using rule 147 (normal_statement -> switch_statement marker .)
    KEYWORD_VAR     reduce using rule 147 (normal_statement -> switch_statement marker .)
    KEYWORD_VAL     reduce using rule 147 (normal_statement -> switch_statement marker .)
    TERMINATOR      reduce using rule 147 (normal_statement -> switch_statement marker .)
    KEYWORD_RETURN  reduce using rule 147 (normal_statement -> switch_statement marker .)
    KEYWORD_DEF     reduce using rule 147 (normal_statement -> switch_statement marker .)
    BLOCKBEGIN      reduce using rule 147 (normal_statement -> switch_statement marker .)
    IDENTIFIER      reduce using rule 147 (normal_statement -> switch_statement marker .)
    PLUS            reduce using rule 147 (normal_statement -> switch_statement marker .)
    MINUS           reduce using rule 147 (normal_statement -> switch_statement marker .)
    TILDA           reduce using rule 147 (normal_statement -> switch_statement marker .)
    NOT             reduce using rule 147 (normal_statement -> switch_statement marker .)
    LPAREN          reduce using rule 147 (normal_statement -> switch_statement marker .)
    DOUBLE_NUMBER   reduce using rule 147 (normal_statement -> switch_statement marker .)
    INT_NUMBER      reduce using rule 147 (normal_statement -> switch_statement marker .)
    CHAR            reduce using rule 147 (normal_statement -> switch_statement marker .)
    STRING          reduce using rule 147 (normal_statement -> switch_statement marker .)
    KEYWORD_NULL    reduce using rule 147 (normal_statement -> switch_statement marker .)
    BOOL_CONSTT     reduce using rule 147 (normal_statement -> switch_statement marker .)
    BOOL_CONSTF     reduce using rule 147 (normal_statement -> switch_statement marker .)
    BLOCKEND        reduce using rule 147 (normal_statement -> switch_statement marker .)
    KEYWORD_ELSE    reduce using rule 147 (normal_statement -> switch_statement marker .)


state 122

    (44) conditional_or_expression -> conditional_or_expression OR . marker conditional_and_expression
    (41) marker -> . empty
    (200) empty -> .

    PLUS            reduce using rule 200 (empty -> .)
    MINUS           reduce using rule 200 (empty -> .)
    TILDA           reduce using rule 200 (empty -> .)
    NOT             reduce using rule 200 (empty -> .)
    LPAREN          reduce using rule 200 (empty -> .)
    IDENTIFIER      reduce using rule 200 (empty -> .)
    DOUBLE_NUMBER   reduce using rule 200 (empty -> .)
    INT_NUMBER      reduce using rule 200 (empty -> .)
    CHAR            reduce using rule 200 (empty -> .)
    STRING          reduce using rule 200 (empty -> .)
    KEYWORD_NULL    reduce using rule 200 (empty -> .)
    BOOL_CONSTT     reduce using rule 200 (empty -> .)
    BOOL_CONSTF     reduce using rule 200 (empty -> .)

    marker                         shift and go to state 204
    empty                          shift and go to state 104

state 123

    (156) while_statement -> KEYWORD_WHILE LPAREN . marker expression RPAREN marker block
    (41) marker -> . empty
    (200) empty -> .

    IDENTIFIER      reduce using rule 200 (empty -> .)
    PLUS            reduce using rule 200 (empty -> .)
    MINUS           reduce using rule 200 (empty -> .)
    TILDA           reduce using rule 200 (empty -> .)
    NOT             reduce using rule 200 (empty -> .)
    LPAREN          reduce using rule 200 (empty -> .)
    DOUBLE_NUMBER   reduce using rule 200 (empty -> .)
    INT_NUMBER      reduce using rule 200 (empty -> .)
    CHAR            reduce using rule 200 (empty -> .)
    STRING          reduce using rule 200 (empty -> .)
    KEYWORD_NULL    reduce using rule 200 (empty -> .)
    BOOL_CONSTT     reduce using rule 200 (empty -> .)
    BOOL_CONSTF     reduce using rule 200 (empty -> .)

    marker                         shift and go to state 205
    empty                          shift and go to state 104

state 124

    (141) statement -> do_while_statement marker .

    KEYWORD_IF      reduce using rule 141 (statement -> do_while_statement marker .)
    KEYWORD_WHILE   reduce using rule 141 (statement -> do_while_statement marker .)
    KEYWORD_DO      reduce using rule 141 (statement -> do_while_statement marker .)
    KEYWORD_FOR     reduce using rule 141 (statement -> do_while_statement marker .)
    KEYWORD_CLASS   reduce using rule 141 (statement -> do_while_statement marker .)
    KEYWORD_OBJECT  reduce using rule 141 (statement -> do_while_statement marker .)
    KEYWORD_VAR     reduce using rule 141 (statement -> do_while_statement marker .)
    KEYWORD_VAL     reduce using rule 141 (statement -> do_while_statement marker .)
    TERMINATOR      reduce using rule 141 (statement -> do_while_statement marker .)
    KEYWORD_RETURN  reduce using rule 141 (statement -> do_while_statement marker .)
    KEYWORD_DEF     reduce using rule 141 (statement -> do_while_statement marker .)
    BLOCKBEGIN      reduce using rule 141 (statement -> do_while_statement marker .)
    IDENTIFIER      reduce using rule 141 (statement -> do_while_statement marker .)
    PLUS            reduce using rule 141 (statement -> do_while_statement marker .)
    MINUS           reduce using rule 141 (statement -> do_while_statement marker .)
    TILDA           reduce using rule 141 (statement -> do_while_statement marker .)
    NOT             reduce using rule 141 (statement -> do_while_statement marker .)
    LPAREN          reduce using rule 141 (statement -> do_while_statement marker .)
    DOUBLE_NUMBER   reduce using rule 141 (statement -> do_while_statement marker .)
    INT_NUMBER      reduce using rule 141 (statement -> do_while_statement marker .)
    CHAR            reduce using rule 141 (statement -> do_while_statement marker .)
    STRING          reduce using rule 141 (statement -> do_while_statement marker .)
    KEYWORD_NULL    reduce using rule 141 (statement -> do_while_statement marker .)
    BOOL_CONSTT     reduce using rule 141 (statement -> do_while_statement marker .)
    BOOL_CONSTF     reduce using rule 141 (statement -> do_while_statement marker .)
    BLOCKEND        reduce using rule 141 (statement -> do_while_statement marker .)


state 125

    (70) multiplicative_expression -> multiplicative_expression REMAINDER . unary_expression
    (71) unary_expression -> . PLUS unary_expression
    (72) unary_expression -> . MINUS unary_expression
    (73) unary_expression -> . unary_expression_not_plus_minus
    (74) unary_expression_not_plus_minus -> . base_variable_set
    (75) unary_expression_not_plus_minus -> . TILDA unary_expression
    (76) unary_expression_not_plus_minus -> . cast_expression
    (77) unary_expression_not_plus_minus -> . NOT unary_expression
    (78) base_variable_set -> . variable_literal
    (79) base_variable_set -> . LPAREN expression RPAREN
    (82) cast_expression -> . LPAREN primitive_type RPAREN unary_expression
    (80) variable_literal -> . valid_variable
    (81) variable_literal -> . primary
    (26) valid_variable -> . name
    (27) valid_variable -> . array_access
    (83) primary -> . literal
    (84) primary -> . method_invocation
    (130) name -> . simple_name
    (131) name -> . qualified_name
    (28) array_access -> . name dimension
    (85) literal -> . int_float
    (86) literal -> . c_literal
    (94) method_invocation -> . name LPAREN argument_list_opt RPAREN
    (132) simple_name -> . IDENTIFIER
    (133) qualified_name -> . name INST simple_name
    (92) int_float -> . DOUBLE_NUMBER
    (93) int_float -> . INT_NUMBER
    (87) c_literal -> . CHAR
    (88) c_literal -> . STRING
    (89) c_literal -> . KEYWORD_NULL
    (90) c_literal -> . BOOL_CONSTT
    (91) c_literal -> . BOOL_CONSTF

    PLUS            shift and go to state 31
    MINUS           shift and go to state 24
    TILDA           shift and go to state 68
    NOT             shift and go to state 53
    LPAREN          shift and go to state 91
    IDENTIFIER      shift and go to state 9
    DOUBLE_NUMBER   shift and go to state 28
    INT_NUMBER      shift and go to state 39
    CHAR            shift and go to state 59
    STRING          shift and go to state 72
    KEYWORD_NULL    shift and go to state 61
    BOOL_CONSTT     shift and go to state 30
    BOOL_CONSTF     shift and go to state 25

    qualified_name                 shift and go to state 75
    int_float                      shift and go to state 35
    c_literal                      shift and go to state 90
    variable_literal               shift and go to state 51
    unary_expression               shift and go to state 206
    base_variable_set              shift and go to state 85
    valid_variable                 shift and go to state 106
    array_access                   shift and go to state 23
    primary                        shift and go to state 58
    unary_expression_not_plus_minus shift and go to state 41
    literal                        shift and go to state 67
    method_invocation              shift and go to state 107
    cast_expression                shift and go to state 77
    simple_name                    shift and go to state 63
    name                           shift and go to state 108

state 126

    (69) multiplicative_expression -> multiplicative_expression DIVIDE . unary_expression
    (71) unary_expression -> . PLUS unary_expression
    (72) unary_expression -> . MINUS unary_expression
    (73) unary_expression -> . unary_expression_not_plus_minus
    (74) unary_expression_not_plus_minus -> . base_variable_set
    (75) unary_expression_not_plus_minus -> . TILDA unary_expression
    (76) unary_expression_not_plus_minus -> . cast_expression
    (77) unary_expression_not_plus_minus -> . NOT unary_expression
    (78) base_variable_set -> . variable_literal
    (79) base_variable_set -> . LPAREN expression RPAREN
    (82) cast_expression -> . LPAREN primitive_type RPAREN unary_expression
    (80) variable_literal -> . valid_variable
    (81) variable_literal -> . primary
    (26) valid_variable -> . name
    (27) valid_variable -> . array_access
    (83) primary -> . literal
    (84) primary -> . method_invocation
    (130) name -> . simple_name
    (131) name -> . qualified_name
    (28) array_access -> . name dimension
    (85) literal -> . int_float
    (86) literal -> . c_literal
    (94) method_invocation -> . name LPAREN argument_list_opt RPAREN
    (132) simple_name -> . IDENTIFIER
    (133) qualified_name -> . name INST simple_name
    (92) int_float -> . DOUBLE_NUMBER
    (93) int_float -> . INT_NUMBER
    (87) c_literal -> . CHAR
    (88) c_literal -> . STRING
    (89) c_literal -> . KEYWORD_NULL
    (90) c_literal -> . BOOL_CONSTT
    (91) c_literal -> . BOOL_CONSTF

    PLUS            shift and go to state 31
    MINUS           shift and go to state 24
    TILDA           shift and go to state 68
    NOT             shift and go to state 53
    LPAREN          shift and go to state 91
    IDENTIFIER      shift and go to state 9
    DOUBLE_NUMBER   shift and go to state 28
    INT_NUMBER      shift and go to state 39
    CHAR            shift and go to state 59
    STRING          shift and go to state 72
    KEYWORD_NULL    shift and go to state 61
    BOOL_CONSTT     shift and go to state 30
    BOOL_CONSTF     shift and go to state 25

    qualified_name                 shift and go to state 75
    int_float                      shift and go to state 35
    c_literal                      shift and go to state 90
    variable_literal               shift and go to state 51
    unary_expression               shift and go to state 207
    base_variable_set              shift and go to state 85
    valid_variable                 shift and go to state 106
    array_access                   shift and go to state 23
    primary                        shift and go to state 58
    unary_expression_not_plus_minus shift and go to state 41
    literal                        shift and go to state 67
    method_invocation              shift and go to state 107
    cast_expression                shift and go to state 77
    simple_name                    shift and go to state 63
    name                           shift and go to state 108

state 127

    (68) multiplicative_expression -> multiplicative_expression TIMES . unary_expression
    (71) unary_expression -> . PLUS unary_expression
    (72) unary_expression -> . MINUS unary_expression
    (73) unary_expression -> . unary_expression_not_plus_minus
    (74) unary_expression_not_plus_minus -> . base_variable_set
    (75) unary_expression_not_plus_minus -> . TILDA unary_expression
    (76) unary_expression_not_plus_minus -> . cast_expression
    (77) unary_expression_not_plus_minus -> . NOT unary_expression
    (78) base_variable_set -> . variable_literal
    (79) base_variable_set -> . LPAREN expression RPAREN
    (82) cast_expression -> . LPAREN primitive_type RPAREN unary_expression
    (80) variable_literal -> . valid_variable
    (81) variable_literal -> . primary
    (26) valid_variable -> . name
    (27) valid_variable -> . array_access
    (83) primary -> . literal
    (84) primary -> . method_invocation
    (130) name -> . simple_name
    (131) name -> . qualified_name
    (28) array_access -> . name dimension
    (85) literal -> . int_float
    (86) literal -> . c_literal
    (94) method_invocation -> . name LPAREN argument_list_opt RPAREN
    (132) simple_name -> . IDENTIFIER
    (133) qualified_name -> . name INST simple_name
    (92) int_float -> . DOUBLE_NUMBER
    (93) int_float -> . INT_NUMBER
    (87) c_literal -> . CHAR
    (88) c_literal -> . STRING
    (89) c_literal -> . KEYWORD_NULL
    (90) c_literal -> . BOOL_CONSTT
    (91) c_literal -> . BOOL_CONSTF

    PLUS            shift and go to state 31
    MINUS           shift and go to state 24
    TILDA           shift and go to state 68
    NOT             shift and go to state 53
    LPAREN          shift and go to state 91
    IDENTIFIER      shift and go to state 9
    DOUBLE_NUMBER   shift and go to state 28
    INT_NUMBER      shift and go to state 39
    CHAR            shift and go to state 59
    STRING          shift and go to state 72
    KEYWORD_NULL    shift and go to state 61
    BOOL_CONSTT     shift and go to state 30
    BOOL_CONSTF     shift and go to state 25

    qualified_name                 shift and go to state 75
    int_float                      shift and go to state 35
    c_literal                      shift and go to state 90
    variable_literal               shift and go to state 51
    unary_expression               shift and go to state 208
    base_variable_set              shift and go to state 85
    valid_variable                 shift and go to state 106
    array_access                   shift and go to state 23
    primary                        shift and go to state 58
    unary_expression_not_plus_minus shift and go to state 41
    literal                        shift and go to state 67
    method_invocation              shift and go to state 107
    cast_expression                shift and go to state 77
    simple_name                    shift and go to state 63
    name                           shift and go to state 108

state 128

    (63) shift_expression -> shift_expression RSHIFT . additive_expression
    (64) additive_expression -> . multiplicative_expression
    (65) additive_expression -> . additive_expression PLUS multiplicative_expression
    (66) additive_expression -> . additive_expression MINUS multiplicative_expression
    (67) multiplicative_expression -> . unary_expression
    (68) multiplicative_expression -> . multiplicative_expression TIMES unary_expression
    (69) multiplicative_expression -> . multiplicative_expression DIVIDE unary_expression
    (70) multiplicative_expression -> . multiplicative_expression REMAINDER unary_expression
    (71) unary_expression -> . PLUS unary_expression
    (72) unary_expression -> . MINUS unary_expression
    (73) unary_expression -> . unary_expression_not_plus_minus
    (74) unary_expression_not_plus_minus -> . base_variable_set
    (75) unary_expression_not_plus_minus -> . TILDA unary_expression
    (76) unary_expression_not_plus_minus -> . cast_expression
    (77) unary_expression_not_plus_minus -> . NOT unary_expression
    (78) base_variable_set -> . variable_literal
    (79) base_variable_set -> . LPAREN expression RPAREN
    (82) cast_expression -> . LPAREN primitive_type RPAREN unary_expression
    (80) variable_literal -> . valid_variable
    (81) variable_literal -> . primary
    (26) valid_variable -> . name
    (27) valid_variable -> . array_access
    (83) primary -> . literal
    (84) primary -> . method_invocation
    (130) name -> . simple_name
    (131) name -> . qualified_name
    (28) array_access -> . name dimension
    (85) literal -> . int_float
    (86) literal -> . c_literal
    (94) method_invocation -> . name LPAREN argument_list_opt RPAREN
    (132) simple_name -> . IDENTIFIER
    (133) qualified_name -> . name INST simple_name
    (92) int_float -> . DOUBLE_NUMBER
    (93) int_float -> . INT_NUMBER
    (87) c_literal -> . CHAR
    (88) c_literal -> . STRING
    (89) c_literal -> . KEYWORD_NULL
    (90) c_literal -> . BOOL_CONSTT
    (91) c_literal -> . BOOL_CONSTF

    PLUS            shift and go to state 31
    MINUS           shift and go to state 24
    TILDA           shift and go to state 68
    NOT             shift and go to state 53
    LPAREN          shift and go to state 91
    IDENTIFIER      shift and go to state 9
    DOUBLE_NUMBER   shift and go to state 28
    INT_NUMBER      shift and go to state 39
    CHAR            shift and go to state 59
    STRING          shift and go to state 72
    KEYWORD_NULL    shift and go to state 61
    BOOL_CONSTT     shift and go to state 30
    BOOL_CONSTF     shift and go to state 25

    unary_expression               shift and go to state 40
    primary                        shift and go to state 58
    unary_expression_not_plus_minus shift and go to state 41
    array_access                   shift and go to state 23
    additive_expression            shift and go to state 209
    simple_name                    shift and go to state 63
    c_literal                      shift and go to state 90
    base_variable_set              shift and go to state 85
    valid_variable                 shift and go to state 106
    literal                        shift and go to state 67
    method_invocation              shift and go to state 107
    qualified_name                 shift and go to state 75
    multiplicative_expression      shift and go to state 46
    cast_expression                shift and go to state 77
    int_float                      shift and go to state 35
    variable_literal               shift and go to state 51
    name                           shift and go to state 108

state 129

    (62) shift_expression -> shift_expression LSHIFT . additive_expression
    (64) additive_expression -> . multiplicative_expression
    (65) additive_expression -> . additive_expression PLUS multiplicative_expression
    (66) additive_expression -> . additive_expression MINUS multiplicative_expression
    (67) multiplicative_expression -> . unary_expression
    (68) multiplicative_expression -> . multiplicative_expression TIMES unary_expression
    (69) multiplicative_expression -> . multiplicative_expression DIVIDE unary_expression
    (70) multiplicative_expression -> . multiplicative_expression REMAINDER unary_expression
    (71) unary_expression -> . PLUS unary_expression
    (72) unary_expression -> . MINUS unary_expression
    (73) unary_expression -> . unary_expression_not_plus_minus
    (74) unary_expression_not_plus_minus -> . base_variable_set
    (75) unary_expression_not_plus_minus -> . TILDA unary_expression
    (76) unary_expression_not_plus_minus -> . cast_expression
    (77) unary_expression_not_plus_minus -> . NOT unary_expression
    (78) base_variable_set -> . variable_literal
    (79) base_variable_set -> . LPAREN expression RPAREN
    (82) cast_expression -> . LPAREN primitive_type RPAREN unary_expression
    (80) variable_literal -> . valid_variable
    (81) variable_literal -> . primary
    (26) valid_variable -> . name
    (27) valid_variable -> . array_access
    (83) primary -> . literal
    (84) primary -> . method_invocation
    (130) name -> . simple_name
    (131) name -> . qualified_name
    (28) array_access -> . name dimension
    (85) literal -> . int_float
    (86) literal -> . c_literal
    (94) method_invocation -> . name LPAREN argument_list_opt RPAREN
    (132) simple_name -> . IDENTIFIER
    (133) qualified_name -> . name INST simple_name
    (92) int_float -> . DOUBLE_NUMBER
    (93) int_float -> . INT_NUMBER
    (87) c_literal -> . CHAR
    (88) c_literal -> . STRING
    (89) c_literal -> . KEYWORD_NULL
    (90) c_literal -> . BOOL_CONSTT
    (91) c_literal -> . BOOL_CONSTF

    PLUS            shift and go to state 31
    MINUS           shift and go to state 24
    TILDA           shift and go to state 68
    NOT             shift and go to state 53
    LPAREN          shift and go to state 91
    IDENTIFIER      shift and go to state 9
    DOUBLE_NUMBER   shift and go to state 28
    INT_NUMBER      shift and go to state 39
    CHAR            shift and go to state 59
    STRING          shift and go to state 72
    KEYWORD_NULL    shift and go to state 61
    BOOL_CONSTT     shift and go to state 30
    BOOL_CONSTF     shift and go to state 25

    unary_expression               shift and go to state 40
    primary                        shift and go to state 58
    unary_expression_not_plus_minus shift and go to state 41
    array_access                   shift and go to state 23
    additive_expression            shift and go to state 210
    simple_name                    shift and go to state 63
    c_literal                      shift and go to state 90
    base_variable_set              shift and go to state 85
    valid_variable                 shift and go to state 106
    literal                        shift and go to state 67
    method_invocation              shift and go to state 107
    qualified_name                 shift and go to state 75
    multiplicative_expression      shift and go to state 46
    cast_expression                shift and go to state 77
    int_float                      shift and go to state 35
    variable_literal               shift and go to state 51
    name                           shift and go to state 108

state 130

    (46) conditional_and_expression -> conditional_and_expression AND . marker inclusive_or_expression
    (41) marker -> . empty
    (200) empty -> .

    PLUS            reduce using rule 200 (empty -> .)
    MINUS           reduce using rule 200 (empty -> .)
    TILDA           reduce using rule 200 (empty -> .)
    NOT             reduce using rule 200 (empty -> .)
    LPAREN          reduce using rule 200 (empty -> .)
    IDENTIFIER      reduce using rule 200 (empty -> .)
    DOUBLE_NUMBER   reduce using rule 200 (empty -> .)
    INT_NUMBER      reduce using rule 200 (empty -> .)
    CHAR            reduce using rule 200 (empty -> .)
    STRING          reduce using rule 200 (empty -> .)
    KEYWORD_NULL    reduce using rule 200 (empty -> .)
    BOOL_CONSTT     reduce using rule 200 (empty -> .)
    BOOL_CONSTF     reduce using rule 200 (empty -> .)

    marker                         shift and go to state 211
    empty                          shift and go to state 104

state 131

    (77) unary_expression_not_plus_minus -> NOT unary_expression .

    TIMES           reduce using rule 77 (unary_expression_not_plus_minus -> NOT unary_expression .)
    DIVIDE          reduce using rule 77 (unary_expression_not_plus_minus -> NOT unary_expression .)
    REMAINDER       reduce using rule 77 (unary_expression_not_plus_minus -> NOT unary_expression .)
    PLUS            reduce using rule 77 (unary_expression_not_plus_minus -> NOT unary_expression .)
    MINUS           reduce using rule 77 (unary_expression_not_plus_minus -> NOT unary_expression .)
    LSHIFT          reduce using rule 77 (unary_expression_not_plus_minus -> NOT unary_expression .)
    RSHIFT          reduce using rule 77 (unary_expression_not_plus_minus -> NOT unary_expression .)
    GREATER         reduce using rule 77 (unary_expression_not_plus_minus -> NOT unary_expression .)
    LESS            reduce using rule 77 (unary_expression_not_plus_minus -> NOT unary_expression .)
    GEQ             reduce using rule 77 (unary_expression_not_plus_minus -> NOT unary_expression .)
    LEQ             reduce using rule 77 (unary_expression_not_plus_minus -> NOT unary_expression .)
    EQUAL           reduce using rule 77 (unary_expression_not_plus_minus -> NOT unary_expression .)
    NEQUAL          reduce using rule 77 (unary_expression_not_plus_minus -> NOT unary_expression .)
    AND_BITWISE     reduce using rule 77 (unary_expression_not_plus_minus -> NOT unary_expression .)
    XOR             reduce using rule 77 (unary_expression_not_plus_minus -> NOT unary_expression .)
    OR_BITWISE      reduce using rule 77 (unary_expression_not_plus_minus -> NOT unary_expression .)
    AND             reduce using rule 77 (unary_expression_not_plus_minus -> NOT unary_expression .)
    OR              reduce using rule 77 (unary_expression_not_plus_minus -> NOT unary_expression .)
    KEYWORD_MATCH   reduce using rule 77 (unary_expression_not_plus_minus -> NOT unary_expression .)
    TERMINATOR      reduce using rule 77 (unary_expression_not_plus_minus -> NOT unary_expression .)
    RPAREN          reduce using rule 77 (unary_expression_not_plus_minus -> NOT unary_expression .)
    RBRAC           reduce using rule 77 (unary_expression_not_plus_minus -> NOT unary_expression .)
    COMMA           reduce using rule 77 (unary_expression_not_plus_minus -> NOT unary_expression .)
    FUNTYPE         reduce using rule 77 (unary_expression_not_plus_minus -> NOT unary_expression .)
    KEYWORD_UNTIL   reduce using rule 77 (unary_expression_not_plus_minus -> NOT unary_expression .)
    KEYWORD_TO      reduce using rule 77 (unary_expression_not_plus_minus -> NOT unary_expression .)
    KEYWORD_BY      reduce using rule 77 (unary_expression_not_plus_minus -> NOT unary_expression .)


state 132

    (165) switch_statement -> expression KEYWORD_MATCH . switch_block marker
    (166) switch_block -> . BLOCKBEGIN BLOCKEND
    (167) switch_block -> . BLOCKBEGIN switch_block_statements BLOCKEND

    BLOCKBEGIN      shift and go to state 212

    switch_block                   shift and go to state 213

state 133

    (143) normal_statement -> block marker .

    KEYWORD_IF      reduce using rule 143 (normal_statement -> block marker .)
    KEYWORD_WHILE   reduce using rule 143 (normal_statement -> block marker .)
    KEYWORD_DO      reduce using rule 143 (normal_statement -> block marker .)
    KEYWORD_FOR     reduce using rule 143 (normal_statement -> block marker .)
    KEYWORD_CLASS   reduce using rule 143 (normal_statement -> block marker .)
    KEYWORD_OBJECT  reduce using rule 143 (normal_statement -> block marker .)
    KEYWORD_VAR     reduce using rule 143 (normal_statement -> block marker .)
    KEYWORD_VAL     reduce using rule 143 (normal_statement -> block marker .)
    TERMINATOR      reduce using rule 143 (normal_statement -> block marker .)
    KEYWORD_RETURN  reduce using rule 143 (normal_statement -> block marker .)
    KEYWORD_DEF     reduce using rule 143 (normal_statement -> block marker .)
    BLOCKBEGIN      reduce using rule 143 (normal_statement -> block marker .)
    IDENTIFIER      reduce using rule 143 (normal_statement -> block marker .)
    PLUS            reduce using rule 143 (normal_statement -> block marker .)
    MINUS           reduce using rule 143 (normal_statement -> block marker .)
    TILDA           reduce using rule 143 (normal_statement -> block marker .)
    NOT             reduce using rule 143 (normal_statement -> block marker .)
    LPAREN          reduce using rule 143 (normal_statement -> block marker .)
    DOUBLE_NUMBER   reduce using rule 143 (normal_statement -> block marker .)
    INT_NUMBER      reduce using rule 143 (normal_statement -> block marker .)
    CHAR            reduce using rule 143 (normal_statement -> block marker .)
    STRING          reduce using rule 143 (normal_statement -> block marker .)
    KEYWORD_NULL    reduce using rule 143 (normal_statement -> block marker .)
    BOOL_CONSTT     reduce using rule 143 (normal_statement -> block marker .)
    BOOL_CONSTF     reduce using rule 143 (normal_statement -> block marker .)
    BLOCKEND        reduce using rule 143 (normal_statement -> block marker .)
    KEYWORD_ELSE    reduce using rule 143 (normal_statement -> block marker .)


state 134

    (139) statement -> if_then_else_statement marker .

    KEYWORD_IF      reduce using rule 139 (statement -> if_then_else_statement marker .)
    KEYWORD_WHILE   reduce using rule 139 (statement -> if_then_else_statement marker .)
    KEYWORD_DO      reduce using rule 139 (statement -> if_then_else_statement marker .)
    KEYWORD_FOR     reduce using rule 139 (statement -> if_then_else_statement marker .)
    KEYWORD_CLASS   reduce using rule 139 (statement -> if_then_else_statement marker .)
    KEYWORD_OBJECT  reduce using rule 139 (statement -> if_then_else_statement marker .)
    KEYWORD_VAR     reduce using rule 139 (statement -> if_then_else_statement marker .)
    KEYWORD_VAL     reduce using rule 139 (statement -> if_then_else_statement marker .)
    TERMINATOR      reduce using rule 139 (statement -> if_then_else_statement marker .)
    KEYWORD_RETURN  reduce using rule 139 (statement -> if_then_else_statement marker .)
    KEYWORD_DEF     reduce using rule 139 (statement -> if_then_else_statement marker .)
    BLOCKBEGIN      reduce using rule 139 (statement -> if_then_else_statement marker .)
    IDENTIFIER      reduce using rule 139 (statement -> if_then_else_statement marker .)
    PLUS            reduce using rule 139 (statement -> if_then_else_statement marker .)
    MINUS           reduce using rule 139 (statement -> if_then_else_statement marker .)
    TILDA           reduce using rule 139 (statement -> if_then_else_statement marker .)
    NOT             reduce using rule 139 (statement -> if_then_else_statement marker .)
    LPAREN          reduce using rule 139 (statement -> if_then_else_statement marker .)
    DOUBLE_NUMBER   reduce using rule 139 (statement -> if_then_else_statement marker .)
    INT_NUMBER      reduce using rule 139 (statement -> if_then_else_statement marker .)
    CHAR            reduce using rule 139 (statement -> if_then_else_statement marker .)
    STRING          reduce using rule 139 (statement -> if_then_else_statement marker .)
    KEYWORD_NULL    reduce using rule 139 (statement -> if_then_else_statement marker .)
    BOOL_CONSTT     reduce using rule 139 (statement -> if_then_else_statement marker .)
    BOOL_CONSTF     reduce using rule 139 (statement -> if_then_else_statement marker .)
    BLOCKEND        reduce using rule 139 (statement -> if_then_else_statement marker .)


state 135

    (50) exclusive_or_expression -> exclusive_or_expression XOR . and_expression
    (51) and_expression -> . equality_expression
    (52) and_expression -> . and_expression AND_BITWISE equality_expression
    (53) equality_expression -> . relational_expression
    (54) equality_expression -> . equality_expression EQUAL relational_expression
    (55) equality_expression -> . equality_expression NEQUAL relational_expression
    (56) relational_expression -> . shift_expression
    (57) relational_expression -> . relational_expression GREATER shift_expression
    (58) relational_expression -> . relational_expression LESS shift_expression
    (59) relational_expression -> . relational_expression GEQ shift_expression
    (60) relational_expression -> . relational_expression LEQ shift_expression
    (61) shift_expression -> . additive_expression
    (62) shift_expression -> . shift_expression LSHIFT additive_expression
    (63) shift_expression -> . shift_expression RSHIFT additive_expression
    (64) additive_expression -> . multiplicative_expression
    (65) additive_expression -> . additive_expression PLUS multiplicative_expression
    (66) additive_expression -> . additive_expression MINUS multiplicative_expression
    (67) multiplicative_expression -> . unary_expression
    (68) multiplicative_expression -> . multiplicative_expression TIMES unary_expression
    (69) multiplicative_expression -> . multiplicative_expression DIVIDE unary_expression
    (70) multiplicative_expression -> . multiplicative_expression REMAINDER unary_expression
    (71) unary_expression -> . PLUS unary_expression
    (72) unary_expression -> . MINUS unary_expression
    (73) unary_expression -> . unary_expression_not_plus_minus
    (74) unary_expression_not_plus_minus -> . base_variable_set
    (75) unary_expression_not_plus_minus -> . TILDA unary_expression
    (76) unary_expression_not_plus_minus -> . cast_expression
    (77) unary_expression_not_plus_minus -> . NOT unary_expression
    (78) base_variable_set -> . variable_literal
    (79) base_variable_set -> . LPAREN expression RPAREN
    (82) cast_expression -> . LPAREN primitive_type RPAREN unary_expression
    (80) variable_literal -> . valid_variable
    (81) variable_literal -> . primary
    (26) valid_variable -> . name
    (27) valid_variable -> . array_access
    (83) primary -> . literal
    (84) primary -> . method_invocation
    (130) name -> . simple_name
    (131) name -> . qualified_name
    (28) array_access -> . name dimension
    (85) literal -> . int_float
    (86) literal -> . c_literal
    (94) method_invocation -> . name LPAREN argument_list_opt RPAREN
    (132) simple_name -> . IDENTIFIER
    (133) qualified_name -> . name INST simple_name
    (92) int_float -> . DOUBLE_NUMBER
    (93) int_float -> . INT_NUMBER
    (87) c_literal -> . CHAR
    (88) c_literal -> . STRING
    (89) c_literal -> . KEYWORD_NULL
    (90) c_literal -> . BOOL_CONSTT
    (91) c_literal -> . BOOL_CONSTF

    PLUS            shift and go to state 31
    MINUS           shift and go to state 24
    TILDA           shift and go to state 68
    NOT             shift and go to state 53
    LPAREN          shift and go to state 91
    IDENTIFIER      shift and go to state 9
    DOUBLE_NUMBER   shift and go to state 28
    INT_NUMBER      shift and go to state 39
    CHAR            shift and go to state 59
    STRING          shift and go to state 72
    KEYWORD_NULL    shift and go to state 61
    BOOL_CONSTT     shift and go to state 30
    BOOL_CONSTF     shift and go to state 25

    unary_expression               shift and go to state 40
    primary                        shift and go to state 58
    unary_expression_not_plus_minus shift and go to state 41
    array_access                   shift and go to state 23
    and_expression                 shift and go to state 214
    simple_name                    shift and go to state 63
    c_literal                      shift and go to state 90
    base_variable_set              shift and go to state 85
    valid_variable                 shift and go to state 106
    literal                        shift and go to state 67
    additive_expression            shift and go to state 62
    method_invocation              shift and go to state 107
    relational_expression          shift and go to state 69
    qualified_name                 shift and go to state 75
    multiplicative_expression      shift and go to state 46
    cast_expression                shift and go to state 77
    shift_expression               shift and go to state 50
    equality_expression            shift and go to state 79
    int_float                      shift and go to state 35
    variable_literal               shift and go to state 51
    name                           shift and go to state 108

state 136

    (138) statement -> if_then_statement marker .

    KEYWORD_IF      reduce using rule 138 (statement -> if_then_statement marker .)
    KEYWORD_WHILE   reduce using rule 138 (statement -> if_then_statement marker .)
    KEYWORD_DO      reduce using rule 138 (statement -> if_then_statement marker .)
    KEYWORD_FOR     reduce using rule 138 (statement -> if_then_statement marker .)
    KEYWORD_CLASS   reduce using rule 138 (statement -> if_then_statement marker .)
    KEYWORD_OBJECT  reduce using rule 138 (statement -> if_then_statement marker .)
    KEYWORD_VAR     reduce using rule 138 (statement -> if_then_statement marker .)
    KEYWORD_VAL     reduce using rule 138 (statement -> if_then_statement marker .)
    TERMINATOR      reduce using rule 138 (statement -> if_then_statement marker .)
    KEYWORD_RETURN  reduce using rule 138 (statement -> if_then_statement marker .)
    KEYWORD_DEF     reduce using rule 138 (statement -> if_then_statement marker .)
    BLOCKBEGIN      reduce using rule 138 (statement -> if_then_statement marker .)
    IDENTIFIER      reduce using rule 138 (statement -> if_then_statement marker .)
    PLUS            reduce using rule 138 (statement -> if_then_statement marker .)
    MINUS           reduce using rule 138 (statement -> if_then_statement marker .)
    TILDA           reduce using rule 138 (statement -> if_then_statement marker .)
    NOT             reduce using rule 138 (statement -> if_then_statement marker .)
    LPAREN          reduce using rule 138 (statement -> if_then_statement marker .)
    DOUBLE_NUMBER   reduce using rule 138 (statement -> if_then_statement marker .)
    INT_NUMBER      reduce using rule 138 (statement -> if_then_statement marker .)
    CHAR            reduce using rule 138 (statement -> if_then_statement marker .)
    STRING          reduce using rule 138 (statement -> if_then_statement marker .)
    KEYWORD_NULL    reduce using rule 138 (statement -> if_then_statement marker .)
    BOOL_CONSTT     reduce using rule 138 (statement -> if_then_statement marker .)
    BOOL_CONSTF     reduce using rule 138 (statement -> if_then_statement marker .)
    BLOCKEND        reduce using rule 138 (statement -> if_then_statement marker .)


state 137

    (65) additive_expression -> additive_expression PLUS . multiplicative_expression
    (67) multiplicative_expression -> . unary_expression
    (68) multiplicative_expression -> . multiplicative_expression TIMES unary_expression
    (69) multiplicative_expression -> . multiplicative_expression DIVIDE unary_expression
    (70) multiplicative_expression -> . multiplicative_expression REMAINDER unary_expression
    (71) unary_expression -> . PLUS unary_expression
    (72) unary_expression -> . MINUS unary_expression
    (73) unary_expression -> . unary_expression_not_plus_minus
    (74) unary_expression_not_plus_minus -> . base_variable_set
    (75) unary_expression_not_plus_minus -> . TILDA unary_expression
    (76) unary_expression_not_plus_minus -> . cast_expression
    (77) unary_expression_not_plus_minus -> . NOT unary_expression
    (78) base_variable_set -> . variable_literal
    (79) base_variable_set -> . LPAREN expression RPAREN
    (82) cast_expression -> . LPAREN primitive_type RPAREN unary_expression
    (80) variable_literal -> . valid_variable
    (81) variable_literal -> . primary
    (26) valid_variable -> . name
    (27) valid_variable -> . array_access
    (83) primary -> . literal
    (84) primary -> . method_invocation
    (130) name -> . simple_name
    (131) name -> . qualified_name
    (28) array_access -> . name dimension
    (85) literal -> . int_float
    (86) literal -> . c_literal
    (94) method_invocation -> . name LPAREN argument_list_opt RPAREN
    (132) simple_name -> . IDENTIFIER
    (133) qualified_name -> . name INST simple_name
    (92) int_float -> . DOUBLE_NUMBER
    (93) int_float -> . INT_NUMBER
    (87) c_literal -> . CHAR
    (88) c_literal -> . STRING
    (89) c_literal -> . KEYWORD_NULL
    (90) c_literal -> . BOOL_CONSTT
    (91) c_literal -> . BOOL_CONSTF

    PLUS            shift and go to state 31
    MINUS           shift and go to state 24
    TILDA           shift and go to state 68
    NOT             shift and go to state 53
    LPAREN          shift and go to state 91
    IDENTIFIER      shift and go to state 9
    DOUBLE_NUMBER   shift and go to state 28
    INT_NUMBER      shift and go to state 39
    CHAR            shift and go to state 59
    STRING          shift and go to state 72
    KEYWORD_NULL    shift and go to state 61
    BOOL_CONSTT     shift and go to state 30
    BOOL_CONSTF     shift and go to state 25

    qualified_name                 shift and go to state 75
    int_float                      shift and go to state 35
    c_literal                      shift and go to state 90
    variable_literal               shift and go to state 51
    base_variable_set              shift and go to state 85
    unary_expression               shift and go to state 40
    valid_variable                 shift and go to state 106
    array_access                   shift and go to state 23
    multiplicative_expression      shift and go to state 215
    primary                        shift and go to state 58
    unary_expression_not_plus_minus shift and go to state 41
    literal                        shift and go to state 67
    method_invocation              shift and go to state 107
    cast_expression                shift and go to state 77
    simple_name                    shift and go to state 63
    name                           shift and go to state 108

state 138

    (66) additive_expression -> additive_expression MINUS . multiplicative_expression
    (67) multiplicative_expression -> . unary_expression
    (68) multiplicative_expression -> . multiplicative_expression TIMES unary_expression
    (69) multiplicative_expression -> . multiplicative_expression DIVIDE unary_expression
    (70) multiplicative_expression -> . multiplicative_expression REMAINDER unary_expression
    (71) unary_expression -> . PLUS unary_expression
    (72) unary_expression -> . MINUS unary_expression
    (73) unary_expression -> . unary_expression_not_plus_minus
    (74) unary_expression_not_plus_minus -> . base_variable_set
    (75) unary_expression_not_plus_minus -> . TILDA unary_expression
    (76) unary_expression_not_plus_minus -> . cast_expression
    (77) unary_expression_not_plus_minus -> . NOT unary_expression
    (78) base_variable_set -> . variable_literal
    (79) base_variable_set -> . LPAREN expression RPAREN
    (82) cast_expression -> . LPAREN primitive_type RPAREN unary_expression
    (80) variable_literal -> . valid_variable
    (81) variable_literal -> . primary
    (26) valid_variable -> . name
    (27) valid_variable -> . array_access
    (83) primary -> . literal
    (84) primary -> . method_invocation
    (130) name -> . simple_name
    (131) name -> . qualified_name
    (28) array_access -> . name dimension
    (85) literal -> . int_float
    (86) literal -> . c_literal
    (94) method_invocation -> . name LPAREN argument_list_opt RPAREN
    (132) simple_name -> . IDENTIFIER
    (133) qualified_name -> . name INST simple_name
    (92) int_float -> . DOUBLE_NUMBER
    (93) int_float -> . INT_NUMBER
    (87) c_literal -> . CHAR
    (88) c_literal -> . STRING
    (89) c_literal -> . KEYWORD_NULL
    (90) c_literal -> . BOOL_CONSTT
    (91) c_literal -> . BOOL_CONSTF

    PLUS            shift and go to state 31
    MINUS           shift and go to state 24
    TILDA           shift and go to state 68
    NOT             shift and go to state 53
    LPAREN          shift and go to state 91
    IDENTIFIER      shift and go to state 9
    DOUBLE_NUMBER   shift and go to state 28
    INT_NUMBER      shift and go to state 39
    CHAR            shift and go to state 59
    STRING          shift and go to state 72
    KEYWORD_NULL    shift and go to state 61
    BOOL_CONSTT     shift and go to state 30
    BOOL_CONSTF     shift and go to state 25

    qualified_name                 shift and go to state 75
    int_float                      shift and go to state 35
    c_literal                      shift and go to state 90
    variable_literal               shift and go to state 51
    base_variable_set              shift and go to state 85
    unary_expression               shift and go to state 40
    valid_variable                 shift and go to state 106
    array_access                   shift and go to state 23
    multiplicative_expression      shift and go to state 216
    primary                        shift and go to state 58
    unary_expression_not_plus_minus shift and go to state 41
    literal                        shift and go to state 67
    method_invocation              shift and go to state 107
    cast_expression                shift and go to state 77
    simple_name                    shift and go to state 63
    name                           shift and go to state 108

state 139

    (24) assignment_expression -> method_invocation .
    (84) primary -> method_invocation .

  ! reduce/reduce conflict for RPAREN resolved using rule 24 (assignment_expression -> method_invocation .)
  ! reduce/reduce conflict for COMMA resolved using rule 24 (assignment_expression -> method_invocation .)
  ! reduce/reduce conflict for TERMINATOR resolved using rule 24 (assignment_expression -> method_invocation .)
  ! reduce/reduce conflict for FUNTYPE resolved using rule 24 (assignment_expression -> method_invocation .)
  ! reduce/reduce conflict for RBRAC resolved using rule 24 (assignment_expression -> method_invocation .)
  ! reduce/reduce conflict for KEYWORD_MATCH resolved using rule 24 (assignment_expression -> method_invocation .)
  ! reduce/reduce conflict for KEYWORD_UNTIL resolved using rule 24 (assignment_expression -> method_invocation .)
  ! reduce/reduce conflict for KEYWORD_TO resolved using rule 24 (assignment_expression -> method_invocation .)
  ! reduce/reduce conflict for KEYWORD_BY resolved using rule 24 (assignment_expression -> method_invocation .)
    TERMINATOR      reduce using rule 24 (assignment_expression -> method_invocation .)
    RBRAC           reduce using rule 24 (assignment_expression -> method_invocation .)
    RPAREN          reduce using rule 24 (assignment_expression -> method_invocation .)
    KEYWORD_MATCH   reduce using rule 24 (assignment_expression -> method_invocation .)
    COMMA           reduce using rule 24 (assignment_expression -> method_invocation .)
    FUNTYPE         reduce using rule 24 (assignment_expression -> method_invocation .)
    KEYWORD_UNTIL   reduce using rule 24 (assignment_expression -> method_invocation .)
    KEYWORD_TO      reduce using rule 24 (assignment_expression -> method_invocation .)
    KEYWORD_BY      reduce using rule 24 (assignment_expression -> method_invocation .)
    TIMES           reduce using rule 84 (primary -> method_invocation .)
    DIVIDE          reduce using rule 84 (primary -> method_invocation .)
    REMAINDER       reduce using rule 84 (primary -> method_invocation .)
    PLUS            reduce using rule 84 (primary -> method_invocation .)
    MINUS           reduce using rule 84 (primary -> method_invocation .)
    LSHIFT          reduce using rule 84 (primary -> method_invocation .)
    RSHIFT          reduce using rule 84 (primary -> method_invocation .)
    GREATER         reduce using rule 84 (primary -> method_invocation .)
    LESS            reduce using rule 84 (primary -> method_invocation .)
    GEQ             reduce using rule 84 (primary -> method_invocation .)
    LEQ             reduce using rule 84 (primary -> method_invocation .)
    EQUAL           reduce using rule 84 (primary -> method_invocation .)
    NEQUAL          reduce using rule 84 (primary -> method_invocation .)
    AND_BITWISE     reduce using rule 84 (primary -> method_invocation .)
    XOR             reduce using rule 84 (primary -> method_invocation .)
    OR_BITWISE      reduce using rule 84 (primary -> method_invocation .)
    AND             reduce using rule 84 (primary -> method_invocation .)
    OR              reduce using rule 84 (primary -> method_invocation .)

  ! RPAREN          [ reduce using rule 84 (primary -> method_invocation .) ]
  ! COMMA           [ reduce using rule 84 (primary -> method_invocation .) ]
  ! TERMINATOR      [ reduce using rule 84 (primary -> method_invocation .) ]
  ! FUNTYPE         [ reduce using rule 84 (primary -> method_invocation .) ]
  ! RBRAC           [ reduce using rule 84 (primary -> method_invocation .) ]
  ! KEYWORD_MATCH   [ reduce using rule 84 (primary -> method_invocation .) ]
  ! KEYWORD_UNTIL   [ reduce using rule 84 (primary -> method_invocation .) ]
  ! KEYWORD_TO      [ reduce using rule 84 (primary -> method_invocation .) ]
  ! KEYWORD_BY      [ reduce using rule 84 (primary -> method_invocation .) ]


state 140

    (21) expression_optional -> empty .

    TERMINATOR      reduce using rule 21 (expression_optional -> empty .)


state 141

    (173) return_statement -> KEYWORD_RETURN expression_optional . TERMINATOR

    TERMINATOR      shift and go to state 217


state 142

    (22) assignment_expression -> assignment .

    TERMINATOR      reduce using rule 22 (assignment_expression -> assignment .)
    RBRAC           reduce using rule 22 (assignment_expression -> assignment .)
    RPAREN          reduce using rule 22 (assignment_expression -> assignment .)
    KEYWORD_MATCH   reduce using rule 22 (assignment_expression -> assignment .)
    COMMA           reduce using rule 22 (assignment_expression -> assignment .)
    FUNTYPE         reduce using rule 22 (assignment_expression -> assignment .)
    KEYWORD_UNTIL   reduce using rule 22 (assignment_expression -> assignment .)
    KEYWORD_TO      reduce using rule 22 (assignment_expression -> assignment .)
    KEYWORD_BY      reduce using rule 22 (assignment_expression -> assignment .)


state 143

    (20) expression_optional -> expression .

    TERMINATOR      reduce using rule 20 (expression_optional -> expression .)


state 144

    (75) unary_expression_not_plus_minus -> TILDA unary_expression .

    TIMES           reduce using rule 75 (unary_expression_not_plus_minus -> TILDA unary_expression .)
    DIVIDE          reduce using rule 75 (unary_expression_not_plus_minus -> TILDA unary_expression .)
    REMAINDER       reduce using rule 75 (unary_expression_not_plus_minus -> TILDA unary_expression .)
    PLUS            reduce using rule 75 (unary_expression_not_plus_minus -> TILDA unary_expression .)
    MINUS           reduce using rule 75 (unary_expression_not_plus_minus -> TILDA unary_expression .)
    LSHIFT          reduce using rule 75 (unary_expression_not_plus_minus -> TILDA unary_expression .)
    RSHIFT          reduce using rule 75 (unary_expression_not_plus_minus -> TILDA unary_expression .)
    GREATER         reduce using rule 75 (unary_expression_not_plus_minus -> TILDA unary_expression .)
    LESS            reduce using rule 75 (unary_expression_not_plus_minus -> TILDA unary_expression .)
    GEQ             reduce using rule 75 (unary_expression_not_plus_minus -> TILDA unary_expression .)
    LEQ             reduce using rule 75 (unary_expression_not_plus_minus -> TILDA unary_expression .)
    EQUAL           reduce using rule 75 (unary_expression_not_plus_minus -> TILDA unary_expression .)
    NEQUAL          reduce using rule 75 (unary_expression_not_plus_minus -> TILDA unary_expression .)
    AND_BITWISE     reduce using rule 75 (unary_expression_not_plus_minus -> TILDA unary_expression .)
    XOR             reduce using rule 75 (unary_expression_not_plus_minus -> TILDA unary_expression .)
    OR_BITWISE      reduce using rule 75 (unary_expression_not_plus_minus -> TILDA unary_expression .)
    AND             reduce using rule 75 (unary_expression_not_plus_minus -> TILDA unary_expression .)
    OR              reduce using rule 75 (unary_expression_not_plus_minus -> TILDA unary_expression .)
    KEYWORD_MATCH   reduce using rule 75 (unary_expression_not_plus_minus -> TILDA unary_expression .)
    TERMINATOR      reduce using rule 75 (unary_expression_not_plus_minus -> TILDA unary_expression .)
    RPAREN          reduce using rule 75 (unary_expression_not_plus_minus -> TILDA unary_expression .)
    RBRAC           reduce using rule 75 (unary_expression_not_plus_minus -> TILDA unary_expression .)
    COMMA           reduce using rule 75 (unary_expression_not_plus_minus -> TILDA unary_expression .)
    FUNTYPE         reduce using rule 75 (unary_expression_not_plus_minus -> TILDA unary_expression .)
    KEYWORD_UNTIL   reduce using rule 75 (unary_expression_not_plus_minus -> TILDA unary_expression .)
    KEYWORD_TO      reduce using rule 75 (unary_expression_not_plus_minus -> TILDA unary_expression .)
    KEYWORD_BY      reduce using rule 75 (unary_expression_not_plus_minus -> TILDA unary_expression .)


state 145

    (59) relational_expression -> relational_expression GEQ . shift_expression
    (61) shift_expression -> . additive_expression
    (62) shift_expression -> . shift_expression LSHIFT additive_expression
    (63) shift_expression -> . shift_expression RSHIFT additive_expression
    (64) additive_expression -> . multiplicative_expression
    (65) additive_expression -> . additive_expression PLUS multiplicative_expression
    (66) additive_expression -> . additive_expression MINUS multiplicative_expression
    (67) multiplicative_expression -> . unary_expression
    (68) multiplicative_expression -> . multiplicative_expression TIMES unary_expression
    (69) multiplicative_expression -> . multiplicative_expression DIVIDE unary_expression
    (70) multiplicative_expression -> . multiplicative_expression REMAINDER unary_expression
    (71) unary_expression -> . PLUS unary_expression
    (72) unary_expression -> . MINUS unary_expression
    (73) unary_expression -> . unary_expression_not_plus_minus
    (74) unary_expression_not_plus_minus -> . base_variable_set
    (75) unary_expression_not_plus_minus -> . TILDA unary_expression
    (76) unary_expression_not_plus_minus -> . cast_expression
    (77) unary_expression_not_plus_minus -> . NOT unary_expression
    (78) base_variable_set -> . variable_literal
    (79) base_variable_set -> . LPAREN expression RPAREN
    (82) cast_expression -> . LPAREN primitive_type RPAREN unary_expression
    (80) variable_literal -> . valid_variable
    (81) variable_literal -> . primary
    (26) valid_variable -> . name
    (27) valid_variable -> . array_access
    (83) primary -> . literal
    (84) primary -> . method_invocation
    (130) name -> . simple_name
    (131) name -> . qualified_name
    (28) array_access -> . name dimension
    (85) literal -> . int_float
    (86) literal -> . c_literal
    (94) method_invocation -> . name LPAREN argument_list_opt RPAREN
    (132) simple_name -> . IDENTIFIER
    (133) qualified_name -> . name INST simple_name
    (92) int_float -> . DOUBLE_NUMBER
    (93) int_float -> . INT_NUMBER
    (87) c_literal -> . CHAR
    (88) c_literal -> . STRING
    (89) c_literal -> . KEYWORD_NULL
    (90) c_literal -> . BOOL_CONSTT
    (91) c_literal -> . BOOL_CONSTF

    PLUS            shift and go to state 31
    MINUS           shift and go to state 24
    TILDA           shift and go to state 68
    NOT             shift and go to state 53
    LPAREN          shift and go to state 91
    IDENTIFIER      shift and go to state 9
    DOUBLE_NUMBER   shift and go to state 28
    INT_NUMBER      shift and go to state 39
    CHAR            shift and go to state 59
    STRING          shift and go to state 72
    KEYWORD_NULL    shift and go to state 61
    BOOL_CONSTT     shift and go to state 30
    BOOL_CONSTF     shift and go to state 25

    unary_expression               shift and go to state 40
    primary                        shift and go to state 58
    unary_expression_not_plus_minus shift and go to state 41
    array_access                   shift and go to state 23
    additive_expression            shift and go to state 62
    simple_name                    shift and go to state 63
    c_literal                      shift and go to state 90
    base_variable_set              shift and go to state 85
    valid_variable                 shift and go to state 106
    literal                        shift and go to state 67
    method_invocation              shift and go to state 107
    qualified_name                 shift and go to state 75
    multiplicative_expression      shift and go to state 46
    cast_expression                shift and go to state 77
    shift_expression               shift and go to state 218
    int_float                      shift and go to state 35
    variable_literal               shift and go to state 51
    name                           shift and go to state 108

state 146

    (57) relational_expression -> relational_expression GREATER . shift_expression
    (61) shift_expression -> . additive_expression
    (62) shift_expression -> . shift_expression LSHIFT additive_expression
    (63) shift_expression -> . shift_expression RSHIFT additive_expression
    (64) additive_expression -> . multiplicative_expression
    (65) additive_expression -> . additive_expression PLUS multiplicative_expression
    (66) additive_expression -> . additive_expression MINUS multiplicative_expression
    (67) multiplicative_expression -> . unary_expression
    (68) multiplicative_expression -> . multiplicative_expression TIMES unary_expression
    (69) multiplicative_expression -> . multiplicative_expression DIVIDE unary_expression
    (70) multiplicative_expression -> . multiplicative_expression REMAINDER unary_expression
    (71) unary_expression -> . PLUS unary_expression
    (72) unary_expression -> . MINUS unary_expression
    (73) unary_expression -> . unary_expression_not_plus_minus
    (74) unary_expression_not_plus_minus -> . base_variable_set
    (75) unary_expression_not_plus_minus -> . TILDA unary_expression
    (76) unary_expression_not_plus_minus -> . cast_expression
    (77) unary_expression_not_plus_minus -> . NOT unary_expression
    (78) base_variable_set -> . variable_literal
    (79) base_variable_set -> . LPAREN expression RPAREN
    (82) cast_expression -> . LPAREN primitive_type RPAREN unary_expression
    (80) variable_literal -> . valid_variable
    (81) variable_literal -> . primary
    (26) valid_variable -> . name
    (27) valid_variable -> . array_access
    (83) primary -> . literal
    (84) primary -> . method_invocation
    (130) name -> . simple_name
    (131) name -> . qualified_name
    (28) array_access -> . name dimension
    (85) literal -> . int_float
    (86) literal -> . c_literal
    (94) method_invocation -> . name LPAREN argument_list_opt RPAREN
    (132) simple_name -> . IDENTIFIER
    (133) qualified_name -> . name INST simple_name
    (92) int_float -> . DOUBLE_NUMBER
    (93) int_float -> . INT_NUMBER
    (87) c_literal -> . CHAR
    (88) c_literal -> . STRING
    (89) c_literal -> . KEYWORD_NULL
    (90) c_literal -> . BOOL_CONSTT
    (91) c_literal -> . BOOL_CONSTF

    PLUS            shift and go to state 31
    MINUS           shift and go to state 24
    TILDA           shift and go to state 68
    NOT             shift and go to state 53
    LPAREN          shift and go to state 91
    IDENTIFIER      shift and go to state 9
    DOUBLE_NUMBER   shift and go to state 28
    INT_NUMBER      shift and go to state 39
    CHAR            shift and go to state 59
    STRING          shift and go to state 72
    KEYWORD_NULL    shift and go to state 61
    BOOL_CONSTT     shift and go to state 30
    BOOL_CONSTF     shift and go to state 25

    unary_expression               shift and go to state 40
    primary                        shift and go to state 58
    unary_expression_not_plus_minus shift and go to state 41
    array_access                   shift and go to state 23
    additive_expression            shift and go to state 62
    simple_name                    shift and go to state 63
    c_literal                      shift and go to state 90
    base_variable_set              shift and go to state 85
    valid_variable                 shift and go to state 106
    literal                        shift and go to state 67
    method_invocation              shift and go to state 107
    qualified_name                 shift and go to state 75
    multiplicative_expression      shift and go to state 46
    cast_expression                shift and go to state 77
    shift_expression               shift and go to state 219
    int_float                      shift and go to state 35
    variable_literal               shift and go to state 51
    name                           shift and go to state 108

state 147

    (58) relational_expression -> relational_expression LESS . shift_expression
    (61) shift_expression -> . additive_expression
    (62) shift_expression -> . shift_expression LSHIFT additive_expression
    (63) shift_expression -> . shift_expression RSHIFT additive_expression
    (64) additive_expression -> . multiplicative_expression
    (65) additive_expression -> . additive_expression PLUS multiplicative_expression
    (66) additive_expression -> . additive_expression MINUS multiplicative_expression
    (67) multiplicative_expression -> . unary_expression
    (68) multiplicative_expression -> . multiplicative_expression TIMES unary_expression
    (69) multiplicative_expression -> . multiplicative_expression DIVIDE unary_expression
    (70) multiplicative_expression -> . multiplicative_expression REMAINDER unary_expression
    (71) unary_expression -> . PLUS unary_expression
    (72) unary_expression -> . MINUS unary_expression
    (73) unary_expression -> . unary_expression_not_plus_minus
    (74) unary_expression_not_plus_minus -> . base_variable_set
    (75) unary_expression_not_plus_minus -> . TILDA unary_expression
    (76) unary_expression_not_plus_minus -> . cast_expression
    (77) unary_expression_not_plus_minus -> . NOT unary_expression
    (78) base_variable_set -> . variable_literal
    (79) base_variable_set -> . LPAREN expression RPAREN
    (82) cast_expression -> . LPAREN primitive_type RPAREN unary_expression
    (80) variable_literal -> . valid_variable
    (81) variable_literal -> . primary
    (26) valid_variable -> . name
    (27) valid_variable -> . array_access
    (83) primary -> . literal
    (84) primary -> . method_invocation
    (130) name -> . simple_name
    (131) name -> . qualified_name
    (28) array_access -> . name dimension
    (85) literal -> . int_float
    (86) literal -> . c_literal
    (94) method_invocation -> . name LPAREN argument_list_opt RPAREN
    (132) simple_name -> . IDENTIFIER
    (133) qualified_name -> . name INST simple_name
    (92) int_float -> . DOUBLE_NUMBER
    (93) int_float -> . INT_NUMBER
    (87) c_literal -> . CHAR
    (88) c_literal -> . STRING
    (89) c_literal -> . KEYWORD_NULL
    (90) c_literal -> . BOOL_CONSTT
    (91) c_literal -> . BOOL_CONSTF

    PLUS            shift and go to state 31
    MINUS           shift and go to state 24
    TILDA           shift and go to state 68
    NOT             shift and go to state 53
    LPAREN          shift and go to state 91
    IDENTIFIER      shift and go to state 9
    DOUBLE_NUMBER   shift and go to state 28
    INT_NUMBER      shift and go to state 39
    CHAR            shift and go to state 59
    STRING          shift and go to state 72
    KEYWORD_NULL    shift and go to state 61
    BOOL_CONSTT     shift and go to state 30
    BOOL_CONSTF     shift and go to state 25

    unary_expression               shift and go to state 40
    primary                        shift and go to state 58
    unary_expression_not_plus_minus shift and go to state 41
    array_access                   shift and go to state 23
    additive_expression            shift and go to state 62
    simple_name                    shift and go to state 63
    c_literal                      shift and go to state 90
    base_variable_set              shift and go to state 85
    valid_variable                 shift and go to state 106
    literal                        shift and go to state 67
    method_invocation              shift and go to state 107
    qualified_name                 shift and go to state 75
    multiplicative_expression      shift and go to state 46
    cast_expression                shift and go to state 77
    shift_expression               shift and go to state 220
    int_float                      shift and go to state 35
    variable_literal               shift and go to state 51
    name                           shift and go to state 108

state 148

    (60) relational_expression -> relational_expression LEQ . shift_expression
    (61) shift_expression -> . additive_expression
    (62) shift_expression -> . shift_expression LSHIFT additive_expression
    (63) shift_expression -> . shift_expression RSHIFT additive_expression
    (64) additive_expression -> . multiplicative_expression
    (65) additive_expression -> . additive_expression PLUS multiplicative_expression
    (66) additive_expression -> . additive_expression MINUS multiplicative_expression
    (67) multiplicative_expression -> . unary_expression
    (68) multiplicative_expression -> . multiplicative_expression TIMES unary_expression
    (69) multiplicative_expression -> . multiplicative_expression DIVIDE unary_expression
    (70) multiplicative_expression -> . multiplicative_expression REMAINDER unary_expression
    (71) unary_expression -> . PLUS unary_expression
    (72) unary_expression -> . MINUS unary_expression
    (73) unary_expression -> . unary_expression_not_plus_minus
    (74) unary_expression_not_plus_minus -> . base_variable_set
    (75) unary_expression_not_plus_minus -> . TILDA unary_expression
    (76) unary_expression_not_plus_minus -> . cast_expression
    (77) unary_expression_not_plus_minus -> . NOT unary_expression
    (78) base_variable_set -> . variable_literal
    (79) base_variable_set -> . LPAREN expression RPAREN
    (82) cast_expression -> . LPAREN primitive_type RPAREN unary_expression
    (80) variable_literal -> . valid_variable
    (81) variable_literal -> . primary
    (26) valid_variable -> . name
    (27) valid_variable -> . array_access
    (83) primary -> . literal
    (84) primary -> . method_invocation
    (130) name -> . simple_name
    (131) name -> . qualified_name
    (28) array_access -> . name dimension
    (85) literal -> . int_float
    (86) literal -> . c_literal
    (94) method_invocation -> . name LPAREN argument_list_opt RPAREN
    (132) simple_name -> . IDENTIFIER
    (133) qualified_name -> . name INST simple_name
    (92) int_float -> . DOUBLE_NUMBER
    (93) int_float -> . INT_NUMBER
    (87) c_literal -> . CHAR
    (88) c_literal -> . STRING
    (89) c_literal -> . KEYWORD_NULL
    (90) c_literal -> . BOOL_CONSTT
    (91) c_literal -> . BOOL_CONSTF

    PLUS            shift and go to state 31
    MINUS           shift and go to state 24
    TILDA           shift and go to state 68
    NOT             shift and go to state 53
    LPAREN          shift and go to state 91
    IDENTIFIER      shift and go to state 9
    DOUBLE_NUMBER   shift and go to state 28
    INT_NUMBER      shift and go to state 39
    CHAR            shift and go to state 59
    STRING          shift and go to state 72
    KEYWORD_NULL    shift and go to state 61
    BOOL_CONSTT     shift and go to state 30
    BOOL_CONSTF     shift and go to state 25

    unary_expression               shift and go to state 40
    primary                        shift and go to state 58
    unary_expression_not_plus_minus shift and go to state 41
    array_access                   shift and go to state 23
    additive_expression            shift and go to state 62
    simple_name                    shift and go to state 63
    c_literal                      shift and go to state 90
    base_variable_set              shift and go to state 85
    valid_variable                 shift and go to state 106
    literal                        shift and go to state 67
    method_invocation              shift and go to state 107
    qualified_name                 shift and go to state 75
    multiplicative_expression      shift and go to state 46
    cast_expression                shift and go to state 77
    shift_expression               shift and go to state 221
    int_float                      shift and go to state 35
    variable_literal               shift and go to state 51
    name                           shift and go to state 108

state 149

    (102) local_variable_declaration -> declaration_keyword variable_declaration_body .

    TERMINATOR      reduce using rule 102 (local_variable_declaration -> declaration_keyword variable_declaration_body .)


state 150

    (108) variable_declaration_body -> identifiers . COLON type ASOP variable_declaration_initializer
    (109) identifiers -> identifiers . COMMA IDENTIFIER

    COLON           shift and go to state 222
    COMMA           shift and go to state 223


state 151

    (110) identifiers -> IDENTIFIER .

    COLON           reduce using rule 110 (identifiers -> IDENTIFIER .)
    COMMA           reduce using rule 110 (identifiers -> IDENTIFIER .)


state 152

    (183) method_header_name -> KEYWORD_DEF IDENTIFIER .

    LPAREN          reduce using rule 183 (method_header_name -> KEYWORD_DEF IDENTIFIER .)


state 153

    (151) if_then_statement -> KEYWORD_IF LPAREN . expression RPAREN marker block
    (152) if_then_else_statement -> KEYWORD_IF LPAREN . expression RPAREN marker if_then_else_intermediate narker KEYWORD_ELSE marker block
    (19) expression -> . assignment_expression
    (22) assignment_expression -> . assignment
    (23) assignment_expression -> . conditional_or_expression
    (24) assignment_expression -> . method_invocation
    (25) assignment -> . valid_variable assignment_operator assignment_expression
    (43) conditional_or_expression -> . conditional_and_expression
    (44) conditional_or_expression -> . conditional_or_expression OR marker conditional_and_expression
    (94) method_invocation -> . name LPAREN argument_list_opt RPAREN
    (26) valid_variable -> . name
    (27) valid_variable -> . array_access
    (45) conditional_and_expression -> . inclusive_or_expression
    (46) conditional_and_expression -> . conditional_and_expression AND marker inclusive_or_expression
    (130) name -> . simple_name
    (131) name -> . qualified_name
    (28) array_access -> . name dimension
    (47) inclusive_or_expression -> . exclusive_or_expression
    (48) inclusive_or_expression -> . inclusive_or_expression OR_BITWISE exclusive_or_expression
    (132) simple_name -> . IDENTIFIER
    (133) qualified_name -> . name INST simple_name
    (49) exclusive_or_expression -> . and_expression
    (50) exclusive_or_expression -> . exclusive_or_expression XOR and_expression
    (51) and_expression -> . equality_expression
    (52) and_expression -> . and_expression AND_BITWISE equality_expression
    (53) equality_expression -> . relational_expression
    (54) equality_expression -> . equality_expression EQUAL relational_expression
    (55) equality_expression -> . equality_expression NEQUAL relational_expression
    (56) relational_expression -> . shift_expression
    (57) relational_expression -> . relational_expression GREATER shift_expression
    (58) relational_expression -> . relational_expression LESS shift_expression
    (59) relational_expression -> . relational_expression GEQ shift_expression
    (60) relational_expression -> . relational_expression LEQ shift_expression
    (61) shift_expression -> . additive_expression
    (62) shift_expression -> . shift_expression LSHIFT additive_expression
    (63) shift_expression -> . shift_expression RSHIFT additive_expression
    (64) additive_expression -> . multiplicative_expression
    (65) additive_expression -> . additive_expression PLUS multiplicative_expression
    (66) additive_expression -> . additive_expression MINUS multiplicative_expression
    (67) multiplicative_expression -> . unary_expression
    (68) multiplicative_expression -> . multiplicative_expression TIMES unary_expression
    (69) multiplicative_expression -> . multiplicative_expression DIVIDE unary_expression
    (70) multiplicative_expression -> . multiplicative_expression REMAINDER unary_expression
    (71) unary_expression -> . PLUS unary_expression
    (72) unary_expression -> . MINUS unary_expression
    (73) unary_expression -> . unary_expression_not_plus_minus
    (74) unary_expression_not_plus_minus -> . base_variable_set
    (75) unary_expression_not_plus_minus -> . TILDA unary_expression
    (76) unary_expression_not_plus_minus -> . cast_expression
    (77) unary_expression_not_plus_minus -> . NOT unary_expression
    (78) base_variable_set -> . variable_literal
    (79) base_variable_set -> . LPAREN expression RPAREN
    (82) cast_expression -> . LPAREN primitive_type RPAREN unary_expression
    (80) variable_literal -> . valid_variable
    (81) variable_literal -> . primary
    (83) primary -> . literal
    (84) primary -> . method_invocation
    (85) literal -> . int_float
    (86) literal -> . c_literal
    (92) int_float -> . DOUBLE_NUMBER
    (93) int_float -> . INT_NUMBER
    (87) c_literal -> . CHAR
    (88) c_literal -> . STRING
    (89) c_literal -> . KEYWORD_NULL
    (90) c_literal -> . BOOL_CONSTT
    (91) c_literal -> . BOOL_CONSTF

    IDENTIFIER      shift and go to state 9
    PLUS            shift and go to state 31
    MINUS           shift and go to state 24
    TILDA           shift and go to state 68
    NOT             shift and go to state 53
    LPAREN          shift and go to state 91
    DOUBLE_NUMBER   shift and go to state 28
    INT_NUMBER      shift and go to state 39
    CHAR            shift and go to state 59
    STRING          shift and go to state 72
    KEYWORD_NULL    shift and go to state 61
    BOOL_CONSTT     shift and go to state 30
    BOOL_CONSTF     shift and go to state 25

    unary_expression               shift and go to state 40
    exclusive_or_expression        shift and go to state 57
    primary                        shift and go to state 58
    unary_expression_not_plus_minus shift and go to state 41
    array_access                   shift and go to state 23
    and_expression                 shift and go to state 84
    simple_name                    shift and go to state 63
    c_literal                      shift and go to state 90
    base_variable_set              shift and go to state 85
    valid_variable                 shift and go to state 92
    inclusive_or_expression        shift and go to state 27
    literal                        shift and go to state 67
    relational_expression          shift and go to state 69
    method_invocation              shift and go to state 139
    conditional_or_expression      shift and go to state 43
    assignment_expression          shift and go to state 88
    qualified_name                 shift and go to state 75
    assignment                     shift and go to state 142
    multiplicative_expression      shift and go to state 46
    additive_expression            shift and go to state 62
    cast_expression                shift and go to state 77
    shift_expression               shift and go to state 50
    equality_expression            shift and go to state 79
    int_float                      shift and go to state 35
    variable_literal               shift and go to state 51
    name                           shift and go to state 38
    expression                     shift and go to state 224
    conditional_and_expression     shift and go to state 52

state 154

    (55) equality_expression -> equality_expression NEQUAL . relational_expression
    (56) relational_expression -> . shift_expression
    (57) relational_expression -> . relational_expression GREATER shift_expression
    (58) relational_expression -> . relational_expression LESS shift_expression
    (59) relational_expression -> . relational_expression GEQ shift_expression
    (60) relational_expression -> . relational_expression LEQ shift_expression
    (61) shift_expression -> . additive_expression
    (62) shift_expression -> . shift_expression LSHIFT additive_expression
    (63) shift_expression -> . shift_expression RSHIFT additive_expression
    (64) additive_expression -> . multiplicative_expression
    (65) additive_expression -> . additive_expression PLUS multiplicative_expression
    (66) additive_expression -> . additive_expression MINUS multiplicative_expression
    (67) multiplicative_expression -> . unary_expression
    (68) multiplicative_expression -> . multiplicative_expression TIMES unary_expression
    (69) multiplicative_expression -> . multiplicative_expression DIVIDE unary_expression
    (70) multiplicative_expression -> . multiplicative_expression REMAINDER unary_expression
    (71) unary_expression -> . PLUS unary_expression
    (72) unary_expression -> . MINUS unary_expression
    (73) unary_expression -> . unary_expression_not_plus_minus
    (74) unary_expression_not_plus_minus -> . base_variable_set
    (75) unary_expression_not_plus_minus -> . TILDA unary_expression
    (76) unary_expression_not_plus_minus -> . cast_expression
    (77) unary_expression_not_plus_minus -> . NOT unary_expression
    (78) base_variable_set -> . variable_literal
    (79) base_variable_set -> . LPAREN expression RPAREN
    (82) cast_expression -> . LPAREN primitive_type RPAREN unary_expression
    (80) variable_literal -> . valid_variable
    (81) variable_literal -> . primary
    (26) valid_variable -> . name
    (27) valid_variable -> . array_access
    (83) primary -> . literal
    (84) primary -> . method_invocation
    (130) name -> . simple_name
    (131) name -> . qualified_name
    (28) array_access -> . name dimension
    (85) literal -> . int_float
    (86) literal -> . c_literal
    (94) method_invocation -> . name LPAREN argument_list_opt RPAREN
    (132) simple_name -> . IDENTIFIER
    (133) qualified_name -> . name INST simple_name
    (92) int_float -> . DOUBLE_NUMBER
    (93) int_float -> . INT_NUMBER
    (87) c_literal -> . CHAR
    (88) c_literal -> . STRING
    (89) c_literal -> . KEYWORD_NULL
    (90) c_literal -> . BOOL_CONSTT
    (91) c_literal -> . BOOL_CONSTF

    PLUS            shift and go to state 31
    MINUS           shift and go to state 24
    TILDA           shift and go to state 68
    NOT             shift and go to state 53
    LPAREN          shift and go to state 91
    IDENTIFIER      shift and go to state 9
    DOUBLE_NUMBER   shift and go to state 28
    INT_NUMBER      shift and go to state 39
    CHAR            shift and go to state 59
    STRING          shift and go to state 72
    KEYWORD_NULL    shift and go to state 61
    BOOL_CONSTT     shift and go to state 30
    BOOL_CONSTF     shift and go to state 25

    unary_expression               shift and go to state 40
    primary                        shift and go to state 58
    unary_expression_not_plus_minus shift and go to state 41
    array_access                   shift and go to state 23
    additive_expression            shift and go to state 62
    simple_name                    shift and go to state 63
    c_literal                      shift and go to state 90
    base_variable_set              shift and go to state 85
    valid_variable                 shift and go to state 106
    literal                        shift and go to state 67
    relational_expression          shift and go to state 225
    method_invocation              shift and go to state 107
    qualified_name                 shift and go to state 75
    multiplicative_expression      shift and go to state 46
    cast_expression                shift and go to state 77
    shift_expression               shift and go to state 50
    int_float                      shift and go to state 35
    variable_literal               shift and go to state 51
    name                           shift and go to state 108

state 155

    (54) equality_expression -> equality_expression EQUAL . relational_expression
    (56) relational_expression -> . shift_expression
    (57) relational_expression -> . relational_expression GREATER shift_expression
    (58) relational_expression -> . relational_expression LESS shift_expression
    (59) relational_expression -> . relational_expression GEQ shift_expression
    (60) relational_expression -> . relational_expression LEQ shift_expression
    (61) shift_expression -> . additive_expression
    (62) shift_expression -> . shift_expression LSHIFT additive_expression
    (63) shift_expression -> . shift_expression RSHIFT additive_expression
    (64) additive_expression -> . multiplicative_expression
    (65) additive_expression -> . additive_expression PLUS multiplicative_expression
    (66) additive_expression -> . additive_expression MINUS multiplicative_expression
    (67) multiplicative_expression -> . unary_expression
    (68) multiplicative_expression -> . multiplicative_expression TIMES unary_expression
    (69) multiplicative_expression -> . multiplicative_expression DIVIDE unary_expression
    (70) multiplicative_expression -> . multiplicative_expression REMAINDER unary_expression
    (71) unary_expression -> . PLUS unary_expression
    (72) unary_expression -> . MINUS unary_expression
    (73) unary_expression -> . unary_expression_not_plus_minus
    (74) unary_expression_not_plus_minus -> . base_variable_set
    (75) unary_expression_not_plus_minus -> . TILDA unary_expression
    (76) unary_expression_not_plus_minus -> . cast_expression
    (77) unary_expression_not_plus_minus -> . NOT unary_expression
    (78) base_variable_set -> . variable_literal
    (79) base_variable_set -> . LPAREN expression RPAREN
    (82) cast_expression -> . LPAREN primitive_type RPAREN unary_expression
    (80) variable_literal -> . valid_variable
    (81) variable_literal -> . primary
    (26) valid_variable -> . name
    (27) valid_variable -> . array_access
    (83) primary -> . literal
    (84) primary -> . method_invocation
    (130) name -> . simple_name
    (131) name -> . qualified_name
    (28) array_access -> . name dimension
    (85) literal -> . int_float
    (86) literal -> . c_literal
    (94) method_invocation -> . name LPAREN argument_list_opt RPAREN
    (132) simple_name -> . IDENTIFIER
    (133) qualified_name -> . name INST simple_name
    (92) int_float -> . DOUBLE_NUMBER
    (93) int_float -> . INT_NUMBER
    (87) c_literal -> . CHAR
    (88) c_literal -> . STRING
    (89) c_literal -> . KEYWORD_NULL
    (90) c_literal -> . BOOL_CONSTT
    (91) c_literal -> . BOOL_CONSTF

    PLUS            shift and go to state 31
    MINUS           shift and go to state 24
    TILDA           shift and go to state 68
    NOT             shift and go to state 53
    LPAREN          shift and go to state 91
    IDENTIFIER      shift and go to state 9
    DOUBLE_NUMBER   shift and go to state 28
    INT_NUMBER      shift and go to state 39
    CHAR            shift and go to state 59
    STRING          shift and go to state 72
    KEYWORD_NULL    shift and go to state 61
    BOOL_CONSTT     shift and go to state 30
    BOOL_CONSTF     shift and go to state 25

    unary_expression               shift and go to state 40
    primary                        shift and go to state 58
    unary_expression_not_plus_minus shift and go to state 41
    array_access                   shift and go to state 23
    additive_expression            shift and go to state 62
    simple_name                    shift and go to state 63
    c_literal                      shift and go to state 90
    base_variable_set              shift and go to state 85
    valid_variable                 shift and go to state 106
    literal                        shift and go to state 67
    relational_expression          shift and go to state 226
    method_invocation              shift and go to state 107
    qualified_name                 shift and go to state 75
    multiplicative_expression      shift and go to state 46
    cast_expression                shift and go to state 77
    shift_expression               shift and go to state 50
    int_float                      shift and go to state 35
    variable_literal               shift and go to state 51
    name                           shift and go to state 108

state 156

    (184) method_body -> method_start_scope . block_statements_opt end_scope
    (10) block_statements_opt -> . block_statements
    (11) block_statements_opt -> . empty
    (12) block_statements -> . block_statement
    (13) block_statements -> . block_statements marker block_statement
    (200) empty -> .
    (14) block_statement -> . local_variable_declaration_statement
    (15) block_statement -> . statement
    (16) block_statement -> . class_declaration
    (17) block_statement -> . SingletonObject
    (18) block_statement -> . method_declaration
    (101) local_variable_declaration_statement -> . local_variable_declaration TERMINATOR
    (137) statement -> . normal_statement marker
    (138) statement -> . if_then_statement marker
    (139) statement -> . if_then_else_statement marker
    (140) statement -> . while_statement marker
    (141) statement -> . do_while_statement marker
    (142) statement -> . for_statement marker
    (186) class_declaration -> . class_header class_body
    (5) SingletonObject -> . ObjectDeclare block
    (174) method_declaration -> . method_header method_body
    (102) local_variable_declaration -> . declaration_keyword variable_declaration_body
    (143) normal_statement -> . block marker
    (144) normal_statement -> . expression_statement marker
    (145) normal_statement -> . empty_statement marker
    (146) normal_statement -> . return_statement marker
    (147) normal_statement -> . switch_statement marker
    (151) if_then_statement -> . KEYWORD_IF LPAREN expression RPAREN marker block
    (152) if_then_else_statement -> . KEYWORD_IF LPAREN expression RPAREN marker if_then_else_intermediate narker KEYWORD_ELSE marker block
    (156) while_statement -> . KEYWORD_WHILE LPAREN marker expression RPAREN marker block
    (157) do_while_statement -> . KEYWORD_DO marker block KEYWORD_WHILE LPAREN marker expression RPAREN TERMINATOR
    (158) for_statement -> . KEYWORD_FOR LPAREN for_update RPAREN marker block
    (187) class_header -> . KEYWORD_CLASS simple_name class_param_clause
    (6) ObjectDeclare -> . KEYWORD_OBJECT IDENTIFIER
    (175) method_header -> . method_header_name func_arg_start fun_params_opt RPAREN COLON method_return_type ASOP
    (99) declaration_keyword -> . KEYWORD_VAR
    (100) declaration_keyword -> . KEYWORD_VAL
    (7) block -> . start_scope block_statements_opt end_scope
    (148) expression_statement -> . statement_expression TERMINATOR
    (172) empty_statement -> . TERMINATOR
    (173) return_statement -> . KEYWORD_RETURN expression_optional TERMINATOR
    (165) switch_statement -> . expression KEYWORD_MATCH switch_block marker
    (183) method_header_name -> . KEYWORD_DEF IDENTIFIER
    (8) start_scope -> . BLOCKBEGIN
    (149) statement_expression -> . assignment
    (150) statement_expression -> . method_invocation
    (19) expression -> . assignment_expression
    (25) assignment -> . valid_variable assignment_operator assignment_expression
    (94) method_invocation -> . name LPAREN argument_list_opt RPAREN
    (22) assignment_expression -> . assignment
    (23) assignment_expression -> . conditional_or_expression
    (24) assignment_expression -> . method_invocation
    (26) valid_variable -> . name
    (27) valid_variable -> . array_access
    (130) name -> . simple_name
    (131) name -> . qualified_name
    (43) conditional_or_expression -> . conditional_and_expression
    (44) conditional_or_expression -> . conditional_or_expression OR marker conditional_and_expression
    (28) array_access -> . name dimension
    (132) simple_name -> . IDENTIFIER
    (133) qualified_name -> . name INST simple_name
    (45) conditional_and_expression -> . inclusive_or_expression
    (46) conditional_and_expression -> . conditional_and_expression AND marker inclusive_or_expression
    (47) inclusive_or_expression -> . exclusive_or_expression
    (48) inclusive_or_expression -> . inclusive_or_expression OR_BITWISE exclusive_or_expression
    (49) exclusive_or_expression -> . and_expression
    (50) exclusive_or_expression -> . exclusive_or_expression XOR and_expression
    (51) and_expression -> . equality_expression
    (52) and_expression -> . and_expression AND_BITWISE equality_expression
    (53) equality_expression -> . relational_expression
    (54) equality_expression -> . equality_expression EQUAL relational_expression
    (55) equality_expression -> . equality_expression NEQUAL relational_expression
    (56) relational_expression -> . shift_expression
    (57) relational_expression -> . relational_expression GREATER shift_expression
    (58) relational_expression -> . relational_expression LESS shift_expression
    (59) relational_expression -> . relational_expression GEQ shift_expression
    (60) relational_expression -> . relational_expression LEQ shift_expression
    (61) shift_expression -> . additive_expression
    (62) shift_expression -> . shift_expression LSHIFT additive_expression
    (63) shift_expression -> . shift_expression RSHIFT additive_expression
    (64) additive_expression -> . multiplicative_expression
    (65) additive_expression -> . additive_expression PLUS multiplicative_expression
    (66) additive_expression -> . additive_expression MINUS multiplicative_expression
    (67) multiplicative_expression -> . unary_expression
    (68) multiplicative_expression -> . multiplicative_expression TIMES unary_expression
    (69) multiplicative_expression -> . multiplicative_expression DIVIDE unary_expression
    (70) multiplicative_expression -> . multiplicative_expression REMAINDER unary_expression
    (71) unary_expression -> . PLUS unary_expression
    (72) unary_expression -> . MINUS unary_expression
    (73) unary_expression -> . unary_expression_not_plus_minus
    (74) unary_expression_not_plus_minus -> . base_variable_set
    (75) unary_expression_not_plus_minus -> . TILDA unary_expression
    (76) unary_expression_not_plus_minus -> . cast_expression
    (77) unary_expression_not_plus_minus -> . NOT unary_expression
    (78) base_variable_set -> . variable_literal
    (79) base_variable_set -> . LPAREN expression RPAREN
    (82) cast_expression -> . LPAREN primitive_type RPAREN unary_expression
    (80) variable_literal -> . valid_variable
    (81) variable_literal -> . primary
    (83) primary -> . literal
    (84) primary -> . method_invocation
    (85) literal -> . int_float
    (86) literal -> . c_literal
    (92) int_float -> . DOUBLE_NUMBER
    (93) int_float -> . INT_NUMBER
    (87) c_literal -> . CHAR
    (88) c_literal -> . STRING
    (89) c_literal -> . KEYWORD_NULL
    (90) c_literal -> . BOOL_CONSTT
    (91) c_literal -> . BOOL_CONSTF

    BLOCKEND        reduce using rule 200 (empty -> .)
    KEYWORD_IF      shift and go to state 78
    KEYWORD_WHILE   shift and go to state 44
    KEYWORD_DO      shift and go to state 95
    KEYWORD_FOR     shift and go to state 94
    KEYWORD_CLASS   shift and go to state 1
    KEYWORD_OBJECT  shift and go to state 8
    KEYWORD_VAR     shift and go to state 47
    KEYWORD_VAL     shift and go to state 48
    TERMINATOR      shift and go to state 49
    KEYWORD_RETURN  shift and go to state 64
    KEYWORD_DEF     shift and go to state 76
    BLOCKBEGIN      shift and go to state 12
    IDENTIFIER      shift and go to state 9
    PLUS            shift and go to state 31
    MINUS           shift and go to state 24
    TILDA           shift and go to state 68
    NOT             shift and go to state 53
    LPAREN          shift and go to state 91
    DOUBLE_NUMBER   shift and go to state 28
    INT_NUMBER      shift and go to state 39
    CHAR            shift and go to state 59
    STRING          shift and go to state 72
    KEYWORD_NULL    shift and go to state 61
    BOOL_CONSTT     shift and go to state 30
    BOOL_CONSTF     shift and go to state 25

    expression_statement           shift and go to state 22
    unary_expression               shift and go to state 40
    exclusive_or_expression        shift and go to state 57
    normal_statement               shift and go to state 83
    ObjectDeclare                  shift and go to state 3
    primary                        shift and go to state 58
    declaration_keyword            shift and go to state 74
    if_then_statement              shift and go to state 60
    array_access                   shift and go to state 23
    switch_statement               shift and go to state 42
    simple_name                    shift and go to state 63
    block_statements_opt           shift and go to state 227
    qualified_name                 shift and go to state 75
    base_variable_set              shift and go to state 85
    inclusive_or_expression        shift and go to state 27
    method_declaration             shift and go to state 65
    cast_expression                shift and go to state 77
    block_statement                shift and go to state 66
    return_statement               shift and go to state 86
    while_statement                shift and go to state 29
    unary_expression_not_plus_minus shift and go to state 41
    and_expression                 shift and go to state 84
    statement                      shift and go to state 70
    c_literal                      shift and go to state 90
    statement_expression           shift and go to state 32
    method_invocation              shift and go to state 71
    conditional_or_expression      shift and go to state 43
    empty                          shift and go to state 73
    relational_expression          shift and go to state 69
    block_statements               shift and go to state 87
    for_statement                  shift and go to state 33
    local_variable_declaration_statement shift and go to state 34
    do_while_statement             shift and go to state 45
    int_float                      shift and go to state 35
    assignment                     shift and go to state 89
    multiplicative_expression      shift and go to state 46
    literal                        shift and go to state 67
    additive_expression            shift and go to state 62
    SingletonObject                shift and go to state 36
    start_scope                    shift and go to state 13
    method_header_name             shift and go to state 37
    class_header                   shift and go to state 7
    shift_expression               shift and go to state 50
    equality_expression            shift and go to state 79
    name                           shift and go to state 38
    variable_literal               shift and go to state 51
    assignment_expression          shift and go to state 88
    valid_variable                 shift and go to state 92
    method_header                  shift and go to state 80
    empty_statement                shift and go to state 81
    class_declaration              shift and go to state 93
    local_variable_declaration     shift and go to state 82
    expression                     shift and go to state 54
    conditional_and_expression     shift and go to state 52
    block                          shift and go to state 55
    if_then_else_statement         shift and go to state 56

state 157

    (174) method_declaration -> method_header method_body .

    KEYWORD_IF      reduce using rule 174 (method_declaration -> method_header method_body .)
    KEYWORD_WHILE   reduce using rule 174 (method_declaration -> method_header method_body .)
    KEYWORD_DO      reduce using rule 174 (method_declaration -> method_header method_body .)
    KEYWORD_FOR     reduce using rule 174 (method_declaration -> method_header method_body .)
    KEYWORD_CLASS   reduce using rule 174 (method_declaration -> method_header method_body .)
    KEYWORD_OBJECT  reduce using rule 174 (method_declaration -> method_header method_body .)
    KEYWORD_VAR     reduce using rule 174 (method_declaration -> method_header method_body .)
    KEYWORD_VAL     reduce using rule 174 (method_declaration -> method_header method_body .)
    TERMINATOR      reduce using rule 174 (method_declaration -> method_header method_body .)
    KEYWORD_RETURN  reduce using rule 174 (method_declaration -> method_header method_body .)
    KEYWORD_DEF     reduce using rule 174 (method_declaration -> method_header method_body .)
    BLOCKBEGIN      reduce using rule 174 (method_declaration -> method_header method_body .)
    IDENTIFIER      reduce using rule 174 (method_declaration -> method_header method_body .)
    PLUS            reduce using rule 174 (method_declaration -> method_header method_body .)
    MINUS           reduce using rule 174 (method_declaration -> method_header method_body .)
    TILDA           reduce using rule 174 (method_declaration -> method_header method_body .)
    NOT             reduce using rule 174 (method_declaration -> method_header method_body .)
    LPAREN          reduce using rule 174 (method_declaration -> method_header method_body .)
    DOUBLE_NUMBER   reduce using rule 174 (method_declaration -> method_header method_body .)
    INT_NUMBER      reduce using rule 174 (method_declaration -> method_header method_body .)
    CHAR            reduce using rule 174 (method_declaration -> method_header method_body .)
    STRING          reduce using rule 174 (method_declaration -> method_header method_body .)
    KEYWORD_NULL    reduce using rule 174 (method_declaration -> method_header method_body .)
    BOOL_CONSTT     reduce using rule 174 (method_declaration -> method_header method_body .)
    BOOL_CONSTF     reduce using rule 174 (method_declaration -> method_header method_body .)
    BLOCKEND        reduce using rule 174 (method_declaration -> method_header method_body .)


state 158

    (185) method_start_scope -> BLOCKBEGIN .

    KEYWORD_IF      reduce using rule 185 (method_start_scope -> BLOCKBEGIN .)
    KEYWORD_WHILE   reduce using rule 185 (method_start_scope -> BLOCKBEGIN .)
    KEYWORD_DO      reduce using rule 185 (method_start_scope -> BLOCKBEGIN .)
    KEYWORD_FOR     reduce using rule 185 (method_start_scope -> BLOCKBEGIN .)
    KEYWORD_CLASS   reduce using rule 185 (method_start_scope -> BLOCKBEGIN .)
    KEYWORD_OBJECT  reduce using rule 185 (method_start_scope -> BLOCKBEGIN .)
    KEYWORD_VAR     reduce using rule 185 (method_start_scope -> BLOCKBEGIN .)
    KEYWORD_VAL     reduce using rule 185 (method_start_scope -> BLOCKBEGIN .)
    TERMINATOR      reduce using rule 185 (method_start_scope -> BLOCKBEGIN .)
    KEYWORD_RETURN  reduce using rule 185 (method_start_scope -> BLOCKBEGIN .)
    KEYWORD_DEF     reduce using rule 185 (method_start_scope -> BLOCKBEGIN .)
    BLOCKBEGIN      reduce using rule 185 (method_start_scope -> BLOCKBEGIN .)
    IDENTIFIER      reduce using rule 185 (method_start_scope -> BLOCKBEGIN .)
    PLUS            reduce using rule 185 (method_start_scope -> BLOCKBEGIN .)
    MINUS           reduce using rule 185 (method_start_scope -> BLOCKBEGIN .)
    TILDA           reduce using rule 185 (method_start_scope -> BLOCKBEGIN .)
    NOT             reduce using rule 185 (method_start_scope -> BLOCKBEGIN .)
    LPAREN          reduce using rule 185 (method_start_scope -> BLOCKBEGIN .)
    DOUBLE_NUMBER   reduce using rule 185 (method_start_scope -> BLOCKBEGIN .)
    INT_NUMBER      reduce using rule 185 (method_start_scope -> BLOCKBEGIN .)
    CHAR            reduce using rule 185 (method_start_scope -> BLOCKBEGIN .)
    STRING          reduce using rule 185 (method_start_scope -> BLOCKBEGIN .)
    KEYWORD_NULL    reduce using rule 185 (method_start_scope -> BLOCKBEGIN .)
    BOOL_CONSTT     reduce using rule 185 (method_start_scope -> BLOCKBEGIN .)
    BOOL_CONSTF     reduce using rule 185 (method_start_scope -> BLOCKBEGIN .)
    BLOCKEND        reduce using rule 185 (method_start_scope -> BLOCKBEGIN .)


state 159

    (145) normal_statement -> empty_statement marker .

    KEYWORD_IF      reduce using rule 145 (normal_statement -> empty_statement marker .)
    KEYWORD_WHILE   reduce using rule 145 (normal_statement -> empty_statement marker .)
    KEYWORD_DO      reduce using rule 145 (normal_statement -> empty_statement marker .)
    KEYWORD_FOR     reduce using rule 145 (normal_statement -> empty_statement marker .)
    KEYWORD_CLASS   reduce using rule 145 (normal_statement -> empty_statement marker .)
    KEYWORD_OBJECT  reduce using rule 145 (normal_statement -> empty_statement marker .)
    KEYWORD_VAR     reduce using rule 145 (normal_statement -> empty_statement marker .)
    KEYWORD_VAL     reduce using rule 145 (normal_statement -> empty_statement marker .)
    TERMINATOR      reduce using rule 145 (normal_statement -> empty_statement marker .)
    KEYWORD_RETURN  reduce using rule 145 (normal_statement -> empty_statement marker .)
    KEYWORD_DEF     reduce using rule 145 (normal_statement -> empty_statement marker .)
    BLOCKBEGIN      reduce using rule 145 (normal_statement -> empty_statement marker .)
    IDENTIFIER      reduce using rule 145 (normal_statement -> empty_statement marker .)
    PLUS            reduce using rule 145 (normal_statement -> empty_statement marker .)
    MINUS           reduce using rule 145 (normal_statement -> empty_statement marker .)
    TILDA           reduce using rule 145 (normal_statement -> empty_statement marker .)
    NOT             reduce using rule 145 (normal_statement -> empty_statement marker .)
    LPAREN          reduce using rule 145 (normal_statement -> empty_statement marker .)
    DOUBLE_NUMBER   reduce using rule 145 (normal_statement -> empty_statement marker .)
    INT_NUMBER      reduce using rule 145 (normal_statement -> empty_statement marker .)
    CHAR            reduce using rule 145 (normal_statement -> empty_statement marker .)
    STRING          reduce using rule 145 (normal_statement -> empty_statement marker .)
    KEYWORD_NULL    reduce using rule 145 (normal_statement -> empty_statement marker .)
    BOOL_CONSTT     reduce using rule 145 (normal_statement -> empty_statement marker .)
    BOOL_CONSTF     reduce using rule 145 (normal_statement -> empty_statement marker .)
    BLOCKEND        reduce using rule 145 (normal_statement -> empty_statement marker .)
    KEYWORD_ELSE    reduce using rule 145 (normal_statement -> empty_statement marker .)


state 160

    (101) local_variable_declaration_statement -> local_variable_declaration TERMINATOR .

    KEYWORD_IF      reduce using rule 101 (local_variable_declaration_statement -> local_variable_declaration TERMINATOR .)
    KEYWORD_WHILE   reduce using rule 101 (local_variable_declaration_statement -> local_variable_declaration TERMINATOR .)
    KEYWORD_DO      reduce using rule 101 (local_variable_declaration_statement -> local_variable_declaration TERMINATOR .)
    KEYWORD_FOR     reduce using rule 101 (local_variable_declaration_statement -> local_variable_declaration TERMINATOR .)
    KEYWORD_CLASS   reduce using rule 101 (local_variable_declaration_statement -> local_variable_declaration TERMINATOR .)
    KEYWORD_OBJECT  reduce using rule 101 (local_variable_declaration_statement -> local_variable_declaration TERMINATOR .)
    KEYWORD_VAR     reduce using rule 101 (local_variable_declaration_statement -> local_variable_declaration TERMINATOR .)
    KEYWORD_VAL     reduce using rule 101 (local_variable_declaration_statement -> local_variable_declaration TERMINATOR .)
    TERMINATOR      reduce using rule 101 (local_variable_declaration_statement -> local_variable_declaration TERMINATOR .)
    KEYWORD_RETURN  reduce using rule 101 (local_variable_declaration_statement -> local_variable_declaration TERMINATOR .)
    KEYWORD_DEF     reduce using rule 101 (local_variable_declaration_statement -> local_variable_declaration TERMINATOR .)
    BLOCKBEGIN      reduce using rule 101 (local_variable_declaration_statement -> local_variable_declaration TERMINATOR .)
    IDENTIFIER      reduce using rule 101 (local_variable_declaration_statement -> local_variable_declaration TERMINATOR .)
    PLUS            reduce using rule 101 (local_variable_declaration_statement -> local_variable_declaration TERMINATOR .)
    MINUS           reduce using rule 101 (local_variable_declaration_statement -> local_variable_declaration TERMINATOR .)
    TILDA           reduce using rule 101 (local_variable_declaration_statement -> local_variable_declaration TERMINATOR .)
    NOT             reduce using rule 101 (local_variable_declaration_statement -> local_variable_declaration TERMINATOR .)
    LPAREN          reduce using rule 101 (local_variable_declaration_statement -> local_variable_declaration TERMINATOR .)
    DOUBLE_NUMBER   reduce using rule 101 (local_variable_declaration_statement -> local_variable_declaration TERMINATOR .)
    INT_NUMBER      reduce using rule 101 (local_variable_declaration_statement -> local_variable_declaration TERMINATOR .)
    CHAR            reduce using rule 101 (local_variable_declaration_statement -> local_variable_declaration TERMINATOR .)
    STRING          reduce using rule 101 (local_variable_declaration_statement -> local_variable_declaration TERMINATOR .)
    KEYWORD_NULL    reduce using rule 101 (local_variable_declaration_statement -> local_variable_declaration TERMINATOR .)
    BOOL_CONSTT     reduce using rule 101 (local_variable_declaration_statement -> local_variable_declaration TERMINATOR .)
    BOOL_CONSTF     reduce using rule 101 (local_variable_declaration_statement -> local_variable_declaration TERMINATOR .)
    BLOCKEND        reduce using rule 101 (local_variable_declaration_statement -> local_variable_declaration TERMINATOR .)


state 161

    (137) statement -> normal_statement marker .

    KEYWORD_IF      reduce using rule 137 (statement -> normal_statement marker .)
    KEYWORD_WHILE   reduce using rule 137 (statement -> normal_statement marker .)
    KEYWORD_DO      reduce using rule 137 (statement -> normal_statement marker .)
    KEYWORD_FOR     reduce using rule 137 (statement -> normal_statement marker .)
    KEYWORD_CLASS   reduce using rule 137 (statement -> normal_statement marker .)
    KEYWORD_OBJECT  reduce using rule 137 (statement -> normal_statement marker .)
    KEYWORD_VAR     reduce using rule 137 (statement -> normal_statement marker .)
    KEYWORD_VAL     reduce using rule 137 (statement -> normal_statement marker .)
    TERMINATOR      reduce using rule 137 (statement -> normal_statement marker .)
    KEYWORD_RETURN  reduce using rule 137 (statement -> normal_statement marker .)
    KEYWORD_DEF     reduce using rule 137 (statement -> normal_statement marker .)
    BLOCKBEGIN      reduce using rule 137 (statement -> normal_statement marker .)
    IDENTIFIER      reduce using rule 137 (statement -> normal_statement marker .)
    PLUS            reduce using rule 137 (statement -> normal_statement marker .)
    MINUS           reduce using rule 137 (statement -> normal_statement marker .)
    TILDA           reduce using rule 137 (statement -> normal_statement marker .)
    NOT             reduce using rule 137 (statement -> normal_statement marker .)
    LPAREN          reduce using rule 137 (statement -> normal_statement marker .)
    DOUBLE_NUMBER   reduce using rule 137 (statement -> normal_statement marker .)
    INT_NUMBER      reduce using rule 137 (statement -> normal_statement marker .)
    CHAR            reduce using rule 137 (statement -> normal_statement marker .)
    STRING          reduce using rule 137 (statement -> normal_statement marker .)
    KEYWORD_NULL    reduce using rule 137 (statement -> normal_statement marker .)
    BOOL_CONSTT     reduce using rule 137 (statement -> normal_statement marker .)
    BOOL_CONSTF     reduce using rule 137 (statement -> normal_statement marker .)
    BLOCKEND        reduce using rule 137 (statement -> normal_statement marker .)


state 162

    (52) and_expression -> and_expression AND_BITWISE . equality_expression
    (53) equality_expression -> . relational_expression
    (54) equality_expression -> . equality_expression EQUAL relational_expression
    (55) equality_expression -> . equality_expression NEQUAL relational_expression
    (56) relational_expression -> . shift_expression
    (57) relational_expression -> . relational_expression GREATER shift_expression
    (58) relational_expression -> . relational_expression LESS shift_expression
    (59) relational_expression -> . relational_expression GEQ shift_expression
    (60) relational_expression -> . relational_expression LEQ shift_expression
    (61) shift_expression -> . additive_expression
    (62) shift_expression -> . shift_expression LSHIFT additive_expression
    (63) shift_expression -> . shift_expression RSHIFT additive_expression
    (64) additive_expression -> . multiplicative_expression
    (65) additive_expression -> . additive_expression PLUS multiplicative_expression
    (66) additive_expression -> . additive_expression MINUS multiplicative_expression
    (67) multiplicative_expression -> . unary_expression
    (68) multiplicative_expression -> . multiplicative_expression TIMES unary_expression
    (69) multiplicative_expression -> . multiplicative_expression DIVIDE unary_expression
    (70) multiplicative_expression -> . multiplicative_expression REMAINDER unary_expression
    (71) unary_expression -> . PLUS unary_expression
    (72) unary_expression -> . MINUS unary_expression
    (73) unary_expression -> . unary_expression_not_plus_minus
    (74) unary_expression_not_plus_minus -> . base_variable_set
    (75) unary_expression_not_plus_minus -> . TILDA unary_expression
    (76) unary_expression_not_plus_minus -> . cast_expression
    (77) unary_expression_not_plus_minus -> . NOT unary_expression
    (78) base_variable_set -> . variable_literal
    (79) base_variable_set -> . LPAREN expression RPAREN
    (82) cast_expression -> . LPAREN primitive_type RPAREN unary_expression
    (80) variable_literal -> . valid_variable
    (81) variable_literal -> . primary
    (26) valid_variable -> . name
    (27) valid_variable -> . array_access
    (83) primary -> . literal
    (84) primary -> . method_invocation
    (130) name -> . simple_name
    (131) name -> . qualified_name
    (28) array_access -> . name dimension
    (85) literal -> . int_float
    (86) literal -> . c_literal
    (94) method_invocation -> . name LPAREN argument_list_opt RPAREN
    (132) simple_name -> . IDENTIFIER
    (133) qualified_name -> . name INST simple_name
    (92) int_float -> . DOUBLE_NUMBER
    (93) int_float -> . INT_NUMBER
    (87) c_literal -> . CHAR
    (88) c_literal -> . STRING
    (89) c_literal -> . KEYWORD_NULL
    (90) c_literal -> . BOOL_CONSTT
    (91) c_literal -> . BOOL_CONSTF

    PLUS            shift and go to state 31
    MINUS           shift and go to state 24
    TILDA           shift and go to state 68
    NOT             shift and go to state 53
    LPAREN          shift and go to state 91
    IDENTIFIER      shift and go to state 9
    DOUBLE_NUMBER   shift and go to state 28
    INT_NUMBER      shift and go to state 39
    CHAR            shift and go to state 59
    STRING          shift and go to state 72
    KEYWORD_NULL    shift and go to state 61
    BOOL_CONSTT     shift and go to state 30
    BOOL_CONSTF     shift and go to state 25

    unary_expression               shift and go to state 40
    primary                        shift and go to state 58
    unary_expression_not_plus_minus shift and go to state 41
    array_access                   shift and go to state 23
    simple_name                    shift and go to state 63
    c_literal                      shift and go to state 90
    base_variable_set              shift and go to state 85
    valid_variable                 shift and go to state 106
    literal                        shift and go to state 67
    additive_expression            shift and go to state 62
    method_invocation              shift and go to state 107
    relational_expression          shift and go to state 69
    qualified_name                 shift and go to state 75
    multiplicative_expression      shift and go to state 46
    cast_expression                shift and go to state 77
    shift_expression               shift and go to state 50
    equality_expression            shift and go to state 228
    int_float                      shift and go to state 35
    variable_literal               shift and go to state 51
    name                           shift and go to state 108

state 163

    (146) normal_statement -> return_statement marker .

    KEYWORD_IF      reduce using rule 146 (normal_statement -> return_statement marker .)
    KEYWORD_WHILE   reduce using rule 146 (normal_statement -> return_statement marker .)
    KEYWORD_DO      reduce using rule 146 (normal_statement -> return_statement marker .)
    KEYWORD_FOR     reduce using rule 146 (normal_statement -> return_statement marker .)
    KEYWORD_CLASS   reduce using rule 146 (normal_statement -> return_statement marker .)
    KEYWORD_OBJECT  reduce using rule 146 (normal_statement -> return_statement marker .)
    KEYWORD_VAR     reduce using rule 146 (normal_statement -> return_statement marker .)
    KEYWORD_VAL     reduce using rule 146 (normal_statement -> return_statement marker .)
    TERMINATOR      reduce using rule 146 (normal_statement -> return_statement marker .)
    KEYWORD_RETURN  reduce using rule 146 (normal_statement -> return_statement marker .)
    KEYWORD_DEF     reduce using rule 146 (normal_statement -> return_statement marker .)
    BLOCKBEGIN      reduce using rule 146 (normal_statement -> return_statement marker .)
    IDENTIFIER      reduce using rule 146 (normal_statement -> return_statement marker .)
    PLUS            reduce using rule 146 (normal_statement -> return_statement marker .)
    MINUS           reduce using rule 146 (normal_statement -> return_statement marker .)
    TILDA           reduce using rule 146 (normal_statement -> return_statement marker .)
    NOT             reduce using rule 146 (normal_statement -> return_statement marker .)
    LPAREN          reduce using rule 146 (normal_statement -> return_statement marker .)
    DOUBLE_NUMBER   reduce using rule 146 (normal_statement -> return_statement marker .)
    INT_NUMBER      reduce using rule 146 (normal_statement -> return_statement marker .)
    CHAR            reduce using rule 146 (normal_statement -> return_statement marker .)
    STRING          reduce using rule 146 (normal_statement -> return_statement marker .)
    KEYWORD_NULL    reduce using rule 146 (normal_statement -> return_statement marker .)
    BOOL_CONSTT     reduce using rule 146 (normal_statement -> return_statement marker .)
    BOOL_CONSTF     reduce using rule 146 (normal_statement -> return_statement marker .)
    BLOCKEND        reduce using rule 146 (normal_statement -> return_statement marker .)
    KEYWORD_ELSE    reduce using rule 146 (normal_statement -> return_statement marker .)


state 164

    (13) block_statements -> block_statements marker . block_statement
    (14) block_statement -> . local_variable_declaration_statement
    (15) block_statement -> . statement
    (16) block_statement -> . class_declaration
    (17) block_statement -> . SingletonObject
    (18) block_statement -> . method_declaration
    (101) local_variable_declaration_statement -> . local_variable_declaration TERMINATOR
    (137) statement -> . normal_statement marker
    (138) statement -> . if_then_statement marker
    (139) statement -> . if_then_else_statement marker
    (140) statement -> . while_statement marker
    (141) statement -> . do_while_statement marker
    (142) statement -> . for_statement marker
    (186) class_declaration -> . class_header class_body
    (5) SingletonObject -> . ObjectDeclare block
    (174) method_declaration -> . method_header method_body
    (102) local_variable_declaration -> . declaration_keyword variable_declaration_body
    (143) normal_statement -> . block marker
    (144) normal_statement -> . expression_statement marker
    (145) normal_statement -> . empty_statement marker
    (146) normal_statement -> . return_statement marker
    (147) normal_statement -> . switch_statement marker
    (151) if_then_statement -> . KEYWORD_IF LPAREN expression RPAREN marker block
    (152) if_then_else_statement -> . KEYWORD_IF LPAREN expression RPAREN marker if_then_else_intermediate narker KEYWORD_ELSE marker block
    (156) while_statement -> . KEYWORD_WHILE LPAREN marker expression RPAREN marker block
    (157) do_while_statement -> . KEYWORD_DO marker block KEYWORD_WHILE LPAREN marker expression RPAREN TERMINATOR
    (158) for_statement -> . KEYWORD_FOR LPAREN for_update RPAREN marker block
    (187) class_header -> . KEYWORD_CLASS simple_name class_param_clause
    (6) ObjectDeclare -> . KEYWORD_OBJECT IDENTIFIER
    (175) method_header -> . method_header_name func_arg_start fun_params_opt RPAREN COLON method_return_type ASOP
    (99) declaration_keyword -> . KEYWORD_VAR
    (100) declaration_keyword -> . KEYWORD_VAL
    (7) block -> . start_scope block_statements_opt end_scope
    (148) expression_statement -> . statement_expression TERMINATOR
    (172) empty_statement -> . TERMINATOR
    (173) return_statement -> . KEYWORD_RETURN expression_optional TERMINATOR
    (165) switch_statement -> . expression KEYWORD_MATCH switch_block marker
    (183) method_header_name -> . KEYWORD_DEF IDENTIFIER
    (8) start_scope -> . BLOCKBEGIN
    (149) statement_expression -> . assignment
    (150) statement_expression -> . method_invocation
    (19) expression -> . assignment_expression
    (25) assignment -> . valid_variable assignment_operator assignment_expression
    (94) method_invocation -> . name LPAREN argument_list_opt RPAREN
    (22) assignment_expression -> . assignment
    (23) assignment_expression -> . conditional_or_expression
    (24) assignment_expression -> . method_invocation
    (26) valid_variable -> . name
    (27) valid_variable -> . array_access
    (130) name -> . simple_name
    (131) name -> . qualified_name
    (43) conditional_or_expression -> . conditional_and_expression
    (44) conditional_or_expression -> . conditional_or_expression OR marker conditional_and_expression
    (28) array_access -> . name dimension
    (132) simple_name -> . IDENTIFIER
    (133) qualified_name -> . name INST simple_name
    (45) conditional_and_expression -> . inclusive_or_expression
    (46) conditional_and_expression -> . conditional_and_expression AND marker inclusive_or_expression
    (47) inclusive_or_expression -> . exclusive_or_expression
    (48) inclusive_or_expression -> . inclusive_or_expression OR_BITWISE exclusive_or_expression
    (49) exclusive_or_expression -> . and_expression
    (50) exclusive_or_expression -> . exclusive_or_expression XOR and_expression
    (51) and_expression -> . equality_expression
    (52) and_expression -> . and_expression AND_BITWISE equality_expression
    (53) equality_expression -> . relational_expression
    (54) equality_expression -> . equality_expression EQUAL relational_expression
    (55) equality_expression -> . equality_expression NEQUAL relational_expression
    (56) relational_expression -> . shift_expression
    (57) relational_expression -> . relational_expression GREATER shift_expression
    (58) relational_expression -> . relational_expression LESS shift_expression
    (59) relational_expression -> . relational_expression GEQ shift_expression
    (60) relational_expression -> . relational_expression LEQ shift_expression
    (61) shift_expression -> . additive_expression
    (62) shift_expression -> . shift_expression LSHIFT additive_expression
    (63) shift_expression -> . shift_expression RSHIFT additive_expression
    (64) additive_expression -> . multiplicative_expression
    (65) additive_expression -> . additive_expression PLUS multiplicative_expression
    (66) additive_expression -> . additive_expression MINUS multiplicative_expression
    (67) multiplicative_expression -> . unary_expression
    (68) multiplicative_expression -> . multiplicative_expression TIMES unary_expression
    (69) multiplicative_expression -> . multiplicative_expression DIVIDE unary_expression
    (70) multiplicative_expression -> . multiplicative_expression REMAINDER unary_expression
    (71) unary_expression -> . PLUS unary_expression
    (72) unary_expression -> . MINUS unary_expression
    (73) unary_expression -> . unary_expression_not_plus_minus
    (74) unary_expression_not_plus_minus -> . base_variable_set
    (75) unary_expression_not_plus_minus -> . TILDA unary_expression
    (76) unary_expression_not_plus_minus -> . cast_expression
    (77) unary_expression_not_plus_minus -> . NOT unary_expression
    (78) base_variable_set -> . variable_literal
    (79) base_variable_set -> . LPAREN expression RPAREN
    (82) cast_expression -> . LPAREN primitive_type RPAREN unary_expression
    (80) variable_literal -> . valid_variable
    (81) variable_literal -> . primary
    (83) primary -> . literal
    (84) primary -> . method_invocation
    (85) literal -> . int_float
    (86) literal -> . c_literal
    (92) int_float -> . DOUBLE_NUMBER
    (93) int_float -> . INT_NUMBER
    (87) c_literal -> . CHAR
    (88) c_literal -> . STRING
    (89) c_literal -> . KEYWORD_NULL
    (90) c_literal -> . BOOL_CONSTT
    (91) c_literal -> . BOOL_CONSTF

    KEYWORD_IF      shift and go to state 78
    KEYWORD_WHILE   shift and go to state 44
    KEYWORD_DO      shift and go to state 95
    KEYWORD_FOR     shift and go to state 94
    KEYWORD_CLASS   shift and go to state 1
    KEYWORD_OBJECT  shift and go to state 8
    KEYWORD_VAR     shift and go to state 47
    KEYWORD_VAL     shift and go to state 48
    TERMINATOR      shift and go to state 49
    KEYWORD_RETURN  shift and go to state 64
    KEYWORD_DEF     shift and go to state 76
    BLOCKBEGIN      shift and go to state 12
    IDENTIFIER      shift and go to state 9
    PLUS            shift and go to state 31
    MINUS           shift and go to state 24
    TILDA           shift and go to state 68
    NOT             shift and go to state 53
    LPAREN          shift and go to state 91
    DOUBLE_NUMBER   shift and go to state 28
    INT_NUMBER      shift and go to state 39
    CHAR            shift and go to state 59
    STRING          shift and go to state 72
    KEYWORD_NULL    shift and go to state 61
    BOOL_CONSTT     shift and go to state 30
    BOOL_CONSTF     shift and go to state 25

    expression_statement           shift and go to state 22
    unary_expression               shift and go to state 40
    exclusive_or_expression        shift and go to state 57
    normal_statement               shift and go to state 83
    ObjectDeclare                  shift and go to state 3
    primary                        shift and go to state 58
    declaration_keyword            shift and go to state 74
    if_then_statement              shift and go to state 60
    array_access                   shift and go to state 23
    switch_statement               shift and go to state 42
    simple_name                    shift and go to state 63
    qualified_name                 shift and go to state 75
    base_variable_set              shift and go to state 85
    inclusive_or_expression        shift and go to state 27
    method_declaration             shift and go to state 65
    cast_expression                shift and go to state 77
    block_statement                shift and go to state 229
    return_statement               shift and go to state 86
    while_statement                shift and go to state 29
    unary_expression_not_plus_minus shift and go to state 41
    and_expression                 shift and go to state 84
    statement                      shift and go to state 70
    c_literal                      shift and go to state 90
    statement_expression           shift and go to state 32
    method_invocation              shift and go to state 71
    conditional_or_expression      shift and go to state 43
    relational_expression          shift and go to state 69
    for_statement                  shift and go to state 33
    local_variable_declaration_statement shift and go to state 34
    do_while_statement             shift and go to state 45
    int_float                      shift and go to state 35
    assignment                     shift and go to state 89
    multiplicative_expression      shift and go to state 46
    literal                        shift and go to state 67
    additive_expression            shift and go to state 62
    SingletonObject                shift and go to state 36
    start_scope                    shift and go to state 13
    method_header_name             shift and go to state 37
    class_header                   shift and go to state 7
    shift_expression               shift and go to state 50
    equality_expression            shift and go to state 79
    variable_literal               shift and go to state 51
    name                           shift and go to state 38
    assignment_expression          shift and go to state 88
    valid_variable                 shift and go to state 92
    method_header                  shift and go to state 80
    empty_statement                shift and go to state 81
    class_declaration              shift and go to state 93
    local_variable_declaration     shift and go to state 82
    expression                     shift and go to state 54
    conditional_and_expression     shift and go to state 52
    block                          shift and go to state 55
    if_then_else_statement         shift and go to state 56

state 165

    (120) primitive_type -> TYPE_INT .

    ASOP            reduce using rule 120 (primitive_type -> TYPE_INT .)
    RBRAC           reduce using rule 120 (primitive_type -> TYPE_INT .)
    COMMA           reduce using rule 120 (primitive_type -> TYPE_INT .)
    RPAREN          reduce using rule 120 (primitive_type -> TYPE_INT .)


state 166

    (123) primitive_type -> TYPE_STRING .

    ASOP            reduce using rule 123 (primitive_type -> TYPE_STRING .)
    RBRAC           reduce using rule 123 (primitive_type -> TYPE_STRING .)
    COMMA           reduce using rule 123 (primitive_type -> TYPE_STRING .)
    RPAREN          reduce using rule 123 (primitive_type -> TYPE_STRING .)


state 167

    (122) primitive_type -> TYPE_CHAR .

    ASOP            reduce using rule 122 (primitive_type -> TYPE_CHAR .)
    RBRAC           reduce using rule 122 (primitive_type -> TYPE_CHAR .)
    COMMA           reduce using rule 122 (primitive_type -> TYPE_CHAR .)
    RPAREN          reduce using rule 122 (primitive_type -> TYPE_CHAR .)


state 168

    (125) primitive_type -> TYPE_VOID .

    RBRAC           reduce using rule 125 (primitive_type -> TYPE_VOID .)
    COMMA           reduce using rule 125 (primitive_type -> TYPE_VOID .)
    RPAREN          reduce using rule 125 (primitive_type -> TYPE_VOID .)
    ASOP            reduce using rule 125 (primitive_type -> TYPE_VOID .)


state 169

    (82) cast_expression -> LPAREN primitive_type . RPAREN unary_expression

    RPAREN          shift and go to state 230


state 170

    (124) primitive_type -> TYPE_BOOLEAN .

    ASOP            reduce using rule 124 (primitive_type -> TYPE_BOOLEAN .)
    RBRAC           reduce using rule 124 (primitive_type -> TYPE_BOOLEAN .)
    COMMA           reduce using rule 124 (primitive_type -> TYPE_BOOLEAN .)
    RPAREN          reduce using rule 124 (primitive_type -> TYPE_BOOLEAN .)


state 171

    (121) primitive_type -> TYPE_DOUBLE .

    ASOP            reduce using rule 121 (primitive_type -> TYPE_DOUBLE .)
    RBRAC           reduce using rule 121 (primitive_type -> TYPE_DOUBLE .)
    COMMA           reduce using rule 121 (primitive_type -> TYPE_DOUBLE .)
    RPAREN          reduce using rule 121 (primitive_type -> TYPE_DOUBLE .)


state 172

    (79) base_variable_set -> LPAREN expression . RPAREN

    RPAREN          shift and go to state 231


state 173

    (31) assignment_operator -> TIMES_ASSIGN .

    IDENTIFIER      reduce using rule 31 (assignment_operator -> TIMES_ASSIGN .)
    PLUS            reduce using rule 31 (assignment_operator -> TIMES_ASSIGN .)
    MINUS           reduce using rule 31 (assignment_operator -> TIMES_ASSIGN .)
    TILDA           reduce using rule 31 (assignment_operator -> TIMES_ASSIGN .)
    NOT             reduce using rule 31 (assignment_operator -> TIMES_ASSIGN .)
    LPAREN          reduce using rule 31 (assignment_operator -> TIMES_ASSIGN .)
    DOUBLE_NUMBER   reduce using rule 31 (assignment_operator -> TIMES_ASSIGN .)
    INT_NUMBER      reduce using rule 31 (assignment_operator -> TIMES_ASSIGN .)
    CHAR            reduce using rule 31 (assignment_operator -> TIMES_ASSIGN .)
    STRING          reduce using rule 31 (assignment_operator -> TIMES_ASSIGN .)
    KEYWORD_NULL    reduce using rule 31 (assignment_operator -> TIMES_ASSIGN .)
    BOOL_CONSTT     reduce using rule 31 (assignment_operator -> TIMES_ASSIGN .)
    BOOL_CONSTF     reduce using rule 31 (assignment_operator -> TIMES_ASSIGN .)


state 174

    (37) assignment_operator -> RSHIFT_ASSIGN .

    IDENTIFIER      reduce using rule 37 (assignment_operator -> RSHIFT_ASSIGN .)
    PLUS            reduce using rule 37 (assignment_operator -> RSHIFT_ASSIGN .)
    MINUS           reduce using rule 37 (assignment_operator -> RSHIFT_ASSIGN .)
    TILDA           reduce using rule 37 (assignment_operator -> RSHIFT_ASSIGN .)
    NOT             reduce using rule 37 (assignment_operator -> RSHIFT_ASSIGN .)
    LPAREN          reduce using rule 37 (assignment_operator -> RSHIFT_ASSIGN .)
    DOUBLE_NUMBER   reduce using rule 37 (assignment_operator -> RSHIFT_ASSIGN .)
    INT_NUMBER      reduce using rule 37 (assignment_operator -> RSHIFT_ASSIGN .)
    CHAR            reduce using rule 37 (assignment_operator -> RSHIFT_ASSIGN .)
    STRING          reduce using rule 37 (assignment_operator -> RSHIFT_ASSIGN .)
    KEYWORD_NULL    reduce using rule 37 (assignment_operator -> RSHIFT_ASSIGN .)
    BOOL_CONSTT     reduce using rule 37 (assignment_operator -> RSHIFT_ASSIGN .)
    BOOL_CONSTF     reduce using rule 37 (assignment_operator -> RSHIFT_ASSIGN .)


state 175

    (35) assignment_operator -> MINUS_ASSIGN .

    IDENTIFIER      reduce using rule 35 (assignment_operator -> MINUS_ASSIGN .)
    PLUS            reduce using rule 35 (assignment_operator -> MINUS_ASSIGN .)
    MINUS           reduce using rule 35 (assignment_operator -> MINUS_ASSIGN .)
    TILDA           reduce using rule 35 (assignment_operator -> MINUS_ASSIGN .)
    NOT             reduce using rule 35 (assignment_operator -> MINUS_ASSIGN .)
    LPAREN          reduce using rule 35 (assignment_operator -> MINUS_ASSIGN .)
    DOUBLE_NUMBER   reduce using rule 35 (assignment_operator -> MINUS_ASSIGN .)
    INT_NUMBER      reduce using rule 35 (assignment_operator -> MINUS_ASSIGN .)
    CHAR            reduce using rule 35 (assignment_operator -> MINUS_ASSIGN .)
    STRING          reduce using rule 35 (assignment_operator -> MINUS_ASSIGN .)
    KEYWORD_NULL    reduce using rule 35 (assignment_operator -> MINUS_ASSIGN .)
    BOOL_CONSTT     reduce using rule 35 (assignment_operator -> MINUS_ASSIGN .)
    BOOL_CONSTF     reduce using rule 35 (assignment_operator -> MINUS_ASSIGN .)


state 176

    (30) assignment_operator -> ASOP .

    IDENTIFIER      reduce using rule 30 (assignment_operator -> ASOP .)
    PLUS            reduce using rule 30 (assignment_operator -> ASOP .)
    MINUS           reduce using rule 30 (assignment_operator -> ASOP .)
    TILDA           reduce using rule 30 (assignment_operator -> ASOP .)
    NOT             reduce using rule 30 (assignment_operator -> ASOP .)
    LPAREN          reduce using rule 30 (assignment_operator -> ASOP .)
    DOUBLE_NUMBER   reduce using rule 30 (assignment_operator -> ASOP .)
    INT_NUMBER      reduce using rule 30 (assignment_operator -> ASOP .)
    CHAR            reduce using rule 30 (assignment_operator -> ASOP .)
    STRING          reduce using rule 30 (assignment_operator -> ASOP .)
    KEYWORD_NULL    reduce using rule 30 (assignment_operator -> ASOP .)
    BOOL_CONSTT     reduce using rule 30 (assignment_operator -> ASOP .)
    BOOL_CONSTF     reduce using rule 30 (assignment_operator -> ASOP .)


state 177

    (33) assignment_operator -> REMAINDER_ASSIGN .

    IDENTIFIER      reduce using rule 33 (assignment_operator -> REMAINDER_ASSIGN .)
    PLUS            reduce using rule 33 (assignment_operator -> REMAINDER_ASSIGN .)
    MINUS           reduce using rule 33 (assignment_operator -> REMAINDER_ASSIGN .)
    TILDA           reduce using rule 33 (assignment_operator -> REMAINDER_ASSIGN .)
    NOT             reduce using rule 33 (assignment_operator -> REMAINDER_ASSIGN .)
    LPAREN          reduce using rule 33 (assignment_operator -> REMAINDER_ASSIGN .)
    DOUBLE_NUMBER   reduce using rule 33 (assignment_operator -> REMAINDER_ASSIGN .)
    INT_NUMBER      reduce using rule 33 (assignment_operator -> REMAINDER_ASSIGN .)
    CHAR            reduce using rule 33 (assignment_operator -> REMAINDER_ASSIGN .)
    STRING          reduce using rule 33 (assignment_operator -> REMAINDER_ASSIGN .)
    KEYWORD_NULL    reduce using rule 33 (assignment_operator -> REMAINDER_ASSIGN .)
    BOOL_CONSTT     reduce using rule 33 (assignment_operator -> REMAINDER_ASSIGN .)
    BOOL_CONSTF     reduce using rule 33 (assignment_operator -> REMAINDER_ASSIGN .)


state 178

    (39) assignment_operator -> OR_ASSIGN .

    IDENTIFIER      reduce using rule 39 (assignment_operator -> OR_ASSIGN .)
    PLUS            reduce using rule 39 (assignment_operator -> OR_ASSIGN .)
    MINUS           reduce using rule 39 (assignment_operator -> OR_ASSIGN .)
    TILDA           reduce using rule 39 (assignment_operator -> OR_ASSIGN .)
    NOT             reduce using rule 39 (assignment_operator -> OR_ASSIGN .)
    LPAREN          reduce using rule 39 (assignment_operator -> OR_ASSIGN .)
    DOUBLE_NUMBER   reduce using rule 39 (assignment_operator -> OR_ASSIGN .)
    INT_NUMBER      reduce using rule 39 (assignment_operator -> OR_ASSIGN .)
    CHAR            reduce using rule 39 (assignment_operator -> OR_ASSIGN .)
    STRING          reduce using rule 39 (assignment_operator -> OR_ASSIGN .)
    KEYWORD_NULL    reduce using rule 39 (assignment_operator -> OR_ASSIGN .)
    BOOL_CONSTT     reduce using rule 39 (assignment_operator -> OR_ASSIGN .)
    BOOL_CONSTF     reduce using rule 39 (assignment_operator -> OR_ASSIGN .)


state 179

    (36) assignment_operator -> LSHIFT_ASSIGN .

    IDENTIFIER      reduce using rule 36 (assignment_operator -> LSHIFT_ASSIGN .)
    PLUS            reduce using rule 36 (assignment_operator -> LSHIFT_ASSIGN .)
    MINUS           reduce using rule 36 (assignment_operator -> LSHIFT_ASSIGN .)
    TILDA           reduce using rule 36 (assignment_operator -> LSHIFT_ASSIGN .)
    NOT             reduce using rule 36 (assignment_operator -> LSHIFT_ASSIGN .)
    LPAREN          reduce using rule 36 (assignment_operator -> LSHIFT_ASSIGN .)
    DOUBLE_NUMBER   reduce using rule 36 (assignment_operator -> LSHIFT_ASSIGN .)
    INT_NUMBER      reduce using rule 36 (assignment_operator -> LSHIFT_ASSIGN .)
    CHAR            reduce using rule 36 (assignment_operator -> LSHIFT_ASSIGN .)
    STRING          reduce using rule 36 (assignment_operator -> LSHIFT_ASSIGN .)
    KEYWORD_NULL    reduce using rule 36 (assignment_operator -> LSHIFT_ASSIGN .)
    BOOL_CONSTT     reduce using rule 36 (assignment_operator -> LSHIFT_ASSIGN .)
    BOOL_CONSTF     reduce using rule 36 (assignment_operator -> LSHIFT_ASSIGN .)


state 180

    (38) assignment_operator -> AND_ASSIGN .

    IDENTIFIER      reduce using rule 38 (assignment_operator -> AND_ASSIGN .)
    PLUS            reduce using rule 38 (assignment_operator -> AND_ASSIGN .)
    MINUS           reduce using rule 38 (assignment_operator -> AND_ASSIGN .)
    TILDA           reduce using rule 38 (assignment_operator -> AND_ASSIGN .)
    NOT             reduce using rule 38 (assignment_operator -> AND_ASSIGN .)
    LPAREN          reduce using rule 38 (assignment_operator -> AND_ASSIGN .)
    DOUBLE_NUMBER   reduce using rule 38 (assignment_operator -> AND_ASSIGN .)
    INT_NUMBER      reduce using rule 38 (assignment_operator -> AND_ASSIGN .)
    CHAR            reduce using rule 38 (assignment_operator -> AND_ASSIGN .)
    STRING          reduce using rule 38 (assignment_operator -> AND_ASSIGN .)
    KEYWORD_NULL    reduce using rule 38 (assignment_operator -> AND_ASSIGN .)
    BOOL_CONSTT     reduce using rule 38 (assignment_operator -> AND_ASSIGN .)
    BOOL_CONSTF     reduce using rule 38 (assignment_operator -> AND_ASSIGN .)


state 181

    (32) assignment_operator -> DIVIDE_ASSIGN .

    IDENTIFIER      reduce using rule 32 (assignment_operator -> DIVIDE_ASSIGN .)
    PLUS            reduce using rule 32 (assignment_operator -> DIVIDE_ASSIGN .)
    MINUS           reduce using rule 32 (assignment_operator -> DIVIDE_ASSIGN .)
    TILDA           reduce using rule 32 (assignment_operator -> DIVIDE_ASSIGN .)
    NOT             reduce using rule 32 (assignment_operator -> DIVIDE_ASSIGN .)
    LPAREN          reduce using rule 32 (assignment_operator -> DIVIDE_ASSIGN .)
    DOUBLE_NUMBER   reduce using rule 32 (assignment_operator -> DIVIDE_ASSIGN .)
    INT_NUMBER      reduce using rule 32 (assignment_operator -> DIVIDE_ASSIGN .)
    CHAR            reduce using rule 32 (assignment_operator -> DIVIDE_ASSIGN .)
    STRING          reduce using rule 32 (assignment_operator -> DIVIDE_ASSIGN .)
    KEYWORD_NULL    reduce using rule 32 (assignment_operator -> DIVIDE_ASSIGN .)
    BOOL_CONSTT     reduce using rule 32 (assignment_operator -> DIVIDE_ASSIGN .)
    BOOL_CONSTF     reduce using rule 32 (assignment_operator -> DIVIDE_ASSIGN .)


state 182

    (25) assignment -> valid_variable assignment_operator . assignment_expression
    (22) assignment_expression -> . assignment
    (23) assignment_expression -> . conditional_or_expression
    (24) assignment_expression -> . method_invocation
    (25) assignment -> . valid_variable assignment_operator assignment_expression
    (43) conditional_or_expression -> . conditional_and_expression
    (44) conditional_or_expression -> . conditional_or_expression OR marker conditional_and_expression
    (94) method_invocation -> . name LPAREN argument_list_opt RPAREN
    (26) valid_variable -> . name
    (27) valid_variable -> . array_access
    (45) conditional_and_expression -> . inclusive_or_expression
    (46) conditional_and_expression -> . conditional_and_expression AND marker inclusive_or_expression
    (130) name -> . simple_name
    (131) name -> . qualified_name
    (28) array_access -> . name dimension
    (47) inclusive_or_expression -> . exclusive_or_expression
    (48) inclusive_or_expression -> . inclusive_or_expression OR_BITWISE exclusive_or_expression
    (132) simple_name -> . IDENTIFIER
    (133) qualified_name -> . name INST simple_name
    (49) exclusive_or_expression -> . and_expression
    (50) exclusive_or_expression -> . exclusive_or_expression XOR and_expression
    (51) and_expression -> . equality_expression
    (52) and_expression -> . and_expression AND_BITWISE equality_expression
    (53) equality_expression -> . relational_expression
    (54) equality_expression -> . equality_expression EQUAL relational_expression
    (55) equality_expression -> . equality_expression NEQUAL relational_expression
    (56) relational_expression -> . shift_expression
    (57) relational_expression -> . relational_expression GREATER shift_expression
    (58) relational_expression -> . relational_expression LESS shift_expression
    (59) relational_expression -> . relational_expression GEQ shift_expression
    (60) relational_expression -> . relational_expression LEQ shift_expression
    (61) shift_expression -> . additive_expression
    (62) shift_expression -> . shift_expression LSHIFT additive_expression
    (63) shift_expression -> . shift_expression RSHIFT additive_expression
    (64) additive_expression -> . multiplicative_expression
    (65) additive_expression -> . additive_expression PLUS multiplicative_expression
    (66) additive_expression -> . additive_expression MINUS multiplicative_expression
    (67) multiplicative_expression -> . unary_expression
    (68) multiplicative_expression -> . multiplicative_expression TIMES unary_expression
    (69) multiplicative_expression -> . multiplicative_expression DIVIDE unary_expression
    (70) multiplicative_expression -> . multiplicative_expression REMAINDER unary_expression
    (71) unary_expression -> . PLUS unary_expression
    (72) unary_expression -> . MINUS unary_expression
    (73) unary_expression -> . unary_expression_not_plus_minus
    (74) unary_expression_not_plus_minus -> . base_variable_set
    (75) unary_expression_not_plus_minus -> . TILDA unary_expression
    (76) unary_expression_not_plus_minus -> . cast_expression
    (77) unary_expression_not_plus_minus -> . NOT unary_expression
    (78) base_variable_set -> . variable_literal
    (79) base_variable_set -> . LPAREN expression RPAREN
    (82) cast_expression -> . LPAREN primitive_type RPAREN unary_expression
    (80) variable_literal -> . valid_variable
    (81) variable_literal -> . primary
    (83) primary -> . literal
    (84) primary -> . method_invocation
    (85) literal -> . int_float
    (86) literal -> . c_literal
    (92) int_float -> . DOUBLE_NUMBER
    (93) int_float -> . INT_NUMBER
    (87) c_literal -> . CHAR
    (88) c_literal -> . STRING
    (89) c_literal -> . KEYWORD_NULL
    (90) c_literal -> . BOOL_CONSTT
    (91) c_literal -> . BOOL_CONSTF

    IDENTIFIER      shift and go to state 9
    PLUS            shift and go to state 31
    MINUS           shift and go to state 24
    TILDA           shift and go to state 68
    NOT             shift and go to state 53
    LPAREN          shift and go to state 91
    DOUBLE_NUMBER   shift and go to state 28
    INT_NUMBER      shift and go to state 39
    CHAR            shift and go to state 59
    STRING          shift and go to state 72
    KEYWORD_NULL    shift and go to state 61
    BOOL_CONSTT     shift and go to state 30
    BOOL_CONSTF     shift and go to state 25

    and_expression                 shift and go to state 84
    exclusive_or_expression        shift and go to state 57
    primary                        shift and go to state 58
    unary_expression_not_plus_minus shift and go to state 41
    array_access                   shift and go to state 23
    additive_expression            shift and go to state 62
    simple_name                    shift and go to state 63
    c_literal                      shift and go to state 90
    unary_expression               shift and go to state 40
    base_variable_set              shift and go to state 85
    valid_variable                 shift and go to state 92
    inclusive_or_expression        shift and go to state 27
    literal                        shift and go to state 67
    relational_expression          shift and go to state 69
    method_invocation              shift and go to state 139
    conditional_or_expression      shift and go to state 43
    assignment_expression          shift and go to state 232
    qualified_name                 shift and go to state 75
    assignment                     shift and go to state 142
    multiplicative_expression      shift and go to state 46
    cast_expression                shift and go to state 77
    shift_expression               shift and go to state 50
    equality_expression            shift and go to state 79
    int_float                      shift and go to state 35
    variable_literal               shift and go to state 51
    name                           shift and go to state 38
    conditional_and_expression     shift and go to state 52

state 183

    (34) assignment_operator -> PLUS_ASSIGN .

    IDENTIFIER      reduce using rule 34 (assignment_operator -> PLUS_ASSIGN .)
    PLUS            reduce using rule 34 (assignment_operator -> PLUS_ASSIGN .)
    MINUS           reduce using rule 34 (assignment_operator -> PLUS_ASSIGN .)
    TILDA           reduce using rule 34 (assignment_operator -> PLUS_ASSIGN .)
    NOT             reduce using rule 34 (assignment_operator -> PLUS_ASSIGN .)
    LPAREN          reduce using rule 34 (assignment_operator -> PLUS_ASSIGN .)
    DOUBLE_NUMBER   reduce using rule 34 (assignment_operator -> PLUS_ASSIGN .)
    INT_NUMBER      reduce using rule 34 (assignment_operator -> PLUS_ASSIGN .)
    CHAR            reduce using rule 34 (assignment_operator -> PLUS_ASSIGN .)
    STRING          reduce using rule 34 (assignment_operator -> PLUS_ASSIGN .)
    KEYWORD_NULL    reduce using rule 34 (assignment_operator -> PLUS_ASSIGN .)
    BOOL_CONSTT     reduce using rule 34 (assignment_operator -> PLUS_ASSIGN .)
    BOOL_CONSTF     reduce using rule 34 (assignment_operator -> PLUS_ASSIGN .)


state 184

    (40) assignment_operator -> XOR_ASSIGN .

    IDENTIFIER      reduce using rule 40 (assignment_operator -> XOR_ASSIGN .)
    PLUS            reduce using rule 40 (assignment_operator -> XOR_ASSIGN .)
    MINUS           reduce using rule 40 (assignment_operator -> XOR_ASSIGN .)
    TILDA           reduce using rule 40 (assignment_operator -> XOR_ASSIGN .)
    NOT             reduce using rule 40 (assignment_operator -> XOR_ASSIGN .)
    LPAREN          reduce using rule 40 (assignment_operator -> XOR_ASSIGN .)
    DOUBLE_NUMBER   reduce using rule 40 (assignment_operator -> XOR_ASSIGN .)
    INT_NUMBER      reduce using rule 40 (assignment_operator -> XOR_ASSIGN .)
    CHAR            reduce using rule 40 (assignment_operator -> XOR_ASSIGN .)
    STRING          reduce using rule 40 (assignment_operator -> XOR_ASSIGN .)
    KEYWORD_NULL    reduce using rule 40 (assignment_operator -> XOR_ASSIGN .)
    BOOL_CONSTT     reduce using rule 40 (assignment_operator -> XOR_ASSIGN .)
    BOOL_CONSTF     reduce using rule 40 (assignment_operator -> XOR_ASSIGN .)


state 185

    (158) for_statement -> KEYWORD_FOR LPAREN . for_update RPAREN marker block
    (159) for_update -> . for_loop marker for_step_opts
    (160) for_loop -> . IDENTIFIER CHOOSE expression for_untilTo marker expression

    IDENTIFIER      shift and go to state 235

    for_loop                       shift and go to state 233
    for_update                     shift and go to state 234

state 186

    (157) do_while_statement -> KEYWORD_DO marker . block KEYWORD_WHILE LPAREN marker expression RPAREN TERMINATOR
    (7) block -> . start_scope block_statements_opt end_scope
    (8) start_scope -> . BLOCKBEGIN

    BLOCKBEGIN      shift and go to state 12

    start_scope                    shift and go to state 13
    block                          shift and go to state 236

state 187

    (198) class_body -> class_body_start block_statements_opt end_scope .

    KEYWORD_OBJECT  reduce using rule 198 (class_body -> class_body_start block_statements_opt end_scope .)
    KEYWORD_CLASS   reduce using rule 198 (class_body -> class_body_start block_statements_opt end_scope .)
    $end            reduce using rule 198 (class_body -> class_body_start block_statements_opt end_scope .)
    KEYWORD_IF      reduce using rule 198 (class_body -> class_body_start block_statements_opt end_scope .)
    KEYWORD_WHILE   reduce using rule 198 (class_body -> class_body_start block_statements_opt end_scope .)
    KEYWORD_DO      reduce using rule 198 (class_body -> class_body_start block_statements_opt end_scope .)
    KEYWORD_FOR     reduce using rule 198 (class_body -> class_body_start block_statements_opt end_scope .)
    KEYWORD_VAR     reduce using rule 198 (class_body -> class_body_start block_statements_opt end_scope .)
    KEYWORD_VAL     reduce using rule 198 (class_body -> class_body_start block_statements_opt end_scope .)
    TERMINATOR      reduce using rule 198 (class_body -> class_body_start block_statements_opt end_scope .)
    KEYWORD_RETURN  reduce using rule 198 (class_body -> class_body_start block_statements_opt end_scope .)
    KEYWORD_DEF     reduce using rule 198 (class_body -> class_body_start block_statements_opt end_scope .)
    BLOCKBEGIN      reduce using rule 198 (class_body -> class_body_start block_statements_opt end_scope .)
    IDENTIFIER      reduce using rule 198 (class_body -> class_body_start block_statements_opt end_scope .)
    PLUS            reduce using rule 198 (class_body -> class_body_start block_statements_opt end_scope .)
    MINUS           reduce using rule 198 (class_body -> class_body_start block_statements_opt end_scope .)
    TILDA           reduce using rule 198 (class_body -> class_body_start block_statements_opt end_scope .)
    NOT             reduce using rule 198 (class_body -> class_body_start block_statements_opt end_scope .)
    LPAREN          reduce using rule 198 (class_body -> class_body_start block_statements_opt end_scope .)
    DOUBLE_NUMBER   reduce using rule 198 (class_body -> class_body_start block_statements_opt end_scope .)
    INT_NUMBER      reduce using rule 198 (class_body -> class_body_start block_statements_opt end_scope .)
    CHAR            reduce using rule 198 (class_body -> class_body_start block_statements_opt end_scope .)
    STRING          reduce using rule 198 (class_body -> class_body_start block_statements_opt end_scope .)
    KEYWORD_NULL    reduce using rule 198 (class_body -> class_body_start block_statements_opt end_scope .)
    BOOL_CONSTT     reduce using rule 198 (class_body -> class_body_start block_statements_opt end_scope .)
    BOOL_CONSTF     reduce using rule 198 (class_body -> class_body_start block_statements_opt end_scope .)
    BLOCKEND        reduce using rule 198 (class_body -> class_body_start block_statements_opt end_scope .)


state 188

    (188) class_param_clause -> func_arg_start class_params_opt RPAREN .

    BLOCKBEGIN      reduce using rule 188 (class_param_clause -> func_arg_start class_params_opt RPAREN .)


state 189

    (192) class_params -> class_params COMMA . class_param
    (193) class_param -> . class_declaration_keyword_opt variable_declarator_id
    (194) class_declaration_keyword_opt -> . declaration_keyword
    (195) class_declaration_keyword_opt -> . empty
    (99) declaration_keyword -> . KEYWORD_VAR
    (100) declaration_keyword -> . KEYWORD_VAL
    (200) empty -> .

    KEYWORD_VAR     shift and go to state 47
    KEYWORD_VAL     shift and go to state 48
    IDENTIFIER      reduce using rule 200 (empty -> .)

    declaration_keyword            shift and go to state 98
    class_param                    shift and go to state 237
    class_declaration_keyword_opt  shift and go to state 101
    empty                          shift and go to state 238

state 190

    (116) variable_declarator_id -> IDENTIFIER . COLON type

    COLON           shift and go to state 239


state 191

    (193) class_param -> class_declaration_keyword_opt variable_declarator_id .

    COMMA           reduce using rule 193 (class_param -> class_declaration_keyword_opt variable_declarator_id .)
    RPAREN          reduce using rule 193 (class_param -> class_declaration_keyword_opt variable_declarator_id .)


state 192

    (48) inclusive_or_expression -> inclusive_or_expression OR_BITWISE exclusive_or_expression .
    (50) exclusive_or_expression -> exclusive_or_expression . XOR and_expression

    OR_BITWISE      reduce using rule 48 (inclusive_or_expression -> inclusive_or_expression OR_BITWISE exclusive_or_expression .)
    AND             reduce using rule 48 (inclusive_or_expression -> inclusive_or_expression OR_BITWISE exclusive_or_expression .)
    OR              reduce using rule 48 (inclusive_or_expression -> inclusive_or_expression OR_BITWISE exclusive_or_expression .)
    TERMINATOR      reduce using rule 48 (inclusive_or_expression -> inclusive_or_expression OR_BITWISE exclusive_or_expression .)
    KEYWORD_MATCH   reduce using rule 48 (inclusive_or_expression -> inclusive_or_expression OR_BITWISE exclusive_or_expression .)
    COMMA           reduce using rule 48 (inclusive_or_expression -> inclusive_or_expression OR_BITWISE exclusive_or_expression .)
    RPAREN          reduce using rule 48 (inclusive_or_expression -> inclusive_or_expression OR_BITWISE exclusive_or_expression .)
    FUNTYPE         reduce using rule 48 (inclusive_or_expression -> inclusive_or_expression OR_BITWISE exclusive_or_expression .)
    RBRAC           reduce using rule 48 (inclusive_or_expression -> inclusive_or_expression OR_BITWISE exclusive_or_expression .)
    KEYWORD_UNTIL   reduce using rule 48 (inclusive_or_expression -> inclusive_or_expression OR_BITWISE exclusive_or_expression .)
    KEYWORD_TO      reduce using rule 48 (inclusive_or_expression -> inclusive_or_expression OR_BITWISE exclusive_or_expression .)
    KEYWORD_BY      reduce using rule 48 (inclusive_or_expression -> inclusive_or_expression OR_BITWISE exclusive_or_expression .)
    XOR             shift and go to state 135


state 193

    (179) fun_params -> fun_variable_declarator_id .

    COMMA           reduce using rule 179 (fun_params -> fun_variable_declarator_id .)
    RPAREN          reduce using rule 179 (fun_params -> fun_variable_declarator_id .)


state 194

    (175) method_header -> method_header_name func_arg_start fun_params_opt . RPAREN COLON method_return_type ASOP

    RPAREN          shift and go to state 240


state 195

    (177) fun_params_opt -> fun_params .
    (180) fun_params -> fun_params . COMMA fun_variable_declarator_id

    RPAREN          reduce using rule 177 (fun_params_opt -> fun_params .)
    COMMA           shift and go to state 241


state 196

    (117) fun_variable_declarator_id -> IDENTIFIER . COLON type

    COLON           shift and go to state 242


state 197

    (178) fun_params_opt -> empty .

    RPAREN          reduce using rule 178 (fun_params_opt -> empty .)


state 198

    (29) dimension -> LBRAC expression . RBRAC

    RBRAC           shift and go to state 243


state 199

    (133) qualified_name -> name INST simple_name .

    LPAREN          reduce using rule 133 (qualified_name -> name INST simple_name .)
    INST            reduce using rule 133 (qualified_name -> name INST simple_name .)
    LBRAC           reduce using rule 133 (qualified_name -> name INST simple_name .)
    TIMES           reduce using rule 133 (qualified_name -> name INST simple_name .)
    DIVIDE          reduce using rule 133 (qualified_name -> name INST simple_name .)
    REMAINDER       reduce using rule 133 (qualified_name -> name INST simple_name .)
    PLUS            reduce using rule 133 (qualified_name -> name INST simple_name .)
    MINUS           reduce using rule 133 (qualified_name -> name INST simple_name .)
    LSHIFT          reduce using rule 133 (qualified_name -> name INST simple_name .)
    RSHIFT          reduce using rule 133 (qualified_name -> name INST simple_name .)
    GREATER         reduce using rule 133 (qualified_name -> name INST simple_name .)
    LESS            reduce using rule 133 (qualified_name -> name INST simple_name .)
    GEQ             reduce using rule 133 (qualified_name -> name INST simple_name .)
    LEQ             reduce using rule 133 (qualified_name -> name INST simple_name .)
    EQUAL           reduce using rule 133 (qualified_name -> name INST simple_name .)
    NEQUAL          reduce using rule 133 (qualified_name -> name INST simple_name .)
    AND_BITWISE     reduce using rule 133 (qualified_name -> name INST simple_name .)
    XOR             reduce using rule 133 (qualified_name -> name INST simple_name .)
    OR_BITWISE      reduce using rule 133 (qualified_name -> name INST simple_name .)
    AND             reduce using rule 133 (qualified_name -> name INST simple_name .)
    OR              reduce using rule 133 (qualified_name -> name INST simple_name .)
    KEYWORD_MATCH   reduce using rule 133 (qualified_name -> name INST simple_name .)
    TERMINATOR      reduce using rule 133 (qualified_name -> name INST simple_name .)
    RPAREN          reduce using rule 133 (qualified_name -> name INST simple_name .)
    RBRAC           reduce using rule 133 (qualified_name -> name INST simple_name .)
    COMMA           reduce using rule 133 (qualified_name -> name INST simple_name .)
    FUNTYPE         reduce using rule 133 (qualified_name -> name INST simple_name .)
    KEYWORD_UNTIL   reduce using rule 133 (qualified_name -> name INST simple_name .)
    KEYWORD_TO      reduce using rule 133 (qualified_name -> name INST simple_name .)
    KEYWORD_BY      reduce using rule 133 (qualified_name -> name INST simple_name .)
    ASOP            reduce using rule 133 (qualified_name -> name INST simple_name .)
    TIMES_ASSIGN    reduce using rule 133 (qualified_name -> name INST simple_name .)
    DIVIDE_ASSIGN   reduce using rule 133 (qualified_name -> name INST simple_name .)
    REMAINDER_ASSIGN reduce using rule 133 (qualified_name -> name INST simple_name .)
    PLUS_ASSIGN     reduce using rule 133 (qualified_name -> name INST simple_name .)
    MINUS_ASSIGN    reduce using rule 133 (qualified_name -> name INST simple_name .)
    LSHIFT_ASSIGN   reduce using rule 133 (qualified_name -> name INST simple_name .)
    RSHIFT_ASSIGN   reduce using rule 133 (qualified_name -> name INST simple_name .)
    AND_ASSIGN      reduce using rule 133 (qualified_name -> name INST simple_name .)
    OR_ASSIGN       reduce using rule 133 (qualified_name -> name INST simple_name .)
    XOR_ASSIGN      reduce using rule 133 (qualified_name -> name INST simple_name .)


state 200

    (95) argument_list_opt -> argument_list .
    (98) argument_list -> argument_list . COMMA expression

    RPAREN          reduce using rule 95 (argument_list_opt -> argument_list .)
    COMMA           shift and go to state 244


state 201

    (96) argument_list_opt -> empty .

    RPAREN          reduce using rule 96 (argument_list_opt -> empty .)


state 202

    (94) method_invocation -> name LPAREN argument_list_opt . RPAREN

    RPAREN          shift and go to state 245


state 203

    (97) argument_list -> expression .

    RPAREN          reduce using rule 97 (argument_list -> expression .)
    COMMA           reduce using rule 97 (argument_list -> expression .)


state 204

    (44) conditional_or_expression -> conditional_or_expression OR marker . conditional_and_expression
    (45) conditional_and_expression -> . inclusive_or_expression
    (46) conditional_and_expression -> . conditional_and_expression AND marker inclusive_or_expression
    (47) inclusive_or_expression -> . exclusive_or_expression
    (48) inclusive_or_expression -> . inclusive_or_expression OR_BITWISE exclusive_or_expression
    (49) exclusive_or_expression -> . and_expression
    (50) exclusive_or_expression -> . exclusive_or_expression XOR and_expression
    (51) and_expression -> . equality_expression
    (52) and_expression -> . and_expression AND_BITWISE equality_expression
    (53) equality_expression -> . relational_expression
    (54) equality_expression -> . equality_expression EQUAL relational_expression
    (55) equality_expression -> . equality_expression NEQUAL relational_expression
    (56) relational_expression -> . shift_expression
    (57) relational_expression -> . relational_expression GREATER shift_expression
    (58) relational_expression -> . relational_expression LESS shift_expression
    (59) relational_expression -> . relational_expression GEQ shift_expression
    (60) relational_expression -> . relational_expression LEQ shift_expression
    (61) shift_expression -> . additive_expression
    (62) shift_expression -> . shift_expression LSHIFT additive_expression
    (63) shift_expression -> . shift_expression RSHIFT additive_expression
    (64) additive_expression -> . multiplicative_expression
    (65) additive_expression -> . additive_expression PLUS multiplicative_expression
    (66) additive_expression -> . additive_expression MINUS multiplicative_expression
    (67) multiplicative_expression -> . unary_expression
    (68) multiplicative_expression -> . multiplicative_expression TIMES unary_expression
    (69) multiplicative_expression -> . multiplicative_expression DIVIDE unary_expression
    (70) multiplicative_expression -> . multiplicative_expression REMAINDER unary_expression
    (71) unary_expression -> . PLUS unary_expression
    (72) unary_expression -> . MINUS unary_expression
    (73) unary_expression -> . unary_expression_not_plus_minus
    (74) unary_expression_not_plus_minus -> . base_variable_set
    (75) unary_expression_not_plus_minus -> . TILDA unary_expression
    (76) unary_expression_not_plus_minus -> . cast_expression
    (77) unary_expression_not_plus_minus -> . NOT unary_expression
    (78) base_variable_set -> . variable_literal
    (79) base_variable_set -> . LPAREN expression RPAREN
    (82) cast_expression -> . LPAREN primitive_type RPAREN unary_expression
    (80) variable_literal -> . valid_variable
    (81) variable_literal -> . primary
    (26) valid_variable -> . name
    (27) valid_variable -> . array_access
    (83) primary -> . literal
    (84) primary -> . method_invocation
    (130) name -> . simple_name
    (131) name -> . qualified_name
    (28) array_access -> . name dimension
    (85) literal -> . int_float
    (86) literal -> . c_literal
    (94) method_invocation -> . name LPAREN argument_list_opt RPAREN
    (132) simple_name -> . IDENTIFIER
    (133) qualified_name -> . name INST simple_name
    (92) int_float -> . DOUBLE_NUMBER
    (93) int_float -> . INT_NUMBER
    (87) c_literal -> . CHAR
    (88) c_literal -> . STRING
    (89) c_literal -> . KEYWORD_NULL
    (90) c_literal -> . BOOL_CONSTT
    (91) c_literal -> . BOOL_CONSTF

    PLUS            shift and go to state 31
    MINUS           shift and go to state 24
    TILDA           shift and go to state 68
    NOT             shift and go to state 53
    LPAREN          shift and go to state 91
    IDENTIFIER      shift and go to state 9
    DOUBLE_NUMBER   shift and go to state 28
    INT_NUMBER      shift and go to state 39
    CHAR            shift and go to state 59
    STRING          shift and go to state 72
    KEYWORD_NULL    shift and go to state 61
    BOOL_CONSTT     shift and go to state 30
    BOOL_CONSTF     shift and go to state 25

    unary_expression               shift and go to state 40
    exclusive_or_expression        shift and go to state 57
    primary                        shift and go to state 58
    unary_expression_not_plus_minus shift and go to state 41
    array_access                   shift and go to state 23
    additive_expression            shift and go to state 62
    simple_name                    shift and go to state 63
    c_literal                      shift and go to state 90
    base_variable_set              shift and go to state 85
    valid_variable                 shift and go to state 106
    inclusive_or_expression        shift and go to state 27
    literal                        shift and go to state 67
    and_expression                 shift and go to state 84
    cast_expression                shift and go to state 77
    relational_expression          shift and go to state 69
    qualified_name                 shift and go to state 75
    multiplicative_expression      shift and go to state 46
    method_invocation              shift and go to state 107
    shift_expression               shift and go to state 50
    equality_expression            shift and go to state 79
    int_float                      shift and go to state 35
    variable_literal               shift and go to state 51
    name                           shift and go to state 108
    conditional_and_expression     shift and go to state 246

state 205

    (156) while_statement -> KEYWORD_WHILE LPAREN marker . expression RPAREN marker block
    (19) expression -> . assignment_expression
    (22) assignment_expression -> . assignment
    (23) assignment_expression -> . conditional_or_expression
    (24) assignment_expression -> . method_invocation
    (25) assignment -> . valid_variable assignment_operator assignment_expression
    (43) conditional_or_expression -> . conditional_and_expression
    (44) conditional_or_expression -> . conditional_or_expression OR marker conditional_and_expression
    (94) method_invocation -> . name LPAREN argument_list_opt RPAREN
    (26) valid_variable -> . name
    (27) valid_variable -> . array_access
    (45) conditional_and_expression -> . inclusive_or_expression
    (46) conditional_and_expression -> . conditional_and_expression AND marker inclusive_or_expression
    (130) name -> . simple_name
    (131) name -> . qualified_name
    (28) array_access -> . name dimension
    (47) inclusive_or_expression -> . exclusive_or_expression
    (48) inclusive_or_expression -> . inclusive_or_expression OR_BITWISE exclusive_or_expression
    (132) simple_name -> . IDENTIFIER
    (133) qualified_name -> . name INST simple_name
    (49) exclusive_or_expression -> . and_expression
    (50) exclusive_or_expression -> . exclusive_or_expression XOR and_expression
    (51) and_expression -> . equality_expression
    (52) and_expression -> . and_expression AND_BITWISE equality_expression
    (53) equality_expression -> . relational_expression
    (54) equality_expression -> . equality_expression EQUAL relational_expression
    (55) equality_expression -> . equality_expression NEQUAL relational_expression
    (56) relational_expression -> . shift_expression
    (57) relational_expression -> . relational_expression GREATER shift_expression
    (58) relational_expression -> . relational_expression LESS shift_expression
    (59) relational_expression -> . relational_expression GEQ shift_expression
    (60) relational_expression -> . relational_expression LEQ shift_expression
    (61) shift_expression -> . additive_expression
    (62) shift_expression -> . shift_expression LSHIFT additive_expression
    (63) shift_expression -> . shift_expression RSHIFT additive_expression
    (64) additive_expression -> . multiplicative_expression
    (65) additive_expression -> . additive_expression PLUS multiplicative_expression
    (66) additive_expression -> . additive_expression MINUS multiplicative_expression
    (67) multiplicative_expression -> . unary_expression
    (68) multiplicative_expression -> . multiplicative_expression TIMES unary_expression
    (69) multiplicative_expression -> . multiplicative_expression DIVIDE unary_expression
    (70) multiplicative_expression -> . multiplicative_expression REMAINDER unary_expression
    (71) unary_expression -> . PLUS unary_expression
    (72) unary_expression -> . MINUS unary_expression
    (73) unary_expression -> . unary_expression_not_plus_minus
    (74) unary_expression_not_plus_minus -> . base_variable_set
    (75) unary_expression_not_plus_minus -> . TILDA unary_expression
    (76) unary_expression_not_plus_minus -> . cast_expression
    (77) unary_expression_not_plus_minus -> . NOT unary_expression
    (78) base_variable_set -> . variable_literal
    (79) base_variable_set -> . LPAREN expression RPAREN
    (82) cast_expression -> . LPAREN primitive_type RPAREN unary_expression
    (80) variable_literal -> . valid_variable
    (81) variable_literal -> . primary
    (83) primary -> . literal
    (84) primary -> . method_invocation
    (85) literal -> . int_float
    (86) literal -> . c_literal
    (92) int_float -> . DOUBLE_NUMBER
    (93) int_float -> . INT_NUMBER
    (87) c_literal -> . CHAR
    (88) c_literal -> . STRING
    (89) c_literal -> . KEYWORD_NULL
    (90) c_literal -> . BOOL_CONSTT
    (91) c_literal -> . BOOL_CONSTF

    IDENTIFIER      shift and go to state 9
    PLUS            shift and go to state 31
    MINUS           shift and go to state 24
    TILDA           shift and go to state 68
    NOT             shift and go to state 53
    LPAREN          shift and go to state 91
    DOUBLE_NUMBER   shift and go to state 28
    INT_NUMBER      shift and go to state 39
    CHAR            shift and go to state 59
    STRING          shift and go to state 72
    KEYWORD_NULL    shift and go to state 61
    BOOL_CONSTT     shift and go to state 30
    BOOL_CONSTF     shift and go to state 25

    unary_expression               shift and go to state 40
    exclusive_or_expression        shift and go to state 57
    primary                        shift and go to state 58
    unary_expression_not_plus_minus shift and go to state 41
    array_access                   shift and go to state 23
    and_expression                 shift and go to state 84
    simple_name                    shift and go to state 63
    c_literal                      shift and go to state 90
    base_variable_set              shift and go to state 85
    valid_variable                 shift and go to state 92
    inclusive_or_expression        shift and go to state 27
    literal                        shift and go to state 67
    relational_expression          shift and go to state 69
    method_invocation              shift and go to state 139
    conditional_or_expression      shift and go to state 43
    assignment_expression          shift and go to state 88
    qualified_name                 shift and go to state 75
    assignment                     shift and go to state 142
    multiplicative_expression      shift and go to state 46
    additive_expression            shift and go to state 62
    cast_expression                shift and go to state 77
    shift_expression               shift and go to state 50
    equality_expression            shift and go to state 79
    int_float                      shift and go to state 35
    variable_literal               shift and go to state 51
    name                           shift and go to state 38
    expression                     shift and go to state 247
    conditional_and_expression     shift and go to state 52

state 206

    (70) multiplicative_expression -> multiplicative_expression REMAINDER unary_expression .

    TIMES           reduce using rule 70 (multiplicative_expression -> multiplicative_expression REMAINDER unary_expression .)
    DIVIDE          reduce using rule 70 (multiplicative_expression -> multiplicative_expression REMAINDER unary_expression .)
    REMAINDER       reduce using rule 70 (multiplicative_expression -> multiplicative_expression REMAINDER unary_expression .)
    PLUS            reduce using rule 70 (multiplicative_expression -> multiplicative_expression REMAINDER unary_expression .)
    MINUS           reduce using rule 70 (multiplicative_expression -> multiplicative_expression REMAINDER unary_expression .)
    LSHIFT          reduce using rule 70 (multiplicative_expression -> multiplicative_expression REMAINDER unary_expression .)
    RSHIFT          reduce using rule 70 (multiplicative_expression -> multiplicative_expression REMAINDER unary_expression .)
    GREATER         reduce using rule 70 (multiplicative_expression -> multiplicative_expression REMAINDER unary_expression .)
    LESS            reduce using rule 70 (multiplicative_expression -> multiplicative_expression REMAINDER unary_expression .)
    GEQ             reduce using rule 70 (multiplicative_expression -> multiplicative_expression REMAINDER unary_expression .)
    LEQ             reduce using rule 70 (multiplicative_expression -> multiplicative_expression REMAINDER unary_expression .)
    EQUAL           reduce using rule 70 (multiplicative_expression -> multiplicative_expression REMAINDER unary_expression .)
    NEQUAL          reduce using rule 70 (multiplicative_expression -> multiplicative_expression REMAINDER unary_expression .)
    AND_BITWISE     reduce using rule 70 (multiplicative_expression -> multiplicative_expression REMAINDER unary_expression .)
    XOR             reduce using rule 70 (multiplicative_expression -> multiplicative_expression REMAINDER unary_expression .)
    OR_BITWISE      reduce using rule 70 (multiplicative_expression -> multiplicative_expression REMAINDER unary_expression .)
    AND             reduce using rule 70 (multiplicative_expression -> multiplicative_expression REMAINDER unary_expression .)
    OR              reduce using rule 70 (multiplicative_expression -> multiplicative_expression REMAINDER unary_expression .)
    FUNTYPE         reduce using rule 70 (multiplicative_expression -> multiplicative_expression REMAINDER unary_expression .)
    KEYWORD_MATCH   reduce using rule 70 (multiplicative_expression -> multiplicative_expression REMAINDER unary_expression .)
    COMMA           reduce using rule 70 (multiplicative_expression -> multiplicative_expression REMAINDER unary_expression .)
    RPAREN          reduce using rule 70 (multiplicative_expression -> multiplicative_expression REMAINDER unary_expression .)
    TERMINATOR      reduce using rule 70 (multiplicative_expression -> multiplicative_expression REMAINDER unary_expression .)
    RBRAC           reduce using rule 70 (multiplicative_expression -> multiplicative_expression REMAINDER unary_expression .)
    KEYWORD_UNTIL   reduce using rule 70 (multiplicative_expression -> multiplicative_expression REMAINDER unary_expression .)
    KEYWORD_TO      reduce using rule 70 (multiplicative_expression -> multiplicative_expression REMAINDER unary_expression .)
    KEYWORD_BY      reduce using rule 70 (multiplicative_expression -> multiplicative_expression REMAINDER unary_expression .)


state 207

    (69) multiplicative_expression -> multiplicative_expression DIVIDE unary_expression .

    TIMES           reduce using rule 69 (multiplicative_expression -> multiplicative_expression DIVIDE unary_expression .)
    DIVIDE          reduce using rule 69 (multiplicative_expression -> multiplicative_expression DIVIDE unary_expression .)
    REMAINDER       reduce using rule 69 (multiplicative_expression -> multiplicative_expression DIVIDE unary_expression .)
    PLUS            reduce using rule 69 (multiplicative_expression -> multiplicative_expression DIVIDE unary_expression .)
    MINUS           reduce using rule 69 (multiplicative_expression -> multiplicative_expression DIVIDE unary_expression .)
    LSHIFT          reduce using rule 69 (multiplicative_expression -> multiplicative_expression DIVIDE unary_expression .)
    RSHIFT          reduce using rule 69 (multiplicative_expression -> multiplicative_expression DIVIDE unary_expression .)
    GREATER         reduce using rule 69 (multiplicative_expression -> multiplicative_expression DIVIDE unary_expression .)
    LESS            reduce using rule 69 (multiplicative_expression -> multiplicative_expression DIVIDE unary_expression .)
    GEQ             reduce using rule 69 (multiplicative_expression -> multiplicative_expression DIVIDE unary_expression .)
    LEQ             reduce using rule 69 (multiplicative_expression -> multiplicative_expression DIVIDE unary_expression .)
    EQUAL           reduce using rule 69 (multiplicative_expression -> multiplicative_expression DIVIDE unary_expression .)
    NEQUAL          reduce using rule 69 (multiplicative_expression -> multiplicative_expression DIVIDE unary_expression .)
    AND_BITWISE     reduce using rule 69 (multiplicative_expression -> multiplicative_expression DIVIDE unary_expression .)
    XOR             reduce using rule 69 (multiplicative_expression -> multiplicative_expression DIVIDE unary_expression .)
    OR_BITWISE      reduce using rule 69 (multiplicative_expression -> multiplicative_expression DIVIDE unary_expression .)
    AND             reduce using rule 69 (multiplicative_expression -> multiplicative_expression DIVIDE unary_expression .)
    OR              reduce using rule 69 (multiplicative_expression -> multiplicative_expression DIVIDE unary_expression .)
    FUNTYPE         reduce using rule 69 (multiplicative_expression -> multiplicative_expression DIVIDE unary_expression .)
    KEYWORD_MATCH   reduce using rule 69 (multiplicative_expression -> multiplicative_expression DIVIDE unary_expression .)
    COMMA           reduce using rule 69 (multiplicative_expression -> multiplicative_expression DIVIDE unary_expression .)
    RPAREN          reduce using rule 69 (multiplicative_expression -> multiplicative_expression DIVIDE unary_expression .)
    TERMINATOR      reduce using rule 69 (multiplicative_expression -> multiplicative_expression DIVIDE unary_expression .)
    RBRAC           reduce using rule 69 (multiplicative_expression -> multiplicative_expression DIVIDE unary_expression .)
    KEYWORD_UNTIL   reduce using rule 69 (multiplicative_expression -> multiplicative_expression DIVIDE unary_expression .)
    KEYWORD_TO      reduce using rule 69 (multiplicative_expression -> multiplicative_expression DIVIDE unary_expression .)
    KEYWORD_BY      reduce using rule 69 (multiplicative_expression -> multiplicative_expression DIVIDE unary_expression .)


state 208

    (68) multiplicative_expression -> multiplicative_expression TIMES unary_expression .

    TIMES           reduce using rule 68 (multiplicative_expression -> multiplicative_expression TIMES unary_expression .)
    DIVIDE          reduce using rule 68 (multiplicative_expression -> multiplicative_expression TIMES unary_expression .)
    REMAINDER       reduce using rule 68 (multiplicative_expression -> multiplicative_expression TIMES unary_expression .)
    PLUS            reduce using rule 68 (multiplicative_expression -> multiplicative_expression TIMES unary_expression .)
    MINUS           reduce using rule 68 (multiplicative_expression -> multiplicative_expression TIMES unary_expression .)
    LSHIFT          reduce using rule 68 (multiplicative_expression -> multiplicative_expression TIMES unary_expression .)
    RSHIFT          reduce using rule 68 (multiplicative_expression -> multiplicative_expression TIMES unary_expression .)
    GREATER         reduce using rule 68 (multiplicative_expression -> multiplicative_expression TIMES unary_expression .)
    LESS            reduce using rule 68 (multiplicative_expression -> multiplicative_expression TIMES unary_expression .)
    GEQ             reduce using rule 68 (multiplicative_expression -> multiplicative_expression TIMES unary_expression .)
    LEQ             reduce using rule 68 (multiplicative_expression -> multiplicative_expression TIMES unary_expression .)
    EQUAL           reduce using rule 68 (multiplicative_expression -> multiplicative_expression TIMES unary_expression .)
    NEQUAL          reduce using rule 68 (multiplicative_expression -> multiplicative_expression TIMES unary_expression .)
    AND_BITWISE     reduce using rule 68 (multiplicative_expression -> multiplicative_expression TIMES unary_expression .)
    XOR             reduce using rule 68 (multiplicative_expression -> multiplicative_expression TIMES unary_expression .)
    OR_BITWISE      reduce using rule 68 (multiplicative_expression -> multiplicative_expression TIMES unary_expression .)
    AND             reduce using rule 68 (multiplicative_expression -> multiplicative_expression TIMES unary_expression .)
    OR              reduce using rule 68 (multiplicative_expression -> multiplicative_expression TIMES unary_expression .)
    FUNTYPE         reduce using rule 68 (multiplicative_expression -> multiplicative_expression TIMES unary_expression .)
    KEYWORD_MATCH   reduce using rule 68 (multiplicative_expression -> multiplicative_expression TIMES unary_expression .)
    COMMA           reduce using rule 68 (multiplicative_expression -> multiplicative_expression TIMES unary_expression .)
    RPAREN          reduce using rule 68 (multiplicative_expression -> multiplicative_expression TIMES unary_expression .)
    TERMINATOR      reduce using rule 68 (multiplicative_expression -> multiplicative_expression TIMES unary_expression .)
    RBRAC           reduce using rule 68 (multiplicative_expression -> multiplicative_expression TIMES unary_expression .)
    KEYWORD_UNTIL   reduce using rule 68 (multiplicative_expression -> multiplicative_expression TIMES unary_expression .)
    KEYWORD_TO      reduce using rule 68 (multiplicative_expression -> multiplicative_expression TIMES unary_expression .)
    KEYWORD_BY      reduce using rule 68 (multiplicative_expression -> multiplicative_expression TIMES unary_expression .)


state 209

    (63) shift_expression -> shift_expression RSHIFT additive_expression .
    (65) additive_expression -> additive_expression . PLUS multiplicative_expression
    (66) additive_expression -> additive_expression . MINUS multiplicative_expression

    LSHIFT          reduce using rule 63 (shift_expression -> shift_expression RSHIFT additive_expression .)
    RSHIFT          reduce using rule 63 (shift_expression -> shift_expression RSHIFT additive_expression .)
    GREATER         reduce using rule 63 (shift_expression -> shift_expression RSHIFT additive_expression .)
    LESS            reduce using rule 63 (shift_expression -> shift_expression RSHIFT additive_expression .)
    GEQ             reduce using rule 63 (shift_expression -> shift_expression RSHIFT additive_expression .)
    LEQ             reduce using rule 63 (shift_expression -> shift_expression RSHIFT additive_expression .)
    EQUAL           reduce using rule 63 (shift_expression -> shift_expression RSHIFT additive_expression .)
    NEQUAL          reduce using rule 63 (shift_expression -> shift_expression RSHIFT additive_expression .)
    AND_BITWISE     reduce using rule 63 (shift_expression -> shift_expression RSHIFT additive_expression .)
    XOR             reduce using rule 63 (shift_expression -> shift_expression RSHIFT additive_expression .)
    OR_BITWISE      reduce using rule 63 (shift_expression -> shift_expression RSHIFT additive_expression .)
    AND             reduce using rule 63 (shift_expression -> shift_expression RSHIFT additive_expression .)
    OR              reduce using rule 63 (shift_expression -> shift_expression RSHIFT additive_expression .)
    COMMA           reduce using rule 63 (shift_expression -> shift_expression RSHIFT additive_expression .)
    RPAREN          reduce using rule 63 (shift_expression -> shift_expression RSHIFT additive_expression .)
    KEYWORD_MATCH   reduce using rule 63 (shift_expression -> shift_expression RSHIFT additive_expression .)
    TERMINATOR      reduce using rule 63 (shift_expression -> shift_expression RSHIFT additive_expression .)
    RBRAC           reduce using rule 63 (shift_expression -> shift_expression RSHIFT additive_expression .)
    FUNTYPE         reduce using rule 63 (shift_expression -> shift_expression RSHIFT additive_expression .)
    KEYWORD_UNTIL   reduce using rule 63 (shift_expression -> shift_expression RSHIFT additive_expression .)
    KEYWORD_TO      reduce using rule 63 (shift_expression -> shift_expression RSHIFT additive_expression .)
    KEYWORD_BY      reduce using rule 63 (shift_expression -> shift_expression RSHIFT additive_expression .)
    PLUS            shift and go to state 137
    MINUS           shift and go to state 138


state 210

    (62) shift_expression -> shift_expression LSHIFT additive_expression .
    (65) additive_expression -> additive_expression . PLUS multiplicative_expression
    (66) additive_expression -> additive_expression . MINUS multiplicative_expression

    LSHIFT          reduce using rule 62 (shift_expression -> shift_expression LSHIFT additive_expression .)
    RSHIFT          reduce using rule 62 (shift_expression -> shift_expression LSHIFT additive_expression .)
    GREATER         reduce using rule 62 (shift_expression -> shift_expression LSHIFT additive_expression .)
    LESS            reduce using rule 62 (shift_expression -> shift_expression LSHIFT additive_expression .)
    GEQ             reduce using rule 62 (shift_expression -> shift_expression LSHIFT additive_expression .)
    LEQ             reduce using rule 62 (shift_expression -> shift_expression LSHIFT additive_expression .)
    EQUAL           reduce using rule 62 (shift_expression -> shift_expression LSHIFT additive_expression .)
    NEQUAL          reduce using rule 62 (shift_expression -> shift_expression LSHIFT additive_expression .)
    AND_BITWISE     reduce using rule 62 (shift_expression -> shift_expression LSHIFT additive_expression .)
    XOR             reduce using rule 62 (shift_expression -> shift_expression LSHIFT additive_expression .)
    OR_BITWISE      reduce using rule 62 (shift_expression -> shift_expression LSHIFT additive_expression .)
    AND             reduce using rule 62 (shift_expression -> shift_expression LSHIFT additive_expression .)
    OR              reduce using rule 62 (shift_expression -> shift_expression LSHIFT additive_expression .)
    COMMA           reduce using rule 62 (shift_expression -> shift_expression LSHIFT additive_expression .)
    RPAREN          reduce using rule 62 (shift_expression -> shift_expression LSHIFT additive_expression .)
    KEYWORD_MATCH   reduce using rule 62 (shift_expression -> shift_expression LSHIFT additive_expression .)
    TERMINATOR      reduce using rule 62 (shift_expression -> shift_expression LSHIFT additive_expression .)
    RBRAC           reduce using rule 62 (shift_expression -> shift_expression LSHIFT additive_expression .)
    FUNTYPE         reduce using rule 62 (shift_expression -> shift_expression LSHIFT additive_expression .)
    KEYWORD_UNTIL   reduce using rule 62 (shift_expression -> shift_expression LSHIFT additive_expression .)
    KEYWORD_TO      reduce using rule 62 (shift_expression -> shift_expression LSHIFT additive_expression .)
    KEYWORD_BY      reduce using rule 62 (shift_expression -> shift_expression LSHIFT additive_expression .)
    PLUS            shift and go to state 137
    MINUS           shift and go to state 138


state 211

    (46) conditional_and_expression -> conditional_and_expression AND marker . inclusive_or_expression
    (47) inclusive_or_expression -> . exclusive_or_expression
    (48) inclusive_or_expression -> . inclusive_or_expression OR_BITWISE exclusive_or_expression
    (49) exclusive_or_expression -> . and_expression
    (50) exclusive_or_expression -> . exclusive_or_expression XOR and_expression
    (51) and_expression -> . equality_expression
    (52) and_expression -> . and_expression AND_BITWISE equality_expression
    (53) equality_expression -> . relational_expression
    (54) equality_expression -> . equality_expression EQUAL relational_expression
    (55) equality_expression -> . equality_expression NEQUAL relational_expression
    (56) relational_expression -> . shift_expression
    (57) relational_expression -> . relational_expression GREATER shift_expression
    (58) relational_expression -> . relational_expression LESS shift_expression
    (59) relational_expression -> . relational_expression GEQ shift_expression
    (60) relational_expression -> . relational_expression LEQ shift_expression
    (61) shift_expression -> . additive_expression
    (62) shift_expression -> . shift_expression LSHIFT additive_expression
    (63) shift_expression -> . shift_expression RSHIFT additive_expression
    (64) additive_expression -> . multiplicative_expression
    (65) additive_expression -> . additive_expression PLUS multiplicative_expression
    (66) additive_expression -> . additive_expression MINUS multiplicative_expression
    (67) multiplicative_expression -> . unary_expression
    (68) multiplicative_expression -> . multiplicative_expression TIMES unary_expression
    (69) multiplicative_expression -> . multiplicative_expression DIVIDE unary_expression
    (70) multiplicative_expression -> . multiplicative_expression REMAINDER unary_expression
    (71) unary_expression -> . PLUS unary_expression
    (72) unary_expression -> . MINUS unary_expression
    (73) unary_expression -> . unary_expression_not_plus_minus
    (74) unary_expression_not_plus_minus -> . base_variable_set
    (75) unary_expression_not_plus_minus -> . TILDA unary_expression
    (76) unary_expression_not_plus_minus -> . cast_expression
    (77) unary_expression_not_plus_minus -> . NOT unary_expression
    (78) base_variable_set -> . variable_literal
    (79) base_variable_set -> . LPAREN expression RPAREN
    (82) cast_expression -> . LPAREN primitive_type RPAREN unary_expression
    (80) variable_literal -> . valid_variable
    (81) variable_literal -> . primary
    (26) valid_variable -> . name
    (27) valid_variable -> . array_access
    (83) primary -> . literal
    (84) primary -> . method_invocation
    (130) name -> . simple_name
    (131) name -> . qualified_name
    (28) array_access -> . name dimension
    (85) literal -> . int_float
    (86) literal -> . c_literal
    (94) method_invocation -> . name LPAREN argument_list_opt RPAREN
    (132) simple_name -> . IDENTIFIER
    (133) qualified_name -> . name INST simple_name
    (92) int_float -> . DOUBLE_NUMBER
    (93) int_float -> . INT_NUMBER
    (87) c_literal -> . CHAR
    (88) c_literal -> . STRING
    (89) c_literal -> . KEYWORD_NULL
    (90) c_literal -> . BOOL_CONSTT
    (91) c_literal -> . BOOL_CONSTF

    PLUS            shift and go to state 31
    MINUS           shift and go to state 24
    TILDA           shift and go to state 68
    NOT             shift and go to state 53
    LPAREN          shift and go to state 91
    IDENTIFIER      shift and go to state 9
    DOUBLE_NUMBER   shift and go to state 28
    INT_NUMBER      shift and go to state 39
    CHAR            shift and go to state 59
    STRING          shift and go to state 72
    KEYWORD_NULL    shift and go to state 61
    BOOL_CONSTT     shift and go to state 30
    BOOL_CONSTF     shift and go to state 25

    unary_expression               shift and go to state 40
    exclusive_or_expression        shift and go to state 57
    primary                        shift and go to state 58
    unary_expression_not_plus_minus shift and go to state 41
    array_access                   shift and go to state 23
    additive_expression            shift and go to state 62
    simple_name                    shift and go to state 63
    c_literal                      shift and go to state 90
    base_variable_set              shift and go to state 85
    valid_variable                 shift and go to state 106
    inclusive_or_expression        shift and go to state 248
    literal                        shift and go to state 67
    and_expression                 shift and go to state 84
    cast_expression                shift and go to state 77
    relational_expression          shift and go to state 69
    qualified_name                 shift and go to state 75
    multiplicative_expression      shift and go to state 46
    method_invocation              shift and go to state 107
    shift_expression               shift and go to state 50
    equality_expression            shift and go to state 79
    int_float                      shift and go to state 35
    variable_literal               shift and go to state 51
    name                           shift and go to state 108

state 212

    (166) switch_block -> BLOCKBEGIN . BLOCKEND
    (167) switch_block -> BLOCKBEGIN . switch_block_statements BLOCKEND
    (168) switch_block_statements -> . switch_block_statement marker
    (169) switch_block_statements -> . switch_block_statements switch_block_statement marker
    (170) switch_block_statement -> . switch_label narker marker block narker
    (171) switch_label -> . KEYWORD_CASE expression FUNTYPE

    BLOCKEND        shift and go to state 251
    KEYWORD_CASE    shift and go to state 250

    switch_block_statement         shift and go to state 253
    switch_label                   shift and go to state 249
    switch_block_statements        shift and go to state 252

state 213

    (165) switch_statement -> expression KEYWORD_MATCH switch_block . marker
    (41) marker -> . empty
    (200) empty -> .

    KEYWORD_IF      reduce using rule 200 (empty -> .)
    KEYWORD_WHILE   reduce using rule 200 (empty -> .)
    KEYWORD_DO      reduce using rule 200 (empty -> .)
    KEYWORD_FOR     reduce using rule 200 (empty -> .)
    KEYWORD_CLASS   reduce using rule 200 (empty -> .)
    KEYWORD_OBJECT  reduce using rule 200 (empty -> .)
    KEYWORD_VAR     reduce using rule 200 (empty -> .)
    KEYWORD_VAL     reduce using rule 200 (empty -> .)
    TERMINATOR      reduce using rule 200 (empty -> .)
    KEYWORD_RETURN  reduce using rule 200 (empty -> .)
    KEYWORD_DEF     reduce using rule 200 (empty -> .)
    BLOCKBEGIN      reduce using rule 200 (empty -> .)
    IDENTIFIER      reduce using rule 200 (empty -> .)
    PLUS            reduce using rule 200 (empty -> .)
    MINUS           reduce using rule 200 (empty -> .)
    TILDA           reduce using rule 200 (empty -> .)
    NOT             reduce using rule 200 (empty -> .)
    LPAREN          reduce using rule 200 (empty -> .)
    DOUBLE_NUMBER   reduce using rule 200 (empty -> .)
    INT_NUMBER      reduce using rule 200 (empty -> .)
    CHAR            reduce using rule 200 (empty -> .)
    STRING          reduce using rule 200 (empty -> .)
    KEYWORD_NULL    reduce using rule 200 (empty -> .)
    BOOL_CONSTT     reduce using rule 200 (empty -> .)
    BOOL_CONSTF     reduce using rule 200 (empty -> .)
    BLOCKEND        reduce using rule 200 (empty -> .)
    KEYWORD_ELSE    reduce using rule 200 (empty -> .)

    marker                         shift and go to state 254
    empty                          shift and go to state 104

state 214

    (50) exclusive_or_expression -> exclusive_or_expression XOR and_expression .
    (52) and_expression -> and_expression . AND_BITWISE equality_expression

    XOR             reduce using rule 50 (exclusive_or_expression -> exclusive_or_expression XOR and_expression .)
    OR_BITWISE      reduce using rule 50 (exclusive_or_expression -> exclusive_or_expression XOR and_expression .)
    AND             reduce using rule 50 (exclusive_or_expression -> exclusive_or_expression XOR and_expression .)
    OR              reduce using rule 50 (exclusive_or_expression -> exclusive_or_expression XOR and_expression .)
    COMMA           reduce using rule 50 (exclusive_or_expression -> exclusive_or_expression XOR and_expression .)
    RPAREN          reduce using rule 50 (exclusive_or_expression -> exclusive_or_expression XOR and_expression .)
    TERMINATOR      reduce using rule 50 (exclusive_or_expression -> exclusive_or_expression XOR and_expression .)
    KEYWORD_MATCH   reduce using rule 50 (exclusive_or_expression -> exclusive_or_expression XOR and_expression .)
    RBRAC           reduce using rule 50 (exclusive_or_expression -> exclusive_or_expression XOR and_expression .)
    FUNTYPE         reduce using rule 50 (exclusive_or_expression -> exclusive_or_expression XOR and_expression .)
    KEYWORD_UNTIL   reduce using rule 50 (exclusive_or_expression -> exclusive_or_expression XOR and_expression .)
    KEYWORD_TO      reduce using rule 50 (exclusive_or_expression -> exclusive_or_expression XOR and_expression .)
    KEYWORD_BY      reduce using rule 50 (exclusive_or_expression -> exclusive_or_expression XOR and_expression .)
    AND_BITWISE     shift and go to state 162


state 215

    (65) additive_expression -> additive_expression PLUS multiplicative_expression .
    (68) multiplicative_expression -> multiplicative_expression . TIMES unary_expression
    (69) multiplicative_expression -> multiplicative_expression . DIVIDE unary_expression
    (70) multiplicative_expression -> multiplicative_expression . REMAINDER unary_expression

    PLUS            reduce using rule 65 (additive_expression -> additive_expression PLUS multiplicative_expression .)
    MINUS           reduce using rule 65 (additive_expression -> additive_expression PLUS multiplicative_expression .)
    LSHIFT          reduce using rule 65 (additive_expression -> additive_expression PLUS multiplicative_expression .)
    RSHIFT          reduce using rule 65 (additive_expression -> additive_expression PLUS multiplicative_expression .)
    GREATER         reduce using rule 65 (additive_expression -> additive_expression PLUS multiplicative_expression .)
    LESS            reduce using rule 65 (additive_expression -> additive_expression PLUS multiplicative_expression .)
    GEQ             reduce using rule 65 (additive_expression -> additive_expression PLUS multiplicative_expression .)
    LEQ             reduce using rule 65 (additive_expression -> additive_expression PLUS multiplicative_expression .)
    EQUAL           reduce using rule 65 (additive_expression -> additive_expression PLUS multiplicative_expression .)
    NEQUAL          reduce using rule 65 (additive_expression -> additive_expression PLUS multiplicative_expression .)
    AND_BITWISE     reduce using rule 65 (additive_expression -> additive_expression PLUS multiplicative_expression .)
    XOR             reduce using rule 65 (additive_expression -> additive_expression PLUS multiplicative_expression .)
    OR_BITWISE      reduce using rule 65 (additive_expression -> additive_expression PLUS multiplicative_expression .)
    AND             reduce using rule 65 (additive_expression -> additive_expression PLUS multiplicative_expression .)
    OR              reduce using rule 65 (additive_expression -> additive_expression PLUS multiplicative_expression .)
    COMMA           reduce using rule 65 (additive_expression -> additive_expression PLUS multiplicative_expression .)
    RPAREN          reduce using rule 65 (additive_expression -> additive_expression PLUS multiplicative_expression .)
    KEYWORD_MATCH   reduce using rule 65 (additive_expression -> additive_expression PLUS multiplicative_expression .)
    TERMINATOR      reduce using rule 65 (additive_expression -> additive_expression PLUS multiplicative_expression .)
    RBRAC           reduce using rule 65 (additive_expression -> additive_expression PLUS multiplicative_expression .)
    FUNTYPE         reduce using rule 65 (additive_expression -> additive_expression PLUS multiplicative_expression .)
    KEYWORD_UNTIL   reduce using rule 65 (additive_expression -> additive_expression PLUS multiplicative_expression .)
    KEYWORD_TO      reduce using rule 65 (additive_expression -> additive_expression PLUS multiplicative_expression .)
    KEYWORD_BY      reduce using rule 65 (additive_expression -> additive_expression PLUS multiplicative_expression .)
    TIMES           shift and go to state 127
    DIVIDE          shift and go to state 126
    REMAINDER       shift and go to state 125


state 216

    (66) additive_expression -> additive_expression MINUS multiplicative_expression .
    (68) multiplicative_expression -> multiplicative_expression . TIMES unary_expression
    (69) multiplicative_expression -> multiplicative_expression . DIVIDE unary_expression
    (70) multiplicative_expression -> multiplicative_expression . REMAINDER unary_expression

    PLUS            reduce using rule 66 (additive_expression -> additive_expression MINUS multiplicative_expression .)
    MINUS           reduce using rule 66 (additive_expression -> additive_expression MINUS multiplicative_expression .)
    LSHIFT          reduce using rule 66 (additive_expression -> additive_expression MINUS multiplicative_expression .)
    RSHIFT          reduce using rule 66 (additive_expression -> additive_expression MINUS multiplicative_expression .)
    GREATER         reduce using rule 66 (additive_expression -> additive_expression MINUS multiplicative_expression .)
    LESS            reduce using rule 66 (additive_expression -> additive_expression MINUS multiplicative_expression .)
    GEQ             reduce using rule 66 (additive_expression -> additive_expression MINUS multiplicative_expression .)
    LEQ             reduce using rule 66 (additive_expression -> additive_expression MINUS multiplicative_expression .)
    EQUAL           reduce using rule 66 (additive_expression -> additive_expression MINUS multiplicative_expression .)
    NEQUAL          reduce using rule 66 (additive_expression -> additive_expression MINUS multiplicative_expression .)
    AND_BITWISE     reduce using rule 66 (additive_expression -> additive_expression MINUS multiplicative_expression .)
    XOR             reduce using rule 66 (additive_expression -> additive_expression MINUS multiplicative_expression .)
    OR_BITWISE      reduce using rule 66 (additive_expression -> additive_expression MINUS multiplicative_expression .)
    AND             reduce using rule 66 (additive_expression -> additive_expression MINUS multiplicative_expression .)
    OR              reduce using rule 66 (additive_expression -> additive_expression MINUS multiplicative_expression .)
    COMMA           reduce using rule 66 (additive_expression -> additive_expression MINUS multiplicative_expression .)
    RPAREN          reduce using rule 66 (additive_expression -> additive_expression MINUS multiplicative_expression .)
    KEYWORD_MATCH   reduce using rule 66 (additive_expression -> additive_expression MINUS multiplicative_expression .)
    TERMINATOR      reduce using rule 66 (additive_expression -> additive_expression MINUS multiplicative_expression .)
    RBRAC           reduce using rule 66 (additive_expression -> additive_expression MINUS multiplicative_expression .)
    FUNTYPE         reduce using rule 66 (additive_expression -> additive_expression MINUS multiplicative_expression .)
    KEYWORD_UNTIL   reduce using rule 66 (additive_expression -> additive_expression MINUS multiplicative_expression .)
    KEYWORD_TO      reduce using rule 66 (additive_expression -> additive_expression MINUS multiplicative_expression .)
    KEYWORD_BY      reduce using rule 66 (additive_expression -> additive_expression MINUS multiplicative_expression .)
    TIMES           shift and go to state 127
    DIVIDE          shift and go to state 126
    REMAINDER       shift and go to state 125


state 217

    (173) return_statement -> KEYWORD_RETURN expression_optional TERMINATOR .

    KEYWORD_IF      reduce using rule 173 (return_statement -> KEYWORD_RETURN expression_optional TERMINATOR .)
    KEYWORD_WHILE   reduce using rule 173 (return_statement -> KEYWORD_RETURN expression_optional TERMINATOR .)
    KEYWORD_DO      reduce using rule 173 (return_statement -> KEYWORD_RETURN expression_optional TERMINATOR .)
    KEYWORD_FOR     reduce using rule 173 (return_statement -> KEYWORD_RETURN expression_optional TERMINATOR .)
    KEYWORD_CLASS   reduce using rule 173 (return_statement -> KEYWORD_RETURN expression_optional TERMINATOR .)
    KEYWORD_OBJECT  reduce using rule 173 (return_statement -> KEYWORD_RETURN expression_optional TERMINATOR .)
    KEYWORD_VAR     reduce using rule 173 (return_statement -> KEYWORD_RETURN expression_optional TERMINATOR .)
    KEYWORD_VAL     reduce using rule 173 (return_statement -> KEYWORD_RETURN expression_optional TERMINATOR .)
    TERMINATOR      reduce using rule 173 (return_statement -> KEYWORD_RETURN expression_optional TERMINATOR .)
    KEYWORD_RETURN  reduce using rule 173 (return_statement -> KEYWORD_RETURN expression_optional TERMINATOR .)
    KEYWORD_DEF     reduce using rule 173 (return_statement -> KEYWORD_RETURN expression_optional TERMINATOR .)
    BLOCKBEGIN      reduce using rule 173 (return_statement -> KEYWORD_RETURN expression_optional TERMINATOR .)
    IDENTIFIER      reduce using rule 173 (return_statement -> KEYWORD_RETURN expression_optional TERMINATOR .)
    PLUS            reduce using rule 173 (return_statement -> KEYWORD_RETURN expression_optional TERMINATOR .)
    MINUS           reduce using rule 173 (return_statement -> KEYWORD_RETURN expression_optional TERMINATOR .)
    TILDA           reduce using rule 173 (return_statement -> KEYWORD_RETURN expression_optional TERMINATOR .)
    NOT             reduce using rule 173 (return_statement -> KEYWORD_RETURN expression_optional TERMINATOR .)
    LPAREN          reduce using rule 173 (return_statement -> KEYWORD_RETURN expression_optional TERMINATOR .)
    DOUBLE_NUMBER   reduce using rule 173 (return_statement -> KEYWORD_RETURN expression_optional TERMINATOR .)
    INT_NUMBER      reduce using rule 173 (return_statement -> KEYWORD_RETURN expression_optional TERMINATOR .)
    CHAR            reduce using rule 173 (return_statement -> KEYWORD_RETURN expression_optional TERMINATOR .)
    STRING          reduce using rule 173 (return_statement -> KEYWORD_RETURN expression_optional TERMINATOR .)
    KEYWORD_NULL    reduce using rule 173 (return_statement -> KEYWORD_RETURN expression_optional TERMINATOR .)
    BOOL_CONSTT     reduce using rule 173 (return_statement -> KEYWORD_RETURN expression_optional TERMINATOR .)
    BOOL_CONSTF     reduce using rule 173 (return_statement -> KEYWORD_RETURN expression_optional TERMINATOR .)
    BLOCKEND        reduce using rule 173 (return_statement -> KEYWORD_RETURN expression_optional TERMINATOR .)
    KEYWORD_ELSE    reduce using rule 173 (return_statement -> KEYWORD_RETURN expression_optional TERMINATOR .)


state 218

    (59) relational_expression -> relational_expression GEQ shift_expression .
    (62) shift_expression -> shift_expression . LSHIFT additive_expression
    (63) shift_expression -> shift_expression . RSHIFT additive_expression

    GREATER         reduce using rule 59 (relational_expression -> relational_expression GEQ shift_expression .)
    LESS            reduce using rule 59 (relational_expression -> relational_expression GEQ shift_expression .)
    GEQ             reduce using rule 59 (relational_expression -> relational_expression GEQ shift_expression .)
    LEQ             reduce using rule 59 (relational_expression -> relational_expression GEQ shift_expression .)
    EQUAL           reduce using rule 59 (relational_expression -> relational_expression GEQ shift_expression .)
    NEQUAL          reduce using rule 59 (relational_expression -> relational_expression GEQ shift_expression .)
    AND_BITWISE     reduce using rule 59 (relational_expression -> relational_expression GEQ shift_expression .)
    XOR             reduce using rule 59 (relational_expression -> relational_expression GEQ shift_expression .)
    OR_BITWISE      reduce using rule 59 (relational_expression -> relational_expression GEQ shift_expression .)
    AND             reduce using rule 59 (relational_expression -> relational_expression GEQ shift_expression .)
    OR              reduce using rule 59 (relational_expression -> relational_expression GEQ shift_expression .)
    RPAREN          reduce using rule 59 (relational_expression -> relational_expression GEQ shift_expression .)
    TERMINATOR      reduce using rule 59 (relational_expression -> relational_expression GEQ shift_expression .)
    KEYWORD_MATCH   reduce using rule 59 (relational_expression -> relational_expression GEQ shift_expression .)
    RBRAC           reduce using rule 59 (relational_expression -> relational_expression GEQ shift_expression .)
    COMMA           reduce using rule 59 (relational_expression -> relational_expression GEQ shift_expression .)
    FUNTYPE         reduce using rule 59 (relational_expression -> relational_expression GEQ shift_expression .)
    KEYWORD_UNTIL   reduce using rule 59 (relational_expression -> relational_expression GEQ shift_expression .)
    KEYWORD_TO      reduce using rule 59 (relational_expression -> relational_expression GEQ shift_expression .)
    KEYWORD_BY      reduce using rule 59 (relational_expression -> relational_expression GEQ shift_expression .)
    LSHIFT          shift and go to state 129
    RSHIFT          shift and go to state 128


state 219

    (57) relational_expression -> relational_expression GREATER shift_expression .
    (62) shift_expression -> shift_expression . LSHIFT additive_expression
    (63) shift_expression -> shift_expression . RSHIFT additive_expression

    GREATER         reduce using rule 57 (relational_expression -> relational_expression GREATER shift_expression .)
    LESS            reduce using rule 57 (relational_expression -> relational_expression GREATER shift_expression .)
    GEQ             reduce using rule 57 (relational_expression -> relational_expression GREATER shift_expression .)
    LEQ             reduce using rule 57 (relational_expression -> relational_expression GREATER shift_expression .)
    EQUAL           reduce using rule 57 (relational_expression -> relational_expression GREATER shift_expression .)
    NEQUAL          reduce using rule 57 (relational_expression -> relational_expression GREATER shift_expression .)
    AND_BITWISE     reduce using rule 57 (relational_expression -> relational_expression GREATER shift_expression .)
    XOR             reduce using rule 57 (relational_expression -> relational_expression GREATER shift_expression .)
    OR_BITWISE      reduce using rule 57 (relational_expression -> relational_expression GREATER shift_expression .)
    AND             reduce using rule 57 (relational_expression -> relational_expression GREATER shift_expression .)
    OR              reduce using rule 57 (relational_expression -> relational_expression GREATER shift_expression .)
    RPAREN          reduce using rule 57 (relational_expression -> relational_expression GREATER shift_expression .)
    TERMINATOR      reduce using rule 57 (relational_expression -> relational_expression GREATER shift_expression .)
    KEYWORD_MATCH   reduce using rule 57 (relational_expression -> relational_expression GREATER shift_expression .)
    RBRAC           reduce using rule 57 (relational_expression -> relational_expression GREATER shift_expression .)
    COMMA           reduce using rule 57 (relational_expression -> relational_expression GREATER shift_expression .)
    FUNTYPE         reduce using rule 57 (relational_expression -> relational_expression GREATER shift_expression .)
    KEYWORD_UNTIL   reduce using rule 57 (relational_expression -> relational_expression GREATER shift_expression .)
    KEYWORD_TO      reduce using rule 57 (relational_expression -> relational_expression GREATER shift_expression .)
    KEYWORD_BY      reduce using rule 57 (relational_expression -> relational_expression GREATER shift_expression .)
    LSHIFT          shift and go to state 129
    RSHIFT          shift and go to state 128


state 220

    (58) relational_expression -> relational_expression LESS shift_expression .
    (62) shift_expression -> shift_expression . LSHIFT additive_expression
    (63) shift_expression -> shift_expression . RSHIFT additive_expression

    GREATER         reduce using rule 58 (relational_expression -> relational_expression LESS shift_expression .)
    LESS            reduce using rule 58 (relational_expression -> relational_expression LESS shift_expression .)
    GEQ             reduce using rule 58 (relational_expression -> relational_expression LESS shift_expression .)
    LEQ             reduce using rule 58 (relational_expression -> relational_expression LESS shift_expression .)
    EQUAL           reduce using rule 58 (relational_expression -> relational_expression LESS shift_expression .)
    NEQUAL          reduce using rule 58 (relational_expression -> relational_expression LESS shift_expression .)
    AND_BITWISE     reduce using rule 58 (relational_expression -> relational_expression LESS shift_expression .)
    XOR             reduce using rule 58 (relational_expression -> relational_expression LESS shift_expression .)
    OR_BITWISE      reduce using rule 58 (relational_expression -> relational_expression LESS shift_expression .)
    AND             reduce using rule 58 (relational_expression -> relational_expression LESS shift_expression .)
    OR              reduce using rule 58 (relational_expression -> relational_expression LESS shift_expression .)
    RPAREN          reduce using rule 58 (relational_expression -> relational_expression LESS shift_expression .)
    TERMINATOR      reduce using rule 58 (relational_expression -> relational_expression LESS shift_expression .)
    KEYWORD_MATCH   reduce using rule 58 (relational_expression -> relational_expression LESS shift_expression .)
    RBRAC           reduce using rule 58 (relational_expression -> relational_expression LESS shift_expression .)
    COMMA           reduce using rule 58 (relational_expression -> relational_expression LESS shift_expression .)
    FUNTYPE         reduce using rule 58 (relational_expression -> relational_expression LESS shift_expression .)
    KEYWORD_UNTIL   reduce using rule 58 (relational_expression -> relational_expression LESS shift_expression .)
    KEYWORD_TO      reduce using rule 58 (relational_expression -> relational_expression LESS shift_expression .)
    KEYWORD_BY      reduce using rule 58 (relational_expression -> relational_expression LESS shift_expression .)
    LSHIFT          shift and go to state 129
    RSHIFT          shift and go to state 128


state 221

    (60) relational_expression -> relational_expression LEQ shift_expression .
    (62) shift_expression -> shift_expression . LSHIFT additive_expression
    (63) shift_expression -> shift_expression . RSHIFT additive_expression

    GREATER         reduce using rule 60 (relational_expression -> relational_expression LEQ shift_expression .)
    LESS            reduce using rule 60 (relational_expression -> relational_expression LEQ shift_expression .)
    GEQ             reduce using rule 60 (relational_expression -> relational_expression LEQ shift_expression .)
    LEQ             reduce using rule 60 (relational_expression -> relational_expression LEQ shift_expression .)
    EQUAL           reduce using rule 60 (relational_expression -> relational_expression LEQ shift_expression .)
    NEQUAL          reduce using rule 60 (relational_expression -> relational_expression LEQ shift_expression .)
    AND_BITWISE     reduce using rule 60 (relational_expression -> relational_expression LEQ shift_expression .)
    XOR             reduce using rule 60 (relational_expression -> relational_expression LEQ shift_expression .)
    OR_BITWISE      reduce using rule 60 (relational_expression -> relational_expression LEQ shift_expression .)
    AND             reduce using rule 60 (relational_expression -> relational_expression LEQ shift_expression .)
    OR              reduce using rule 60 (relational_expression -> relational_expression LEQ shift_expression .)
    RPAREN          reduce using rule 60 (relational_expression -> relational_expression LEQ shift_expression .)
    TERMINATOR      reduce using rule 60 (relational_expression -> relational_expression LEQ shift_expression .)
    KEYWORD_MATCH   reduce using rule 60 (relational_expression -> relational_expression LEQ shift_expression .)
    RBRAC           reduce using rule 60 (relational_expression -> relational_expression LEQ shift_expression .)
    COMMA           reduce using rule 60 (relational_expression -> relational_expression LEQ shift_expression .)
    FUNTYPE         reduce using rule 60 (relational_expression -> relational_expression LEQ shift_expression .)
    KEYWORD_UNTIL   reduce using rule 60 (relational_expression -> relational_expression LEQ shift_expression .)
    KEYWORD_TO      reduce using rule 60 (relational_expression -> relational_expression LEQ shift_expression .)
    KEYWORD_BY      reduce using rule 60 (relational_expression -> relational_expression LEQ shift_expression .)
    LSHIFT          shift and go to state 129
    RSHIFT          shift and go to state 128


state 222

    (108) variable_declaration_body -> identifiers COLON . type ASOP variable_declaration_initializer
    (118) type -> . primitive_type
    (119) type -> . reference_type
    (120) primitive_type -> . TYPE_INT
    (121) primitive_type -> . TYPE_DOUBLE
    (122) primitive_type -> . TYPE_CHAR
    (123) primitive_type -> . TYPE_STRING
    (124) primitive_type -> . TYPE_BOOLEAN
    (125) primitive_type -> . TYPE_VOID
    (126) reference_type -> . class_data_type
    (127) reference_type -> . array_data_type
    (128) class_data_type -> . name
    (129) array_data_type -> . KEYWORD_ARRAY LBRAC TYPE_INT RBRAC
    (130) name -> . simple_name
    (131) name -> . qualified_name
    (132) simple_name -> . IDENTIFIER
    (133) qualified_name -> . name INST simple_name

    TYPE_INT        shift and go to state 165
    TYPE_DOUBLE     shift and go to state 171
    TYPE_CHAR       shift and go to state 167
    TYPE_STRING     shift and go to state 166
    TYPE_BOOLEAN    shift and go to state 170
    TYPE_VOID       shift and go to state 168
    KEYWORD_ARRAY   shift and go to state 261
    IDENTIFIER      shift and go to state 9

    name                           shift and go to state 260
    qualified_name                 shift and go to state 75
    reference_type                 shift and go to state 256
    primitive_type                 shift and go to state 257
    class_data_type                shift and go to state 255
    type                           shift and go to state 258
    array_data_type                shift and go to state 259
    simple_name                    shift and go to state 63

state 223

    (109) identifiers -> identifiers COMMA . IDENTIFIER

    IDENTIFIER      shift and go to state 262


state 224

    (151) if_then_statement -> KEYWORD_IF LPAREN expression . RPAREN marker block
    (152) if_then_else_statement -> KEYWORD_IF LPAREN expression . RPAREN marker if_then_else_intermediate narker KEYWORD_ELSE marker block

    RPAREN          shift and go to state 263


state 225

    (55) equality_expression -> equality_expression NEQUAL relational_expression .
    (57) relational_expression -> relational_expression . GREATER shift_expression
    (58) relational_expression -> relational_expression . LESS shift_expression
    (59) relational_expression -> relational_expression . GEQ shift_expression
    (60) relational_expression -> relational_expression . LEQ shift_expression

    EQUAL           reduce using rule 55 (equality_expression -> equality_expression NEQUAL relational_expression .)
    NEQUAL          reduce using rule 55 (equality_expression -> equality_expression NEQUAL relational_expression .)
    AND_BITWISE     reduce using rule 55 (equality_expression -> equality_expression NEQUAL relational_expression .)
    XOR             reduce using rule 55 (equality_expression -> equality_expression NEQUAL relational_expression .)
    OR_BITWISE      reduce using rule 55 (equality_expression -> equality_expression NEQUAL relational_expression .)
    AND             reduce using rule 55 (equality_expression -> equality_expression NEQUAL relational_expression .)
    OR              reduce using rule 55 (equality_expression -> equality_expression NEQUAL relational_expression .)
    KEYWORD_UNTIL   reduce using rule 55 (equality_expression -> equality_expression NEQUAL relational_expression .)
    KEYWORD_TO      reduce using rule 55 (equality_expression -> equality_expression NEQUAL relational_expression .)
    KEYWORD_MATCH   reduce using rule 55 (equality_expression -> equality_expression NEQUAL relational_expression .)
    RBRAC           reduce using rule 55 (equality_expression -> equality_expression NEQUAL relational_expression .)
    RPAREN          reduce using rule 55 (equality_expression -> equality_expression NEQUAL relational_expression .)
    COMMA           reduce using rule 55 (equality_expression -> equality_expression NEQUAL relational_expression .)
    TERMINATOR      reduce using rule 55 (equality_expression -> equality_expression NEQUAL relational_expression .)
    FUNTYPE         reduce using rule 55 (equality_expression -> equality_expression NEQUAL relational_expression .)
    KEYWORD_BY      reduce using rule 55 (equality_expression -> equality_expression NEQUAL relational_expression .)
    GREATER         shift and go to state 146
    LESS            shift and go to state 147
    GEQ             shift and go to state 145
    LEQ             shift and go to state 148


state 226

    (54) equality_expression -> equality_expression EQUAL relational_expression .
    (57) relational_expression -> relational_expression . GREATER shift_expression
    (58) relational_expression -> relational_expression . LESS shift_expression
    (59) relational_expression -> relational_expression . GEQ shift_expression
    (60) relational_expression -> relational_expression . LEQ shift_expression

    EQUAL           reduce using rule 54 (equality_expression -> equality_expression EQUAL relational_expression .)
    NEQUAL          reduce using rule 54 (equality_expression -> equality_expression EQUAL relational_expression .)
    AND_BITWISE     reduce using rule 54 (equality_expression -> equality_expression EQUAL relational_expression .)
    XOR             reduce using rule 54 (equality_expression -> equality_expression EQUAL relational_expression .)
    OR_BITWISE      reduce using rule 54 (equality_expression -> equality_expression EQUAL relational_expression .)
    AND             reduce using rule 54 (equality_expression -> equality_expression EQUAL relational_expression .)
    OR              reduce using rule 54 (equality_expression -> equality_expression EQUAL relational_expression .)
    KEYWORD_UNTIL   reduce using rule 54 (equality_expression -> equality_expression EQUAL relational_expression .)
    KEYWORD_TO      reduce using rule 54 (equality_expression -> equality_expression EQUAL relational_expression .)
    KEYWORD_MATCH   reduce using rule 54 (equality_expression -> equality_expression EQUAL relational_expression .)
    RBRAC           reduce using rule 54 (equality_expression -> equality_expression EQUAL relational_expression .)
    RPAREN          reduce using rule 54 (equality_expression -> equality_expression EQUAL relational_expression .)
    COMMA           reduce using rule 54 (equality_expression -> equality_expression EQUAL relational_expression .)
    TERMINATOR      reduce using rule 54 (equality_expression -> equality_expression EQUAL relational_expression .)
    FUNTYPE         reduce using rule 54 (equality_expression -> equality_expression EQUAL relational_expression .)
    KEYWORD_BY      reduce using rule 54 (equality_expression -> equality_expression EQUAL relational_expression .)
    GREATER         shift and go to state 146
    LESS            shift and go to state 147
    GEQ             shift and go to state 145
    LEQ             shift and go to state 148


state 227

    (184) method_body -> method_start_scope block_statements_opt . end_scope
    (9) end_scope -> . BLOCKEND

    BLOCKEND        shift and go to state 109

    end_scope                      shift and go to state 264

state 228

    (52) and_expression -> and_expression AND_BITWISE equality_expression .
    (54) equality_expression -> equality_expression . EQUAL relational_expression
    (55) equality_expression -> equality_expression . NEQUAL relational_expression

    AND_BITWISE     reduce using rule 52 (and_expression -> and_expression AND_BITWISE equality_expression .)
    XOR             reduce using rule 52 (and_expression -> and_expression AND_BITWISE equality_expression .)
    OR_BITWISE      reduce using rule 52 (and_expression -> and_expression AND_BITWISE equality_expression .)
    AND             reduce using rule 52 (and_expression -> and_expression AND_BITWISE equality_expression .)
    OR              reduce using rule 52 (and_expression -> and_expression AND_BITWISE equality_expression .)
    TERMINATOR      reduce using rule 52 (and_expression -> and_expression AND_BITWISE equality_expression .)
    KEYWORD_MATCH   reduce using rule 52 (and_expression -> and_expression AND_BITWISE equality_expression .)
    RPAREN          reduce using rule 52 (and_expression -> and_expression AND_BITWISE equality_expression .)
    RBRAC           reduce using rule 52 (and_expression -> and_expression AND_BITWISE equality_expression .)
    COMMA           reduce using rule 52 (and_expression -> and_expression AND_BITWISE equality_expression .)
    FUNTYPE         reduce using rule 52 (and_expression -> and_expression AND_BITWISE equality_expression .)
    KEYWORD_UNTIL   reduce using rule 52 (and_expression -> and_expression AND_BITWISE equality_expression .)
    KEYWORD_TO      reduce using rule 52 (and_expression -> and_expression AND_BITWISE equality_expression .)
    KEYWORD_BY      reduce using rule 52 (and_expression -> and_expression AND_BITWISE equality_expression .)
    EQUAL           shift and go to state 155
    NEQUAL          shift and go to state 154


state 229

    (13) block_statements -> block_statements marker block_statement .

    KEYWORD_IF      reduce using rule 13 (block_statements -> block_statements marker block_statement .)
    KEYWORD_WHILE   reduce using rule 13 (block_statements -> block_statements marker block_statement .)
    KEYWORD_DO      reduce using rule 13 (block_statements -> block_statements marker block_statement .)
    KEYWORD_FOR     reduce using rule 13 (block_statements -> block_statements marker block_statement .)
    KEYWORD_CLASS   reduce using rule 13 (block_statements -> block_statements marker block_statement .)
    KEYWORD_OBJECT  reduce using rule 13 (block_statements -> block_statements marker block_statement .)
    KEYWORD_VAR     reduce using rule 13 (block_statements -> block_statements marker block_statement .)
    KEYWORD_VAL     reduce using rule 13 (block_statements -> block_statements marker block_statement .)
    TERMINATOR      reduce using rule 13 (block_statements -> block_statements marker block_statement .)
    KEYWORD_RETURN  reduce using rule 13 (block_statements -> block_statements marker block_statement .)
    KEYWORD_DEF     reduce using rule 13 (block_statements -> block_statements marker block_statement .)
    BLOCKBEGIN      reduce using rule 13 (block_statements -> block_statements marker block_statement .)
    IDENTIFIER      reduce using rule 13 (block_statements -> block_statements marker block_statement .)
    PLUS            reduce using rule 13 (block_statements -> block_statements marker block_statement .)
    MINUS           reduce using rule 13 (block_statements -> block_statements marker block_statement .)
    TILDA           reduce using rule 13 (block_statements -> block_statements marker block_statement .)
    NOT             reduce using rule 13 (block_statements -> block_statements marker block_statement .)
    LPAREN          reduce using rule 13 (block_statements -> block_statements marker block_statement .)
    DOUBLE_NUMBER   reduce using rule 13 (block_statements -> block_statements marker block_statement .)
    INT_NUMBER      reduce using rule 13 (block_statements -> block_statements marker block_statement .)
    CHAR            reduce using rule 13 (block_statements -> block_statements marker block_statement .)
    STRING          reduce using rule 13 (block_statements -> block_statements marker block_statement .)
    KEYWORD_NULL    reduce using rule 13 (block_statements -> block_statements marker block_statement .)
    BOOL_CONSTT     reduce using rule 13 (block_statements -> block_statements marker block_statement .)
    BOOL_CONSTF     reduce using rule 13 (block_statements -> block_statements marker block_statement .)
    BLOCKEND        reduce using rule 13 (block_statements -> block_statements marker block_statement .)


state 230

    (82) cast_expression -> LPAREN primitive_type RPAREN . unary_expression
    (71) unary_expression -> . PLUS unary_expression
    (72) unary_expression -> . MINUS unary_expression
    (73) unary_expression -> . unary_expression_not_plus_minus
    (74) unary_expression_not_plus_minus -> . base_variable_set
    (75) unary_expression_not_plus_minus -> . TILDA unary_expression
    (76) unary_expression_not_plus_minus -> . cast_expression
    (77) unary_expression_not_plus_minus -> . NOT unary_expression
    (78) base_variable_set -> . variable_literal
    (79) base_variable_set -> . LPAREN expression RPAREN
    (82) cast_expression -> . LPAREN primitive_type RPAREN unary_expression
    (80) variable_literal -> . valid_variable
    (81) variable_literal -> . primary
    (26) valid_variable -> . name
    (27) valid_variable -> . array_access
    (83) primary -> . literal
    (84) primary -> . method_invocation
    (130) name -> . simple_name
    (131) name -> . qualified_name
    (28) array_access -> . name dimension
    (85) literal -> . int_float
    (86) literal -> . c_literal
    (94) method_invocation -> . name LPAREN argument_list_opt RPAREN
    (132) simple_name -> . IDENTIFIER
    (133) qualified_name -> . name INST simple_name
    (92) int_float -> . DOUBLE_NUMBER
    (93) int_float -> . INT_NUMBER
    (87) c_literal -> . CHAR
    (88) c_literal -> . STRING
    (89) c_literal -> . KEYWORD_NULL
    (90) c_literal -> . BOOL_CONSTT
    (91) c_literal -> . BOOL_CONSTF

    PLUS            shift and go to state 31
    MINUS           shift and go to state 24
    TILDA           shift and go to state 68
    NOT             shift and go to state 53
    LPAREN          shift and go to state 91
    IDENTIFIER      shift and go to state 9
    DOUBLE_NUMBER   shift and go to state 28
    INT_NUMBER      shift and go to state 39
    CHAR            shift and go to state 59
    STRING          shift and go to state 72
    KEYWORD_NULL    shift and go to state 61
    BOOL_CONSTT     shift and go to state 30
    BOOL_CONSTF     shift and go to state 25

    qualified_name                 shift and go to state 75
    int_float                      shift and go to state 35
    c_literal                      shift and go to state 90
    variable_literal               shift and go to state 51
    unary_expression               shift and go to state 265
    base_variable_set              shift and go to state 85
    valid_variable                 shift and go to state 106
    array_access                   shift and go to state 23
    primary                        shift and go to state 58
    unary_expression_not_plus_minus shift and go to state 41
    literal                        shift and go to state 67
    method_invocation              shift and go to state 107
    cast_expression                shift and go to state 77
    simple_name                    shift and go to state 63
    name                           shift and go to state 108

state 231

    (79) base_variable_set -> LPAREN expression RPAREN .

    TIMES           reduce using rule 79 (base_variable_set -> LPAREN expression RPAREN .)
    DIVIDE          reduce using rule 79 (base_variable_set -> LPAREN expression RPAREN .)
    REMAINDER       reduce using rule 79 (base_variable_set -> LPAREN expression RPAREN .)
    PLUS            reduce using rule 79 (base_variable_set -> LPAREN expression RPAREN .)
    MINUS           reduce using rule 79 (base_variable_set -> LPAREN expression RPAREN .)
    LSHIFT          reduce using rule 79 (base_variable_set -> LPAREN expression RPAREN .)
    RSHIFT          reduce using rule 79 (base_variable_set -> LPAREN expression RPAREN .)
    GREATER         reduce using rule 79 (base_variable_set -> LPAREN expression RPAREN .)
    LESS            reduce using rule 79 (base_variable_set -> LPAREN expression RPAREN .)
    GEQ             reduce using rule 79 (base_variable_set -> LPAREN expression RPAREN .)
    LEQ             reduce using rule 79 (base_variable_set -> LPAREN expression RPAREN .)
    EQUAL           reduce using rule 79 (base_variable_set -> LPAREN expression RPAREN .)
    NEQUAL          reduce using rule 79 (base_variable_set -> LPAREN expression RPAREN .)
    AND_BITWISE     reduce using rule 79 (base_variable_set -> LPAREN expression RPAREN .)
    XOR             reduce using rule 79 (base_variable_set -> LPAREN expression RPAREN .)
    OR_BITWISE      reduce using rule 79 (base_variable_set -> LPAREN expression RPAREN .)
    AND             reduce using rule 79 (base_variable_set -> LPAREN expression RPAREN .)
    OR              reduce using rule 79 (base_variable_set -> LPAREN expression RPAREN .)
    KEYWORD_UNTIL   reduce using rule 79 (base_variable_set -> LPAREN expression RPAREN .)
    KEYWORD_TO      reduce using rule 79 (base_variable_set -> LPAREN expression RPAREN .)
    RPAREN          reduce using rule 79 (base_variable_set -> LPAREN expression RPAREN .)
    TERMINATOR      reduce using rule 79 (base_variable_set -> LPAREN expression RPAREN .)
    KEYWORD_MATCH   reduce using rule 79 (base_variable_set -> LPAREN expression RPAREN .)
    RBRAC           reduce using rule 79 (base_variable_set -> LPAREN expression RPAREN .)
    COMMA           reduce using rule 79 (base_variable_set -> LPAREN expression RPAREN .)
    FUNTYPE         reduce using rule 79 (base_variable_set -> LPAREN expression RPAREN .)
    KEYWORD_BY      reduce using rule 79 (base_variable_set -> LPAREN expression RPAREN .)


state 232

    (25) assignment -> valid_variable assignment_operator assignment_expression .

    FUNTYPE         reduce using rule 25 (assignment -> valid_variable assignment_operator assignment_expression .)
    COMMA           reduce using rule 25 (assignment -> valid_variable assignment_operator assignment_expression .)
    RPAREN          reduce using rule 25 (assignment -> valid_variable assignment_operator assignment_expression .)
    RBRAC           reduce using rule 25 (assignment -> valid_variable assignment_operator assignment_expression .)
    TERMINATOR      reduce using rule 25 (assignment -> valid_variable assignment_operator assignment_expression .)
    KEYWORD_MATCH   reduce using rule 25 (assignment -> valid_variable assignment_operator assignment_expression .)
    KEYWORD_BY      reduce using rule 25 (assignment -> valid_variable assignment_operator assignment_expression .)
    KEYWORD_UNTIL   reduce using rule 25 (assignment -> valid_variable assignment_operator assignment_expression .)
    KEYWORD_TO      reduce using rule 25 (assignment -> valid_variable assignment_operator assignment_expression .)


state 233

    (159) for_update -> for_loop . marker for_step_opts
    (41) marker -> . empty
    (200) empty -> .

    KEYWORD_BY      reduce using rule 200 (empty -> .)
    RPAREN          reduce using rule 200 (empty -> .)

    marker                         shift and go to state 266
    empty                          shift and go to state 104

state 234

    (158) for_statement -> KEYWORD_FOR LPAREN for_update . RPAREN marker block

    RPAREN          shift and go to state 267


state 235

    (160) for_loop -> IDENTIFIER . CHOOSE expression for_untilTo marker expression

    CHOOSE          shift and go to state 268


state 236

    (157) do_while_statement -> KEYWORD_DO marker block . KEYWORD_WHILE LPAREN marker expression RPAREN TERMINATOR

    KEYWORD_WHILE   shift and go to state 269


state 237

    (192) class_params -> class_params COMMA class_param .

    COMMA           reduce using rule 192 (class_params -> class_params COMMA class_param .)
    RPAREN          reduce using rule 192 (class_params -> class_params COMMA class_param .)


state 238

    (195) class_declaration_keyword_opt -> empty .

    IDENTIFIER      reduce using rule 195 (class_declaration_keyword_opt -> empty .)


state 239

    (116) variable_declarator_id -> IDENTIFIER COLON . type
    (118) type -> . primitive_type
    (119) type -> . reference_type
    (120) primitive_type -> . TYPE_INT
    (121) primitive_type -> . TYPE_DOUBLE
    (122) primitive_type -> . TYPE_CHAR
    (123) primitive_type -> . TYPE_STRING
    (124) primitive_type -> . TYPE_BOOLEAN
    (125) primitive_type -> . TYPE_VOID
    (126) reference_type -> . class_data_type
    (127) reference_type -> . array_data_type
    (128) class_data_type -> . name
    (129) array_data_type -> . KEYWORD_ARRAY LBRAC TYPE_INT RBRAC
    (130) name -> . simple_name
    (131) name -> . qualified_name
    (132) simple_name -> . IDENTIFIER
    (133) qualified_name -> . name INST simple_name

    TYPE_INT        shift and go to state 165
    TYPE_DOUBLE     shift and go to state 171
    TYPE_CHAR       shift and go to state 167
    TYPE_STRING     shift and go to state 166
    TYPE_BOOLEAN    shift and go to state 170
    TYPE_VOID       shift and go to state 168
    KEYWORD_ARRAY   shift and go to state 261
    IDENTIFIER      shift and go to state 9

    name                           shift and go to state 260
    qualified_name                 shift and go to state 75
    reference_type                 shift and go to state 256
    primitive_type                 shift and go to state 257
    class_data_type                shift and go to state 255
    type                           shift and go to state 270
    array_data_type                shift and go to state 259
    simple_name                    shift and go to state 63

state 240

    (175) method_header -> method_header_name func_arg_start fun_params_opt RPAREN . COLON method_return_type ASOP

    COLON           shift and go to state 271


state 241

    (180) fun_params -> fun_params COMMA . fun_variable_declarator_id
    (117) fun_variable_declarator_id -> . IDENTIFIER COLON type

    IDENTIFIER      shift and go to state 196

    fun_variable_declarator_id     shift and go to state 272

state 242

    (117) fun_variable_declarator_id -> IDENTIFIER COLON . type
    (118) type -> . primitive_type
    (119) type -> . reference_type
    (120) primitive_type -> . TYPE_INT
    (121) primitive_type -> . TYPE_DOUBLE
    (122) primitive_type -> . TYPE_CHAR
    (123) primitive_type -> . TYPE_STRING
    (124) primitive_type -> . TYPE_BOOLEAN
    (125) primitive_type -> . TYPE_VOID
    (126) reference_type -> . class_data_type
    (127) reference_type -> . array_data_type
    (128) class_data_type -> . name
    (129) array_data_type -> . KEYWORD_ARRAY LBRAC TYPE_INT RBRAC
    (130) name -> . simple_name
    (131) name -> . qualified_name
    (132) simple_name -> . IDENTIFIER
    (133) qualified_name -> . name INST simple_name

    TYPE_INT        shift and go to state 165
    TYPE_DOUBLE     shift and go to state 171
    TYPE_CHAR       shift and go to state 167
    TYPE_STRING     shift and go to state 166
    TYPE_BOOLEAN    shift and go to state 170
    TYPE_VOID       shift and go to state 168
    KEYWORD_ARRAY   shift and go to state 261
    IDENTIFIER      shift and go to state 9

    name                           shift and go to state 260
    qualified_name                 shift and go to state 75
    reference_type                 shift and go to state 256
    primitive_type                 shift and go to state 257
    class_data_type                shift and go to state 255
    type                           shift and go to state 273
    array_data_type                shift and go to state 259
    simple_name                    shift and go to state 63

state 243

    (29) dimension -> LBRAC expression RBRAC .

    ASOP            reduce using rule 29 (dimension -> LBRAC expression RBRAC .)
    TIMES_ASSIGN    reduce using rule 29 (dimension -> LBRAC expression RBRAC .)
    DIVIDE_ASSIGN   reduce using rule 29 (dimension -> LBRAC expression RBRAC .)
    REMAINDER_ASSIGN reduce using rule 29 (dimension -> LBRAC expression RBRAC .)
    PLUS_ASSIGN     reduce using rule 29 (dimension -> LBRAC expression RBRAC .)
    MINUS_ASSIGN    reduce using rule 29 (dimension -> LBRAC expression RBRAC .)
    LSHIFT_ASSIGN   reduce using rule 29 (dimension -> LBRAC expression RBRAC .)
    RSHIFT_ASSIGN   reduce using rule 29 (dimension -> LBRAC expression RBRAC .)
    AND_ASSIGN      reduce using rule 29 (dimension -> LBRAC expression RBRAC .)
    OR_ASSIGN       reduce using rule 29 (dimension -> LBRAC expression RBRAC .)
    XOR_ASSIGN      reduce using rule 29 (dimension -> LBRAC expression RBRAC .)
    TIMES           reduce using rule 29 (dimension -> LBRAC expression RBRAC .)
    DIVIDE          reduce using rule 29 (dimension -> LBRAC expression RBRAC .)
    REMAINDER       reduce using rule 29 (dimension -> LBRAC expression RBRAC .)
    PLUS            reduce using rule 29 (dimension -> LBRAC expression RBRAC .)
    MINUS           reduce using rule 29 (dimension -> LBRAC expression RBRAC .)
    LSHIFT          reduce using rule 29 (dimension -> LBRAC expression RBRAC .)
    RSHIFT          reduce using rule 29 (dimension -> LBRAC expression RBRAC .)
    GREATER         reduce using rule 29 (dimension -> LBRAC expression RBRAC .)
    LESS            reduce using rule 29 (dimension -> LBRAC expression RBRAC .)
    GEQ             reduce using rule 29 (dimension -> LBRAC expression RBRAC .)
    LEQ             reduce using rule 29 (dimension -> LBRAC expression RBRAC .)
    EQUAL           reduce using rule 29 (dimension -> LBRAC expression RBRAC .)
    NEQUAL          reduce using rule 29 (dimension -> LBRAC expression RBRAC .)
    AND_BITWISE     reduce using rule 29 (dimension -> LBRAC expression RBRAC .)
    XOR             reduce using rule 29 (dimension -> LBRAC expression RBRAC .)
    OR_BITWISE      reduce using rule 29 (dimension -> LBRAC expression RBRAC .)
    AND             reduce using rule 29 (dimension -> LBRAC expression RBRAC .)
    OR              reduce using rule 29 (dimension -> LBRAC expression RBRAC .)
    KEYWORD_MATCH   reduce using rule 29 (dimension -> LBRAC expression RBRAC .)
    TERMINATOR      reduce using rule 29 (dimension -> LBRAC expression RBRAC .)
    RPAREN          reduce using rule 29 (dimension -> LBRAC expression RBRAC .)
    RBRAC           reduce using rule 29 (dimension -> LBRAC expression RBRAC .)
    COMMA           reduce using rule 29 (dimension -> LBRAC expression RBRAC .)
    FUNTYPE         reduce using rule 29 (dimension -> LBRAC expression RBRAC .)
    KEYWORD_UNTIL   reduce using rule 29 (dimension -> LBRAC expression RBRAC .)
    KEYWORD_TO      reduce using rule 29 (dimension -> LBRAC expression RBRAC .)
    KEYWORD_BY      reduce using rule 29 (dimension -> LBRAC expression RBRAC .)


state 244

    (98) argument_list -> argument_list COMMA . expression
    (19) expression -> . assignment_expression
    (22) assignment_expression -> . assignment
    (23) assignment_expression -> . conditional_or_expression
    (24) assignment_expression -> . method_invocation
    (25) assignment -> . valid_variable assignment_operator assignment_expression
    (43) conditional_or_expression -> . conditional_and_expression
    (44) conditional_or_expression -> . conditional_or_expression OR marker conditional_and_expression
    (94) method_invocation -> . name LPAREN argument_list_opt RPAREN
    (26) valid_variable -> . name
    (27) valid_variable -> . array_access
    (45) conditional_and_expression -> . inclusive_or_expression
    (46) conditional_and_expression -> . conditional_and_expression AND marker inclusive_or_expression
    (130) name -> . simple_name
    (131) name -> . qualified_name
    (28) array_access -> . name dimension
    (47) inclusive_or_expression -> . exclusive_or_expression
    (48) inclusive_or_expression -> . inclusive_or_expression OR_BITWISE exclusive_or_expression
    (132) simple_name -> . IDENTIFIER
    (133) qualified_name -> . name INST simple_name
    (49) exclusive_or_expression -> . and_expression
    (50) exclusive_or_expression -> . exclusive_or_expression XOR and_expression
    (51) and_expression -> . equality_expression
    (52) and_expression -> . and_expression AND_BITWISE equality_expression
    (53) equality_expression -> . relational_expression
    (54) equality_expression -> . equality_expression EQUAL relational_expression
    (55) equality_expression -> . equality_expression NEQUAL relational_expression
    (56) relational_expression -> . shift_expression
    (57) relational_expression -> . relational_expression GREATER shift_expression
    (58) relational_expression -> . relational_expression LESS shift_expression
    (59) relational_expression -> . relational_expression GEQ shift_expression
    (60) relational_expression -> . relational_expression LEQ shift_expression
    (61) shift_expression -> . additive_expression
    (62) shift_expression -> . shift_expression LSHIFT additive_expression
    (63) shift_expression -> . shift_expression RSHIFT additive_expression
    (64) additive_expression -> . multiplicative_expression
    (65) additive_expression -> . additive_expression PLUS multiplicative_expression
    (66) additive_expression -> . additive_expression MINUS multiplicative_expression
    (67) multiplicative_expression -> . unary_expression
    (68) multiplicative_expression -> . multiplicative_expression TIMES unary_expression
    (69) multiplicative_expression -> . multiplicative_expression DIVIDE unary_expression
    (70) multiplicative_expression -> . multiplicative_expression REMAINDER unary_expression
    (71) unary_expression -> . PLUS unary_expression
    (72) unary_expression -> . MINUS unary_expression
    (73) unary_expression -> . unary_expression_not_plus_minus
    (74) unary_expression_not_plus_minus -> . base_variable_set
    (75) unary_expression_not_plus_minus -> . TILDA unary_expression
    (76) unary_expression_not_plus_minus -> . cast_expression
    (77) unary_expression_not_plus_minus -> . NOT unary_expression
    (78) base_variable_set -> . variable_literal
    (79) base_variable_set -> . LPAREN expression RPAREN
    (82) cast_expression -> . LPAREN primitive_type RPAREN unary_expression
    (80) variable_literal -> . valid_variable
    (81) variable_literal -> . primary
    (83) primary -> . literal
    (84) primary -> . method_invocation
    (85) literal -> . int_float
    (86) literal -> . c_literal
    (92) int_float -> . DOUBLE_NUMBER
    (93) int_float -> . INT_NUMBER
    (87) c_literal -> . CHAR
    (88) c_literal -> . STRING
    (89) c_literal -> . KEYWORD_NULL
    (90) c_literal -> . BOOL_CONSTT
    (91) c_literal -> . BOOL_CONSTF

    IDENTIFIER      shift and go to state 9
    PLUS            shift and go to state 31
    MINUS           shift and go to state 24
    TILDA           shift and go to state 68
    NOT             shift and go to state 53
    LPAREN          shift and go to state 91
    DOUBLE_NUMBER   shift and go to state 28
    INT_NUMBER      shift and go to state 39
    CHAR            shift and go to state 59
    STRING          shift and go to state 72
    KEYWORD_NULL    shift and go to state 61
    BOOL_CONSTT     shift and go to state 30
    BOOL_CONSTF     shift and go to state 25

    unary_expression               shift and go to state 40
    exclusive_or_expression        shift and go to state 57
    primary                        shift and go to state 58
    unary_expression_not_plus_minus shift and go to state 41
    array_access                   shift and go to state 23
    and_expression                 shift and go to state 84
    simple_name                    shift and go to state 63
    c_literal                      shift and go to state 90
    base_variable_set              shift and go to state 85
    valid_variable                 shift and go to state 92
    inclusive_or_expression        shift and go to state 27
    literal                        shift and go to state 67
    relational_expression          shift and go to state 69
    method_invocation              shift and go to state 139
    conditional_or_expression      shift and go to state 43
    assignment_expression          shift and go to state 88
    qualified_name                 shift and go to state 75
    assignment                     shift and go to state 142
    multiplicative_expression      shift and go to state 46
    additive_expression            shift and go to state 62
    cast_expression                shift and go to state 77
    shift_expression               shift and go to state 50
    equality_expression            shift and go to state 79
    int_float                      shift and go to state 35
    variable_literal               shift and go to state 51
    name                           shift and go to state 38
    expression                     shift and go to state 274
    conditional_and_expression     shift and go to state 52

state 245

    (94) method_invocation -> name LPAREN argument_list_opt RPAREN .

    TIMES           reduce using rule 94 (method_invocation -> name LPAREN argument_list_opt RPAREN .)
    DIVIDE          reduce using rule 94 (method_invocation -> name LPAREN argument_list_opt RPAREN .)
    REMAINDER       reduce using rule 94 (method_invocation -> name LPAREN argument_list_opt RPAREN .)
    PLUS            reduce using rule 94 (method_invocation -> name LPAREN argument_list_opt RPAREN .)
    MINUS           reduce using rule 94 (method_invocation -> name LPAREN argument_list_opt RPAREN .)
    LSHIFT          reduce using rule 94 (method_invocation -> name LPAREN argument_list_opt RPAREN .)
    RSHIFT          reduce using rule 94 (method_invocation -> name LPAREN argument_list_opt RPAREN .)
    GREATER         reduce using rule 94 (method_invocation -> name LPAREN argument_list_opt RPAREN .)
    LESS            reduce using rule 94 (method_invocation -> name LPAREN argument_list_opt RPAREN .)
    GEQ             reduce using rule 94 (method_invocation -> name LPAREN argument_list_opt RPAREN .)
    LEQ             reduce using rule 94 (method_invocation -> name LPAREN argument_list_opt RPAREN .)
    EQUAL           reduce using rule 94 (method_invocation -> name LPAREN argument_list_opt RPAREN .)
    NEQUAL          reduce using rule 94 (method_invocation -> name LPAREN argument_list_opt RPAREN .)
    AND_BITWISE     reduce using rule 94 (method_invocation -> name LPAREN argument_list_opt RPAREN .)
    XOR             reduce using rule 94 (method_invocation -> name LPAREN argument_list_opt RPAREN .)
    OR_BITWISE      reduce using rule 94 (method_invocation -> name LPAREN argument_list_opt RPAREN .)
    AND             reduce using rule 94 (method_invocation -> name LPAREN argument_list_opt RPAREN .)
    OR              reduce using rule 94 (method_invocation -> name LPAREN argument_list_opt RPAREN .)
    KEYWORD_MATCH   reduce using rule 94 (method_invocation -> name LPAREN argument_list_opt RPAREN .)
    TERMINATOR      reduce using rule 94 (method_invocation -> name LPAREN argument_list_opt RPAREN .)
    RPAREN          reduce using rule 94 (method_invocation -> name LPAREN argument_list_opt RPAREN .)
    RBRAC           reduce using rule 94 (method_invocation -> name LPAREN argument_list_opt RPAREN .)
    COMMA           reduce using rule 94 (method_invocation -> name LPAREN argument_list_opt RPAREN .)
    FUNTYPE         reduce using rule 94 (method_invocation -> name LPAREN argument_list_opt RPAREN .)
    KEYWORD_UNTIL   reduce using rule 94 (method_invocation -> name LPAREN argument_list_opt RPAREN .)
    KEYWORD_TO      reduce using rule 94 (method_invocation -> name LPAREN argument_list_opt RPAREN .)
    KEYWORD_BY      reduce using rule 94 (method_invocation -> name LPAREN argument_list_opt RPAREN .)


state 246

    (44) conditional_or_expression -> conditional_or_expression OR marker conditional_and_expression .
    (46) conditional_and_expression -> conditional_and_expression . AND marker inclusive_or_expression

    OR              reduce using rule 44 (conditional_or_expression -> conditional_or_expression OR marker conditional_and_expression .)
    KEYWORD_MATCH   reduce using rule 44 (conditional_or_expression -> conditional_or_expression OR marker conditional_and_expression .)
    RPAREN          reduce using rule 44 (conditional_or_expression -> conditional_or_expression OR marker conditional_and_expression .)
    COMMA           reduce using rule 44 (conditional_or_expression -> conditional_or_expression OR marker conditional_and_expression .)
    KEYWORD_BY      reduce using rule 44 (conditional_or_expression -> conditional_or_expression OR marker conditional_and_expression .)
    KEYWORD_UNTIL   reduce using rule 44 (conditional_or_expression -> conditional_or_expression OR marker conditional_and_expression .)
    KEYWORD_TO      reduce using rule 44 (conditional_or_expression -> conditional_or_expression OR marker conditional_and_expression .)
    RBRAC           reduce using rule 44 (conditional_or_expression -> conditional_or_expression OR marker conditional_and_expression .)
    TERMINATOR      reduce using rule 44 (conditional_or_expression -> conditional_or_expression OR marker conditional_and_expression .)
    FUNTYPE         reduce using rule 44 (conditional_or_expression -> conditional_or_expression OR marker conditional_and_expression .)
    AND             shift and go to state 130


state 247

    (156) while_statement -> KEYWORD_WHILE LPAREN marker expression . RPAREN marker block

    RPAREN          shift and go to state 275


state 248

    (46) conditional_and_expression -> conditional_and_expression AND marker inclusive_or_expression .
    (48) inclusive_or_expression -> inclusive_or_expression . OR_BITWISE exclusive_or_expression

    AND             reduce using rule 46 (conditional_and_expression -> conditional_and_expression AND marker inclusive_or_expression .)
    OR              reduce using rule 46 (conditional_and_expression -> conditional_and_expression AND marker inclusive_or_expression .)
    RPAREN          reduce using rule 46 (conditional_and_expression -> conditional_and_expression AND marker inclusive_or_expression .)
    KEYWORD_MATCH   reduce using rule 46 (conditional_and_expression -> conditional_and_expression AND marker inclusive_or_expression .)
    TERMINATOR      reduce using rule 46 (conditional_and_expression -> conditional_and_expression AND marker inclusive_or_expression .)
    RBRAC           reduce using rule 46 (conditional_and_expression -> conditional_and_expression AND marker inclusive_or_expression .)
    COMMA           reduce using rule 46 (conditional_and_expression -> conditional_and_expression AND marker inclusive_or_expression .)
    FUNTYPE         reduce using rule 46 (conditional_and_expression -> conditional_and_expression AND marker inclusive_or_expression .)
    KEYWORD_UNTIL   reduce using rule 46 (conditional_and_expression -> conditional_and_expression AND marker inclusive_or_expression .)
    KEYWORD_TO      reduce using rule 46 (conditional_and_expression -> conditional_and_expression AND marker inclusive_or_expression .)
    KEYWORD_BY      reduce using rule 46 (conditional_and_expression -> conditional_and_expression AND marker inclusive_or_expression .)
    OR_BITWISE      shift and go to state 111


state 249

    (170) switch_block_statement -> switch_label . narker marker block narker
    (42) narker -> . empty
    (200) empty -> .

    BLOCKBEGIN      reduce using rule 200 (empty -> .)

    empty                          shift and go to state 276
    narker                         shift and go to state 277

state 250

    (171) switch_label -> KEYWORD_CASE . expression FUNTYPE
    (19) expression -> . assignment_expression
    (22) assignment_expression -> . assignment
    (23) assignment_expression -> . conditional_or_expression
    (24) assignment_expression -> . method_invocation
    (25) assignment -> . valid_variable assignment_operator assignment_expression
    (43) conditional_or_expression -> . conditional_and_expression
    (44) conditional_or_expression -> . conditional_or_expression OR marker conditional_and_expression
    (94) method_invocation -> . name LPAREN argument_list_opt RPAREN
    (26) valid_variable -> . name
    (27) valid_variable -> . array_access
    (45) conditional_and_expression -> . inclusive_or_expression
    (46) conditional_and_expression -> . conditional_and_expression AND marker inclusive_or_expression
    (130) name -> . simple_name
    (131) name -> . qualified_name
    (28) array_access -> . name dimension
    (47) inclusive_or_expression -> . exclusive_or_expression
    (48) inclusive_or_expression -> . inclusive_or_expression OR_BITWISE exclusive_or_expression
    (132) simple_name -> . IDENTIFIER
    (133) qualified_name -> . name INST simple_name
    (49) exclusive_or_expression -> . and_expression
    (50) exclusive_or_expression -> . exclusive_or_expression XOR and_expression
    (51) and_expression -> . equality_expression
    (52) and_expression -> . and_expression AND_BITWISE equality_expression
    (53) equality_expression -> . relational_expression
    (54) equality_expression -> . equality_expression EQUAL relational_expression
    (55) equality_expression -> . equality_expression NEQUAL relational_expression
    (56) relational_expression -> . shift_expression
    (57) relational_expression -> . relational_expression GREATER shift_expression
    (58) relational_expression -> . relational_expression LESS shift_expression
    (59) relational_expression -> . relational_expression GEQ shift_expression
    (60) relational_expression -> . relational_expression LEQ shift_expression
    (61) shift_expression -> . additive_expression
    (62) shift_expression -> . shift_expression LSHIFT additive_expression
    (63) shift_expression -> . shift_expression RSHIFT additive_expression
    (64) additive_expression -> . multiplicative_expression
    (65) additive_expression -> . additive_expression PLUS multiplicative_expression
    (66) additive_expression -> . additive_expression MINUS multiplicative_expression
    (67) multiplicative_expression -> . unary_expression
    (68) multiplicative_expression -> . multiplicative_expression TIMES unary_expression
    (69) multiplicative_expression -> . multiplicative_expression DIVIDE unary_expression
    (70) multiplicative_expression -> . multiplicative_expression REMAINDER unary_expression
    (71) unary_expression -> . PLUS unary_expression
    (72) unary_expression -> . MINUS unary_expression
    (73) unary_expression -> . unary_expression_not_plus_minus
    (74) unary_expression_not_plus_minus -> . base_variable_set
    (75) unary_expression_not_plus_minus -> . TILDA unary_expression
    (76) unary_expression_not_plus_minus -> . cast_expression
    (77) unary_expression_not_plus_minus -> . NOT unary_expression
    (78) base_variable_set -> . variable_literal
    (79) base_variable_set -> . LPAREN expression RPAREN
    (82) cast_expression -> . LPAREN primitive_type RPAREN unary_expression
    (80) variable_literal -> . valid_variable
    (81) variable_literal -> . primary
    (83) primary -> . literal
    (84) primary -> . method_invocation
    (85) literal -> . int_float
    (86) literal -> . c_literal
    (92) int_float -> . DOUBLE_NUMBER
    (93) int_float -> . INT_NUMBER
    (87) c_literal -> . CHAR
    (88) c_literal -> . STRING
    (89) c_literal -> . KEYWORD_NULL
    (90) c_literal -> . BOOL_CONSTT
    (91) c_literal -> . BOOL_CONSTF

    IDENTIFIER      shift and go to state 9
    PLUS            shift and go to state 31
    MINUS           shift and go to state 24
    TILDA           shift and go to state 68
    NOT             shift and go to state 53
    LPAREN          shift and go to state 91
    DOUBLE_NUMBER   shift and go to state 28
    INT_NUMBER      shift and go to state 39
    CHAR            shift and go to state 59
    STRING          shift and go to state 72
    KEYWORD_NULL    shift and go to state 61
    BOOL_CONSTT     shift and go to state 30
    BOOL_CONSTF     shift and go to state 25

    and_expression                 shift and go to state 84
    exclusive_or_expression        shift and go to state 57
    primary                        shift and go to state 58
    unary_expression_not_plus_minus shift and go to state 41
    array_access                   shift and go to state 23
    additive_expression            shift and go to state 62
    simple_name                    shift and go to state 63
    c_literal                      shift and go to state 90
    unary_expression               shift and go to state 40
    base_variable_set              shift and go to state 85
    valid_variable                 shift and go to state 92
    inclusive_or_expression        shift and go to state 27
    literal                        shift and go to state 67
    relational_expression          shift and go to state 69
    method_invocation              shift and go to state 139
    conditional_or_expression      shift and go to state 43
    assignment_expression          shift and go to state 88
    qualified_name                 shift and go to state 75
    assignment                     shift and go to state 142
    multiplicative_expression      shift and go to state 46
    cast_expression                shift and go to state 77
    shift_expression               shift and go to state 50
    equality_expression            shift and go to state 79
    int_float                      shift and go to state 35
    variable_literal               shift and go to state 51
    name                           shift and go to state 38
    expression                     shift and go to state 278
    conditional_and_expression     shift and go to state 52

state 251

    (166) switch_block -> BLOCKBEGIN BLOCKEND .

    KEYWORD_IF      reduce using rule 166 (switch_block -> BLOCKBEGIN BLOCKEND .)
    KEYWORD_WHILE   reduce using rule 166 (switch_block -> BLOCKBEGIN BLOCKEND .)
    KEYWORD_DO      reduce using rule 166 (switch_block -> BLOCKBEGIN BLOCKEND .)
    KEYWORD_FOR     reduce using rule 166 (switch_block -> BLOCKBEGIN BLOCKEND .)
    KEYWORD_CLASS   reduce using rule 166 (switch_block -> BLOCKBEGIN BLOCKEND .)
    KEYWORD_OBJECT  reduce using rule 166 (switch_block -> BLOCKBEGIN BLOCKEND .)
    KEYWORD_VAR     reduce using rule 166 (switch_block -> BLOCKBEGIN BLOCKEND .)
    KEYWORD_VAL     reduce using rule 166 (switch_block -> BLOCKBEGIN BLOCKEND .)
    TERMINATOR      reduce using rule 166 (switch_block -> BLOCKBEGIN BLOCKEND .)
    KEYWORD_RETURN  reduce using rule 166 (switch_block -> BLOCKBEGIN BLOCKEND .)
    KEYWORD_DEF     reduce using rule 166 (switch_block -> BLOCKBEGIN BLOCKEND .)
    BLOCKBEGIN      reduce using rule 166 (switch_block -> BLOCKBEGIN BLOCKEND .)
    IDENTIFIER      reduce using rule 166 (switch_block -> BLOCKBEGIN BLOCKEND .)
    PLUS            reduce using rule 166 (switch_block -> BLOCKBEGIN BLOCKEND .)
    MINUS           reduce using rule 166 (switch_block -> BLOCKBEGIN BLOCKEND .)
    TILDA           reduce using rule 166 (switch_block -> BLOCKBEGIN BLOCKEND .)
    NOT             reduce using rule 166 (switch_block -> BLOCKBEGIN BLOCKEND .)
    LPAREN          reduce using rule 166 (switch_block -> BLOCKBEGIN BLOCKEND .)
    DOUBLE_NUMBER   reduce using rule 166 (switch_block -> BLOCKBEGIN BLOCKEND .)
    INT_NUMBER      reduce using rule 166 (switch_block -> BLOCKBEGIN BLOCKEND .)
    CHAR            reduce using rule 166 (switch_block -> BLOCKBEGIN BLOCKEND .)
    STRING          reduce using rule 166 (switch_block -> BLOCKBEGIN BLOCKEND .)
    KEYWORD_NULL    reduce using rule 166 (switch_block -> BLOCKBEGIN BLOCKEND .)
    BOOL_CONSTT     reduce using rule 166 (switch_block -> BLOCKBEGIN BLOCKEND .)
    BOOL_CONSTF     reduce using rule 166 (switch_block -> BLOCKBEGIN BLOCKEND .)
    BLOCKEND        reduce using rule 166 (switch_block -> BLOCKBEGIN BLOCKEND .)
    KEYWORD_ELSE    reduce using rule 166 (switch_block -> BLOCKBEGIN BLOCKEND .)


state 252

    (167) switch_block -> BLOCKBEGIN switch_block_statements . BLOCKEND
    (169) switch_block_statements -> switch_block_statements . switch_block_statement marker
    (170) switch_block_statement -> . switch_label narker marker block narker
    (171) switch_label -> . KEYWORD_CASE expression FUNTYPE

    BLOCKEND        shift and go to state 279
    KEYWORD_CASE    shift and go to state 250

    switch_block_statement         shift and go to state 280
    switch_label                   shift and go to state 249

state 253

    (168) switch_block_statements -> switch_block_statement . marker
    (41) marker -> . empty
    (200) empty -> .

    BLOCKEND        reduce using rule 200 (empty -> .)
    KEYWORD_CASE    reduce using rule 200 (empty -> .)

    marker                         shift and go to state 281
    empty                          shift and go to state 104

state 254

    (165) switch_statement -> expression KEYWORD_MATCH switch_block marker .

    KEYWORD_ELSE    reduce using rule 165 (switch_statement -> expression KEYWORD_MATCH switch_block marker .)
    KEYWORD_IF      reduce using rule 165 (switch_statement -> expression KEYWORD_MATCH switch_block marker .)
    KEYWORD_WHILE   reduce using rule 165 (switch_statement -> expression KEYWORD_MATCH switch_block marker .)
    KEYWORD_DO      reduce using rule 165 (switch_statement -> expression KEYWORD_MATCH switch_block marker .)
    KEYWORD_FOR     reduce using rule 165 (switch_statement -> expression KEYWORD_MATCH switch_block marker .)
    KEYWORD_CLASS   reduce using rule 165 (switch_statement -> expression KEYWORD_MATCH switch_block marker .)
    KEYWORD_OBJECT  reduce using rule 165 (switch_statement -> expression KEYWORD_MATCH switch_block marker .)
    KEYWORD_VAR     reduce using rule 165 (switch_statement -> expression KEYWORD_MATCH switch_block marker .)
    KEYWORD_VAL     reduce using rule 165 (switch_statement -> expression KEYWORD_MATCH switch_block marker .)
    TERMINATOR      reduce using rule 165 (switch_statement -> expression KEYWORD_MATCH switch_block marker .)
    KEYWORD_RETURN  reduce using rule 165 (switch_statement -> expression KEYWORD_MATCH switch_block marker .)
    KEYWORD_DEF     reduce using rule 165 (switch_statement -> expression KEYWORD_MATCH switch_block marker .)
    BLOCKBEGIN      reduce using rule 165 (switch_statement -> expression KEYWORD_MATCH switch_block marker .)
    IDENTIFIER      reduce using rule 165 (switch_statement -> expression KEYWORD_MATCH switch_block marker .)
    PLUS            reduce using rule 165 (switch_statement -> expression KEYWORD_MATCH switch_block marker .)
    MINUS           reduce using rule 165 (switch_statement -> expression KEYWORD_MATCH switch_block marker .)
    TILDA           reduce using rule 165 (switch_statement -> expression KEYWORD_MATCH switch_block marker .)
    NOT             reduce using rule 165 (switch_statement -> expression KEYWORD_MATCH switch_block marker .)
    LPAREN          reduce using rule 165 (switch_statement -> expression KEYWORD_MATCH switch_block marker .)
    DOUBLE_NUMBER   reduce using rule 165 (switch_statement -> expression KEYWORD_MATCH switch_block marker .)
    INT_NUMBER      reduce using rule 165 (switch_statement -> expression KEYWORD_MATCH switch_block marker .)
    CHAR            reduce using rule 165 (switch_statement -> expression KEYWORD_MATCH switch_block marker .)
    STRING          reduce using rule 165 (switch_statement -> expression KEYWORD_MATCH switch_block marker .)
    KEYWORD_NULL    reduce using rule 165 (switch_statement -> expression KEYWORD_MATCH switch_block marker .)
    BOOL_CONSTT     reduce using rule 165 (switch_statement -> expression KEYWORD_MATCH switch_block marker .)
    BOOL_CONSTF     reduce using rule 165 (switch_statement -> expression KEYWORD_MATCH switch_block marker .)
    BLOCKEND        reduce using rule 165 (switch_statement -> expression KEYWORD_MATCH switch_block marker .)


state 255

    (126) reference_type -> class_data_type .

    COMMA           reduce using rule 126 (reference_type -> class_data_type .)
    RPAREN          reduce using rule 126 (reference_type -> class_data_type .)
    RBRAC           reduce using rule 126 (reference_type -> class_data_type .)
    ASOP            reduce using rule 126 (reference_type -> class_data_type .)


state 256

    (119) type -> reference_type .

    RBRAC           reduce using rule 119 (type -> reference_type .)
    COMMA           reduce using rule 119 (type -> reference_type .)
    RPAREN          reduce using rule 119 (type -> reference_type .)
    ASOP            reduce using rule 119 (type -> reference_type .)


state 257

    (118) type -> primitive_type .

    RBRAC           reduce using rule 118 (type -> primitive_type .)
    COMMA           reduce using rule 118 (type -> primitive_type .)
    RPAREN          reduce using rule 118 (type -> primitive_type .)
    ASOP            reduce using rule 118 (type -> primitive_type .)


state 258

    (108) variable_declaration_body -> identifiers COLON type . ASOP variable_declaration_initializer

    ASOP            shift and go to state 282


state 259

    (127) reference_type -> array_data_type .

    COMMA           reduce using rule 127 (reference_type -> array_data_type .)
    RPAREN          reduce using rule 127 (reference_type -> array_data_type .)
    RBRAC           reduce using rule 127 (reference_type -> array_data_type .)
    ASOP            reduce using rule 127 (reference_type -> array_data_type .)


state 260

    (128) class_data_type -> name .
    (133) qualified_name -> name . INST simple_name

    RBRAC           reduce using rule 128 (class_data_type -> name .)
    ASOP            reduce using rule 128 (class_data_type -> name .)
    COMMA           reduce using rule 128 (class_data_type -> name .)
    RPAREN          reduce using rule 128 (class_data_type -> name .)
    INST            shift and go to state 118


state 261

    (129) array_data_type -> KEYWORD_ARRAY . LBRAC TYPE_INT RBRAC

    LBRAC           shift and go to state 283


state 262

    (109) identifiers -> identifiers COMMA IDENTIFIER .

    COLON           reduce using rule 109 (identifiers -> identifiers COMMA IDENTIFIER .)
    COMMA           reduce using rule 109 (identifiers -> identifiers COMMA IDENTIFIER .)


state 263

    (151) if_then_statement -> KEYWORD_IF LPAREN expression RPAREN . marker block
    (152) if_then_else_statement -> KEYWORD_IF LPAREN expression RPAREN . marker if_then_else_intermediate narker KEYWORD_ELSE marker block
    (41) marker -> . empty
    (200) empty -> .

    BLOCKBEGIN      reduce using rule 200 (empty -> .)
    KEYWORD_IF      reduce using rule 200 (empty -> .)
    TERMINATOR      reduce using rule 200 (empty -> .)
    KEYWORD_RETURN  reduce using rule 200 (empty -> .)
    IDENTIFIER      reduce using rule 200 (empty -> .)
    PLUS            reduce using rule 200 (empty -> .)
    MINUS           reduce using rule 200 (empty -> .)
    TILDA           reduce using rule 200 (empty -> .)
    NOT             reduce using rule 200 (empty -> .)
    LPAREN          reduce using rule 200 (empty -> .)
    DOUBLE_NUMBER   reduce using rule 200 (empty -> .)
    INT_NUMBER      reduce using rule 200 (empty -> .)
    CHAR            reduce using rule 200 (empty -> .)
    STRING          reduce using rule 200 (empty -> .)
    KEYWORD_NULL    reduce using rule 200 (empty -> .)
    BOOL_CONSTT     reduce using rule 200 (empty -> .)
    BOOL_CONSTF     reduce using rule 200 (empty -> .)

    marker                         shift and go to state 284
    empty                          shift and go to state 104

state 264

    (184) method_body -> method_start_scope block_statements_opt end_scope .

    KEYWORD_IF      reduce using rule 184 (method_body -> method_start_scope block_statements_opt end_scope .)
    KEYWORD_WHILE   reduce using rule 184 (method_body -> method_start_scope block_statements_opt end_scope .)
    KEYWORD_DO      reduce using rule 184 (method_body -> method_start_scope block_statements_opt end_scope .)
    KEYWORD_FOR     reduce using rule 184 (method_body -> method_start_scope block_statements_opt end_scope .)
    KEYWORD_CLASS   reduce using rule 184 (method_body -> method_start_scope block_statements_opt end_scope .)
    KEYWORD_OBJECT  reduce using rule 184 (method_body -> method_start_scope block_statements_opt end_scope .)
    KEYWORD_VAR     reduce using rule 184 (method_body -> method_start_scope block_statements_opt end_scope .)
    KEYWORD_VAL     reduce using rule 184 (method_body -> method_start_scope block_statements_opt end_scope .)
    TERMINATOR      reduce using rule 184 (method_body -> method_start_scope block_statements_opt end_scope .)
    KEYWORD_RETURN  reduce using rule 184 (method_body -> method_start_scope block_statements_opt end_scope .)
    KEYWORD_DEF     reduce using rule 184 (method_body -> method_start_scope block_statements_opt end_scope .)
    BLOCKBEGIN      reduce using rule 184 (method_body -> method_start_scope block_statements_opt end_scope .)
    IDENTIFIER      reduce using rule 184 (method_body -> method_start_scope block_statements_opt end_scope .)
    PLUS            reduce using rule 184 (method_body -> method_start_scope block_statements_opt end_scope .)
    MINUS           reduce using rule 184 (method_body -> method_start_scope block_statements_opt end_scope .)
    TILDA           reduce using rule 184 (method_body -> method_start_scope block_statements_opt end_scope .)
    NOT             reduce using rule 184 (method_body -> method_start_scope block_statements_opt end_scope .)
    LPAREN          reduce using rule 184 (method_body -> method_start_scope block_statements_opt end_scope .)
    DOUBLE_NUMBER   reduce using rule 184 (method_body -> method_start_scope block_statements_opt end_scope .)
    INT_NUMBER      reduce using rule 184 (method_body -> method_start_scope block_statements_opt end_scope .)
    CHAR            reduce using rule 184 (method_body -> method_start_scope block_statements_opt end_scope .)
    STRING          reduce using rule 184 (method_body -> method_start_scope block_statements_opt end_scope .)
    KEYWORD_NULL    reduce using rule 184 (method_body -> method_start_scope block_statements_opt end_scope .)
    BOOL_CONSTT     reduce using rule 184 (method_body -> method_start_scope block_statements_opt end_scope .)
    BOOL_CONSTF     reduce using rule 184 (method_body -> method_start_scope block_statements_opt end_scope .)
    BLOCKEND        reduce using rule 184 (method_body -> method_start_scope block_statements_opt end_scope .)


state 265

    (82) cast_expression -> LPAREN primitive_type RPAREN unary_expression .

    TIMES           reduce using rule 82 (cast_expression -> LPAREN primitive_type RPAREN unary_expression .)
    DIVIDE          reduce using rule 82 (cast_expression -> LPAREN primitive_type RPAREN unary_expression .)
    REMAINDER       reduce using rule 82 (cast_expression -> LPAREN primitive_type RPAREN unary_expression .)
    PLUS            reduce using rule 82 (cast_expression -> LPAREN primitive_type RPAREN unary_expression .)
    MINUS           reduce using rule 82 (cast_expression -> LPAREN primitive_type RPAREN unary_expression .)
    LSHIFT          reduce using rule 82 (cast_expression -> LPAREN primitive_type RPAREN unary_expression .)
    RSHIFT          reduce using rule 82 (cast_expression -> LPAREN primitive_type RPAREN unary_expression .)
    GREATER         reduce using rule 82 (cast_expression -> LPAREN primitive_type RPAREN unary_expression .)
    LESS            reduce using rule 82 (cast_expression -> LPAREN primitive_type RPAREN unary_expression .)
    GEQ             reduce using rule 82 (cast_expression -> LPAREN primitive_type RPAREN unary_expression .)
    LEQ             reduce using rule 82 (cast_expression -> LPAREN primitive_type RPAREN unary_expression .)
    EQUAL           reduce using rule 82 (cast_expression -> LPAREN primitive_type RPAREN unary_expression .)
    NEQUAL          reduce using rule 82 (cast_expression -> LPAREN primitive_type RPAREN unary_expression .)
    AND_BITWISE     reduce using rule 82 (cast_expression -> LPAREN primitive_type RPAREN unary_expression .)
    XOR             reduce using rule 82 (cast_expression -> LPAREN primitive_type RPAREN unary_expression .)
    OR_BITWISE      reduce using rule 82 (cast_expression -> LPAREN primitive_type RPAREN unary_expression .)
    AND             reduce using rule 82 (cast_expression -> LPAREN primitive_type RPAREN unary_expression .)
    OR              reduce using rule 82 (cast_expression -> LPAREN primitive_type RPAREN unary_expression .)
    KEYWORD_BY      reduce using rule 82 (cast_expression -> LPAREN primitive_type RPAREN unary_expression .)
    RPAREN          reduce using rule 82 (cast_expression -> LPAREN primitive_type RPAREN unary_expression .)
    KEYWORD_MATCH   reduce using rule 82 (cast_expression -> LPAREN primitive_type RPAREN unary_expression .)
    TERMINATOR      reduce using rule 82 (cast_expression -> LPAREN primitive_type RPAREN unary_expression .)
    RBRAC           reduce using rule 82 (cast_expression -> LPAREN primitive_type RPAREN unary_expression .)
    COMMA           reduce using rule 82 (cast_expression -> LPAREN primitive_type RPAREN unary_expression .)
    FUNTYPE         reduce using rule 82 (cast_expression -> LPAREN primitive_type RPAREN unary_expression .)
    KEYWORD_UNTIL   reduce using rule 82 (cast_expression -> LPAREN primitive_type RPAREN unary_expression .)
    KEYWORD_TO      reduce using rule 82 (cast_expression -> LPAREN primitive_type RPAREN unary_expression .)


state 266

    (159) for_update -> for_loop marker . for_step_opts
    (163) for_step_opts -> . KEYWORD_BY expression
    (164) for_step_opts -> . empty
    (200) empty -> .

    KEYWORD_BY      shift and go to state 285
    RPAREN          reduce using rule 200 (empty -> .)

    for_step_opts                  shift and go to state 286
    empty                          shift and go to state 287

state 267

    (158) for_statement -> KEYWORD_FOR LPAREN for_update RPAREN . marker block
    (41) marker -> . empty
    (200) empty -> .

    BLOCKBEGIN      reduce using rule 200 (empty -> .)

    marker                         shift and go to state 288
    empty                          shift and go to state 104

state 268

    (160) for_loop -> IDENTIFIER CHOOSE . expression for_untilTo marker expression
    (19) expression -> . assignment_expression
    (22) assignment_expression -> . assignment
    (23) assignment_expression -> . conditional_or_expression
    (24) assignment_expression -> . method_invocation
    (25) assignment -> . valid_variable assignment_operator assignment_expression
    (43) conditional_or_expression -> . conditional_and_expression
    (44) conditional_or_expression -> . conditional_or_expression OR marker conditional_and_expression
    (94) method_invocation -> . name LPAREN argument_list_opt RPAREN
    (26) valid_variable -> . name
    (27) valid_variable -> . array_access
    (45) conditional_and_expression -> . inclusive_or_expression
    (46) conditional_and_expression -> . conditional_and_expression AND marker inclusive_or_expression
    (130) name -> . simple_name
    (131) name -> . qualified_name
    (28) array_access -> . name dimension
    (47) inclusive_or_expression -> . exclusive_or_expression
    (48) inclusive_or_expression -> . inclusive_or_expression OR_BITWISE exclusive_or_expression
    (132) simple_name -> . IDENTIFIER
    (133) qualified_name -> . name INST simple_name
    (49) exclusive_or_expression -> . and_expression
    (50) exclusive_or_expression -> . exclusive_or_expression XOR and_expression
    (51) and_expression -> . equality_expression
    (52) and_expression -> . and_expression AND_BITWISE equality_expression
    (53) equality_expression -> . relational_expression
    (54) equality_expression -> . equality_expression EQUAL relational_expression
    (55) equality_expression -> . equality_expression NEQUAL relational_expression
    (56) relational_expression -> . shift_expression
    (57) relational_expression -> . relational_expression GREATER shift_expression
    (58) relational_expression -> . relational_expression LESS shift_expression
    (59) relational_expression -> . relational_expression GEQ shift_expression
    (60) relational_expression -> . relational_expression LEQ shift_expression
    (61) shift_expression -> . additive_expression
    (62) shift_expression -> . shift_expression LSHIFT additive_expression
    (63) shift_expression -> . shift_expression RSHIFT additive_expression
    (64) additive_expression -> . multiplicative_expression
    (65) additive_expression -> . additive_expression PLUS multiplicative_expression
    (66) additive_expression -> . additive_expression MINUS multiplicative_expression
    (67) multiplicative_expression -> . unary_expression
    (68) multiplicative_expression -> . multiplicative_expression TIMES unary_expression
    (69) multiplicative_expression -> . multiplicative_expression DIVIDE unary_expression
    (70) multiplicative_expression -> . multiplicative_expression REMAINDER unary_expression
    (71) unary_expression -> . PLUS unary_expression
    (72) unary_expression -> . MINUS unary_expression
    (73) unary_expression -> . unary_expression_not_plus_minus
    (74) unary_expression_not_plus_minus -> . base_variable_set
    (75) unary_expression_not_plus_minus -> . TILDA unary_expression
    (76) unary_expression_not_plus_minus -> . cast_expression
    (77) unary_expression_not_plus_minus -> . NOT unary_expression
    (78) base_variable_set -> . variable_literal
    (79) base_variable_set -> . LPAREN expression RPAREN
    (82) cast_expression -> . LPAREN primitive_type RPAREN unary_expression
    (80) variable_literal -> . valid_variable
    (81) variable_literal -> . primary
    (83) primary -> . literal
    (84) primary -> . method_invocation
    (85) literal -> . int_float
    (86) literal -> . c_literal
    (92) int_float -> . DOUBLE_NUMBER
    (93) int_float -> . INT_NUMBER
    (87) c_literal -> . CHAR
    (88) c_literal -> . STRING
    (89) c_literal -> . KEYWORD_NULL
    (90) c_literal -> . BOOL_CONSTT
    (91) c_literal -> . BOOL_CONSTF

    IDENTIFIER      shift and go to state 9
    PLUS            shift and go to state 31
    MINUS           shift and go to state 24
    TILDA           shift and go to state 68
    NOT             shift and go to state 53
    LPAREN          shift and go to state 91
    DOUBLE_NUMBER   shift and go to state 28
    INT_NUMBER      shift and go to state 39
    CHAR            shift and go to state 59
    STRING          shift and go to state 72
    KEYWORD_NULL    shift and go to state 61
    BOOL_CONSTT     shift and go to state 30
    BOOL_CONSTF     shift and go to state 25

    unary_expression               shift and go to state 40
    exclusive_or_expression        shift and go to state 57
    primary                        shift and go to state 58
    unary_expression_not_plus_minus shift and go to state 41
    array_access                   shift and go to state 23
    and_expression                 shift and go to state 84
    simple_name                    shift and go to state 63
    c_literal                      shift and go to state 90
    base_variable_set              shift and go to state 85
    valid_variable                 shift and go to state 92
    inclusive_or_expression        shift and go to state 27
    literal                        shift and go to state 67
    relational_expression          shift and go to state 69
    method_invocation              shift and go to state 139
    conditional_or_expression      shift and go to state 43
    assignment_expression          shift and go to state 88
    qualified_name                 shift and go to state 75
    assignment                     shift and go to state 142
    multiplicative_expression      shift and go to state 46
    additive_expression            shift and go to state 62
    cast_expression                shift and go to state 77
    shift_expression               shift and go to state 50
    equality_expression            shift and go to state 79
    int_float                      shift and go to state 35
    variable_literal               shift and go to state 51
    name                           shift and go to state 38
    expression                     shift and go to state 289
    conditional_and_expression     shift and go to state 52

state 269

    (157) do_while_statement -> KEYWORD_DO marker block KEYWORD_WHILE . LPAREN marker expression RPAREN TERMINATOR

    LPAREN          shift and go to state 290


state 270

    (116) variable_declarator_id -> IDENTIFIER COLON type .

    COMMA           reduce using rule 116 (variable_declarator_id -> IDENTIFIER COLON type .)
    RPAREN          reduce using rule 116 (variable_declarator_id -> IDENTIFIER COLON type .)


state 271

    (175) method_header -> method_header_name func_arg_start fun_params_opt RPAREN COLON . method_return_type ASOP
    (181) method_return_type -> . type
    (182) method_return_type -> . TYPE_VOID
    (118) type -> . primitive_type
    (119) type -> . reference_type
    (120) primitive_type -> . TYPE_INT
    (121) primitive_type -> . TYPE_DOUBLE
    (122) primitive_type -> . TYPE_CHAR
    (123) primitive_type -> . TYPE_STRING
    (124) primitive_type -> . TYPE_BOOLEAN
    (125) primitive_type -> . TYPE_VOID
    (126) reference_type -> . class_data_type
    (127) reference_type -> . array_data_type
    (128) class_data_type -> . name
    (129) array_data_type -> . KEYWORD_ARRAY LBRAC TYPE_INT RBRAC
    (130) name -> . simple_name
    (131) name -> . qualified_name
    (132) simple_name -> . IDENTIFIER
    (133) qualified_name -> . name INST simple_name

    TYPE_VOID       shift and go to state 291
    TYPE_INT        shift and go to state 165
    TYPE_DOUBLE     shift and go to state 171
    TYPE_CHAR       shift and go to state 167
    TYPE_STRING     shift and go to state 166
    TYPE_BOOLEAN    shift and go to state 170
    KEYWORD_ARRAY   shift and go to state 261
    IDENTIFIER      shift and go to state 9

    primitive_type                 shift and go to state 257
    name                           shift and go to state 260
    qualified_name                 shift and go to state 75
    method_return_type             shift and go to state 293
    reference_type                 shift and go to state 256
    class_data_type                shift and go to state 255
    type                           shift and go to state 292
    array_data_type                shift and go to state 259
    simple_name                    shift and go to state 63

state 272

    (180) fun_params -> fun_params COMMA fun_variable_declarator_id .

    COMMA           reduce using rule 180 (fun_params -> fun_params COMMA fun_variable_declarator_id .)
    RPAREN          reduce using rule 180 (fun_params -> fun_params COMMA fun_variable_declarator_id .)


state 273

    (117) fun_variable_declarator_id -> IDENTIFIER COLON type .

    COMMA           reduce using rule 117 (fun_variable_declarator_id -> IDENTIFIER COLON type .)
    RPAREN          reduce using rule 117 (fun_variable_declarator_id -> IDENTIFIER COLON type .)


state 274

    (98) argument_list -> argument_list COMMA expression .

    RPAREN          reduce using rule 98 (argument_list -> argument_list COMMA expression .)
    COMMA           reduce using rule 98 (argument_list -> argument_list COMMA expression .)


state 275

    (156) while_statement -> KEYWORD_WHILE LPAREN marker expression RPAREN . marker block
    (41) marker -> . empty
    (200) empty -> .

    BLOCKBEGIN      reduce using rule 200 (empty -> .)

    marker                         shift and go to state 294
    empty                          shift and go to state 104

state 276

    (42) narker -> empty .

    KEYWORD_ELSE    reduce using rule 42 (narker -> empty .)
    BLOCKBEGIN      reduce using rule 42 (narker -> empty .)
    BLOCKEND        reduce using rule 42 (narker -> empty .)
    KEYWORD_CASE    reduce using rule 42 (narker -> empty .)


state 277

    (170) switch_block_statement -> switch_label narker . marker block narker
    (41) marker -> . empty
    (200) empty -> .

    BLOCKBEGIN      reduce using rule 200 (empty -> .)

    marker                         shift and go to state 295
    empty                          shift and go to state 104

state 278

    (171) switch_label -> KEYWORD_CASE expression . FUNTYPE

    FUNTYPE         shift and go to state 296


state 279

    (167) switch_block -> BLOCKBEGIN switch_block_statements BLOCKEND .

    KEYWORD_IF      reduce using rule 167 (switch_block -> BLOCKBEGIN switch_block_statements BLOCKEND .)
    KEYWORD_WHILE   reduce using rule 167 (switch_block -> BLOCKBEGIN switch_block_statements BLOCKEND .)
    KEYWORD_DO      reduce using rule 167 (switch_block -> BLOCKBEGIN switch_block_statements BLOCKEND .)
    KEYWORD_FOR     reduce using rule 167 (switch_block -> BLOCKBEGIN switch_block_statements BLOCKEND .)
    KEYWORD_CLASS   reduce using rule 167 (switch_block -> BLOCKBEGIN switch_block_statements BLOCKEND .)
    KEYWORD_OBJECT  reduce using rule 167 (switch_block -> BLOCKBEGIN switch_block_statements BLOCKEND .)
    KEYWORD_VAR     reduce using rule 167 (switch_block -> BLOCKBEGIN switch_block_statements BLOCKEND .)
    KEYWORD_VAL     reduce using rule 167 (switch_block -> BLOCKBEGIN switch_block_statements BLOCKEND .)
    TERMINATOR      reduce using rule 167 (switch_block -> BLOCKBEGIN switch_block_statements BLOCKEND .)
    KEYWORD_RETURN  reduce using rule 167 (switch_block -> BLOCKBEGIN switch_block_statements BLOCKEND .)
    KEYWORD_DEF     reduce using rule 167 (switch_block -> BLOCKBEGIN switch_block_statements BLOCKEND .)
    BLOCKBEGIN      reduce using rule 167 (switch_block -> BLOCKBEGIN switch_block_statements BLOCKEND .)
    IDENTIFIER      reduce using rule 167 (switch_block -> BLOCKBEGIN switch_block_statements BLOCKEND .)
    PLUS            reduce using rule 167 (switch_block -> BLOCKBEGIN switch_block_statements BLOCKEND .)
    MINUS           reduce using rule 167 (switch_block -> BLOCKBEGIN switch_block_statements BLOCKEND .)
    TILDA           reduce using rule 167 (switch_block -> BLOCKBEGIN switch_block_statements BLOCKEND .)
    NOT             reduce using rule 167 (switch_block -> BLOCKBEGIN switch_block_statements BLOCKEND .)
    LPAREN          reduce using rule 167 (switch_block -> BLOCKBEGIN switch_block_statements BLOCKEND .)
    DOUBLE_NUMBER   reduce using rule 167 (switch_block -> BLOCKBEGIN switch_block_statements BLOCKEND .)
    INT_NUMBER      reduce using rule 167 (switch_block -> BLOCKBEGIN switch_block_statements BLOCKEND .)
    CHAR            reduce using rule 167 (switch_block -> BLOCKBEGIN switch_block_statements BLOCKEND .)
    STRING          reduce using rule 167 (switch_block -> BLOCKBEGIN switch_block_statements BLOCKEND .)
    KEYWORD_NULL    reduce using rule 167 (switch_block -> BLOCKBEGIN switch_block_statements BLOCKEND .)
    BOOL_CONSTT     reduce using rule 167 (switch_block -> BLOCKBEGIN switch_block_statements BLOCKEND .)
    BOOL_CONSTF     reduce using rule 167 (switch_block -> BLOCKBEGIN switch_block_statements BLOCKEND .)
    BLOCKEND        reduce using rule 167 (switch_block -> BLOCKBEGIN switch_block_statements BLOCKEND .)
    KEYWORD_ELSE    reduce using rule 167 (switch_block -> BLOCKBEGIN switch_block_statements BLOCKEND .)


state 280

    (169) switch_block_statements -> switch_block_statements switch_block_statement . marker
    (41) marker -> . empty
    (200) empty -> .

    BLOCKEND        reduce using rule 200 (empty -> .)
    KEYWORD_CASE    reduce using rule 200 (empty -> .)

    marker                         shift and go to state 297
    empty                          shift and go to state 104

state 281

    (168) switch_block_statements -> switch_block_statement marker .

    BLOCKEND        reduce using rule 168 (switch_block_statements -> switch_block_statement marker .)
    KEYWORD_CASE    reduce using rule 168 (switch_block_statements -> switch_block_statement marker .)


state 282

    (108) variable_declaration_body -> identifiers COLON type ASOP . variable_declaration_initializer
    (103) variable_declaration_initializer -> . expression
    (104) variable_declaration_initializer -> . array_initializer
    (105) variable_declaration_initializer -> . class_initializer
    (19) expression -> . assignment_expression
    (134) array_initializer -> . KEYWORD_NEW KEYWORD_ARRAY LBRAC type RBRAC LPAREN conditional_or_expression RPAREN
    (135) array_initializer -> . KEYWORD_ARRAY LBRAC type RBRAC LPAREN argument_list RPAREN
    (136) class_initializer -> . KEYWORD_NEW name LPAREN argument_list_opt RPAREN
    (22) assignment_expression -> . assignment
    (23) assignment_expression -> . conditional_or_expression
    (24) assignment_expression -> . method_invocation
    (25) assignment -> . valid_variable assignment_operator assignment_expression
    (43) conditional_or_expression -> . conditional_and_expression
    (44) conditional_or_expression -> . conditional_or_expression OR marker conditional_and_expression
    (94) method_invocation -> . name LPAREN argument_list_opt RPAREN
    (26) valid_variable -> . name
    (27) valid_variable -> . array_access
    (45) conditional_and_expression -> . inclusive_or_expression
    (46) conditional_and_expression -> . conditional_and_expression AND marker inclusive_or_expression
    (130) name -> . simple_name
    (131) name -> . qualified_name
    (28) array_access -> . name dimension
    (47) inclusive_or_expression -> . exclusive_or_expression
    (48) inclusive_or_expression -> . inclusive_or_expression OR_BITWISE exclusive_or_expression
    (132) simple_name -> . IDENTIFIER
    (133) qualified_name -> . name INST simple_name
    (49) exclusive_or_expression -> . and_expression
    (50) exclusive_or_expression -> . exclusive_or_expression XOR and_expression
    (51) and_expression -> . equality_expression
    (52) and_expression -> . and_expression AND_BITWISE equality_expression
    (53) equality_expression -> . relational_expression
    (54) equality_expression -> . equality_expression EQUAL relational_expression
    (55) equality_expression -> . equality_expression NEQUAL relational_expression
    (56) relational_expression -> . shift_expression
    (57) relational_expression -> . relational_expression GREATER shift_expression
    (58) relational_expression -> . relational_expression LESS shift_expression
    (59) relational_expression -> . relational_expression GEQ shift_expression
    (60) relational_expression -> . relational_expression LEQ shift_expression
    (61) shift_expression -> . additive_expression
    (62) shift_expression -> . shift_expression LSHIFT additive_expression
    (63) shift_expression -> . shift_expression RSHIFT additive_expression
    (64) additive_expression -> . multiplicative_expression
    (65) additive_expression -> . additive_expression PLUS multiplicative_expression
    (66) additive_expression -> . additive_expression MINUS multiplicative_expression
    (67) multiplicative_expression -> . unary_expression
    (68) multiplicative_expression -> . multiplicative_expression TIMES unary_expression
    (69) multiplicative_expression -> . multiplicative_expression DIVIDE unary_expression
    (70) multiplicative_expression -> . multiplicative_expression REMAINDER unary_expression
    (71) unary_expression -> . PLUS unary_expression
    (72) unary_expression -> . MINUS unary_expression
    (73) unary_expression -> . unary_expression_not_plus_minus
    (74) unary_expression_not_plus_minus -> . base_variable_set
    (75) unary_expression_not_plus_minus -> . TILDA unary_expression
    (76) unary_expression_not_plus_minus -> . cast_expression
    (77) unary_expression_not_plus_minus -> . NOT unary_expression
    (78) base_variable_set -> . variable_literal
    (79) base_variable_set -> . LPAREN expression RPAREN
    (82) cast_expression -> . LPAREN primitive_type RPAREN unary_expression
    (80) variable_literal -> . valid_variable
    (81) variable_literal -> . primary
    (83) primary -> . literal
    (84) primary -> . method_invocation
    (85) literal -> . int_float
    (86) literal -> . c_literal
    (92) int_float -> . DOUBLE_NUMBER
    (93) int_float -> . INT_NUMBER
    (87) c_literal -> . CHAR
    (88) c_literal -> . STRING
    (89) c_literal -> . KEYWORD_NULL
    (90) c_literal -> . BOOL_CONSTT
    (91) c_literal -> . BOOL_CONSTF

    KEYWORD_NEW     shift and go to state 300
    KEYWORD_ARRAY   shift and go to state 302
    IDENTIFIER      shift and go to state 9
    PLUS            shift and go to state 31
    MINUS           shift and go to state 24
    TILDA           shift and go to state 68
    NOT             shift and go to state 53
    LPAREN          shift and go to state 91
    DOUBLE_NUMBER   shift and go to state 28
    INT_NUMBER      shift and go to state 39
    CHAR            shift and go to state 59
    STRING          shift and go to state 72
    KEYWORD_NULL    shift and go to state 61
    BOOL_CONSTT     shift and go to state 30
    BOOL_CONSTF     shift and go to state 25

    variable_declaration_initializer shift and go to state 298
    unary_expression               shift and go to state 40
    exclusive_or_expression        shift and go to state 57
    primary                        shift and go to state 58
    unary_expression_not_plus_minus shift and go to state 41
    array_access                   shift and go to state 23
    and_expression                 shift and go to state 84
    simple_name                    shift and go to state 63
    c_literal                      shift and go to state 90
    base_variable_set              shift and go to state 85
    valid_variable                 shift and go to state 92
    inclusive_or_expression        shift and go to state 27
    literal                        shift and go to state 67
    method_invocation              shift and go to state 139
    conditional_or_expression      shift and go to state 43
    relational_expression          shift and go to state 69
    assignment_expression          shift and go to state 88
    qualified_name                 shift and go to state 75
    assignment                     shift and go to state 142
    multiplicative_expression      shift and go to state 46
    additive_expression            shift and go to state 62
    cast_expression                shift and go to state 77
    class_initializer              shift and go to state 301
    shift_expression               shift and go to state 50
    equality_expression            shift and go to state 79
    array_initializer              shift and go to state 299
    int_float                      shift and go to state 35
    variable_literal               shift and go to state 51
    name                           shift and go to state 38
    expression                     shift and go to state 303
    conditional_and_expression     shift and go to state 52

state 283

    (129) array_data_type -> KEYWORD_ARRAY LBRAC . TYPE_INT RBRAC

    TYPE_INT        shift and go to state 304


state 284

    (151) if_then_statement -> KEYWORD_IF LPAREN expression RPAREN marker . block
    (152) if_then_else_statement -> KEYWORD_IF LPAREN expression RPAREN marker . if_then_else_intermediate narker KEYWORD_ELSE marker block
    (7) block -> . start_scope block_statements_opt end_scope
    (154) if_then_else_intermediate -> . normal_statement
    (155) if_then_else_intermediate -> . if_then_else_statement_precedence
    (8) start_scope -> . BLOCKBEGIN
    (143) normal_statement -> . block marker
    (144) normal_statement -> . expression_statement marker
    (145) normal_statement -> . empty_statement marker
    (146) normal_statement -> . return_statement marker
    (147) normal_statement -> . switch_statement marker
    (153) if_then_else_statement_precedence -> . KEYWORD_IF LPAREN expression RPAREN marker if_then_else_intermediate narker KEYWORD_ELSE marker if_then_else_intermediate
    (148) expression_statement -> . statement_expression TERMINATOR
    (172) empty_statement -> . TERMINATOR
    (173) return_statement -> . KEYWORD_RETURN expression_optional TERMINATOR
    (165) switch_statement -> . expression KEYWORD_MATCH switch_block marker
    (149) statement_expression -> . assignment
    (150) statement_expression -> . method_invocation
    (19) expression -> . assignment_expression
    (25) assignment -> . valid_variable assignment_operator assignment_expression
    (94) method_invocation -> . name LPAREN argument_list_opt RPAREN
    (22) assignment_expression -> . assignment
    (23) assignment_expression -> . conditional_or_expression
    (24) assignment_expression -> . method_invocation
    (26) valid_variable -> . name
    (27) valid_variable -> . array_access
    (130) name -> . simple_name
    (131) name -> . qualified_name
    (43) conditional_or_expression -> . conditional_and_expression
    (44) conditional_or_expression -> . conditional_or_expression OR marker conditional_and_expression
    (28) array_access -> . name dimension
    (132) simple_name -> . IDENTIFIER
    (133) qualified_name -> . name INST simple_name
    (45) conditional_and_expression -> . inclusive_or_expression
    (46) conditional_and_expression -> . conditional_and_expression AND marker inclusive_or_expression
    (47) inclusive_or_expression -> . exclusive_or_expression
    (48) inclusive_or_expression -> . inclusive_or_expression OR_BITWISE exclusive_or_expression
    (49) exclusive_or_expression -> . and_expression
    (50) exclusive_or_expression -> . exclusive_or_expression XOR and_expression
    (51) and_expression -> . equality_expression
    (52) and_expression -> . and_expression AND_BITWISE equality_expression
    (53) equality_expression -> . relational_expression
    (54) equality_expression -> . equality_expression EQUAL relational_expression
    (55) equality_expression -> . equality_expression NEQUAL relational_expression
    (56) relational_expression -> . shift_expression
    (57) relational_expression -> . relational_expression GREATER shift_expression
    (58) relational_expression -> . relational_expression LESS shift_expression
    (59) relational_expression -> . relational_expression GEQ shift_expression
    (60) relational_expression -> . relational_expression LEQ shift_expression
    (61) shift_expression -> . additive_expression
    (62) shift_expression -> . shift_expression LSHIFT additive_expression
    (63) shift_expression -> . shift_expression RSHIFT additive_expression
    (64) additive_expression -> . multiplicative_expression
    (65) additive_expression -> . additive_expression PLUS multiplicative_expression
    (66) additive_expression -> . additive_expression MINUS multiplicative_expression
    (67) multiplicative_expression -> . unary_expression
    (68) multiplicative_expression -> . multiplicative_expression TIMES unary_expression
    (69) multiplicative_expression -> . multiplicative_expression DIVIDE unary_expression
    (70) multiplicative_expression -> . multiplicative_expression REMAINDER unary_expression
    (71) unary_expression -> . PLUS unary_expression
    (72) unary_expression -> . MINUS unary_expression
    (73) unary_expression -> . unary_expression_not_plus_minus
    (74) unary_expression_not_plus_minus -> . base_variable_set
    (75) unary_expression_not_plus_minus -> . TILDA unary_expression
    (76) unary_expression_not_plus_minus -> . cast_expression
    (77) unary_expression_not_plus_minus -> . NOT unary_expression
    (78) base_variable_set -> . variable_literal
    (79) base_variable_set -> . LPAREN expression RPAREN
    (82) cast_expression -> . LPAREN primitive_type RPAREN unary_expression
    (80) variable_literal -> . valid_variable
    (81) variable_literal -> . primary
    (83) primary -> . literal
    (84) primary -> . method_invocation
    (85) literal -> . int_float
    (86) literal -> . c_literal
    (92) int_float -> . DOUBLE_NUMBER
    (93) int_float -> . INT_NUMBER
    (87) c_literal -> . CHAR
    (88) c_literal -> . STRING
    (89) c_literal -> . KEYWORD_NULL
    (90) c_literal -> . BOOL_CONSTT
    (91) c_literal -> . BOOL_CONSTF

    BLOCKBEGIN      shift and go to state 12
    KEYWORD_IF      shift and go to state 308
    TERMINATOR      shift and go to state 49
    KEYWORD_RETURN  shift and go to state 64
    IDENTIFIER      shift and go to state 9
    PLUS            shift and go to state 31
    MINUS           shift and go to state 24
    TILDA           shift and go to state 68
    NOT             shift and go to state 53
    LPAREN          shift and go to state 91
    DOUBLE_NUMBER   shift and go to state 28
    INT_NUMBER      shift and go to state 39
    CHAR            shift and go to state 59
    STRING          shift and go to state 72
    KEYWORD_NULL    shift and go to state 61
    BOOL_CONSTT     shift and go to state 30
    BOOL_CONSTF     shift and go to state 25

    expression_statement           shift and go to state 22
    if_then_else_statement_precedence shift and go to state 305
    unary_expression               shift and go to state 40
    exclusive_or_expression        shift and go to state 57
    normal_statement               shift and go to state 306
    primary                        shift and go to state 58
    unary_expression_not_plus_minus shift and go to state 41
    if_then_else_intermediate      shift and go to state 307
    array_access                   shift and go to state 23
    switch_statement               shift and go to state 42
    simple_name                    shift and go to state 63
    qualified_name                 shift and go to state 75
    base_variable_set              shift and go to state 85
    inclusive_or_expression        shift and go to state 27
    return_statement               shift and go to state 86
    literal                        shift and go to state 67
    and_expression                 shift and go to state 84
    statement_expression           shift and go to state 32
    method_invocation              shift and go to state 71
    conditional_or_expression      shift and go to state 43
    relational_expression          shift and go to state 69
    assignment_expression          shift and go to state 88
    assignment                     shift and go to state 89
    multiplicative_expression      shift and go to state 46
    c_literal                      shift and go to state 90
    additive_expression            shift and go to state 62
    start_scope                    shift and go to state 13
    cast_expression                shift and go to state 77
    shift_expression               shift and go to state 50
    equality_expression            shift and go to state 79
    int_float                      shift and go to state 35
    variable_literal               shift and go to state 51
    name                           shift and go to state 38
    valid_variable                 shift and go to state 92
    empty_statement                shift and go to state 81
    expression                     shift and go to state 54
    conditional_and_expression     shift and go to state 52
    block                          shift and go to state 309

state 285

    (163) for_step_opts -> KEYWORD_BY . expression
    (19) expression -> . assignment_expression
    (22) assignment_expression -> . assignment
    (23) assignment_expression -> . conditional_or_expression
    (24) assignment_expression -> . method_invocation
    (25) assignment -> . valid_variable assignment_operator assignment_expression
    (43) conditional_or_expression -> . conditional_and_expression
    (44) conditional_or_expression -> . conditional_or_expression OR marker conditional_and_expression
    (94) method_invocation -> . name LPAREN argument_list_opt RPAREN
    (26) valid_variable -> . name
    (27) valid_variable -> . array_access
    (45) conditional_and_expression -> . inclusive_or_expression
    (46) conditional_and_expression -> . conditional_and_expression AND marker inclusive_or_expression
    (130) name -> . simple_name
    (131) name -> . qualified_name
    (28) array_access -> . name dimension
    (47) inclusive_or_expression -> . exclusive_or_expression
    (48) inclusive_or_expression -> . inclusive_or_expression OR_BITWISE exclusive_or_expression
    (132) simple_name -> . IDENTIFIER
    (133) qualified_name -> . name INST simple_name
    (49) exclusive_or_expression -> . and_expression
    (50) exclusive_or_expression -> . exclusive_or_expression XOR and_expression
    (51) and_expression -> . equality_expression
    (52) and_expression -> . and_expression AND_BITWISE equality_expression
    (53) equality_expression -> . relational_expression
    (54) equality_expression -> . equality_expression EQUAL relational_expression
    (55) equality_expression -> . equality_expression NEQUAL relational_expression
    (56) relational_expression -> . shift_expression
    (57) relational_expression -> . relational_expression GREATER shift_expression
    (58) relational_expression -> . relational_expression LESS shift_expression
    (59) relational_expression -> . relational_expression GEQ shift_expression
    (60) relational_expression -> . relational_expression LEQ shift_expression
    (61) shift_expression -> . additive_expression
    (62) shift_expression -> . shift_expression LSHIFT additive_expression
    (63) shift_expression -> . shift_expression RSHIFT additive_expression
    (64) additive_expression -> . multiplicative_expression
    (65) additive_expression -> . additive_expression PLUS multiplicative_expression
    (66) additive_expression -> . additive_expression MINUS multiplicative_expression
    (67) multiplicative_expression -> . unary_expression
    (68) multiplicative_expression -> . multiplicative_expression TIMES unary_expression
    (69) multiplicative_expression -> . multiplicative_expression DIVIDE unary_expression
    (70) multiplicative_expression -> . multiplicative_expression REMAINDER unary_expression
    (71) unary_expression -> . PLUS unary_expression
    (72) unary_expression -> . MINUS unary_expression
    (73) unary_expression -> . unary_expression_not_plus_minus
    (74) unary_expression_not_plus_minus -> . base_variable_set
    (75) unary_expression_not_plus_minus -> . TILDA unary_expression
    (76) unary_expression_not_plus_minus -> . cast_expression
    (77) unary_expression_not_plus_minus -> . NOT unary_expression
    (78) base_variable_set -> . variable_literal
    (79) base_variable_set -> . LPAREN expression RPAREN
    (82) cast_expression -> . LPAREN primitive_type RPAREN unary_expression
    (80) variable_literal -> . valid_variable
    (81) variable_literal -> . primary
    (83) primary -> . literal
    (84) primary -> . method_invocation
    (85) literal -> . int_float
    (86) literal -> . c_literal
    (92) int_float -> . DOUBLE_NUMBER
    (93) int_float -> . INT_NUMBER
    (87) c_literal -> . CHAR
    (88) c_literal -> . STRING
    (89) c_literal -> . KEYWORD_NULL
    (90) c_literal -> . BOOL_CONSTT
    (91) c_literal -> . BOOL_CONSTF

    IDENTIFIER      shift and go to state 9
    PLUS            shift and go to state 31
    MINUS           shift and go to state 24
    TILDA           shift and go to state 68
    NOT             shift and go to state 53
    LPAREN          shift and go to state 91
    DOUBLE_NUMBER   shift and go to state 28
    INT_NUMBER      shift and go to state 39
    CHAR            shift and go to state 59
    STRING          shift and go to state 72
    KEYWORD_NULL    shift and go to state 61
    BOOL_CONSTT     shift and go to state 30
    BOOL_CONSTF     shift and go to state 25

    and_expression                 shift and go to state 84
    exclusive_or_expression        shift and go to state 57
    primary                        shift and go to state 58
    unary_expression_not_plus_minus shift and go to state 41
    array_access                   shift and go to state 23
    additive_expression            shift and go to state 62
    simple_name                    shift and go to state 63
    c_literal                      shift and go to state 90
    unary_expression               shift and go to state 40
    base_variable_set              shift and go to state 85
    valid_variable                 shift and go to state 92
    inclusive_or_expression        shift and go to state 27
    literal                        shift and go to state 67
    relational_expression          shift and go to state 69
    method_invocation              shift and go to state 139
    conditional_or_expression      shift and go to state 43
    assignment_expression          shift and go to state 88
    qualified_name                 shift and go to state 75
    assignment                     shift and go to state 142
    multiplicative_expression      shift and go to state 46
    cast_expression                shift and go to state 77
    shift_expression               shift and go to state 50
    equality_expression            shift and go to state 79
    int_float                      shift and go to state 35
    variable_literal               shift and go to state 51
    name                           shift and go to state 38
    expression                     shift and go to state 310
    conditional_and_expression     shift and go to state 52

state 286

    (159) for_update -> for_loop marker for_step_opts .

    RPAREN          reduce using rule 159 (for_update -> for_loop marker for_step_opts .)


state 287

    (164) for_step_opts -> empty .

    RPAREN          reduce using rule 164 (for_step_opts -> empty .)


state 288

    (158) for_statement -> KEYWORD_FOR LPAREN for_update RPAREN marker . block
    (7) block -> . start_scope block_statements_opt end_scope
    (8) start_scope -> . BLOCKBEGIN

    BLOCKBEGIN      shift and go to state 12

    start_scope                    shift and go to state 13
    block                          shift and go to state 311

state 289

    (160) for_loop -> IDENTIFIER CHOOSE expression . for_untilTo marker expression
    (161) for_untilTo -> . KEYWORD_UNTIL
    (162) for_untilTo -> . KEYWORD_TO

    KEYWORD_UNTIL   shift and go to state 314
    KEYWORD_TO      shift and go to state 313

    for_untilTo                    shift and go to state 312

state 290

    (157) do_while_statement -> KEYWORD_DO marker block KEYWORD_WHILE LPAREN . marker expression RPAREN TERMINATOR
    (41) marker -> . empty
    (200) empty -> .

    IDENTIFIER      reduce using rule 200 (empty -> .)
    PLUS            reduce using rule 200 (empty -> .)
    MINUS           reduce using rule 200 (empty -> .)
    TILDA           reduce using rule 200 (empty -> .)
    NOT             reduce using rule 200 (empty -> .)
    LPAREN          reduce using rule 200 (empty -> .)
    DOUBLE_NUMBER   reduce using rule 200 (empty -> .)
    INT_NUMBER      reduce using rule 200 (empty -> .)
    CHAR            reduce using rule 200 (empty -> .)
    STRING          reduce using rule 200 (empty -> .)
    KEYWORD_NULL    reduce using rule 200 (empty -> .)
    BOOL_CONSTT     reduce using rule 200 (empty -> .)
    BOOL_CONSTF     reduce using rule 200 (empty -> .)

    marker                         shift and go to state 315
    empty                          shift and go to state 104

state 291

    (182) method_return_type -> TYPE_VOID .
    (125) primitive_type -> TYPE_VOID .

  ! reduce/reduce conflict for ASOP resolved using rule 125 (primitive_type -> TYPE_VOID .)
    ASOP            reduce using rule 125 (primitive_type -> TYPE_VOID .)

  ! ASOP            [ reduce using rule 182 (method_return_type -> TYPE_VOID .) ]


state 292

    (181) method_return_type -> type .

    ASOP            reduce using rule 181 (method_return_type -> type .)


state 293

    (175) method_header -> method_header_name func_arg_start fun_params_opt RPAREN COLON method_return_type . ASOP

    ASOP            shift and go to state 316


state 294

    (156) while_statement -> KEYWORD_WHILE LPAREN marker expression RPAREN marker . block
    (7) block -> . start_scope block_statements_opt end_scope
    (8) start_scope -> . BLOCKBEGIN

    BLOCKBEGIN      shift and go to state 12

    start_scope                    shift and go to state 13
    block                          shift and go to state 317

state 295

    (170) switch_block_statement -> switch_label narker marker . block narker
    (7) block -> . start_scope block_statements_opt end_scope
    (8) start_scope -> . BLOCKBEGIN

    BLOCKBEGIN      shift and go to state 12

    start_scope                    shift and go to state 13
    block                          shift and go to state 318

state 296

    (171) switch_label -> KEYWORD_CASE expression FUNTYPE .

    BLOCKBEGIN      reduce using rule 171 (switch_label -> KEYWORD_CASE expression FUNTYPE .)


state 297

    (169) switch_block_statements -> switch_block_statements switch_block_statement marker .

    BLOCKEND        reduce using rule 169 (switch_block_statements -> switch_block_statements switch_block_statement marker .)
    KEYWORD_CASE    reduce using rule 169 (switch_block_statements -> switch_block_statements switch_block_statement marker .)


state 298

    (108) variable_declaration_body -> identifiers COLON type ASOP variable_declaration_initializer .

    TERMINATOR      reduce using rule 108 (variable_declaration_body -> identifiers COLON type ASOP variable_declaration_initializer .)


state 299

    (104) variable_declaration_initializer -> array_initializer .

    TERMINATOR      reduce using rule 104 (variable_declaration_initializer -> array_initializer .)


state 300

    (134) array_initializer -> KEYWORD_NEW . KEYWORD_ARRAY LBRAC type RBRAC LPAREN conditional_or_expression RPAREN
    (136) class_initializer -> KEYWORD_NEW . name LPAREN argument_list_opt RPAREN
    (130) name -> . simple_name
    (131) name -> . qualified_name
    (132) simple_name -> . IDENTIFIER
    (133) qualified_name -> . name INST simple_name

    KEYWORD_ARRAY   shift and go to state 319
    IDENTIFIER      shift and go to state 9

    name                           shift and go to state 320
    qualified_name                 shift and go to state 75
    simple_name                    shift and go to state 63

state 301

    (105) variable_declaration_initializer -> class_initializer .

    TERMINATOR      reduce using rule 105 (variable_declaration_initializer -> class_initializer .)


state 302

    (135) array_initializer -> KEYWORD_ARRAY . LBRAC type RBRAC LPAREN argument_list RPAREN

    LBRAC           shift and go to state 321


state 303

    (103) variable_declaration_initializer -> expression .

    TERMINATOR      reduce using rule 103 (variable_declaration_initializer -> expression .)


state 304

    (129) array_data_type -> KEYWORD_ARRAY LBRAC TYPE_INT . RBRAC

    RBRAC           shift and go to state 322


state 305

    (155) if_then_else_intermediate -> if_then_else_statement_precedence .

    KEYWORD_ELSE    reduce using rule 155 (if_then_else_intermediate -> if_then_else_statement_precedence .)


state 306

    (154) if_then_else_intermediate -> normal_statement .

    KEYWORD_ELSE    reduce using rule 154 (if_then_else_intermediate -> normal_statement .)


state 307

    (152) if_then_else_statement -> KEYWORD_IF LPAREN expression RPAREN marker if_then_else_intermediate . narker KEYWORD_ELSE marker block
    (42) narker -> . empty
    (200) empty -> .

    KEYWORD_ELSE    reduce using rule 200 (empty -> .)

    narker                         shift and go to state 323
    empty                          shift and go to state 276

state 308

    (153) if_then_else_statement_precedence -> KEYWORD_IF . LPAREN expression RPAREN marker if_then_else_intermediate narker KEYWORD_ELSE marker if_then_else_intermediate

    LPAREN          shift and go to state 324


state 309

    (151) if_then_statement -> KEYWORD_IF LPAREN expression RPAREN marker block .
    (143) normal_statement -> block . marker
    (41) marker -> . empty
    (200) empty -> .

    KEYWORD_IF      reduce using rule 151 (if_then_statement -> KEYWORD_IF LPAREN expression RPAREN marker block .)
    KEYWORD_WHILE   reduce using rule 151 (if_then_statement -> KEYWORD_IF LPAREN expression RPAREN marker block .)
    KEYWORD_DO      reduce using rule 151 (if_then_statement -> KEYWORD_IF LPAREN expression RPAREN marker block .)
    KEYWORD_FOR     reduce using rule 151 (if_then_statement -> KEYWORD_IF LPAREN expression RPAREN marker block .)
    KEYWORD_CLASS   reduce using rule 151 (if_then_statement -> KEYWORD_IF LPAREN expression RPAREN marker block .)
    KEYWORD_OBJECT  reduce using rule 151 (if_then_statement -> KEYWORD_IF LPAREN expression RPAREN marker block .)
    KEYWORD_VAR     reduce using rule 151 (if_then_statement -> KEYWORD_IF LPAREN expression RPAREN marker block .)
    KEYWORD_VAL     reduce using rule 151 (if_then_statement -> KEYWORD_IF LPAREN expression RPAREN marker block .)
    TERMINATOR      reduce using rule 151 (if_then_statement -> KEYWORD_IF LPAREN expression RPAREN marker block .)
    KEYWORD_RETURN  reduce using rule 151 (if_then_statement -> KEYWORD_IF LPAREN expression RPAREN marker block .)
    KEYWORD_DEF     reduce using rule 151 (if_then_statement -> KEYWORD_IF LPAREN expression RPAREN marker block .)
    BLOCKBEGIN      reduce using rule 151 (if_then_statement -> KEYWORD_IF LPAREN expression RPAREN marker block .)
    IDENTIFIER      reduce using rule 151 (if_then_statement -> KEYWORD_IF LPAREN expression RPAREN marker block .)
    PLUS            reduce using rule 151 (if_then_statement -> KEYWORD_IF LPAREN expression RPAREN marker block .)
    MINUS           reduce using rule 151 (if_then_statement -> KEYWORD_IF LPAREN expression RPAREN marker block .)
    TILDA           reduce using rule 151 (if_then_statement -> KEYWORD_IF LPAREN expression RPAREN marker block .)
    NOT             reduce using rule 151 (if_then_statement -> KEYWORD_IF LPAREN expression RPAREN marker block .)
    LPAREN          reduce using rule 151 (if_then_statement -> KEYWORD_IF LPAREN expression RPAREN marker block .)
    DOUBLE_NUMBER   reduce using rule 151 (if_then_statement -> KEYWORD_IF LPAREN expression RPAREN marker block .)
    INT_NUMBER      reduce using rule 151 (if_then_statement -> KEYWORD_IF LPAREN expression RPAREN marker block .)
    CHAR            reduce using rule 151 (if_then_statement -> KEYWORD_IF LPAREN expression RPAREN marker block .)
    STRING          reduce using rule 151 (if_then_statement -> KEYWORD_IF LPAREN expression RPAREN marker block .)
    KEYWORD_NULL    reduce using rule 151 (if_then_statement -> KEYWORD_IF LPAREN expression RPAREN marker block .)
    BOOL_CONSTT     reduce using rule 151 (if_then_statement -> KEYWORD_IF LPAREN expression RPAREN marker block .)
    BOOL_CONSTF     reduce using rule 151 (if_then_statement -> KEYWORD_IF LPAREN expression RPAREN marker block .)
    BLOCKEND        reduce using rule 151 (if_then_statement -> KEYWORD_IF LPAREN expression RPAREN marker block .)
    KEYWORD_ELSE    reduce using rule 200 (empty -> .)

    marker                         shift and go to state 133
    empty                          shift and go to state 104

state 310

    (163) for_step_opts -> KEYWORD_BY expression .

    RPAREN          reduce using rule 163 (for_step_opts -> KEYWORD_BY expression .)


state 311

    (158) for_statement -> KEYWORD_FOR LPAREN for_update RPAREN marker block .

    KEYWORD_IF      reduce using rule 158 (for_statement -> KEYWORD_FOR LPAREN for_update RPAREN marker block .)
    KEYWORD_WHILE   reduce using rule 158 (for_statement -> KEYWORD_FOR LPAREN for_update RPAREN marker block .)
    KEYWORD_DO      reduce using rule 158 (for_statement -> KEYWORD_FOR LPAREN for_update RPAREN marker block .)
    KEYWORD_FOR     reduce using rule 158 (for_statement -> KEYWORD_FOR LPAREN for_update RPAREN marker block .)
    KEYWORD_CLASS   reduce using rule 158 (for_statement -> KEYWORD_FOR LPAREN for_update RPAREN marker block .)
    KEYWORD_OBJECT  reduce using rule 158 (for_statement -> KEYWORD_FOR LPAREN for_update RPAREN marker block .)
    KEYWORD_VAR     reduce using rule 158 (for_statement -> KEYWORD_FOR LPAREN for_update RPAREN marker block .)
    KEYWORD_VAL     reduce using rule 158 (for_statement -> KEYWORD_FOR LPAREN for_update RPAREN marker block .)
    TERMINATOR      reduce using rule 158 (for_statement -> KEYWORD_FOR LPAREN for_update RPAREN marker block .)
    KEYWORD_RETURN  reduce using rule 158 (for_statement -> KEYWORD_FOR LPAREN for_update RPAREN marker block .)
    KEYWORD_DEF     reduce using rule 158 (for_statement -> KEYWORD_FOR LPAREN for_update RPAREN marker block .)
    BLOCKBEGIN      reduce using rule 158 (for_statement -> KEYWORD_FOR LPAREN for_update RPAREN marker block .)
    IDENTIFIER      reduce using rule 158 (for_statement -> KEYWORD_FOR LPAREN for_update RPAREN marker block .)
    PLUS            reduce using rule 158 (for_statement -> KEYWORD_FOR LPAREN for_update RPAREN marker block .)
    MINUS           reduce using rule 158 (for_statement -> KEYWORD_FOR LPAREN for_update RPAREN marker block .)
    TILDA           reduce using rule 158 (for_statement -> KEYWORD_FOR LPAREN for_update RPAREN marker block .)
    NOT             reduce using rule 158 (for_statement -> KEYWORD_FOR LPAREN for_update RPAREN marker block .)
    LPAREN          reduce using rule 158 (for_statement -> KEYWORD_FOR LPAREN for_update RPAREN marker block .)
    DOUBLE_NUMBER   reduce using rule 158 (for_statement -> KEYWORD_FOR LPAREN for_update RPAREN marker block .)
    INT_NUMBER      reduce using rule 158 (for_statement -> KEYWORD_FOR LPAREN for_update RPAREN marker block .)
    CHAR            reduce using rule 158 (for_statement -> KEYWORD_FOR LPAREN for_update RPAREN marker block .)
    STRING          reduce using rule 158 (for_statement -> KEYWORD_FOR LPAREN for_update RPAREN marker block .)
    KEYWORD_NULL    reduce using rule 158 (for_statement -> KEYWORD_FOR LPAREN for_update RPAREN marker block .)
    BOOL_CONSTT     reduce using rule 158 (for_statement -> KEYWORD_FOR LPAREN for_update RPAREN marker block .)
    BOOL_CONSTF     reduce using rule 158 (for_statement -> KEYWORD_FOR LPAREN for_update RPAREN marker block .)
    BLOCKEND        reduce using rule 158 (for_statement -> KEYWORD_FOR LPAREN for_update RPAREN marker block .)


state 312

    (160) for_loop -> IDENTIFIER CHOOSE expression for_untilTo . marker expression
    (41) marker -> . empty
    (200) empty -> .

    IDENTIFIER      reduce using rule 200 (empty -> .)
    PLUS            reduce using rule 200 (empty -> .)
    MINUS           reduce using rule 200 (empty -> .)
    TILDA           reduce using rule 200 (empty -> .)
    NOT             reduce using rule 200 (empty -> .)
    LPAREN          reduce using rule 200 (empty -> .)
    DOUBLE_NUMBER   reduce using rule 200 (empty -> .)
    INT_NUMBER      reduce using rule 200 (empty -> .)
    CHAR            reduce using rule 200 (empty -> .)
    STRING          reduce using rule 200 (empty -> .)
    KEYWORD_NULL    reduce using rule 200 (empty -> .)
    BOOL_CONSTT     reduce using rule 200 (empty -> .)
    BOOL_CONSTF     reduce using rule 200 (empty -> .)

    marker                         shift and go to state 325
    empty                          shift and go to state 104

state 313

    (162) for_untilTo -> KEYWORD_TO .

    IDENTIFIER      reduce using rule 162 (for_untilTo -> KEYWORD_TO .)
    PLUS            reduce using rule 162 (for_untilTo -> KEYWORD_TO .)
    MINUS           reduce using rule 162 (for_untilTo -> KEYWORD_TO .)
    TILDA           reduce using rule 162 (for_untilTo -> KEYWORD_TO .)
    NOT             reduce using rule 162 (for_untilTo -> KEYWORD_TO .)
    LPAREN          reduce using rule 162 (for_untilTo -> KEYWORD_TO .)
    DOUBLE_NUMBER   reduce using rule 162 (for_untilTo -> KEYWORD_TO .)
    INT_NUMBER      reduce using rule 162 (for_untilTo -> KEYWORD_TO .)
    CHAR            reduce using rule 162 (for_untilTo -> KEYWORD_TO .)
    STRING          reduce using rule 162 (for_untilTo -> KEYWORD_TO .)
    KEYWORD_NULL    reduce using rule 162 (for_untilTo -> KEYWORD_TO .)
    BOOL_CONSTT     reduce using rule 162 (for_untilTo -> KEYWORD_TO .)
    BOOL_CONSTF     reduce using rule 162 (for_untilTo -> KEYWORD_TO .)


state 314

    (161) for_untilTo -> KEYWORD_UNTIL .

    IDENTIFIER      reduce using rule 161 (for_untilTo -> KEYWORD_UNTIL .)
    PLUS            reduce using rule 161 (for_untilTo -> KEYWORD_UNTIL .)
    MINUS           reduce using rule 161 (for_untilTo -> KEYWORD_UNTIL .)
    TILDA           reduce using rule 161 (for_untilTo -> KEYWORD_UNTIL .)
    NOT             reduce using rule 161 (for_untilTo -> KEYWORD_UNTIL .)
    LPAREN          reduce using rule 161 (for_untilTo -> KEYWORD_UNTIL .)
    DOUBLE_NUMBER   reduce using rule 161 (for_untilTo -> KEYWORD_UNTIL .)
    INT_NUMBER      reduce using rule 161 (for_untilTo -> KEYWORD_UNTIL .)
    CHAR            reduce using rule 161 (for_untilTo -> KEYWORD_UNTIL .)
    STRING          reduce using rule 161 (for_untilTo -> KEYWORD_UNTIL .)
    KEYWORD_NULL    reduce using rule 161 (for_untilTo -> KEYWORD_UNTIL .)
    BOOL_CONSTT     reduce using rule 161 (for_untilTo -> KEYWORD_UNTIL .)
    BOOL_CONSTF     reduce using rule 161 (for_untilTo -> KEYWORD_UNTIL .)


state 315

    (157) do_while_statement -> KEYWORD_DO marker block KEYWORD_WHILE LPAREN marker . expression RPAREN TERMINATOR
    (19) expression -> . assignment_expression
    (22) assignment_expression -> . assignment
    (23) assignment_expression -> . conditional_or_expression
    (24) assignment_expression -> . method_invocation
    (25) assignment -> . valid_variable assignment_operator assignment_expression
    (43) conditional_or_expression -> . conditional_and_expression
    (44) conditional_or_expression -> . conditional_or_expression OR marker conditional_and_expression
    (94) method_invocation -> . name LPAREN argument_list_opt RPAREN
    (26) valid_variable -> . name
    (27) valid_variable -> . array_access
    (45) conditional_and_expression -> . inclusive_or_expression
    (46) conditional_and_expression -> . conditional_and_expression AND marker inclusive_or_expression
    (130) name -> . simple_name
    (131) name -> . qualified_name
    (28) array_access -> . name dimension
    (47) inclusive_or_expression -> . exclusive_or_expression
    (48) inclusive_or_expression -> . inclusive_or_expression OR_BITWISE exclusive_or_expression
    (132) simple_name -> . IDENTIFIER
    (133) qualified_name -> . name INST simple_name
    (49) exclusive_or_expression -> . and_expression
    (50) exclusive_or_expression -> . exclusive_or_expression XOR and_expression
    (51) and_expression -> . equality_expression
    (52) and_expression -> . and_expression AND_BITWISE equality_expression
    (53) equality_expression -> . relational_expression
    (54) equality_expression -> . equality_expression EQUAL relational_expression
    (55) equality_expression -> . equality_expression NEQUAL relational_expression
    (56) relational_expression -> . shift_expression
    (57) relational_expression -> . relational_expression GREATER shift_expression
    (58) relational_expression -> . relational_expression LESS shift_expression
    (59) relational_expression -> . relational_expression GEQ shift_expression
    (60) relational_expression -> . relational_expression LEQ shift_expression
    (61) shift_expression -> . additive_expression
    (62) shift_expression -> . shift_expression LSHIFT additive_expression
    (63) shift_expression -> . shift_expression RSHIFT additive_expression
    (64) additive_expression -> . multiplicative_expression
    (65) additive_expression -> . additive_expression PLUS multiplicative_expression
    (66) additive_expression -> . additive_expression MINUS multiplicative_expression
    (67) multiplicative_expression -> . unary_expression
    (68) multiplicative_expression -> . multiplicative_expression TIMES unary_expression
    (69) multiplicative_expression -> . multiplicative_expression DIVIDE unary_expression
    (70) multiplicative_expression -> . multiplicative_expression REMAINDER unary_expression
    (71) unary_expression -> . PLUS unary_expression
    (72) unary_expression -> . MINUS unary_expression
    (73) unary_expression -> . unary_expression_not_plus_minus
    (74) unary_expression_not_plus_minus -> . base_variable_set
    (75) unary_expression_not_plus_minus -> . TILDA unary_expression
    (76) unary_expression_not_plus_minus -> . cast_expression
    (77) unary_expression_not_plus_minus -> . NOT unary_expression
    (78) base_variable_set -> . variable_literal
    (79) base_variable_set -> . LPAREN expression RPAREN
    (82) cast_expression -> . LPAREN primitive_type RPAREN unary_expression
    (80) variable_literal -> . valid_variable
    (81) variable_literal -> . primary
    (83) primary -> . literal
    (84) primary -> . method_invocation
    (85) literal -> . int_float
    (86) literal -> . c_literal
    (92) int_float -> . DOUBLE_NUMBER
    (93) int_float -> . INT_NUMBER
    (87) c_literal -> . CHAR
    (88) c_literal -> . STRING
    (89) c_literal -> . KEYWORD_NULL
    (90) c_literal -> . BOOL_CONSTT
    (91) c_literal -> . BOOL_CONSTF

    IDENTIFIER      shift and go to state 9
    PLUS            shift and go to state 31
    MINUS           shift and go to state 24
    TILDA           shift and go to state 68
    NOT             shift and go to state 53
    LPAREN          shift and go to state 91
    DOUBLE_NUMBER   shift and go to state 28
    INT_NUMBER      shift and go to state 39
    CHAR            shift and go to state 59
    STRING          shift and go to state 72
    KEYWORD_NULL    shift and go to state 61
    BOOL_CONSTT     shift and go to state 30
    BOOL_CONSTF     shift and go to state 25

    unary_expression               shift and go to state 40
    exclusive_or_expression        shift and go to state 57
    primary                        shift and go to state 58
    unary_expression_not_plus_minus shift and go to state 41
    array_access                   shift and go to state 23
    and_expression                 shift and go to state 84
    simple_name                    shift and go to state 63
    c_literal                      shift and go to state 90
    base_variable_set              shift and go to state 85
    valid_variable                 shift and go to state 92
    inclusive_or_expression        shift and go to state 27
    literal                        shift and go to state 67
    relational_expression          shift and go to state 69
    method_invocation              shift and go to state 139
    conditional_or_expression      shift and go to state 43
    assignment_expression          shift and go to state 88
    qualified_name                 shift and go to state 75
    assignment                     shift and go to state 142
    multiplicative_expression      shift and go to state 46
    additive_expression            shift and go to state 62
    cast_expression                shift and go to state 77
    shift_expression               shift and go to state 50
    equality_expression            shift and go to state 79
    int_float                      shift and go to state 35
    variable_literal               shift and go to state 51
    name                           shift and go to state 38
    expression                     shift and go to state 326
    conditional_and_expression     shift and go to state 52

state 316

    (175) method_header -> method_header_name func_arg_start fun_params_opt RPAREN COLON method_return_type ASOP .

    BLOCKBEGIN      reduce using rule 175 (method_header -> method_header_name func_arg_start fun_params_opt RPAREN COLON method_return_type ASOP .)


state 317

    (156) while_statement -> KEYWORD_WHILE LPAREN marker expression RPAREN marker block .

    KEYWORD_IF      reduce using rule 156 (while_statement -> KEYWORD_WHILE LPAREN marker expression RPAREN marker block .)
    KEYWORD_WHILE   reduce using rule 156 (while_statement -> KEYWORD_WHILE LPAREN marker expression RPAREN marker block .)
    KEYWORD_DO      reduce using rule 156 (while_statement -> KEYWORD_WHILE LPAREN marker expression RPAREN marker block .)
    KEYWORD_FOR     reduce using rule 156 (while_statement -> KEYWORD_WHILE LPAREN marker expression RPAREN marker block .)
    KEYWORD_CLASS   reduce using rule 156 (while_statement -> KEYWORD_WHILE LPAREN marker expression RPAREN marker block .)
    KEYWORD_OBJECT  reduce using rule 156 (while_statement -> KEYWORD_WHILE LPAREN marker expression RPAREN marker block .)
    KEYWORD_VAR     reduce using rule 156 (while_statement -> KEYWORD_WHILE LPAREN marker expression RPAREN marker block .)
    KEYWORD_VAL     reduce using rule 156 (while_statement -> KEYWORD_WHILE LPAREN marker expression RPAREN marker block .)
    TERMINATOR      reduce using rule 156 (while_statement -> KEYWORD_WHILE LPAREN marker expression RPAREN marker block .)
    KEYWORD_RETURN  reduce using rule 156 (while_statement -> KEYWORD_WHILE LPAREN marker expression RPAREN marker block .)
    KEYWORD_DEF     reduce using rule 156 (while_statement -> KEYWORD_WHILE LPAREN marker expression RPAREN marker block .)
    BLOCKBEGIN      reduce using rule 156 (while_statement -> KEYWORD_WHILE LPAREN marker expression RPAREN marker block .)
    IDENTIFIER      reduce using rule 156 (while_statement -> KEYWORD_WHILE LPAREN marker expression RPAREN marker block .)
    PLUS            reduce using rule 156 (while_statement -> KEYWORD_WHILE LPAREN marker expression RPAREN marker block .)
    MINUS           reduce using rule 156 (while_statement -> KEYWORD_WHILE LPAREN marker expression RPAREN marker block .)
    TILDA           reduce using rule 156 (while_statement -> KEYWORD_WHILE LPAREN marker expression RPAREN marker block .)
    NOT             reduce using rule 156 (while_statement -> KEYWORD_WHILE LPAREN marker expression RPAREN marker block .)
    LPAREN          reduce using rule 156 (while_statement -> KEYWORD_WHILE LPAREN marker expression RPAREN marker block .)
    DOUBLE_NUMBER   reduce using rule 156 (while_statement -> KEYWORD_WHILE LPAREN marker expression RPAREN marker block .)
    INT_NUMBER      reduce using rule 156 (while_statement -> KEYWORD_WHILE LPAREN marker expression RPAREN marker block .)
    CHAR            reduce using rule 156 (while_statement -> KEYWORD_WHILE LPAREN marker expression RPAREN marker block .)
    STRING          reduce using rule 156 (while_statement -> KEYWORD_WHILE LPAREN marker expression RPAREN marker block .)
    KEYWORD_NULL    reduce using rule 156 (while_statement -> KEYWORD_WHILE LPAREN marker expression RPAREN marker block .)
    BOOL_CONSTT     reduce using rule 156 (while_statement -> KEYWORD_WHILE LPAREN marker expression RPAREN marker block .)
    BOOL_CONSTF     reduce using rule 156 (while_statement -> KEYWORD_WHILE LPAREN marker expression RPAREN marker block .)
    BLOCKEND        reduce using rule 156 (while_statement -> KEYWORD_WHILE LPAREN marker expression RPAREN marker block .)


state 318

    (170) switch_block_statement -> switch_label narker marker block . narker
    (42) narker -> . empty
    (200) empty -> .

    BLOCKEND        reduce using rule 200 (empty -> .)
    KEYWORD_CASE    reduce using rule 200 (empty -> .)

    empty                          shift and go to state 276
    narker                         shift and go to state 327

state 319

    (134) array_initializer -> KEYWORD_NEW KEYWORD_ARRAY . LBRAC type RBRAC LPAREN conditional_or_expression RPAREN

    LBRAC           shift and go to state 328


state 320

    (136) class_initializer -> KEYWORD_NEW name . LPAREN argument_list_opt RPAREN
    (133) qualified_name -> name . INST simple_name

    LPAREN          shift and go to state 329
    INST            shift and go to state 118


state 321

    (135) array_initializer -> KEYWORD_ARRAY LBRAC . type RBRAC LPAREN argument_list RPAREN
    (118) type -> . primitive_type
    (119) type -> . reference_type
    (120) primitive_type -> . TYPE_INT
    (121) primitive_type -> . TYPE_DOUBLE
    (122) primitive_type -> . TYPE_CHAR
    (123) primitive_type -> . TYPE_STRING
    (124) primitive_type -> . TYPE_BOOLEAN
    (125) primitive_type -> . TYPE_VOID
    (126) reference_type -> . class_data_type
    (127) reference_type -> . array_data_type
    (128) class_data_type -> . name
    (129) array_data_type -> . KEYWORD_ARRAY LBRAC TYPE_INT RBRAC
    (130) name -> . simple_name
    (131) name -> . qualified_name
    (132) simple_name -> . IDENTIFIER
    (133) qualified_name -> . name INST simple_name

    TYPE_INT        shift and go to state 165
    TYPE_DOUBLE     shift and go to state 171
    TYPE_CHAR       shift and go to state 167
    TYPE_STRING     shift and go to state 166
    TYPE_BOOLEAN    shift and go to state 170
    TYPE_VOID       shift and go to state 168
    KEYWORD_ARRAY   shift and go to state 261
    IDENTIFIER      shift and go to state 9

    name                           shift and go to state 260
    qualified_name                 shift and go to state 75
    reference_type                 shift and go to state 256
    primitive_type                 shift and go to state 257
    simple_name                    shift and go to state 63
    type                           shift and go to state 330
    array_data_type                shift and go to state 259
    class_data_type                shift and go to state 255

state 322

    (129) array_data_type -> KEYWORD_ARRAY LBRAC TYPE_INT RBRAC .

    ASOP            reduce using rule 129 (array_data_type -> KEYWORD_ARRAY LBRAC TYPE_INT RBRAC .)
    RBRAC           reduce using rule 129 (array_data_type -> KEYWORD_ARRAY LBRAC TYPE_INT RBRAC .)
    COMMA           reduce using rule 129 (array_data_type -> KEYWORD_ARRAY LBRAC TYPE_INT RBRAC .)
    RPAREN          reduce using rule 129 (array_data_type -> KEYWORD_ARRAY LBRAC TYPE_INT RBRAC .)


state 323

    (152) if_then_else_statement -> KEYWORD_IF LPAREN expression RPAREN marker if_then_else_intermediate narker . KEYWORD_ELSE marker block

    KEYWORD_ELSE    shift and go to state 331


state 324

    (153) if_then_else_statement_precedence -> KEYWORD_IF LPAREN . expression RPAREN marker if_then_else_intermediate narker KEYWORD_ELSE marker if_then_else_intermediate
    (19) expression -> . assignment_expression
    (22) assignment_expression -> . assignment
    (23) assignment_expression -> . conditional_or_expression
    (24) assignment_expression -> . method_invocation
    (25) assignment -> . valid_variable assignment_operator assignment_expression
    (43) conditional_or_expression -> . conditional_and_expression
    (44) conditional_or_expression -> . conditional_or_expression OR marker conditional_and_expression
    (94) method_invocation -> . name LPAREN argument_list_opt RPAREN
    (26) valid_variable -> . name
    (27) valid_variable -> . array_access
    (45) conditional_and_expression -> . inclusive_or_expression
    (46) conditional_and_expression -> . conditional_and_expression AND marker inclusive_or_expression
    (130) name -> . simple_name
    (131) name -> . qualified_name
    (28) array_access -> . name dimension
    (47) inclusive_or_expression -> . exclusive_or_expression
    (48) inclusive_or_expression -> . inclusive_or_expression OR_BITWISE exclusive_or_expression
    (132) simple_name -> . IDENTIFIER
    (133) qualified_name -> . name INST simple_name
    (49) exclusive_or_expression -> . and_expression
    (50) exclusive_or_expression -> . exclusive_or_expression XOR and_expression
    (51) and_expression -> . equality_expression
    (52) and_expression -> . and_expression AND_BITWISE equality_expression
    (53) equality_expression -> . relational_expression
    (54) equality_expression -> . equality_expression EQUAL relational_expression
    (55) equality_expression -> . equality_expression NEQUAL relational_expression
    (56) relational_expression -> . shift_expression
    (57) relational_expression -> . relational_expression GREATER shift_expression
    (58) relational_expression -> . relational_expression LESS shift_expression
    (59) relational_expression -> . relational_expression GEQ shift_expression
    (60) relational_expression -> . relational_expression LEQ shift_expression
    (61) shift_expression -> . additive_expression
    (62) shift_expression -> . shift_expression LSHIFT additive_expression
    (63) shift_expression -> . shift_expression RSHIFT additive_expression
    (64) additive_expression -> . multiplicative_expression
    (65) additive_expression -> . additive_expression PLUS multiplicative_expression
    (66) additive_expression -> . additive_expression MINUS multiplicative_expression
    (67) multiplicative_expression -> . unary_expression
    (68) multiplicative_expression -> . multiplicative_expression TIMES unary_expression
    (69) multiplicative_expression -> . multiplicative_expression DIVIDE unary_expression
    (70) multiplicative_expression -> . multiplicative_expression REMAINDER unary_expression
    (71) unary_expression -> . PLUS unary_expression
    (72) unary_expression -> . MINUS unary_expression
    (73) unary_expression -> . unary_expression_not_plus_minus
    (74) unary_expression_not_plus_minus -> . base_variable_set
    (75) unary_expression_not_plus_minus -> . TILDA unary_expression
    (76) unary_expression_not_plus_minus -> . cast_expression
    (77) unary_expression_not_plus_minus -> . NOT unary_expression
    (78) base_variable_set -> . variable_literal
    (79) base_variable_set -> . LPAREN expression RPAREN
    (82) cast_expression -> . LPAREN primitive_type RPAREN unary_expression
    (80) variable_literal -> . valid_variable
    (81) variable_literal -> . primary
    (83) primary -> . literal
    (84) primary -> . method_invocation
    (85) literal -> . int_float
    (86) literal -> . c_literal
    (92) int_float -> . DOUBLE_NUMBER
    (93) int_float -> . INT_NUMBER
    (87) c_literal -> . CHAR
    (88) c_literal -> . STRING
    (89) c_literal -> . KEYWORD_NULL
    (90) c_literal -> . BOOL_CONSTT
    (91) c_literal -> . BOOL_CONSTF

    IDENTIFIER      shift and go to state 9
    PLUS            shift and go to state 31
    MINUS           shift and go to state 24
    TILDA           shift and go to state 68
    NOT             shift and go to state 53
    LPAREN          shift and go to state 91
    DOUBLE_NUMBER   shift and go to state 28
    INT_NUMBER      shift and go to state 39
    CHAR            shift and go to state 59
    STRING          shift and go to state 72
    KEYWORD_NULL    shift and go to state 61
    BOOL_CONSTT     shift and go to state 30
    BOOL_CONSTF     shift and go to state 25

    unary_expression               shift and go to state 40
    exclusive_or_expression        shift and go to state 57
    primary                        shift and go to state 58
    unary_expression_not_plus_minus shift and go to state 41
    array_access                   shift and go to state 23
    and_expression                 shift and go to state 84
    simple_name                    shift and go to state 63
    c_literal                      shift and go to state 90
    base_variable_set              shift and go to state 85
    valid_variable                 shift and go to state 92
    inclusive_or_expression        shift and go to state 27
    literal                        shift and go to state 67
    relational_expression          shift and go to state 69
    method_invocation              shift and go to state 139
    conditional_or_expression      shift and go to state 43
    assignment_expression          shift and go to state 88
    qualified_name                 shift and go to state 75
    assignment                     shift and go to state 142
    multiplicative_expression      shift and go to state 46
    additive_expression            shift and go to state 62
    cast_expression                shift and go to state 77
    shift_expression               shift and go to state 50
    equality_expression            shift and go to state 79
    int_float                      shift and go to state 35
    variable_literal               shift and go to state 51
    name                           shift and go to state 38
    expression                     shift and go to state 332
    conditional_and_expression     shift and go to state 52

state 325

    (160) for_loop -> IDENTIFIER CHOOSE expression for_untilTo marker . expression
    (19) expression -> . assignment_expression
    (22) assignment_expression -> . assignment
    (23) assignment_expression -> . conditional_or_expression
    (24) assignment_expression -> . method_invocation
    (25) assignment -> . valid_variable assignment_operator assignment_expression
    (43) conditional_or_expression -> . conditional_and_expression
    (44) conditional_or_expression -> . conditional_or_expression OR marker conditional_and_expression
    (94) method_invocation -> . name LPAREN argument_list_opt RPAREN
    (26) valid_variable -> . name
    (27) valid_variable -> . array_access
    (45) conditional_and_expression -> . inclusive_or_expression
    (46) conditional_and_expression -> . conditional_and_expression AND marker inclusive_or_expression
    (130) name -> . simple_name
    (131) name -> . qualified_name
    (28) array_access -> . name dimension
    (47) inclusive_or_expression -> . exclusive_or_expression
    (48) inclusive_or_expression -> . inclusive_or_expression OR_BITWISE exclusive_or_expression
    (132) simple_name -> . IDENTIFIER
    (133) qualified_name -> . name INST simple_name
    (49) exclusive_or_expression -> . and_expression
    (50) exclusive_or_expression -> . exclusive_or_expression XOR and_expression
    (51) and_expression -> . equality_expression
    (52) and_expression -> . and_expression AND_BITWISE equality_expression
    (53) equality_expression -> . relational_expression
    (54) equality_expression -> . equality_expression EQUAL relational_expression
    (55) equality_expression -> . equality_expression NEQUAL relational_expression
    (56) relational_expression -> . shift_expression
    (57) relational_expression -> . relational_expression GREATER shift_expression
    (58) relational_expression -> . relational_expression LESS shift_expression
    (59) relational_expression -> . relational_expression GEQ shift_expression
    (60) relational_expression -> . relational_expression LEQ shift_expression
    (61) shift_expression -> . additive_expression
    (62) shift_expression -> . shift_expression LSHIFT additive_expression
    (63) shift_expression -> . shift_expression RSHIFT additive_expression
    (64) additive_expression -> . multiplicative_expression
    (65) additive_expression -> . additive_expression PLUS multiplicative_expression
    (66) additive_expression -> . additive_expression MINUS multiplicative_expression
    (67) multiplicative_expression -> . unary_expression
    (68) multiplicative_expression -> . multiplicative_expression TIMES unary_expression
    (69) multiplicative_expression -> . multiplicative_expression DIVIDE unary_expression
    (70) multiplicative_expression -> . multiplicative_expression REMAINDER unary_expression
    (71) unary_expression -> . PLUS unary_expression
    (72) unary_expression -> . MINUS unary_expression
    (73) unary_expression -> . unary_expression_not_plus_minus
    (74) unary_expression_not_plus_minus -> . base_variable_set
    (75) unary_expression_not_plus_minus -> . TILDA unary_expression
    (76) unary_expression_not_plus_minus -> . cast_expression
    (77) unary_expression_not_plus_minus -> . NOT unary_expression
    (78) base_variable_set -> . variable_literal
    (79) base_variable_set -> . LPAREN expression RPAREN
    (82) cast_expression -> . LPAREN primitive_type RPAREN unary_expression
    (80) variable_literal -> . valid_variable
    (81) variable_literal -> . primary
    (83) primary -> . literal
    (84) primary -> . method_invocation
    (85) literal -> . int_float
    (86) literal -> . c_literal
    (92) int_float -> . DOUBLE_NUMBER
    (93) int_float -> . INT_NUMBER
    (87) c_literal -> . CHAR
    (88) c_literal -> . STRING
    (89) c_literal -> . KEYWORD_NULL
    (90) c_literal -> . BOOL_CONSTT
    (91) c_literal -> . BOOL_CONSTF

    IDENTIFIER      shift and go to state 9
    PLUS            shift and go to state 31
    MINUS           shift and go to state 24
    TILDA           shift and go to state 68
    NOT             shift and go to state 53
    LPAREN          shift and go to state 91
    DOUBLE_NUMBER   shift and go to state 28
    INT_NUMBER      shift and go to state 39
    CHAR            shift and go to state 59
    STRING          shift and go to state 72
    KEYWORD_NULL    shift and go to state 61
    BOOL_CONSTT     shift and go to state 30
    BOOL_CONSTF     shift and go to state 25

    unary_expression               shift and go to state 40
    exclusive_or_expression        shift and go to state 57
    primary                        shift and go to state 58
    unary_expression_not_plus_minus shift and go to state 41
    array_access                   shift and go to state 23
    and_expression                 shift and go to state 84
    simple_name                    shift and go to state 63
    c_literal                      shift and go to state 90
    base_variable_set              shift and go to state 85
    valid_variable                 shift and go to state 92
    inclusive_or_expression        shift and go to state 27
    literal                        shift and go to state 67
    relational_expression          shift and go to state 69
    method_invocation              shift and go to state 139
    conditional_or_expression      shift and go to state 43
    assignment_expression          shift and go to state 88
    qualified_name                 shift and go to state 75
    assignment                     shift and go to state 142
    multiplicative_expression      shift and go to state 46
    additive_expression            shift and go to state 62
    cast_expression                shift and go to state 77
    shift_expression               shift and go to state 50
    equality_expression            shift and go to state 79
    int_float                      shift and go to state 35
    variable_literal               shift and go to state 51
    name                           shift and go to state 38
    expression                     shift and go to state 333
    conditional_and_expression     shift and go to state 52

state 326

    (157) do_while_statement -> KEYWORD_DO marker block KEYWORD_WHILE LPAREN marker expression . RPAREN TERMINATOR

    RPAREN          shift and go to state 334


state 327

    (170) switch_block_statement -> switch_label narker marker block narker .

    BLOCKEND        reduce using rule 170 (switch_block_statement -> switch_label narker marker block narker .)
    KEYWORD_CASE    reduce using rule 170 (switch_block_statement -> switch_label narker marker block narker .)


state 328

    (134) array_initializer -> KEYWORD_NEW KEYWORD_ARRAY LBRAC . type RBRAC LPAREN conditional_or_expression RPAREN
    (118) type -> . primitive_type
    (119) type -> . reference_type
    (120) primitive_type -> . TYPE_INT
    (121) primitive_type -> . TYPE_DOUBLE
    (122) primitive_type -> . TYPE_CHAR
    (123) primitive_type -> . TYPE_STRING
    (124) primitive_type -> . TYPE_BOOLEAN
    (125) primitive_type -> . TYPE_VOID
    (126) reference_type -> . class_data_type
    (127) reference_type -> . array_data_type
    (128) class_data_type -> . name
    (129) array_data_type -> . KEYWORD_ARRAY LBRAC TYPE_INT RBRAC
    (130) name -> . simple_name
    (131) name -> . qualified_name
    (132) simple_name -> . IDENTIFIER
    (133) qualified_name -> . name INST simple_name

    TYPE_INT        shift and go to state 165
    TYPE_DOUBLE     shift and go to state 171
    TYPE_CHAR       shift and go to state 167
    TYPE_STRING     shift and go to state 166
    TYPE_BOOLEAN    shift and go to state 170
    TYPE_VOID       shift and go to state 168
    KEYWORD_ARRAY   shift and go to state 261
    IDENTIFIER      shift and go to state 9

    name                           shift and go to state 260
    qualified_name                 shift and go to state 75
    type                           shift and go to state 335
    reference_type                 shift and go to state 256
    primitive_type                 shift and go to state 257
    class_data_type                shift and go to state 255
    array_data_type                shift and go to state 259
    simple_name                    shift and go to state 63

state 329

    (136) class_initializer -> KEYWORD_NEW name LPAREN . argument_list_opt RPAREN
    (95) argument_list_opt -> . argument_list
    (96) argument_list_opt -> . empty
    (97) argument_list -> . expression
    (98) argument_list -> . argument_list COMMA expression
    (200) empty -> .
    (19) expression -> . assignment_expression
    (22) assignment_expression -> . assignment
    (23) assignment_expression -> . conditional_or_expression
    (24) assignment_expression -> . method_invocation
    (25) assignment -> . valid_variable assignment_operator assignment_expression
    (43) conditional_or_expression -> . conditional_and_expression
    (44) conditional_or_expression -> . conditional_or_expression OR marker conditional_and_expression
    (94) method_invocation -> . name LPAREN argument_list_opt RPAREN
    (26) valid_variable -> . name
    (27) valid_variable -> . array_access
    (45) conditional_and_expression -> . inclusive_or_expression
    (46) conditional_and_expression -> . conditional_and_expression AND marker inclusive_or_expression
    (130) name -> . simple_name
    (131) name -> . qualified_name
    (28) array_access -> . name dimension
    (47) inclusive_or_expression -> . exclusive_or_expression
    (48) inclusive_or_expression -> . inclusive_or_expression OR_BITWISE exclusive_or_expression
    (132) simple_name -> . IDENTIFIER
    (133) qualified_name -> . name INST simple_name
    (49) exclusive_or_expression -> . and_expression
    (50) exclusive_or_expression -> . exclusive_or_expression XOR and_expression
    (51) and_expression -> . equality_expression
    (52) and_expression -> . and_expression AND_BITWISE equality_expression
    (53) equality_expression -> . relational_expression
    (54) equality_expression -> . equality_expression EQUAL relational_expression
    (55) equality_expression -> . equality_expression NEQUAL relational_expression
    (56) relational_expression -> . shift_expression
    (57) relational_expression -> . relational_expression GREATER shift_expression
    (58) relational_expression -> . relational_expression LESS shift_expression
    (59) relational_expression -> . relational_expression GEQ shift_expression
    (60) relational_expression -> . relational_expression LEQ shift_expression
    (61) shift_expression -> . additive_expression
    (62) shift_expression -> . shift_expression LSHIFT additive_expression
    (63) shift_expression -> . shift_expression RSHIFT additive_expression
    (64) additive_expression -> . multiplicative_expression
    (65) additive_expression -> . additive_expression PLUS multiplicative_expression
    (66) additive_expression -> . additive_expression MINUS multiplicative_expression
    (67) multiplicative_expression -> . unary_expression
    (68) multiplicative_expression -> . multiplicative_expression TIMES unary_expression
    (69) multiplicative_expression -> . multiplicative_expression DIVIDE unary_expression
    (70) multiplicative_expression -> . multiplicative_expression REMAINDER unary_expression
    (71) unary_expression -> . PLUS unary_expression
    (72) unary_expression -> . MINUS unary_expression
    (73) unary_expression -> . unary_expression_not_plus_minus
    (74) unary_expression_not_plus_minus -> . base_variable_set
    (75) unary_expression_not_plus_minus -> . TILDA unary_expression
    (76) unary_expression_not_plus_minus -> . cast_expression
    (77) unary_expression_not_plus_minus -> . NOT unary_expression
    (78) base_variable_set -> . variable_literal
    (79) base_variable_set -> . LPAREN expression RPAREN
    (82) cast_expression -> . LPAREN primitive_type RPAREN unary_expression
    (80) variable_literal -> . valid_variable
    (81) variable_literal -> . primary
    (83) primary -> . literal
    (84) primary -> . method_invocation
    (85) literal -> . int_float
    (86) literal -> . c_literal
    (92) int_float -> . DOUBLE_NUMBER
    (93) int_float -> . INT_NUMBER
    (87) c_literal -> . CHAR
    (88) c_literal -> . STRING
    (89) c_literal -> . KEYWORD_NULL
    (90) c_literal -> . BOOL_CONSTT
    (91) c_literal -> . BOOL_CONSTF

    RPAREN          reduce using rule 200 (empty -> .)
    IDENTIFIER      shift and go to state 9
    PLUS            shift and go to state 31
    MINUS           shift and go to state 24
    TILDA           shift and go to state 68
    NOT             shift and go to state 53
    LPAREN          shift and go to state 91
    DOUBLE_NUMBER   shift and go to state 28
    INT_NUMBER      shift and go to state 39
    CHAR            shift and go to state 59
    STRING          shift and go to state 72
    KEYWORD_NULL    shift and go to state 61
    BOOL_CONSTT     shift and go to state 30
    BOOL_CONSTF     shift and go to state 25

    unary_expression               shift and go to state 40
    exclusive_or_expression        shift and go to state 57
    primary                        shift and go to state 58
    unary_expression_not_plus_minus shift and go to state 41
    array_access                   shift and go to state 23
    and_expression                 shift and go to state 84
    simple_name                    shift and go to state 63
    c_literal                      shift and go to state 90
    base_variable_set              shift and go to state 85
    valid_variable                 shift and go to state 92
    inclusive_or_expression        shift and go to state 27
    literal                        shift and go to state 67
    relational_expression          shift and go to state 69
    method_invocation              shift and go to state 139
    conditional_or_expression      shift and go to state 43
    empty                          shift and go to state 201
    argument_list                  shift and go to state 200
    assignment_expression          shift and go to state 88
    qualified_name                 shift and go to state 75
    assignment                     shift and go to state 142
    multiplicative_expression      shift and go to state 46
    additive_expression            shift and go to state 62
    cast_expression                shift and go to state 77
    shift_expression               shift and go to state 50
    equality_expression            shift and go to state 79
    int_float                      shift and go to state 35
    variable_literal               shift and go to state 51
    name                           shift and go to state 38
    argument_list_opt              shift and go to state 336
    expression                     shift and go to state 203
    conditional_and_expression     shift and go to state 52

state 330

    (135) array_initializer -> KEYWORD_ARRAY LBRAC type . RBRAC LPAREN argument_list RPAREN

    RBRAC           shift and go to state 337


state 331

    (152) if_then_else_statement -> KEYWORD_IF LPAREN expression RPAREN marker if_then_else_intermediate narker KEYWORD_ELSE . marker block
    (41) marker -> . empty
    (200) empty -> .

    BLOCKBEGIN      reduce using rule 200 (empty -> .)

    marker                         shift and go to state 338
    empty                          shift and go to state 104

state 332

    (153) if_then_else_statement_precedence -> KEYWORD_IF LPAREN expression . RPAREN marker if_then_else_intermediate narker KEYWORD_ELSE marker if_then_else_intermediate

    RPAREN          shift and go to state 339


state 333

    (160) for_loop -> IDENTIFIER CHOOSE expression for_untilTo marker expression .

    KEYWORD_BY      reduce using rule 160 (for_loop -> IDENTIFIER CHOOSE expression for_untilTo marker expression .)
    RPAREN          reduce using rule 160 (for_loop -> IDENTIFIER CHOOSE expression for_untilTo marker expression .)


state 334

    (157) do_while_statement -> KEYWORD_DO marker block KEYWORD_WHILE LPAREN marker expression RPAREN . TERMINATOR

    TERMINATOR      shift and go to state 340


state 335

    (134) array_initializer -> KEYWORD_NEW KEYWORD_ARRAY LBRAC type . RBRAC LPAREN conditional_or_expression RPAREN

    RBRAC           shift and go to state 341


state 336

    (136) class_initializer -> KEYWORD_NEW name LPAREN argument_list_opt . RPAREN

    RPAREN          shift and go to state 342


state 337

    (135) array_initializer -> KEYWORD_ARRAY LBRAC type RBRAC . LPAREN argument_list RPAREN

    LPAREN          shift and go to state 343


state 338

    (152) if_then_else_statement -> KEYWORD_IF LPAREN expression RPAREN marker if_then_else_intermediate narker KEYWORD_ELSE marker . block
    (7) block -> . start_scope block_statements_opt end_scope
    (8) start_scope -> . BLOCKBEGIN

    BLOCKBEGIN      shift and go to state 12

    start_scope                    shift and go to state 13
    block                          shift and go to state 344

state 339

    (153) if_then_else_statement_precedence -> KEYWORD_IF LPAREN expression RPAREN . marker if_then_else_intermediate narker KEYWORD_ELSE marker if_then_else_intermediate
    (41) marker -> . empty
    (200) empty -> .

    KEYWORD_IF      reduce using rule 200 (empty -> .)
    TERMINATOR      reduce using rule 200 (empty -> .)
    KEYWORD_RETURN  reduce using rule 200 (empty -> .)
    BLOCKBEGIN      reduce using rule 200 (empty -> .)
    IDENTIFIER      reduce using rule 200 (empty -> .)
    PLUS            reduce using rule 200 (empty -> .)
    MINUS           reduce using rule 200 (empty -> .)
    TILDA           reduce using rule 200 (empty -> .)
    NOT             reduce using rule 200 (empty -> .)
    LPAREN          reduce using rule 200 (empty -> .)
    DOUBLE_NUMBER   reduce using rule 200 (empty -> .)
    INT_NUMBER      reduce using rule 200 (empty -> .)
    CHAR            reduce using rule 200 (empty -> .)
    STRING          reduce using rule 200 (empty -> .)
    KEYWORD_NULL    reduce using rule 200 (empty -> .)
    BOOL_CONSTT     reduce using rule 200 (empty -> .)
    BOOL_CONSTF     reduce using rule 200 (empty -> .)

    marker                         shift and go to state 345
    empty                          shift and go to state 104

state 340

    (157) do_while_statement -> KEYWORD_DO marker block KEYWORD_WHILE LPAREN marker expression RPAREN TERMINATOR .

    KEYWORD_IF      reduce using rule 157 (do_while_statement -> KEYWORD_DO marker block KEYWORD_WHILE LPAREN marker expression RPAREN TERMINATOR .)
    KEYWORD_WHILE   reduce using rule 157 (do_while_statement -> KEYWORD_DO marker block KEYWORD_WHILE LPAREN marker expression RPAREN TERMINATOR .)
    KEYWORD_DO      reduce using rule 157 (do_while_statement -> KEYWORD_DO marker block KEYWORD_WHILE LPAREN marker expression RPAREN TERMINATOR .)
    KEYWORD_FOR     reduce using rule 157 (do_while_statement -> KEYWORD_DO marker block KEYWORD_WHILE LPAREN marker expression RPAREN TERMINATOR .)
    KEYWORD_CLASS   reduce using rule 157 (do_while_statement -> KEYWORD_DO marker block KEYWORD_WHILE LPAREN marker expression RPAREN TERMINATOR .)
    KEYWORD_OBJECT  reduce using rule 157 (do_while_statement -> KEYWORD_DO marker block KEYWORD_WHILE LPAREN marker expression RPAREN TERMINATOR .)
    KEYWORD_VAR     reduce using rule 157 (do_while_statement -> KEYWORD_DO marker block KEYWORD_WHILE LPAREN marker expression RPAREN TERMINATOR .)
    KEYWORD_VAL     reduce using rule 157 (do_while_statement -> KEYWORD_DO marker block KEYWORD_WHILE LPAREN marker expression RPAREN TERMINATOR .)
    TERMINATOR      reduce using rule 157 (do_while_statement -> KEYWORD_DO marker block KEYWORD_WHILE LPAREN marker expression RPAREN TERMINATOR .)
    KEYWORD_RETURN  reduce using rule 157 (do_while_statement -> KEYWORD_DO marker block KEYWORD_WHILE LPAREN marker expression RPAREN TERMINATOR .)
    KEYWORD_DEF     reduce using rule 157 (do_while_statement -> KEYWORD_DO marker block KEYWORD_WHILE LPAREN marker expression RPAREN TERMINATOR .)
    BLOCKBEGIN      reduce using rule 157 (do_while_statement -> KEYWORD_DO marker block KEYWORD_WHILE LPAREN marker expression RPAREN TERMINATOR .)
    IDENTIFIER      reduce using rule 157 (do_while_statement -> KEYWORD_DO marker block KEYWORD_WHILE LPAREN marker expression RPAREN TERMINATOR .)
    PLUS            reduce using rule 157 (do_while_statement -> KEYWORD_DO marker block KEYWORD_WHILE LPAREN marker expression RPAREN TERMINATOR .)
    MINUS           reduce using rule 157 (do_while_statement -> KEYWORD_DO marker block KEYWORD_WHILE LPAREN marker expression RPAREN TERMINATOR .)
    TILDA           reduce using rule 157 (do_while_statement -> KEYWORD_DO marker block KEYWORD_WHILE LPAREN marker expression RPAREN TERMINATOR .)
    NOT             reduce using rule 157 (do_while_statement -> KEYWORD_DO marker block KEYWORD_WHILE LPAREN marker expression RPAREN TERMINATOR .)
    LPAREN          reduce using rule 157 (do_while_statement -> KEYWORD_DO marker block KEYWORD_WHILE LPAREN marker expression RPAREN TERMINATOR .)
    DOUBLE_NUMBER   reduce using rule 157 (do_while_statement -> KEYWORD_DO marker block KEYWORD_WHILE LPAREN marker expression RPAREN TERMINATOR .)
    INT_NUMBER      reduce using rule 157 (do_while_statement -> KEYWORD_DO marker block KEYWORD_WHILE LPAREN marker expression RPAREN TERMINATOR .)
    CHAR            reduce using rule 157 (do_while_statement -> KEYWORD_DO marker block KEYWORD_WHILE LPAREN marker expression RPAREN TERMINATOR .)
    STRING          reduce using rule 157 (do_while_statement -> KEYWORD_DO marker block KEYWORD_WHILE LPAREN marker expression RPAREN TERMINATOR .)
    KEYWORD_NULL    reduce using rule 157 (do_while_statement -> KEYWORD_DO marker block KEYWORD_WHILE LPAREN marker expression RPAREN TERMINATOR .)
    BOOL_CONSTT     reduce using rule 157 (do_while_statement -> KEYWORD_DO marker block KEYWORD_WHILE LPAREN marker expression RPAREN TERMINATOR .)
    BOOL_CONSTF     reduce using rule 157 (do_while_statement -> KEYWORD_DO marker block KEYWORD_WHILE LPAREN marker expression RPAREN TERMINATOR .)
    BLOCKEND        reduce using rule 157 (do_while_statement -> KEYWORD_DO marker block KEYWORD_WHILE LPAREN marker expression RPAREN TERMINATOR .)


state 341

    (134) array_initializer -> KEYWORD_NEW KEYWORD_ARRAY LBRAC type RBRAC . LPAREN conditional_or_expression RPAREN

    LPAREN          shift and go to state 346


state 342

    (136) class_initializer -> KEYWORD_NEW name LPAREN argument_list_opt RPAREN .

    TERMINATOR      reduce using rule 136 (class_initializer -> KEYWORD_NEW name LPAREN argument_list_opt RPAREN .)


state 343

    (135) array_initializer -> KEYWORD_ARRAY LBRAC type RBRAC LPAREN . argument_list RPAREN
    (97) argument_list -> . expression
    (98) argument_list -> . argument_list COMMA expression
    (19) expression -> . assignment_expression
    (22) assignment_expression -> . assignment
    (23) assignment_expression -> . conditional_or_expression
    (24) assignment_expression -> . method_invocation
    (25) assignment -> . valid_variable assignment_operator assignment_expression
    (43) conditional_or_expression -> . conditional_and_expression
    (44) conditional_or_expression -> . conditional_or_expression OR marker conditional_and_expression
    (94) method_invocation -> . name LPAREN argument_list_opt RPAREN
    (26) valid_variable -> . name
    (27) valid_variable -> . array_access
    (45) conditional_and_expression -> . inclusive_or_expression
    (46) conditional_and_expression -> . conditional_and_expression AND marker inclusive_or_expression
    (130) name -> . simple_name
    (131) name -> . qualified_name
    (28) array_access -> . name dimension
    (47) inclusive_or_expression -> . exclusive_or_expression
    (48) inclusive_or_expression -> . inclusive_or_expression OR_BITWISE exclusive_or_expression
    (132) simple_name -> . IDENTIFIER
    (133) qualified_name -> . name INST simple_name
    (49) exclusive_or_expression -> . and_expression
    (50) exclusive_or_expression -> . exclusive_or_expression XOR and_expression
    (51) and_expression -> . equality_expression
    (52) and_expression -> . and_expression AND_BITWISE equality_expression
    (53) equality_expression -> . relational_expression
    (54) equality_expression -> . equality_expression EQUAL relational_expression
    (55) equality_expression -> . equality_expression NEQUAL relational_expression
    (56) relational_expression -> . shift_expression
    (57) relational_expression -> . relational_expression GREATER shift_expression
    (58) relational_expression -> . relational_expression LESS shift_expression
    (59) relational_expression -> . relational_expression GEQ shift_expression
    (60) relational_expression -> . relational_expression LEQ shift_expression
    (61) shift_expression -> . additive_expression
    (62) shift_expression -> . shift_expression LSHIFT additive_expression
    (63) shift_expression -> . shift_expression RSHIFT additive_expression
    (64) additive_expression -> . multiplicative_expression
    (65) additive_expression -> . additive_expression PLUS multiplicative_expression
    (66) additive_expression -> . additive_expression MINUS multiplicative_expression
    (67) multiplicative_expression -> . unary_expression
    (68) multiplicative_expression -> . multiplicative_expression TIMES unary_expression
    (69) multiplicative_expression -> . multiplicative_expression DIVIDE unary_expression
    (70) multiplicative_expression -> . multiplicative_expression REMAINDER unary_expression
    (71) unary_expression -> . PLUS unary_expression
    (72) unary_expression -> . MINUS unary_expression
    (73) unary_expression -> . unary_expression_not_plus_minus
    (74) unary_expression_not_plus_minus -> . base_variable_set
    (75) unary_expression_not_plus_minus -> . TILDA unary_expression
    (76) unary_expression_not_plus_minus -> . cast_expression
    (77) unary_expression_not_plus_minus -> . NOT unary_expression
    (78) base_variable_set -> . variable_literal
    (79) base_variable_set -> . LPAREN expression RPAREN
    (82) cast_expression -> . LPAREN primitive_type RPAREN unary_expression
    (80) variable_literal -> . valid_variable
    (81) variable_literal -> . primary
    (83) primary -> . literal
    (84) primary -> . method_invocation
    (85) literal -> . int_float
    (86) literal -> . c_literal
    (92) int_float -> . DOUBLE_NUMBER
    (93) int_float -> . INT_NUMBER
    (87) c_literal -> . CHAR
    (88) c_literal -> . STRING
    (89) c_literal -> . KEYWORD_NULL
    (90) c_literal -> . BOOL_CONSTT
    (91) c_literal -> . BOOL_CONSTF

    IDENTIFIER      shift and go to state 9
    PLUS            shift and go to state 31
    MINUS           shift and go to state 24
    TILDA           shift and go to state 68
    NOT             shift and go to state 53
    LPAREN          shift and go to state 91
    DOUBLE_NUMBER   shift and go to state 28
    INT_NUMBER      shift and go to state 39
    CHAR            shift and go to state 59
    STRING          shift and go to state 72
    KEYWORD_NULL    shift and go to state 61
    BOOL_CONSTT     shift and go to state 30
    BOOL_CONSTF     shift and go to state 25

    unary_expression               shift and go to state 40
    exclusive_or_expression        shift and go to state 57
    primary                        shift and go to state 58
    unary_expression_not_plus_minus shift and go to state 41
    array_access                   shift and go to state 23
    and_expression                 shift and go to state 84
    simple_name                    shift and go to state 63
    c_literal                      shift and go to state 90
    base_variable_set              shift and go to state 85
    valid_variable                 shift and go to state 92
    inclusive_or_expression        shift and go to state 27
    literal                        shift and go to state 67
    relational_expression          shift and go to state 69
    method_invocation              shift and go to state 139
    conditional_or_expression      shift and go to state 43
    argument_list                  shift and go to state 347
    assignment_expression          shift and go to state 88
    qualified_name                 shift and go to state 75
    assignment                     shift and go to state 142
    multiplicative_expression      shift and go to state 46
    additive_expression            shift and go to state 62
    cast_expression                shift and go to state 77
    shift_expression               shift and go to state 50
    equality_expression            shift and go to state 79
    int_float                      shift and go to state 35
    variable_literal               shift and go to state 51
    name                           shift and go to state 38
    expression                     shift and go to state 203
    conditional_and_expression     shift and go to state 52

state 344

    (152) if_then_else_statement -> KEYWORD_IF LPAREN expression RPAREN marker if_then_else_intermediate narker KEYWORD_ELSE marker block .

    KEYWORD_IF      reduce using rule 152 (if_then_else_statement -> KEYWORD_IF LPAREN expression RPAREN marker if_then_else_intermediate narker KEYWORD_ELSE marker block .)
    KEYWORD_WHILE   reduce using rule 152 (if_then_else_statement -> KEYWORD_IF LPAREN expression RPAREN marker if_then_else_intermediate narker KEYWORD_ELSE marker block .)
    KEYWORD_DO      reduce using rule 152 (if_then_else_statement -> KEYWORD_IF LPAREN expression RPAREN marker if_then_else_intermediate narker KEYWORD_ELSE marker block .)
    KEYWORD_FOR     reduce using rule 152 (if_then_else_statement -> KEYWORD_IF LPAREN expression RPAREN marker if_then_else_intermediate narker KEYWORD_ELSE marker block .)
    KEYWORD_CLASS   reduce using rule 152 (if_then_else_statement -> KEYWORD_IF LPAREN expression RPAREN marker if_then_else_intermediate narker KEYWORD_ELSE marker block .)
    KEYWORD_OBJECT  reduce using rule 152 (if_then_else_statement -> KEYWORD_IF LPAREN expression RPAREN marker if_then_else_intermediate narker KEYWORD_ELSE marker block .)
    KEYWORD_VAR     reduce using rule 152 (if_then_else_statement -> KEYWORD_IF LPAREN expression RPAREN marker if_then_else_intermediate narker KEYWORD_ELSE marker block .)
    KEYWORD_VAL     reduce using rule 152 (if_then_else_statement -> KEYWORD_IF LPAREN expression RPAREN marker if_then_else_intermediate narker KEYWORD_ELSE marker block .)
    TERMINATOR      reduce using rule 152 (if_then_else_statement -> KEYWORD_IF LPAREN expression RPAREN marker if_then_else_intermediate narker KEYWORD_ELSE marker block .)
    KEYWORD_RETURN  reduce using rule 152 (if_then_else_statement -> KEYWORD_IF LPAREN expression RPAREN marker if_then_else_intermediate narker KEYWORD_ELSE marker block .)
    KEYWORD_DEF     reduce using rule 152 (if_then_else_statement -> KEYWORD_IF LPAREN expression RPAREN marker if_then_else_intermediate narker KEYWORD_ELSE marker block .)
    BLOCKBEGIN      reduce using rule 152 (if_then_else_statement -> KEYWORD_IF LPAREN expression RPAREN marker if_then_else_intermediate narker KEYWORD_ELSE marker block .)
    IDENTIFIER      reduce using rule 152 (if_then_else_statement -> KEYWORD_IF LPAREN expression RPAREN marker if_then_else_intermediate narker KEYWORD_ELSE marker block .)
    PLUS            reduce using rule 152 (if_then_else_statement -> KEYWORD_IF LPAREN expression RPAREN marker if_then_else_intermediate narker KEYWORD_ELSE marker block .)
    MINUS           reduce using rule 152 (if_then_else_statement -> KEYWORD_IF LPAREN expression RPAREN marker if_then_else_intermediate narker KEYWORD_ELSE marker block .)
    TILDA           reduce using rule 152 (if_then_else_statement -> KEYWORD_IF LPAREN expression RPAREN marker if_then_else_intermediate narker KEYWORD_ELSE marker block .)
    NOT             reduce using rule 152 (if_then_else_statement -> KEYWORD_IF LPAREN expression RPAREN marker if_then_else_intermediate narker KEYWORD_ELSE marker block .)
    LPAREN          reduce using rule 152 (if_then_else_statement -> KEYWORD_IF LPAREN expression RPAREN marker if_then_else_intermediate narker KEYWORD_ELSE marker block .)
    DOUBLE_NUMBER   reduce using rule 152 (if_then_else_statement -> KEYWORD_IF LPAREN expression RPAREN marker if_then_else_intermediate narker KEYWORD_ELSE marker block .)
    INT_NUMBER      reduce using rule 152 (if_then_else_statement -> KEYWORD_IF LPAREN expression RPAREN marker if_then_else_intermediate narker KEYWORD_ELSE marker block .)
    CHAR            reduce using rule 152 (if_then_else_statement -> KEYWORD_IF LPAREN expression RPAREN marker if_then_else_intermediate narker KEYWORD_ELSE marker block .)
    STRING          reduce using rule 152 (if_then_else_statement -> KEYWORD_IF LPAREN expression RPAREN marker if_then_else_intermediate narker KEYWORD_ELSE marker block .)
    KEYWORD_NULL    reduce using rule 152 (if_then_else_statement -> KEYWORD_IF LPAREN expression RPAREN marker if_then_else_intermediate narker KEYWORD_ELSE marker block .)
    BOOL_CONSTT     reduce using rule 152 (if_then_else_statement -> KEYWORD_IF LPAREN expression RPAREN marker if_then_else_intermediate narker KEYWORD_ELSE marker block .)
    BOOL_CONSTF     reduce using rule 152 (if_then_else_statement -> KEYWORD_IF LPAREN expression RPAREN marker if_then_else_intermediate narker KEYWORD_ELSE marker block .)
    BLOCKEND        reduce using rule 152 (if_then_else_statement -> KEYWORD_IF LPAREN expression RPAREN marker if_then_else_intermediate narker KEYWORD_ELSE marker block .)


state 345

    (153) if_then_else_statement_precedence -> KEYWORD_IF LPAREN expression RPAREN marker . if_then_else_intermediate narker KEYWORD_ELSE marker if_then_else_intermediate
    (154) if_then_else_intermediate -> . normal_statement
    (155) if_then_else_intermediate -> . if_then_else_statement_precedence
    (143) normal_statement -> . block marker
    (144) normal_statement -> . expression_statement marker
    (145) normal_statement -> . empty_statement marker
    (146) normal_statement -> . return_statement marker
    (147) normal_statement -> . switch_statement marker
    (153) if_then_else_statement_precedence -> . KEYWORD_IF LPAREN expression RPAREN marker if_then_else_intermediate narker KEYWORD_ELSE marker if_then_else_intermediate
    (7) block -> . start_scope block_statements_opt end_scope
    (148) expression_statement -> . statement_expression TERMINATOR
    (172) empty_statement -> . TERMINATOR
    (173) return_statement -> . KEYWORD_RETURN expression_optional TERMINATOR
    (165) switch_statement -> . expression KEYWORD_MATCH switch_block marker
    (8) start_scope -> . BLOCKBEGIN
    (149) statement_expression -> . assignment
    (150) statement_expression -> . method_invocation
    (19) expression -> . assignment_expression
    (25) assignment -> . valid_variable assignment_operator assignment_expression
    (94) method_invocation -> . name LPAREN argument_list_opt RPAREN
    (22) assignment_expression -> . assignment
    (23) assignment_expression -> . conditional_or_expression
    (24) assignment_expression -> . method_invocation
    (26) valid_variable -> . name
    (27) valid_variable -> . array_access
    (130) name -> . simple_name
    (131) name -> . qualified_name
    (43) conditional_or_expression -> . conditional_and_expression
    (44) conditional_or_expression -> . conditional_or_expression OR marker conditional_and_expression
    (28) array_access -> . name dimension
    (132) simple_name -> . IDENTIFIER
    (133) qualified_name -> . name INST simple_name
    (45) conditional_and_expression -> . inclusive_or_expression
    (46) conditional_and_expression -> . conditional_and_expression AND marker inclusive_or_expression
    (47) inclusive_or_expression -> . exclusive_or_expression
    (48) inclusive_or_expression -> . inclusive_or_expression OR_BITWISE exclusive_or_expression
    (49) exclusive_or_expression -> . and_expression
    (50) exclusive_or_expression -> . exclusive_or_expression XOR and_expression
    (51) and_expression -> . equality_expression
    (52) and_expression -> . and_expression AND_BITWISE equality_expression
    (53) equality_expression -> . relational_expression
    (54) equality_expression -> . equality_expression EQUAL relational_expression
    (55) equality_expression -> . equality_expression NEQUAL relational_expression
    (56) relational_expression -> . shift_expression
    (57) relational_expression -> . relational_expression GREATER shift_expression
    (58) relational_expression -> . relational_expression LESS shift_expression
    (59) relational_expression -> . relational_expression GEQ shift_expression
    (60) relational_expression -> . relational_expression LEQ shift_expression
    (61) shift_expression -> . additive_expression
    (62) shift_expression -> . shift_expression LSHIFT additive_expression
    (63) shift_expression -> . shift_expression RSHIFT additive_expression
    (64) additive_expression -> . multiplicative_expression
    (65) additive_expression -> . additive_expression PLUS multiplicative_expression
    (66) additive_expression -> . additive_expression MINUS multiplicative_expression
    (67) multiplicative_expression -> . unary_expression
    (68) multiplicative_expression -> . multiplicative_expression TIMES unary_expression
    (69) multiplicative_expression -> . multiplicative_expression DIVIDE unary_expression
    (70) multiplicative_expression -> . multiplicative_expression REMAINDER unary_expression
    (71) unary_expression -> . PLUS unary_expression
    (72) unary_expression -> . MINUS unary_expression
    (73) unary_expression -> . unary_expression_not_plus_minus
    (74) unary_expression_not_plus_minus -> . base_variable_set
    (75) unary_expression_not_plus_minus -> . TILDA unary_expression
    (76) unary_expression_not_plus_minus -> . cast_expression
    (77) unary_expression_not_plus_minus -> . NOT unary_expression
    (78) base_variable_set -> . variable_literal
    (79) base_variable_set -> . LPAREN expression RPAREN
    (82) cast_expression -> . LPAREN primitive_type RPAREN unary_expression
    (80) variable_literal -> . valid_variable
    (81) variable_literal -> . primary
    (83) primary -> . literal
    (84) primary -> . method_invocation
    (85) literal -> . int_float
    (86) literal -> . c_literal
    (92) int_float -> . DOUBLE_NUMBER
    (93) int_float -> . INT_NUMBER
    (87) c_literal -> . CHAR
    (88) c_literal -> . STRING
    (89) c_literal -> . KEYWORD_NULL
    (90) c_literal -> . BOOL_CONSTT
    (91) c_literal -> . BOOL_CONSTF

    KEYWORD_IF      shift and go to state 308
    TERMINATOR      shift and go to state 49
    KEYWORD_RETURN  shift and go to state 64
    BLOCKBEGIN      shift and go to state 12
    IDENTIFIER      shift and go to state 9
    PLUS            shift and go to state 31
    MINUS           shift and go to state 24
    TILDA           shift and go to state 68
    NOT             shift and go to state 53
    LPAREN          shift and go to state 91
    DOUBLE_NUMBER   shift and go to state 28
    INT_NUMBER      shift and go to state 39
    CHAR            shift and go to state 59
    STRING          shift and go to state 72
    KEYWORD_NULL    shift and go to state 61
    BOOL_CONSTT     shift and go to state 30
    BOOL_CONSTF     shift and go to state 25

    expression_statement           shift and go to state 22
    if_then_else_statement_precedence shift and go to state 305
    unary_expression               shift and go to state 40
    exclusive_or_expression        shift and go to state 57
    normal_statement               shift and go to state 306
    primary                        shift and go to state 58
    unary_expression_not_plus_minus shift and go to state 41
    if_then_else_intermediate      shift and go to state 348
    array_access                   shift and go to state 23
    switch_statement               shift and go to state 42
    simple_name                    shift and go to state 63
    qualified_name                 shift and go to state 75
    base_variable_set              shift and go to state 85
    inclusive_or_expression        shift and go to state 27
    return_statement               shift and go to state 86
    literal                        shift and go to state 67
    and_expression                 shift and go to state 84
    statement_expression           shift and go to state 32
    method_invocation              shift and go to state 71
    conditional_or_expression      shift and go to state 43
    relational_expression          shift and go to state 69
    assignment_expression          shift and go to state 88
    assignment                     shift and go to state 89
    multiplicative_expression      shift and go to state 46
    c_literal                      shift and go to state 90
    additive_expression            shift and go to state 62
    start_scope                    shift and go to state 13
    cast_expression                shift and go to state 77
    shift_expression               shift and go to state 50
    equality_expression            shift and go to state 79
    int_float                      shift and go to state 35
    variable_literal               shift and go to state 51
    name                           shift and go to state 38
    valid_variable                 shift and go to state 92
    empty_statement                shift and go to state 81
    expression                     shift and go to state 54
    conditional_and_expression     shift and go to state 52
    block                          shift and go to state 55

state 346

    (134) array_initializer -> KEYWORD_NEW KEYWORD_ARRAY LBRAC type RBRAC LPAREN . conditional_or_expression RPAREN
    (43) conditional_or_expression -> . conditional_and_expression
    (44) conditional_or_expression -> . conditional_or_expression OR marker conditional_and_expression
    (45) conditional_and_expression -> . inclusive_or_expression
    (46) conditional_and_expression -> . conditional_and_expression AND marker inclusive_or_expression
    (47) inclusive_or_expression -> . exclusive_or_expression
    (48) inclusive_or_expression -> . inclusive_or_expression OR_BITWISE exclusive_or_expression
    (49) exclusive_or_expression -> . and_expression
    (50) exclusive_or_expression -> . exclusive_or_expression XOR and_expression
    (51) and_expression -> . equality_expression
    (52) and_expression -> . and_expression AND_BITWISE equality_expression
    (53) equality_expression -> . relational_expression
    (54) equality_expression -> . equality_expression EQUAL relational_expression
    (55) equality_expression -> . equality_expression NEQUAL relational_expression
    (56) relational_expression -> . shift_expression
    (57) relational_expression -> . relational_expression GREATER shift_expression
    (58) relational_expression -> . relational_expression LESS shift_expression
    (59) relational_expression -> . relational_expression GEQ shift_expression
    (60) relational_expression -> . relational_expression LEQ shift_expression
    (61) shift_expression -> . additive_expression
    (62) shift_expression -> . shift_expression LSHIFT additive_expression
    (63) shift_expression -> . shift_expression RSHIFT additive_expression
    (64) additive_expression -> . multiplicative_expression
    (65) additive_expression -> . additive_expression PLUS multiplicative_expression
    (66) additive_expression -> . additive_expression MINUS multiplicative_expression
    (67) multiplicative_expression -> . unary_expression
    (68) multiplicative_expression -> . multiplicative_expression TIMES unary_expression
    (69) multiplicative_expression -> . multiplicative_expression DIVIDE unary_expression
    (70) multiplicative_expression -> . multiplicative_expression REMAINDER unary_expression
    (71) unary_expression -> . PLUS unary_expression
    (72) unary_expression -> . MINUS unary_expression
    (73) unary_expression -> . unary_expression_not_plus_minus
    (74) unary_expression_not_plus_minus -> . base_variable_set
    (75) unary_expression_not_plus_minus -> . TILDA unary_expression
    (76) unary_expression_not_plus_minus -> . cast_expression
    (77) unary_expression_not_plus_minus -> . NOT unary_expression
    (78) base_variable_set -> . variable_literal
    (79) base_variable_set -> . LPAREN expression RPAREN
    (82) cast_expression -> . LPAREN primitive_type RPAREN unary_expression
    (80) variable_literal -> . valid_variable
    (81) variable_literal -> . primary
    (26) valid_variable -> . name
    (27) valid_variable -> . array_access
    (83) primary -> . literal
    (84) primary -> . method_invocation
    (130) name -> . simple_name
    (131) name -> . qualified_name
    (28) array_access -> . name dimension
    (85) literal -> . int_float
    (86) literal -> . c_literal
    (94) method_invocation -> . name LPAREN argument_list_opt RPAREN
    (132) simple_name -> . IDENTIFIER
    (133) qualified_name -> . name INST simple_name
    (92) int_float -> . DOUBLE_NUMBER
    (93) int_float -> . INT_NUMBER
    (87) c_literal -> . CHAR
    (88) c_literal -> . STRING
    (89) c_literal -> . KEYWORD_NULL
    (90) c_literal -> . BOOL_CONSTT
    (91) c_literal -> . BOOL_CONSTF

    PLUS            shift and go to state 31
    MINUS           shift and go to state 24
    TILDA           shift and go to state 68
    NOT             shift and go to state 53
    LPAREN          shift and go to state 91
    IDENTIFIER      shift and go to state 9
    DOUBLE_NUMBER   shift and go to state 28
    INT_NUMBER      shift and go to state 39
    CHAR            shift and go to state 59
    STRING          shift and go to state 72
    KEYWORD_NULL    shift and go to state 61
    BOOL_CONSTT     shift and go to state 30
    BOOL_CONSTF     shift and go to state 25

    unary_expression               shift and go to state 40
    exclusive_or_expression        shift and go to state 57
    primary                        shift and go to state 58
    unary_expression_not_plus_minus shift and go to state 41
    array_access                   shift and go to state 23
    additive_expression            shift and go to state 62
    simple_name                    shift and go to state 63
    c_literal                      shift and go to state 90
    base_variable_set              shift and go to state 85
    valid_variable                 shift and go to state 106
    inclusive_or_expression        shift and go to state 27
    literal                        shift and go to state 67
    and_expression                 shift and go to state 84
    cast_expression                shift and go to state 77
    relational_expression          shift and go to state 69
    qualified_name                 shift and go to state 75
    multiplicative_expression      shift and go to state 46
    method_invocation              shift and go to state 107
    shift_expression               shift and go to state 50
    equality_expression            shift and go to state 79
    int_float                      shift and go to state 35
    variable_literal               shift and go to state 51
    name                           shift and go to state 108
    conditional_or_expression      shift and go to state 349
    conditional_and_expression     shift and go to state 52

state 347

    (135) array_initializer -> KEYWORD_ARRAY LBRAC type RBRAC LPAREN argument_list . RPAREN
    (98) argument_list -> argument_list . COMMA expression

    RPAREN          shift and go to state 350
    COMMA           shift and go to state 244


state 348

    (153) if_then_else_statement_precedence -> KEYWORD_IF LPAREN expression RPAREN marker if_then_else_intermediate . narker KEYWORD_ELSE marker if_then_else_intermediate
    (42) narker -> . empty
    (200) empty -> .

    KEYWORD_ELSE    reduce using rule 200 (empty -> .)

    narker                         shift and go to state 351
    empty                          shift and go to state 276

state 349

    (134) array_initializer -> KEYWORD_NEW KEYWORD_ARRAY LBRAC type RBRAC LPAREN conditional_or_expression . RPAREN
    (44) conditional_or_expression -> conditional_or_expression . OR marker conditional_and_expression

    RPAREN          shift and go to state 352
    OR              shift and go to state 122


state 350

    (135) array_initializer -> KEYWORD_ARRAY LBRAC type RBRAC LPAREN argument_list RPAREN .

    TERMINATOR      reduce using rule 135 (array_initializer -> KEYWORD_ARRAY LBRAC type RBRAC LPAREN argument_list RPAREN .)


state 351

    (153) if_then_else_statement_precedence -> KEYWORD_IF LPAREN expression RPAREN marker if_then_else_intermediate narker . KEYWORD_ELSE marker if_then_else_intermediate

    KEYWORD_ELSE    shift and go to state 353


state 352

    (134) array_initializer -> KEYWORD_NEW KEYWORD_ARRAY LBRAC type RBRAC LPAREN conditional_or_expression RPAREN .

    TERMINATOR      reduce using rule 134 (array_initializer -> KEYWORD_NEW KEYWORD_ARRAY LBRAC type RBRAC LPAREN conditional_or_expression RPAREN .)


state 353

    (153) if_then_else_statement_precedence -> KEYWORD_IF LPAREN expression RPAREN marker if_then_else_intermediate narker KEYWORD_ELSE . marker if_then_else_intermediate
    (41) marker -> . empty
    (200) empty -> .

    KEYWORD_IF      reduce using rule 200 (empty -> .)
    TERMINATOR      reduce using rule 200 (empty -> .)
    KEYWORD_RETURN  reduce using rule 200 (empty -> .)
    BLOCKBEGIN      reduce using rule 200 (empty -> .)
    IDENTIFIER      reduce using rule 200 (empty -> .)
    PLUS            reduce using rule 200 (empty -> .)
    MINUS           reduce using rule 200 (empty -> .)
    TILDA           reduce using rule 200 (empty -> .)
    NOT             reduce using rule 200 (empty -> .)
    LPAREN          reduce using rule 200 (empty -> .)
    DOUBLE_NUMBER   reduce using rule 200 (empty -> .)
    INT_NUMBER      reduce using rule 200 (empty -> .)
    CHAR            reduce using rule 200 (empty -> .)
    STRING          reduce using rule 200 (empty -> .)
    KEYWORD_NULL    reduce using rule 200 (empty -> .)
    BOOL_CONSTT     reduce using rule 200 (empty -> .)
    BOOL_CONSTF     reduce using rule 200 (empty -> .)

    marker                         shift and go to state 354
    empty                          shift and go to state 104

state 354

    (153) if_then_else_statement_precedence -> KEYWORD_IF LPAREN expression RPAREN marker if_then_else_intermediate narker KEYWORD_ELSE marker . if_then_else_intermediate
    (154) if_then_else_intermediate -> . normal_statement
    (155) if_then_else_intermediate -> . if_then_else_statement_precedence
    (143) normal_statement -> . block marker
    (144) normal_statement -> . expression_statement marker
    (145) normal_statement -> . empty_statement marker
    (146) normal_statement -> . return_statement marker
    (147) normal_statement -> . switch_statement marker
    (153) if_then_else_statement_precedence -> . KEYWORD_IF LPAREN expression RPAREN marker if_then_else_intermediate narker KEYWORD_ELSE marker if_then_else_intermediate
    (7) block -> . start_scope block_statements_opt end_scope
    (148) expression_statement -> . statement_expression TERMINATOR
    (172) empty_statement -> . TERMINATOR
    (173) return_statement -> . KEYWORD_RETURN expression_optional TERMINATOR
    (165) switch_statement -> . expression KEYWORD_MATCH switch_block marker
    (8) start_scope -> . BLOCKBEGIN
    (149) statement_expression -> . assignment
    (150) statement_expression -> . method_invocation
    (19) expression -> . assignment_expression
    (25) assignment -> . valid_variable assignment_operator assignment_expression
    (94) method_invocation -> . name LPAREN argument_list_opt RPAREN
    (22) assignment_expression -> . assignment
    (23) assignment_expression -> . conditional_or_expression
    (24) assignment_expression -> . method_invocation
    (26) valid_variable -> . name
    (27) valid_variable -> . array_access
    (130) name -> . simple_name
    (131) name -> . qualified_name
    (43) conditional_or_expression -> . conditional_and_expression
    (44) conditional_or_expression -> . conditional_or_expression OR marker conditional_and_expression
    (28) array_access -> . name dimension
    (132) simple_name -> . IDENTIFIER
    (133) qualified_name -> . name INST simple_name
    (45) conditional_and_expression -> . inclusive_or_expression
    (46) conditional_and_expression -> . conditional_and_expression AND marker inclusive_or_expression
    (47) inclusive_or_expression -> . exclusive_or_expression
    (48) inclusive_or_expression -> . inclusive_or_expression OR_BITWISE exclusive_or_expression
    (49) exclusive_or_expression -> . and_expression
    (50) exclusive_or_expression -> . exclusive_or_expression XOR and_expression
    (51) and_expression -> . equality_expression
    (52) and_expression -> . and_expression AND_BITWISE equality_expression
    (53) equality_expression -> . relational_expression
    (54) equality_expression -> . equality_expression EQUAL relational_expression
    (55) equality_expression -> . equality_expression NEQUAL relational_expression
    (56) relational_expression -> . shift_expression
    (57) relational_expression -> . relational_expression GREATER shift_expression
    (58) relational_expression -> . relational_expression LESS shift_expression
    (59) relational_expression -> . relational_expression GEQ shift_expression
    (60) relational_expression -> . relational_expression LEQ shift_expression
    (61) shift_expression -> . additive_expression
    (62) shift_expression -> . shift_expression LSHIFT additive_expression
    (63) shift_expression -> . shift_expression RSHIFT additive_expression
    (64) additive_expression -> . multiplicative_expression
    (65) additive_expression -> . additive_expression PLUS multiplicative_expression
    (66) additive_expression -> . additive_expression MINUS multiplicative_expression
    (67) multiplicative_expression -> . unary_expression
    (68) multiplicative_expression -> . multiplicative_expression TIMES unary_expression
    (69) multiplicative_expression -> . multiplicative_expression DIVIDE unary_expression
    (70) multiplicative_expression -> . multiplicative_expression REMAINDER unary_expression
    (71) unary_expression -> . PLUS unary_expression
    (72) unary_expression -> . MINUS unary_expression
    (73) unary_expression -> . unary_expression_not_plus_minus
    (74) unary_expression_not_plus_minus -> . base_variable_set
    (75) unary_expression_not_plus_minus -> . TILDA unary_expression
    (76) unary_expression_not_plus_minus -> . cast_expression
    (77) unary_expression_not_plus_minus -> . NOT unary_expression
    (78) base_variable_set -> . variable_literal
    (79) base_variable_set -> . LPAREN expression RPAREN
    (82) cast_expression -> . LPAREN primitive_type RPAREN unary_expression
    (80) variable_literal -> . valid_variable
    (81) variable_literal -> . primary
    (83) primary -> . literal
    (84) primary -> . method_invocation
    (85) literal -> . int_float
    (86) literal -> . c_literal
    (92) int_float -> . DOUBLE_NUMBER
    (93) int_float -> . INT_NUMBER
    (87) c_literal -> . CHAR
    (88) c_literal -> . STRING
    (89) c_literal -> . KEYWORD_NULL
    (90) c_literal -> . BOOL_CONSTT
    (91) c_literal -> . BOOL_CONSTF

    KEYWORD_IF      shift and go to state 308
    TERMINATOR      shift and go to state 49
    KEYWORD_RETURN  shift and go to state 64
    BLOCKBEGIN      shift and go to state 12
    IDENTIFIER      shift and go to state 9
    PLUS            shift and go to state 31
    MINUS           shift and go to state 24
    TILDA           shift and go to state 68
    NOT             shift and go to state 53
    LPAREN          shift and go to state 91
    DOUBLE_NUMBER   shift and go to state 28
    INT_NUMBER      shift and go to state 39
    CHAR            shift and go to state 59
    STRING          shift and go to state 72
    KEYWORD_NULL    shift and go to state 61
    BOOL_CONSTT     shift and go to state 30
    BOOL_CONSTF     shift and go to state 25

    expression_statement           shift and go to state 22
    if_then_else_statement_precedence shift and go to state 305
    unary_expression               shift and go to state 40
    exclusive_or_expression        shift and go to state 57
    normal_statement               shift and go to state 306
    primary                        shift and go to state 58
    unary_expression_not_plus_minus shift and go to state 41
    if_then_else_intermediate      shift and go to state 355
    array_access                   shift and go to state 23
    switch_statement               shift and go to state 42
    simple_name                    shift and go to state 63
    qualified_name                 shift and go to state 75
    base_variable_set              shift and go to state 85
    inclusive_or_expression        shift and go to state 27
    return_statement               shift and go to state 86
    literal                        shift and go to state 67
    and_expression                 shift and go to state 84
    statement_expression           shift and go to state 32
    method_invocation              shift and go to state 71
    conditional_or_expression      shift and go to state 43
    relational_expression          shift and go to state 69
    assignment_expression          shift and go to state 88
    assignment                     shift and go to state 89
    multiplicative_expression      shift and go to state 46
    c_literal                      shift and go to state 90
    additive_expression            shift and go to state 62
    start_scope                    shift and go to state 13
    cast_expression                shift and go to state 77
    shift_expression               shift and go to state 50
    equality_expression            shift and go to state 79
    int_float                      shift and go to state 35
    variable_literal               shift and go to state 51
    name                           shift and go to state 38
    valid_variable                 shift and go to state 92
    empty_statement                shift and go to state 81
    expression                     shift and go to state 54
    conditional_and_expression     shift and go to state 52
    block                          shift and go to state 55

state 355

    (153) if_then_else_statement_precedence -> KEYWORD_IF LPAREN expression RPAREN marker if_then_else_intermediate narker KEYWORD_ELSE marker if_then_else_intermediate .

    KEYWORD_ELSE    reduce using rule 153 (if_then_else_statement_precedence -> KEYWORD_IF LPAREN expression RPAREN marker if_then_else_intermediate narker KEYWORD_ELSE marker if_then_else_intermediate .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: reduce/reduce conflict in state 71 resolved using rule (assignment_expression -> method_invocation)
WARNING: rejected rule (primary -> method_invocation) in state 71
WARNING: reduce/reduce conflict in state 139 resolved using rule (assignment_expression -> method_invocation)
WARNING: rejected rule (primary -> method_invocation) in state 139
WARNING: reduce/reduce conflict in state 291 resolved using rule (primitive_type -> TYPE_VOID)
WARNING: rejected rule (method_return_type -> TYPE_VOID) in state 291
WARNING: Rule (method_return_type -> TYPE_VOID) is never reduced
