Created by PLY version 3.8 (http://www.dabeaz.com/ply)

Unused terminals:

    KEYWORD_THIS
    KEYWORD_DEFINE
    KEYWORD_PACKAGE
    COMMENT
    KEYWORD_YIELD
    KEYWORD_WITH
    COMMENT_BEGIN
    KEYWORD_TYPE
    KEYWORD_IMPORT
    KEYWORD_BREAK
    COMMENT_END

Grammar

Rule 0     S' -> ProgramStructure
Rule 1     ProgramStructure -> ProgramStructure class_and_objects
Rule 2     ProgramStructure -> class_and_objects
Rule 3     class_and_objects -> SingletonObject
Rule 4     class_and_objects -> class_declaration
Rule 5     SingletonObject -> ObjectDeclare block
Rule 6     ObjectDeclare -> KEYWORD_OBJECT IDENTIFIER
Rule 7     ObjectDeclare -> KEYWORD_OBJECT IDENTIFIER KEYWORD_EXTENDS IDENTIFIER
Rule 8     block -> BLOCKBEGIN block_statements_opt BLOCKEND
Rule 9     block_statements_opt -> block_statements
Rule 10    block_statements_opt -> empty
Rule 11    block_statements -> block_statement
Rule 12    block_statements -> block_statements block_statement
Rule 13    block_statement -> local_variable_declaration_statement
Rule 14    block_statement -> statement
Rule 15    block_statement -> class_declaration
Rule 16    block_statement -> SingletonObject
Rule 17    block_statement -> method_declaration
Rule 18    expression -> assignment_expression
Rule 19    expression_optional -> expression
Rule 20    expression_optional -> empty
Rule 21    assignment_expression -> assignment
Rule 22    assignment_expression -> conditional_or_expression
Rule 23    assignment -> valid_variable assignment_operator assignment_expression
Rule 24    valid_variable -> name
Rule 25    valid_variable -> array_access
Rule 26    array_access -> name LBRAC expression RBRAC
Rule 27    assignment_operator -> ASOP
Rule 28    conditional_or_expression -> conditional_and_expression
Rule 29    conditional_or_expression -> conditional_or_expression OR conditional_and_expression
Rule 30    conditional_and_expression -> inclusive_or_expression
Rule 31    conditional_and_expression -> conditional_and_expression AND inclusive_or_expression
Rule 32    inclusive_or_expression -> exclusive_or_expression
Rule 33    inclusive_or_expression -> inclusive_or_expression OR_BITWISE exclusive_or_expression
Rule 34    exclusive_or_expression -> and_expression
Rule 35    exclusive_or_expression -> exclusive_or_expression XOR and_expression
Rule 36    and_expression -> equality_expression
Rule 37    and_expression -> and_expression AND_BITWISE equality_expression
Rule 38    equality_expression -> relational_expression
Rule 39    equality_expression -> equality_expression EQUAL relational_expression
Rule 40    equality_expression -> equality_expression NEQUAL relational_expression
Rule 41    relational_expression -> shift_expression
Rule 42    relational_expression -> relational_expression GREATER shift_expression
Rule 43    relational_expression -> relational_expression LESS shift_expression
Rule 44    relational_expression -> relational_expression GEQ shift_expression
Rule 45    relational_expression -> relational_expression LEQ shift_expression
Rule 46    shift_expression -> additive_expression
Rule 47    shift_expression -> shift_expression LSHIFT additive_expression
Rule 48    shift_expression -> shift_expression RSHIFT additive_expression
Rule 49    additive_expression -> multiplicative_expression
Rule 50    additive_expression -> additive_expression PLUS multiplicative_expression
Rule 51    additive_expression -> additive_expression MINUS multiplicative_expression
Rule 52    multiplicative_expression -> unary_expression
Rule 53    multiplicative_expression -> multiplicative_expression TIMES unary_expression
Rule 54    multiplicative_expression -> multiplicative_expression DIVIDE unary_expression
Rule 55    multiplicative_expression -> multiplicative_expression REMAINDER unary_expression
Rule 56    unary_expression -> PLUS unary_expression
Rule 57    unary_expression -> MINUS unary_expression
Rule 58    unary_expression -> unary_expression_not_plus_minus
Rule 59    unary_expression_not_plus_minus -> base_variable_set
Rule 60    unary_expression_not_plus_minus -> TILDA unary_expression
Rule 61    unary_expression_not_plus_minus -> NOT unary_expression
Rule 62    unary_expression_not_plus_minus -> cast_expression
Rule 63    base_variable_set -> variable_literal
Rule 64    base_variable_set -> LPAREN expression RPAREN
Rule 65    variable_literal -> valid_variable
Rule 66    variable_literal -> primary
Rule 67    cast_expression -> LPAREN primitive_type RPAREN unary_expression
Rule 68    primary -> literal
Rule 69    primary -> method_invocation
Rule 70    literal -> int_float
Rule 71    literal -> c_literal
Rule 72    c_literal -> CHAR
Rule 73    c_literal -> STRING
Rule 74    c_literal -> BOOL_CONSTT
Rule 75    c_literal -> BOOL_CONSTF
Rule 76    c_literal -> KEYWORD_NULL
Rule 77    int_float -> DOUBLE_NUMBER
Rule 78    int_float -> INT_NUMBER
Rule 79    method_invocation -> name LPAREN argument_list_opt RPAREN
Rule 80    argument_list_opt -> argument_list
Rule 81    argument_list_opt -> empty
Rule 82    argument_list -> expression
Rule 83    argument_list -> argument_list COMMA expression
Rule 84    modifier -> KEYWORD_PROTECTED
Rule 85    modifier -> KEYWORD_PRIVATE
Rule 86    modifier_opts -> modifier
Rule 87    modifier_opts -> empty
Rule 88    declaration_keyword -> KEYWORD_VAR
Rule 89    declaration_keyword -> KEYWORD_VAL
Rule 90    local_variable_declaration_statement -> local_variable_declaration TERMINATOR
Rule 91    local_variable_declaration -> modifier_opts declaration_keyword variable_declaration_body
Rule 92    variable_declaration_initializer -> expression
Rule 93    variable_declaration_initializer -> array_initializer
Rule 94    variable_declaration_initializer -> class_initializer
Rule 95    variable_arguement_list -> variable_declaration_initializer
Rule 96    variable_arguement_list -> variable_arguement_list COMMA variable_declaration_initializer
Rule 97    variable_declaration_body -> variable_declarator ASOP variable_declaration_initializer
Rule 98    variable_declaration_body -> LPAREN variable_declarators RPAREN ASOP LPAREN variable_arguement_list RPAREN
Rule 99    variable_declaration_body -> IDENTIFIER ASOP LPAREN func_arguement_list_opt RPAREN FUNTYPE expression
Rule 100   variable_declarators -> variable_declarator
Rule 101   variable_declarators -> variable_declarators COMMA variable_declarator
Rule 102   variable_declarator -> variable_declarator_id
Rule 103   variable_declarator_id -> IDENTIFIER COLON type
Rule 104   type -> primitive_type
Rule 105   type -> reference_type
Rule 106   primitive_type -> TYPE_INT
Rule 107   primitive_type -> TYPE_DOUBLE
Rule 108   primitive_type -> TYPE_CHAR
Rule 109   primitive_type -> TYPE_STRING
Rule 110   primitive_type -> TYPE_BOOLEAN
Rule 111   reference_type -> class_data_type
Rule 112   reference_type -> array_data_type
Rule 113   class_data_type -> name
Rule 114   array_data_type -> KEYWORD_ARRAY LBRAC type RBRAC
Rule 115   name -> simple_name
Rule 116   name -> qualified_name
Rule 117   simple_name -> IDENTIFIER
Rule 118   qualified_name -> name INST simple_name
Rule 119   array_initializer -> KEYWORD_NEW KEYWORD_ARRAY LBRAC type RBRAC LPAREN INT_NUMBER RPAREN
Rule 120   array_initializer -> KEYWORD_ARRAY LPAREN argument_list_opt RPAREN
Rule 121   class_initializer -> KEYWORD_NEW name LPAREN argument_list_opt RPAREN
Rule 122   statement -> normal_statement
Rule 123   statement -> if_then_statement
Rule 124   statement -> if_then_else_statement
Rule 125   statement -> while_statement
Rule 126   statement -> do_while_statement
Rule 127   statement -> for_statement
Rule 128   normal_statement -> block
Rule 129   normal_statement -> expression_statement
Rule 130   normal_statement -> empty_statement
Rule 131   normal_statement -> return_statement
Rule 132   normal_statement -> switch_statement
Rule 133   expression_statement -> statement_expression TERMINATOR
Rule 134   statement_expression -> assignment
Rule 135   statement_expression -> method_invocation
Rule 136   if_then_statement -> KEYWORD_IF LPAREN expression RPAREN statement
Rule 137   if_then_else_statement -> KEYWORD_IF LPAREN expression RPAREN if_then_else_intermediate KEYWORD_ELSE statement
Rule 138   if_then_else_statement_precedence -> KEYWORD_IF LPAREN expression RPAREN if_then_else_intermediate KEYWORD_ELSE if_then_else_intermediate
Rule 139   if_then_else_intermediate -> normal_statement
Rule 140   if_then_else_intermediate -> if_then_else_statement_precedence
Rule 141   while_statement -> KEYWORD_WHILE LPAREN expression RPAREN statement
Rule 142   do_while_statement -> KEYWORD_DO statement KEYWORD_WHILE LPAREN expression RPAREN TERMINATOR
Rule 143   for_statement -> KEYWORD_FOR LPAREN for_logic RPAREN statement
Rule 144   for_logic -> for_update
Rule 145   for_logic -> for_update TERMINATOR for_logic
Rule 146   for_update -> for_loop for_step_opts
Rule 147   for_loop -> IDENTIFIER CHOOSE expression for_untilTo expression
Rule 148   for_untilTo -> KEYWORD_UNTIL
Rule 149   for_untilTo -> KEYWORD_TO
Rule 150   for_step_opts -> KEYWORD_BY expression
Rule 151   for_step_opts -> empty
Rule 152   switch_statement -> expression KEYWORD_MATCH switch_block
Rule 153   switch_block -> BLOCKBEGIN BLOCKEND
Rule 154   switch_block -> BLOCKBEGIN switch_block_statements BLOCKEND
Rule 155   switch_block -> BLOCKBEGIN switch_labels BLOCKEND
Rule 156   switch_block -> BLOCKBEGIN switch_block_statements switch_labels BLOCKEND
Rule 157   switch_block_statements -> switch_block_statement
Rule 158   switch_block_statements -> switch_block_statements switch_block_statement
Rule 159   switch_block_statement -> switch_labels block_statements
Rule 160   switch_labels -> switch_label
Rule 161   switch_labels -> switch_labels switch_label
Rule 162   switch_label -> KEYWORD_CASE expression FUNTYPE
Rule 163   empty_statement -> TERMINATOR
Rule 164   return_statement -> KEYWORD_RETURN expression_optional TERMINATOR
Rule 165   class_declaration -> class_header class_body
Rule 166   class_header -> class_header_name class_header_extends_opt
Rule 167   class_header_name -> class_header_name1 LPAREN constructor_arguement_list_opt RPAREN
Rule 168   class_header_name1 -> modifier_opts KEYWORD_CLASS name
Rule 169   class_header_extends_opt -> class_header_extends
Rule 170   class_header_extends_opt -> empty
Rule 171   class_header_extends -> KEYWORD_EXTENDS name LPAREN func_arguement_list_opt RPAREN
Rule 172   constructor_arguement_list_opt -> constructor_arguement_list
Rule 173   constructor_arguement_list_opt -> empty
Rule 174   constructor_arguement_list -> constructor_arguement_list_declarator
Rule 175   constructor_arguement_list -> constructor_arguement_list COMMA constructor_arguement_list_declarator
Rule 176   constructor_arguement_list_declarator -> declaration_keyword IDENTIFIER COLON type
Rule 177   class_body -> block
Rule 178   method_declaration -> method_header method_body
Rule 179   method_header -> method_header_name LPAREN func_arguement_list_opt RPAREN COLON method_return_type ASOP
Rule 180   method_return_type -> type
Rule 181   method_return_type -> TYPE_VOID
Rule 182   method_header_name -> modifier_opts KEYWORD_DEF IDENTIFIER
Rule 183   func_arguement_list_opt -> variable_declarators
Rule 184   func_arguement_list_opt -> empty
Rule 185   method_body -> block
Rule 186   empty -> <empty>

Terminals, with rules where they appear

AND                  : 31
AND_BITWISE          : 37
ASOP                 : 27 97 98 99 179
BLOCKBEGIN           : 8 153 154 155 156
BLOCKEND             : 8 153 154 155 156
BOOL_CONSTF          : 75
BOOL_CONSTT          : 74
CHAR                 : 72
CHOOSE               : 147
COLON                : 103 176 179
COMMA                : 83 96 101 175
COMMENT              : 
COMMENT_BEGIN        : 
COMMENT_END          : 
DIVIDE               : 54
DOUBLE_NUMBER        : 77
EQUAL                : 39
FUNTYPE              : 99 162
GEQ                  : 44
GREATER              : 42
IDENTIFIER           : 6 7 7 99 103 117 147 176 182
INST                 : 118
INT_NUMBER           : 78 119
KEYWORD_ARRAY        : 114 119 120
KEYWORD_BREAK        : 
KEYWORD_BY           : 150
KEYWORD_CASE         : 162
KEYWORD_CLASS        : 168
KEYWORD_DEF          : 182
KEYWORD_DEFINE       : 
KEYWORD_DO           : 142
KEYWORD_ELSE         : 137 138
KEYWORD_EXTENDS      : 7 171
KEYWORD_FOR          : 143
KEYWORD_IF           : 136 137 138
KEYWORD_IMPORT       : 
KEYWORD_MATCH        : 152
KEYWORD_NEW          : 119 121
KEYWORD_NULL         : 76
KEYWORD_OBJECT       : 6 7
KEYWORD_PACKAGE      : 
KEYWORD_PRIVATE      : 85
KEYWORD_PROTECTED    : 84
KEYWORD_RETURN       : 164
KEYWORD_THIS         : 
KEYWORD_TO           : 149
KEYWORD_TYPE         : 
KEYWORD_UNTIL        : 148
KEYWORD_VAL          : 89
KEYWORD_VAR          : 88
KEYWORD_WHILE        : 141 142
KEYWORD_WITH         : 
KEYWORD_YIELD        : 
LBRAC                : 26 114 119
LEQ                  : 45
LESS                 : 43
LPAREN               : 64 67 79 98 98 99 119 120 121 136 137 138 141 142 143 167 171 179
LSHIFT               : 47
MINUS                : 51 57
NEQUAL               : 40
NOT                  : 61
OR                   : 29
OR_BITWISE           : 33
PLUS                 : 50 56
RBRAC                : 26 114 119
REMAINDER            : 55
RPAREN               : 64 67 79 98 98 99 119 120 121 136 137 138 141 142 143 167 171 179
RSHIFT               : 48
STRING               : 73
TERMINATOR           : 90 133 142 145 163 164
TILDA                : 60
TIMES                : 53
TYPE_BOOLEAN         : 110
TYPE_CHAR            : 108
TYPE_DOUBLE          : 107
TYPE_INT             : 106
TYPE_STRING          : 109
TYPE_VOID            : 181
XOR                  : 35
error                : 

Nonterminals, with rules where they appear

ObjectDeclare        : 5
ProgramStructure     : 1 0
SingletonObject      : 3 16
additive_expression  : 46 47 48 50 51
and_expression       : 34 35 37
argument_list        : 80 83
argument_list_opt    : 79 120 121
array_access         : 25
array_data_type      : 112
array_initializer    : 93
assignment           : 21 134
assignment_expression : 18 23
assignment_operator  : 23
base_variable_set    : 59
block                : 5 128 177 185
block_statement      : 11 12
block_statements     : 9 12 159
block_statements_opt : 8
c_literal            : 71
cast_expression      : 62
class_and_objects    : 1 2
class_body           : 165
class_data_type      : 111
class_declaration    : 4 15
class_header         : 165
class_header_extends : 169
class_header_extends_opt : 166
class_header_name    : 166
class_header_name1   : 167
class_initializer    : 94
conditional_and_expression : 28 29 31
conditional_or_expression : 22 29
constructor_arguement_list : 172 175
constructor_arguement_list_declarator : 174 175
constructor_arguement_list_opt : 167
declaration_keyword  : 91 176
do_while_statement   : 126
empty                : 10 20 81 87 151 170 173 184
empty_statement      : 130
equality_expression  : 36 37 39 40
exclusive_or_expression : 32 33 35
expression           : 19 26 64 82 83 92 99 136 137 138 141 142 147 147 150 152 162
expression_optional  : 164
expression_statement : 129
for_logic            : 143 145
for_loop             : 146
for_statement        : 127
for_step_opts        : 146
for_untilTo          : 147
for_update           : 144 145
func_arguement_list_opt : 99 171 179
if_then_else_intermediate : 137 138 138
if_then_else_statement : 124
if_then_else_statement_precedence : 140
if_then_statement    : 123
inclusive_or_expression : 30 31 33
int_float            : 70
literal              : 68
local_variable_declaration : 90
local_variable_declaration_statement : 13
method_body          : 178
method_declaration   : 17
method_header        : 178
method_header_name   : 179
method_invocation    : 69 135
method_return_type   : 179
modifier             : 86
modifier_opts        : 91 168 182
multiplicative_expression : 49 50 51 53 54 55
name                 : 24 26 79 113 118 121 168 171
normal_statement     : 122 139
primary              : 66
primitive_type       : 67 104
qualified_name       : 116
reference_type       : 105
relational_expression : 38 39 40 42 43 44 45
return_statement     : 131
shift_expression     : 41 42 43 44 45 47 48
simple_name          : 115 118
statement            : 14 136 137 141 142 143
statement_expression : 133
switch_block         : 152
switch_block_statement : 157 158
switch_block_statements : 154 156 158
switch_label         : 160 161
switch_labels        : 155 156 159 161
switch_statement     : 132
type                 : 103 114 119 176 180
unary_expression     : 52 53 54 55 56 57 60 61 67
unary_expression_not_plus_minus : 58
valid_variable       : 23 65
variable_arguement_list : 96 98
variable_declaration_body : 91
variable_declaration_initializer : 95 96 97
variable_declarator  : 97 100 101
variable_declarator_id : 102
variable_declarators : 98 101 183
variable_literal     : 63
while_statement      : 125

Parsing method: LALR

state 0

    (0) S' -> . ProgramStructure
    (1) ProgramStructure -> . ProgramStructure class_and_objects
    (2) ProgramStructure -> . class_and_objects
    (3) class_and_objects -> . SingletonObject
    (4) class_and_objects -> . class_declaration
    (5) SingletonObject -> . ObjectDeclare block
    (165) class_declaration -> . class_header class_body
    (6) ObjectDeclare -> . KEYWORD_OBJECT IDENTIFIER
    (7) ObjectDeclare -> . KEYWORD_OBJECT IDENTIFIER KEYWORD_EXTENDS IDENTIFIER
    (166) class_header -> . class_header_name class_header_extends_opt
    (167) class_header_name -> . class_header_name1 LPAREN constructor_arguement_list_opt RPAREN
    (168) class_header_name1 -> . modifier_opts KEYWORD_CLASS name
    (86) modifier_opts -> . modifier
    (87) modifier_opts -> . empty
    (84) modifier -> . KEYWORD_PROTECTED
    (85) modifier -> . KEYWORD_PRIVATE
    (186) empty -> .

    KEYWORD_OBJECT  shift and go to state 3
    KEYWORD_PROTECTED shift and go to state 12
    KEYWORD_PRIVATE shift and go to state 9
    KEYWORD_CLASS   reduce using rule 186 (empty -> .)

    class_header_name              shift and go to state 5
    ProgramStructure               shift and go to state 7
    ObjectDeclare                  shift and go to state 1
    class_header_name1             shift and go to state 2
    class_declaration              shift and go to state 4
    class_and_objects              shift and go to state 13
    empty                          shift and go to state 6
    SingletonObject                shift and go to state 8
    modifier                       shift and go to state 14
    class_header                   shift and go to state 10
    modifier_opts                  shift and go to state 11

state 1

    (5) SingletonObject -> ObjectDeclare . block
    (8) block -> . BLOCKBEGIN block_statements_opt BLOCKEND

    BLOCKBEGIN      shift and go to state 15

    block                          shift and go to state 16

state 2

    (167) class_header_name -> class_header_name1 . LPAREN constructor_arguement_list_opt RPAREN

    LPAREN          shift and go to state 17


state 3

    (6) ObjectDeclare -> KEYWORD_OBJECT . IDENTIFIER
    (7) ObjectDeclare -> KEYWORD_OBJECT . IDENTIFIER KEYWORD_EXTENDS IDENTIFIER

    IDENTIFIER      shift and go to state 18


state 4

    (4) class_and_objects -> class_declaration .

    KEYWORD_OBJECT  reduce using rule 4 (class_and_objects -> class_declaration .)
    KEYWORD_PROTECTED reduce using rule 4 (class_and_objects -> class_declaration .)
    KEYWORD_PRIVATE reduce using rule 4 (class_and_objects -> class_declaration .)
    $end            reduce using rule 4 (class_and_objects -> class_declaration .)
    KEYWORD_CLASS   reduce using rule 4 (class_and_objects -> class_declaration .)


state 5

    (166) class_header -> class_header_name . class_header_extends_opt
    (169) class_header_extends_opt -> . class_header_extends
    (170) class_header_extends_opt -> . empty
    (171) class_header_extends -> . KEYWORD_EXTENDS name LPAREN func_arguement_list_opt RPAREN
    (186) empty -> .

    KEYWORD_EXTENDS shift and go to state 21
    BLOCKBEGIN      reduce using rule 186 (empty -> .)

    class_header_extends           shift and go to state 19
    class_header_extends_opt       shift and go to state 20
    empty                          shift and go to state 22

state 6

    (87) modifier_opts -> empty .

    KEYWORD_DEF     reduce using rule 87 (modifier_opts -> empty .)
    KEYWORD_CLASS   reduce using rule 87 (modifier_opts -> empty .)
    KEYWORD_VAR     reduce using rule 87 (modifier_opts -> empty .)
    KEYWORD_VAL     reduce using rule 87 (modifier_opts -> empty .)


state 7

    (0) S' -> ProgramStructure .
    (1) ProgramStructure -> ProgramStructure . class_and_objects
    (3) class_and_objects -> . SingletonObject
    (4) class_and_objects -> . class_declaration
    (5) SingletonObject -> . ObjectDeclare block
    (165) class_declaration -> . class_header class_body
    (6) ObjectDeclare -> . KEYWORD_OBJECT IDENTIFIER
    (7) ObjectDeclare -> . KEYWORD_OBJECT IDENTIFIER KEYWORD_EXTENDS IDENTIFIER
    (166) class_header -> . class_header_name class_header_extends_opt
    (167) class_header_name -> . class_header_name1 LPAREN constructor_arguement_list_opt RPAREN
    (168) class_header_name1 -> . modifier_opts KEYWORD_CLASS name
    (86) modifier_opts -> . modifier
    (87) modifier_opts -> . empty
    (84) modifier -> . KEYWORD_PROTECTED
    (85) modifier -> . KEYWORD_PRIVATE
    (186) empty -> .

    KEYWORD_OBJECT  shift and go to state 3
    KEYWORD_PROTECTED shift and go to state 12
    KEYWORD_PRIVATE shift and go to state 9
    KEYWORD_CLASS   reduce using rule 186 (empty -> .)

    class_header_name              shift and go to state 5
    ObjectDeclare                  shift and go to state 1
    class_header_name1             shift and go to state 2
    class_declaration              shift and go to state 4
    class_and_objects              shift and go to state 23
    empty                          shift and go to state 6
    SingletonObject                shift and go to state 8
    modifier                       shift and go to state 14
    class_header                   shift and go to state 10
    modifier_opts                  shift and go to state 11

state 8

    (3) class_and_objects -> SingletonObject .

    KEYWORD_OBJECT  reduce using rule 3 (class_and_objects -> SingletonObject .)
    KEYWORD_PROTECTED reduce using rule 3 (class_and_objects -> SingletonObject .)
    KEYWORD_PRIVATE reduce using rule 3 (class_and_objects -> SingletonObject .)
    $end            reduce using rule 3 (class_and_objects -> SingletonObject .)
    KEYWORD_CLASS   reduce using rule 3 (class_and_objects -> SingletonObject .)


state 9

    (85) modifier -> KEYWORD_PRIVATE .

    KEYWORD_DEF     reduce using rule 85 (modifier -> KEYWORD_PRIVATE .)
    KEYWORD_CLASS   reduce using rule 85 (modifier -> KEYWORD_PRIVATE .)
    KEYWORD_VAR     reduce using rule 85 (modifier -> KEYWORD_PRIVATE .)
    KEYWORD_VAL     reduce using rule 85 (modifier -> KEYWORD_PRIVATE .)


state 10

    (165) class_declaration -> class_header . class_body
    (177) class_body -> . block
    (8) block -> . BLOCKBEGIN block_statements_opt BLOCKEND

    BLOCKBEGIN      shift and go to state 15

    class_body                     shift and go to state 24
    block                          shift and go to state 25

state 11

    (168) class_header_name1 -> modifier_opts . KEYWORD_CLASS name

    KEYWORD_CLASS   shift and go to state 26


state 12

    (84) modifier -> KEYWORD_PROTECTED .

    KEYWORD_DEF     reduce using rule 84 (modifier -> KEYWORD_PROTECTED .)
    KEYWORD_CLASS   reduce using rule 84 (modifier -> KEYWORD_PROTECTED .)
    KEYWORD_VAR     reduce using rule 84 (modifier -> KEYWORD_PROTECTED .)
    KEYWORD_VAL     reduce using rule 84 (modifier -> KEYWORD_PROTECTED .)


state 13

    (2) ProgramStructure -> class_and_objects .

    KEYWORD_OBJECT  reduce using rule 2 (ProgramStructure -> class_and_objects .)
    KEYWORD_PROTECTED reduce using rule 2 (ProgramStructure -> class_and_objects .)
    KEYWORD_PRIVATE reduce using rule 2 (ProgramStructure -> class_and_objects .)
    $end            reduce using rule 2 (ProgramStructure -> class_and_objects .)
    KEYWORD_CLASS   reduce using rule 2 (ProgramStructure -> class_and_objects .)


state 14

    (86) modifier_opts -> modifier .

    KEYWORD_DEF     reduce using rule 86 (modifier_opts -> modifier .)
    KEYWORD_CLASS   reduce using rule 86 (modifier_opts -> modifier .)
    KEYWORD_VAR     reduce using rule 86 (modifier_opts -> modifier .)
    KEYWORD_VAL     reduce using rule 86 (modifier_opts -> modifier .)


state 15

    (8) block -> BLOCKBEGIN . block_statements_opt BLOCKEND
    (9) block_statements_opt -> . block_statements
    (10) block_statements_opt -> . empty
    (11) block_statements -> . block_statement
    (12) block_statements -> . block_statements block_statement
    (186) empty -> .
    (13) block_statement -> . local_variable_declaration_statement
    (14) block_statement -> . statement
    (15) block_statement -> . class_declaration
    (16) block_statement -> . SingletonObject
    (17) block_statement -> . method_declaration
    (90) local_variable_declaration_statement -> . local_variable_declaration TERMINATOR
    (122) statement -> . normal_statement
    (123) statement -> . if_then_statement
    (124) statement -> . if_then_else_statement
    (125) statement -> . while_statement
    (126) statement -> . do_while_statement
    (127) statement -> . for_statement
    (165) class_declaration -> . class_header class_body
    (5) SingletonObject -> . ObjectDeclare block
    (178) method_declaration -> . method_header method_body
    (91) local_variable_declaration -> . modifier_opts declaration_keyword variable_declaration_body
    (128) normal_statement -> . block
    (129) normal_statement -> . expression_statement
    (130) normal_statement -> . empty_statement
    (131) normal_statement -> . return_statement
    (132) normal_statement -> . switch_statement
    (136) if_then_statement -> . KEYWORD_IF LPAREN expression RPAREN statement
    (137) if_then_else_statement -> . KEYWORD_IF LPAREN expression RPAREN if_then_else_intermediate KEYWORD_ELSE statement
    (141) while_statement -> . KEYWORD_WHILE LPAREN expression RPAREN statement
    (142) do_while_statement -> . KEYWORD_DO statement KEYWORD_WHILE LPAREN expression RPAREN TERMINATOR
    (143) for_statement -> . KEYWORD_FOR LPAREN for_logic RPAREN statement
    (166) class_header -> . class_header_name class_header_extends_opt
    (6) ObjectDeclare -> . KEYWORD_OBJECT IDENTIFIER
    (7) ObjectDeclare -> . KEYWORD_OBJECT IDENTIFIER KEYWORD_EXTENDS IDENTIFIER
    (179) method_header -> . method_header_name LPAREN func_arguement_list_opt RPAREN COLON method_return_type ASOP
    (86) modifier_opts -> . modifier
    (87) modifier_opts -> . empty
    (8) block -> . BLOCKBEGIN block_statements_opt BLOCKEND
    (133) expression_statement -> . statement_expression TERMINATOR
    (163) empty_statement -> . TERMINATOR
    (164) return_statement -> . KEYWORD_RETURN expression_optional TERMINATOR
    (152) switch_statement -> . expression KEYWORD_MATCH switch_block
    (167) class_header_name -> . class_header_name1 LPAREN constructor_arguement_list_opt RPAREN
    (182) method_header_name -> . modifier_opts KEYWORD_DEF IDENTIFIER
    (84) modifier -> . KEYWORD_PROTECTED
    (85) modifier -> . KEYWORD_PRIVATE
    (134) statement_expression -> . assignment
    (135) statement_expression -> . method_invocation
    (18) expression -> . assignment_expression
    (168) class_header_name1 -> . modifier_opts KEYWORD_CLASS name
    (23) assignment -> . valid_variable assignment_operator assignment_expression
    (79) method_invocation -> . name LPAREN argument_list_opt RPAREN
    (21) assignment_expression -> . assignment
    (22) assignment_expression -> . conditional_or_expression
    (24) valid_variable -> . name
    (25) valid_variable -> . array_access
    (115) name -> . simple_name
    (116) name -> . qualified_name
    (28) conditional_or_expression -> . conditional_and_expression
    (29) conditional_or_expression -> . conditional_or_expression OR conditional_and_expression
    (26) array_access -> . name LBRAC expression RBRAC
    (117) simple_name -> . IDENTIFIER
    (118) qualified_name -> . name INST simple_name
    (30) conditional_and_expression -> . inclusive_or_expression
    (31) conditional_and_expression -> . conditional_and_expression AND inclusive_or_expression
    (32) inclusive_or_expression -> . exclusive_or_expression
    (33) inclusive_or_expression -> . inclusive_or_expression OR_BITWISE exclusive_or_expression
    (34) exclusive_or_expression -> . and_expression
    (35) exclusive_or_expression -> . exclusive_or_expression XOR and_expression
    (36) and_expression -> . equality_expression
    (37) and_expression -> . and_expression AND_BITWISE equality_expression
    (38) equality_expression -> . relational_expression
    (39) equality_expression -> . equality_expression EQUAL relational_expression
    (40) equality_expression -> . equality_expression NEQUAL relational_expression
    (41) relational_expression -> . shift_expression
    (42) relational_expression -> . relational_expression GREATER shift_expression
    (43) relational_expression -> . relational_expression LESS shift_expression
    (44) relational_expression -> . relational_expression GEQ shift_expression
    (45) relational_expression -> . relational_expression LEQ shift_expression
    (46) shift_expression -> . additive_expression
    (47) shift_expression -> . shift_expression LSHIFT additive_expression
    (48) shift_expression -> . shift_expression RSHIFT additive_expression
    (49) additive_expression -> . multiplicative_expression
    (50) additive_expression -> . additive_expression PLUS multiplicative_expression
    (51) additive_expression -> . additive_expression MINUS multiplicative_expression
    (52) multiplicative_expression -> . unary_expression
    (53) multiplicative_expression -> . multiplicative_expression TIMES unary_expression
    (54) multiplicative_expression -> . multiplicative_expression DIVIDE unary_expression
    (55) multiplicative_expression -> . multiplicative_expression REMAINDER unary_expression
    (56) unary_expression -> . PLUS unary_expression
    (57) unary_expression -> . MINUS unary_expression
    (58) unary_expression -> . unary_expression_not_plus_minus
    (59) unary_expression_not_plus_minus -> . base_variable_set
    (60) unary_expression_not_plus_minus -> . TILDA unary_expression
    (61) unary_expression_not_plus_minus -> . NOT unary_expression
    (62) unary_expression_not_plus_minus -> . cast_expression
    (63) base_variable_set -> . variable_literal
    (64) base_variable_set -> . LPAREN expression RPAREN
    (67) cast_expression -> . LPAREN primitive_type RPAREN unary_expression
    (65) variable_literal -> . valid_variable
    (66) variable_literal -> . primary
    (68) primary -> . literal
    (69) primary -> . method_invocation
    (70) literal -> . int_float
    (71) literal -> . c_literal
    (77) int_float -> . DOUBLE_NUMBER
    (78) int_float -> . INT_NUMBER
    (72) c_literal -> . CHAR
    (73) c_literal -> . STRING
    (74) c_literal -> . BOOL_CONSTT
    (75) c_literal -> . BOOL_CONSTF
    (76) c_literal -> . KEYWORD_NULL

    BLOCKEND        reduce using rule 186 (empty -> .)
    KEYWORD_DEF     reduce using rule 186 (empty -> .)
    KEYWORD_CLASS   reduce using rule 186 (empty -> .)
    KEYWORD_VAR     reduce using rule 186 (empty -> .)
    KEYWORD_VAL     reduce using rule 186 (empty -> .)
    KEYWORD_IF      shift and go to state 81
    KEYWORD_WHILE   shift and go to state 50
    KEYWORD_DO      shift and go to state 98
    KEYWORD_FOR     shift and go to state 97
    KEYWORD_OBJECT  shift and go to state 3
    BLOCKBEGIN      shift and go to state 15
    TERMINATOR      shift and go to state 53
    KEYWORD_RETURN  shift and go to state 68
    KEYWORD_PROTECTED shift and go to state 12
    KEYWORD_PRIVATE shift and go to state 9
    IDENTIFIER      shift and go to state 77
    PLUS            shift and go to state 36
    MINUS           shift and go to state 29
    TILDA           shift and go to state 72
    NOT             shift and go to state 57
    LPAREN          shift and go to state 94
    DOUBLE_NUMBER   shift and go to state 33
    INT_NUMBER      shift and go to state 44
    CHAR            shift and go to state 63
    STRING          shift and go to state 76
    BOOL_CONSTT     shift and go to state 35
    BOOL_CONSTF     shift and go to state 30
    KEYWORD_NULL    shift and go to state 65

    expression_statement           shift and go to state 27
    unary_expression               shift and go to state 45
    exclusive_or_expression        shift and go to state 61
    normal_statement               shift and go to state 86
    ObjectDeclare                  shift and go to state 1
    class_header_name1             shift and go to state 2
    if_then_statement              shift and go to state 64
    array_access                   shift and go to state 28
    switch_statement               shift and go to state 47
    assignment_expression          shift and go to state 91
    block_statements_opt           shift and go to state 31
    qualified_name                 shift and go to state 79
    base_variable_set              shift and go to state 88
    valid_variable                 shift and go to state 48
    inclusive_or_expression        shift and go to state 32
    class_header_name              shift and go to state 5
    method_declaration             shift and go to state 69
    cast_expression                shift and go to state 80
    block_statement                shift and go to state 70
    shift_expression               shift and go to state 54
    return_statement               shift and go to state 89
    while_statement                shift and go to state 34
    and_expression                 shift and go to state 87
    statement                      shift and go to state 74
    literal                        shift and go to state 71
    statement_expression           shift and go to state 37
    method_invocation              shift and go to state 75
    simple_name                    shift and go to state 67
    conditional_or_expression      shift and go to state 49
    c_literal                      shift and go to state 93
    empty                          shift and go to state 78
    relational_expression          shift and go to state 73
    block_statements               shift and go to state 90
    for_statement                  shift and go to state 38
    local_variable_declaration_statement shift and go to state 39
    do_while_statement             shift and go to state 51
    int_float                      shift and go to state 40
    assignment                     shift and go to state 92
    multiplicative_expression      shift and go to state 52
    primary                        shift and go to state 62
    additive_expression            shift and go to state 66
    SingletonObject                shift and go to state 41
    method_header_name             shift and go to state 42
    class_header                   shift and go to state 10
    modifier_opts                  shift and go to state 95
    equality_expression            shift and go to state 82
    variable_literal               shift and go to state 55
    name                           shift and go to state 43
    unary_expression_not_plus_minus shift and go to state 46
    method_header                  shift and go to state 83
    empty_statement                shift and go to state 84
    class_declaration              shift and go to state 96
    local_variable_declaration     shift and go to state 85
    modifier                       shift and go to state 14
    expression                     shift and go to state 58
    conditional_and_expression     shift and go to state 56
    block                          shift and go to state 59
    if_then_else_statement         shift and go to state 60

state 16

    (5) SingletonObject -> ObjectDeclare block .

    KEYWORD_OBJECT  reduce using rule 5 (SingletonObject -> ObjectDeclare block .)
    KEYWORD_PROTECTED reduce using rule 5 (SingletonObject -> ObjectDeclare block .)
    KEYWORD_PRIVATE reduce using rule 5 (SingletonObject -> ObjectDeclare block .)
    $end            reduce using rule 5 (SingletonObject -> ObjectDeclare block .)
    KEYWORD_CLASS   reduce using rule 5 (SingletonObject -> ObjectDeclare block .)
    KEYWORD_IF      reduce using rule 5 (SingletonObject -> ObjectDeclare block .)
    KEYWORD_WHILE   reduce using rule 5 (SingletonObject -> ObjectDeclare block .)
    KEYWORD_DO      reduce using rule 5 (SingletonObject -> ObjectDeclare block .)
    KEYWORD_FOR     reduce using rule 5 (SingletonObject -> ObjectDeclare block .)
    BLOCKBEGIN      reduce using rule 5 (SingletonObject -> ObjectDeclare block .)
    TERMINATOR      reduce using rule 5 (SingletonObject -> ObjectDeclare block .)
    KEYWORD_RETURN  reduce using rule 5 (SingletonObject -> ObjectDeclare block .)
    IDENTIFIER      reduce using rule 5 (SingletonObject -> ObjectDeclare block .)
    PLUS            reduce using rule 5 (SingletonObject -> ObjectDeclare block .)
    MINUS           reduce using rule 5 (SingletonObject -> ObjectDeclare block .)
    TILDA           reduce using rule 5 (SingletonObject -> ObjectDeclare block .)
    NOT             reduce using rule 5 (SingletonObject -> ObjectDeclare block .)
    LPAREN          reduce using rule 5 (SingletonObject -> ObjectDeclare block .)
    DOUBLE_NUMBER   reduce using rule 5 (SingletonObject -> ObjectDeclare block .)
    INT_NUMBER      reduce using rule 5 (SingletonObject -> ObjectDeclare block .)
    CHAR            reduce using rule 5 (SingletonObject -> ObjectDeclare block .)
    STRING          reduce using rule 5 (SingletonObject -> ObjectDeclare block .)
    BOOL_CONSTT     reduce using rule 5 (SingletonObject -> ObjectDeclare block .)
    BOOL_CONSTF     reduce using rule 5 (SingletonObject -> ObjectDeclare block .)
    KEYWORD_NULL    reduce using rule 5 (SingletonObject -> ObjectDeclare block .)
    KEYWORD_DEF     reduce using rule 5 (SingletonObject -> ObjectDeclare block .)
    KEYWORD_VAR     reduce using rule 5 (SingletonObject -> ObjectDeclare block .)
    KEYWORD_VAL     reduce using rule 5 (SingletonObject -> ObjectDeclare block .)
    BLOCKEND        reduce using rule 5 (SingletonObject -> ObjectDeclare block .)
    KEYWORD_CASE    reduce using rule 5 (SingletonObject -> ObjectDeclare block .)


state 17

    (167) class_header_name -> class_header_name1 LPAREN . constructor_arguement_list_opt RPAREN
    (172) constructor_arguement_list_opt -> . constructor_arguement_list
    (173) constructor_arguement_list_opt -> . empty
    (174) constructor_arguement_list -> . constructor_arguement_list_declarator
    (175) constructor_arguement_list -> . constructor_arguement_list COMMA constructor_arguement_list_declarator
    (186) empty -> .
    (176) constructor_arguement_list_declarator -> . declaration_keyword IDENTIFIER COLON type
    (88) declaration_keyword -> . KEYWORD_VAR
    (89) declaration_keyword -> . KEYWORD_VAL

    RPAREN          reduce using rule 186 (empty -> .)
    KEYWORD_VAR     shift and go to state 100
    KEYWORD_VAL     shift and go to state 103

    constructor_arguement_list_opt shift and go to state 99
    declaration_keyword            shift and go to state 101
    constructor_arguement_list     shift and go to state 102
    constructor_arguement_list_declarator shift and go to state 104
    empty                          shift and go to state 105

state 18

    (6) ObjectDeclare -> KEYWORD_OBJECT IDENTIFIER .
    (7) ObjectDeclare -> KEYWORD_OBJECT IDENTIFIER . KEYWORD_EXTENDS IDENTIFIER

    BLOCKBEGIN      reduce using rule 6 (ObjectDeclare -> KEYWORD_OBJECT IDENTIFIER .)
    KEYWORD_EXTENDS shift and go to state 106


state 19

    (169) class_header_extends_opt -> class_header_extends .

    BLOCKBEGIN      reduce using rule 169 (class_header_extends_opt -> class_header_extends .)


state 20

    (166) class_header -> class_header_name class_header_extends_opt .

    BLOCKBEGIN      reduce using rule 166 (class_header -> class_header_name class_header_extends_opt .)


state 21

    (171) class_header_extends -> KEYWORD_EXTENDS . name LPAREN func_arguement_list_opt RPAREN
    (115) name -> . simple_name
    (116) name -> . qualified_name
    (117) simple_name -> . IDENTIFIER
    (118) qualified_name -> . name INST simple_name

    IDENTIFIER      shift and go to state 77

    name                           shift and go to state 107
    qualified_name                 shift and go to state 79
    simple_name                    shift and go to state 67

state 22

    (170) class_header_extends_opt -> empty .

    BLOCKBEGIN      reduce using rule 170 (class_header_extends_opt -> empty .)


state 23

    (1) ProgramStructure -> ProgramStructure class_and_objects .

    KEYWORD_OBJECT  reduce using rule 1 (ProgramStructure -> ProgramStructure class_and_objects .)
    KEYWORD_PROTECTED reduce using rule 1 (ProgramStructure -> ProgramStructure class_and_objects .)
    KEYWORD_PRIVATE reduce using rule 1 (ProgramStructure -> ProgramStructure class_and_objects .)
    $end            reduce using rule 1 (ProgramStructure -> ProgramStructure class_and_objects .)
    KEYWORD_CLASS   reduce using rule 1 (ProgramStructure -> ProgramStructure class_and_objects .)


state 24

    (165) class_declaration -> class_header class_body .

    KEYWORD_OBJECT  reduce using rule 165 (class_declaration -> class_header class_body .)
    KEYWORD_PROTECTED reduce using rule 165 (class_declaration -> class_header class_body .)
    KEYWORD_PRIVATE reduce using rule 165 (class_declaration -> class_header class_body .)
    $end            reduce using rule 165 (class_declaration -> class_header class_body .)
    KEYWORD_CLASS   reduce using rule 165 (class_declaration -> class_header class_body .)
    KEYWORD_IF      reduce using rule 165 (class_declaration -> class_header class_body .)
    KEYWORD_WHILE   reduce using rule 165 (class_declaration -> class_header class_body .)
    KEYWORD_DO      reduce using rule 165 (class_declaration -> class_header class_body .)
    KEYWORD_FOR     reduce using rule 165 (class_declaration -> class_header class_body .)
    BLOCKBEGIN      reduce using rule 165 (class_declaration -> class_header class_body .)
    TERMINATOR      reduce using rule 165 (class_declaration -> class_header class_body .)
    KEYWORD_RETURN  reduce using rule 165 (class_declaration -> class_header class_body .)
    IDENTIFIER      reduce using rule 165 (class_declaration -> class_header class_body .)
    PLUS            reduce using rule 165 (class_declaration -> class_header class_body .)
    MINUS           reduce using rule 165 (class_declaration -> class_header class_body .)
    TILDA           reduce using rule 165 (class_declaration -> class_header class_body .)
    NOT             reduce using rule 165 (class_declaration -> class_header class_body .)
    LPAREN          reduce using rule 165 (class_declaration -> class_header class_body .)
    DOUBLE_NUMBER   reduce using rule 165 (class_declaration -> class_header class_body .)
    INT_NUMBER      reduce using rule 165 (class_declaration -> class_header class_body .)
    CHAR            reduce using rule 165 (class_declaration -> class_header class_body .)
    STRING          reduce using rule 165 (class_declaration -> class_header class_body .)
    BOOL_CONSTT     reduce using rule 165 (class_declaration -> class_header class_body .)
    BOOL_CONSTF     reduce using rule 165 (class_declaration -> class_header class_body .)
    KEYWORD_NULL    reduce using rule 165 (class_declaration -> class_header class_body .)
    KEYWORD_DEF     reduce using rule 165 (class_declaration -> class_header class_body .)
    KEYWORD_VAR     reduce using rule 165 (class_declaration -> class_header class_body .)
    KEYWORD_VAL     reduce using rule 165 (class_declaration -> class_header class_body .)
    BLOCKEND        reduce using rule 165 (class_declaration -> class_header class_body .)
    KEYWORD_CASE    reduce using rule 165 (class_declaration -> class_header class_body .)


state 25

    (177) class_body -> block .

    KEYWORD_OBJECT  reduce using rule 177 (class_body -> block .)
    KEYWORD_PROTECTED reduce using rule 177 (class_body -> block .)
    KEYWORD_PRIVATE reduce using rule 177 (class_body -> block .)
    $end            reduce using rule 177 (class_body -> block .)
    KEYWORD_CLASS   reduce using rule 177 (class_body -> block .)
    KEYWORD_IF      reduce using rule 177 (class_body -> block .)
    KEYWORD_WHILE   reduce using rule 177 (class_body -> block .)
    KEYWORD_DO      reduce using rule 177 (class_body -> block .)
    KEYWORD_FOR     reduce using rule 177 (class_body -> block .)
    BLOCKBEGIN      reduce using rule 177 (class_body -> block .)
    TERMINATOR      reduce using rule 177 (class_body -> block .)
    KEYWORD_RETURN  reduce using rule 177 (class_body -> block .)
    IDENTIFIER      reduce using rule 177 (class_body -> block .)
    PLUS            reduce using rule 177 (class_body -> block .)
    MINUS           reduce using rule 177 (class_body -> block .)
    TILDA           reduce using rule 177 (class_body -> block .)
    NOT             reduce using rule 177 (class_body -> block .)
    LPAREN          reduce using rule 177 (class_body -> block .)
    DOUBLE_NUMBER   reduce using rule 177 (class_body -> block .)
    INT_NUMBER      reduce using rule 177 (class_body -> block .)
    CHAR            reduce using rule 177 (class_body -> block .)
    STRING          reduce using rule 177 (class_body -> block .)
    BOOL_CONSTT     reduce using rule 177 (class_body -> block .)
    BOOL_CONSTF     reduce using rule 177 (class_body -> block .)
    KEYWORD_NULL    reduce using rule 177 (class_body -> block .)
    KEYWORD_DEF     reduce using rule 177 (class_body -> block .)
    KEYWORD_VAR     reduce using rule 177 (class_body -> block .)
    KEYWORD_VAL     reduce using rule 177 (class_body -> block .)
    BLOCKEND        reduce using rule 177 (class_body -> block .)
    KEYWORD_CASE    reduce using rule 177 (class_body -> block .)


state 26

    (168) class_header_name1 -> modifier_opts KEYWORD_CLASS . name
    (115) name -> . simple_name
    (116) name -> . qualified_name
    (117) simple_name -> . IDENTIFIER
    (118) qualified_name -> . name INST simple_name

    IDENTIFIER      shift and go to state 77

    simple_name                    shift and go to state 67
    qualified_name                 shift and go to state 79
    name                           shift and go to state 108

state 27

    (129) normal_statement -> expression_statement .

    KEYWORD_IF      reduce using rule 129 (normal_statement -> expression_statement .)
    KEYWORD_WHILE   reduce using rule 129 (normal_statement -> expression_statement .)
    KEYWORD_DO      reduce using rule 129 (normal_statement -> expression_statement .)
    KEYWORD_FOR     reduce using rule 129 (normal_statement -> expression_statement .)
    KEYWORD_OBJECT  reduce using rule 129 (normal_statement -> expression_statement .)
    BLOCKBEGIN      reduce using rule 129 (normal_statement -> expression_statement .)
    TERMINATOR      reduce using rule 129 (normal_statement -> expression_statement .)
    KEYWORD_RETURN  reduce using rule 129 (normal_statement -> expression_statement .)
    KEYWORD_PROTECTED reduce using rule 129 (normal_statement -> expression_statement .)
    KEYWORD_PRIVATE reduce using rule 129 (normal_statement -> expression_statement .)
    IDENTIFIER      reduce using rule 129 (normal_statement -> expression_statement .)
    PLUS            reduce using rule 129 (normal_statement -> expression_statement .)
    MINUS           reduce using rule 129 (normal_statement -> expression_statement .)
    TILDA           reduce using rule 129 (normal_statement -> expression_statement .)
    NOT             reduce using rule 129 (normal_statement -> expression_statement .)
    LPAREN          reduce using rule 129 (normal_statement -> expression_statement .)
    DOUBLE_NUMBER   reduce using rule 129 (normal_statement -> expression_statement .)
    INT_NUMBER      reduce using rule 129 (normal_statement -> expression_statement .)
    CHAR            reduce using rule 129 (normal_statement -> expression_statement .)
    STRING          reduce using rule 129 (normal_statement -> expression_statement .)
    BOOL_CONSTT     reduce using rule 129 (normal_statement -> expression_statement .)
    BOOL_CONSTF     reduce using rule 129 (normal_statement -> expression_statement .)
    KEYWORD_NULL    reduce using rule 129 (normal_statement -> expression_statement .)
    KEYWORD_DEF     reduce using rule 129 (normal_statement -> expression_statement .)
    KEYWORD_CLASS   reduce using rule 129 (normal_statement -> expression_statement .)
    KEYWORD_VAR     reduce using rule 129 (normal_statement -> expression_statement .)
    KEYWORD_VAL     reduce using rule 129 (normal_statement -> expression_statement .)
    BLOCKEND        reduce using rule 129 (normal_statement -> expression_statement .)
    KEYWORD_CASE    reduce using rule 129 (normal_statement -> expression_statement .)
    KEYWORD_ELSE    reduce using rule 129 (normal_statement -> expression_statement .)


state 28

    (25) valid_variable -> array_access .

    ASOP            reduce using rule 25 (valid_variable -> array_access .)
    TIMES           reduce using rule 25 (valid_variable -> array_access .)
    DIVIDE          reduce using rule 25 (valid_variable -> array_access .)
    REMAINDER       reduce using rule 25 (valid_variable -> array_access .)
    PLUS            reduce using rule 25 (valid_variable -> array_access .)
    MINUS           reduce using rule 25 (valid_variable -> array_access .)
    LSHIFT          reduce using rule 25 (valid_variable -> array_access .)
    RSHIFT          reduce using rule 25 (valid_variable -> array_access .)
    GREATER         reduce using rule 25 (valid_variable -> array_access .)
    LESS            reduce using rule 25 (valid_variable -> array_access .)
    GEQ             reduce using rule 25 (valid_variable -> array_access .)
    LEQ             reduce using rule 25 (valid_variable -> array_access .)
    EQUAL           reduce using rule 25 (valid_variable -> array_access .)
    NEQUAL          reduce using rule 25 (valid_variable -> array_access .)
    AND_BITWISE     reduce using rule 25 (valid_variable -> array_access .)
    XOR             reduce using rule 25 (valid_variable -> array_access .)
    OR_BITWISE      reduce using rule 25 (valid_variable -> array_access .)
    AND             reduce using rule 25 (valid_variable -> array_access .)
    OR              reduce using rule 25 (valid_variable -> array_access .)
    RPAREN          reduce using rule 25 (valid_variable -> array_access .)
    COMMA           reduce using rule 25 (valid_variable -> array_access .)
    KEYWORD_MATCH   reduce using rule 25 (valid_variable -> array_access .)
    TERMINATOR      reduce using rule 25 (valid_variable -> array_access .)
    RBRAC           reduce using rule 25 (valid_variable -> array_access .)
    FUNTYPE         reduce using rule 25 (valid_variable -> array_access .)
    KEYWORD_UNTIL   reduce using rule 25 (valid_variable -> array_access .)
    KEYWORD_TO      reduce using rule 25 (valid_variable -> array_access .)
    KEYWORD_BY      reduce using rule 25 (valid_variable -> array_access .)


state 29

    (57) unary_expression -> MINUS . unary_expression
    (56) unary_expression -> . PLUS unary_expression
    (57) unary_expression -> . MINUS unary_expression
    (58) unary_expression -> . unary_expression_not_plus_minus
    (59) unary_expression_not_plus_minus -> . base_variable_set
    (60) unary_expression_not_plus_minus -> . TILDA unary_expression
    (61) unary_expression_not_plus_minus -> . NOT unary_expression
    (62) unary_expression_not_plus_minus -> . cast_expression
    (63) base_variable_set -> . variable_literal
    (64) base_variable_set -> . LPAREN expression RPAREN
    (67) cast_expression -> . LPAREN primitive_type RPAREN unary_expression
    (65) variable_literal -> . valid_variable
    (66) variable_literal -> . primary
    (24) valid_variable -> . name
    (25) valid_variable -> . array_access
    (68) primary -> . literal
    (69) primary -> . method_invocation
    (115) name -> . simple_name
    (116) name -> . qualified_name
    (26) array_access -> . name LBRAC expression RBRAC
    (70) literal -> . int_float
    (71) literal -> . c_literal
    (79) method_invocation -> . name LPAREN argument_list_opt RPAREN
    (117) simple_name -> . IDENTIFIER
    (118) qualified_name -> . name INST simple_name
    (77) int_float -> . DOUBLE_NUMBER
    (78) int_float -> . INT_NUMBER
    (72) c_literal -> . CHAR
    (73) c_literal -> . STRING
    (74) c_literal -> . BOOL_CONSTT
    (75) c_literal -> . BOOL_CONSTF
    (76) c_literal -> . KEYWORD_NULL

    PLUS            shift and go to state 36
    MINUS           shift and go to state 29
    TILDA           shift and go to state 72
    NOT             shift and go to state 57
    LPAREN          shift and go to state 94
    IDENTIFIER      shift and go to state 77
    DOUBLE_NUMBER   shift and go to state 33
    INT_NUMBER      shift and go to state 44
    CHAR            shift and go to state 63
    STRING          shift and go to state 76
    BOOL_CONSTT     shift and go to state 35
    BOOL_CONSTF     shift and go to state 30
    KEYWORD_NULL    shift and go to state 65

    qualified_name                 shift and go to state 79
    int_float                      shift and go to state 40
    c_literal                      shift and go to state 93
    variable_literal               shift and go to state 55
    unary_expression               shift and go to state 109
    base_variable_set              shift and go to state 88
    valid_variable                 shift and go to state 110
    array_access                   shift and go to state 28
    primary                        shift and go to state 62
    unary_expression_not_plus_minus shift and go to state 46
    literal                        shift and go to state 71
    method_invocation              shift and go to state 111
    cast_expression                shift and go to state 80
    simple_name                    shift and go to state 67
    name                           shift and go to state 112

state 30

    (75) c_literal -> BOOL_CONSTF .

    TIMES           reduce using rule 75 (c_literal -> BOOL_CONSTF .)
    DIVIDE          reduce using rule 75 (c_literal -> BOOL_CONSTF .)
    REMAINDER       reduce using rule 75 (c_literal -> BOOL_CONSTF .)
    PLUS            reduce using rule 75 (c_literal -> BOOL_CONSTF .)
    MINUS           reduce using rule 75 (c_literal -> BOOL_CONSTF .)
    LSHIFT          reduce using rule 75 (c_literal -> BOOL_CONSTF .)
    RSHIFT          reduce using rule 75 (c_literal -> BOOL_CONSTF .)
    GREATER         reduce using rule 75 (c_literal -> BOOL_CONSTF .)
    LESS            reduce using rule 75 (c_literal -> BOOL_CONSTF .)
    GEQ             reduce using rule 75 (c_literal -> BOOL_CONSTF .)
    LEQ             reduce using rule 75 (c_literal -> BOOL_CONSTF .)
    EQUAL           reduce using rule 75 (c_literal -> BOOL_CONSTF .)
    NEQUAL          reduce using rule 75 (c_literal -> BOOL_CONSTF .)
    AND_BITWISE     reduce using rule 75 (c_literal -> BOOL_CONSTF .)
    XOR             reduce using rule 75 (c_literal -> BOOL_CONSTF .)
    OR_BITWISE      reduce using rule 75 (c_literal -> BOOL_CONSTF .)
    AND             reduce using rule 75 (c_literal -> BOOL_CONSTF .)
    OR              reduce using rule 75 (c_literal -> BOOL_CONSTF .)
    KEYWORD_MATCH   reduce using rule 75 (c_literal -> BOOL_CONSTF .)
    TERMINATOR      reduce using rule 75 (c_literal -> BOOL_CONSTF .)
    RPAREN          reduce using rule 75 (c_literal -> BOOL_CONSTF .)
    RBRAC           reduce using rule 75 (c_literal -> BOOL_CONSTF .)
    COMMA           reduce using rule 75 (c_literal -> BOOL_CONSTF .)
    FUNTYPE         reduce using rule 75 (c_literal -> BOOL_CONSTF .)
    KEYWORD_UNTIL   reduce using rule 75 (c_literal -> BOOL_CONSTF .)
    KEYWORD_TO      reduce using rule 75 (c_literal -> BOOL_CONSTF .)
    KEYWORD_BY      reduce using rule 75 (c_literal -> BOOL_CONSTF .)


state 31

    (8) block -> BLOCKBEGIN block_statements_opt . BLOCKEND

    BLOCKEND        shift and go to state 113


state 32

    (30) conditional_and_expression -> inclusive_or_expression .
    (33) inclusive_or_expression -> inclusive_or_expression . OR_BITWISE exclusive_or_expression

    AND             reduce using rule 30 (conditional_and_expression -> inclusive_or_expression .)
    OR              reduce using rule 30 (conditional_and_expression -> inclusive_or_expression .)
    KEYWORD_MATCH   reduce using rule 30 (conditional_and_expression -> inclusive_or_expression .)
    KEYWORD_BY      reduce using rule 30 (conditional_and_expression -> inclusive_or_expression .)
    TERMINATOR      reduce using rule 30 (conditional_and_expression -> inclusive_or_expression .)
    RPAREN          reduce using rule 30 (conditional_and_expression -> inclusive_or_expression .)
    COMMA           reduce using rule 30 (conditional_and_expression -> inclusive_or_expression .)
    FUNTYPE         reduce using rule 30 (conditional_and_expression -> inclusive_or_expression .)
    KEYWORD_UNTIL   reduce using rule 30 (conditional_and_expression -> inclusive_or_expression .)
    KEYWORD_TO      reduce using rule 30 (conditional_and_expression -> inclusive_or_expression .)
    RBRAC           reduce using rule 30 (conditional_and_expression -> inclusive_or_expression .)
    OR_BITWISE      shift and go to state 114


state 33

    (77) int_float -> DOUBLE_NUMBER .

    TIMES           reduce using rule 77 (int_float -> DOUBLE_NUMBER .)
    DIVIDE          reduce using rule 77 (int_float -> DOUBLE_NUMBER .)
    REMAINDER       reduce using rule 77 (int_float -> DOUBLE_NUMBER .)
    PLUS            reduce using rule 77 (int_float -> DOUBLE_NUMBER .)
    MINUS           reduce using rule 77 (int_float -> DOUBLE_NUMBER .)
    LSHIFT          reduce using rule 77 (int_float -> DOUBLE_NUMBER .)
    RSHIFT          reduce using rule 77 (int_float -> DOUBLE_NUMBER .)
    GREATER         reduce using rule 77 (int_float -> DOUBLE_NUMBER .)
    LESS            reduce using rule 77 (int_float -> DOUBLE_NUMBER .)
    GEQ             reduce using rule 77 (int_float -> DOUBLE_NUMBER .)
    LEQ             reduce using rule 77 (int_float -> DOUBLE_NUMBER .)
    EQUAL           reduce using rule 77 (int_float -> DOUBLE_NUMBER .)
    NEQUAL          reduce using rule 77 (int_float -> DOUBLE_NUMBER .)
    AND_BITWISE     reduce using rule 77 (int_float -> DOUBLE_NUMBER .)
    XOR             reduce using rule 77 (int_float -> DOUBLE_NUMBER .)
    OR_BITWISE      reduce using rule 77 (int_float -> DOUBLE_NUMBER .)
    AND             reduce using rule 77 (int_float -> DOUBLE_NUMBER .)
    OR              reduce using rule 77 (int_float -> DOUBLE_NUMBER .)
    KEYWORD_MATCH   reduce using rule 77 (int_float -> DOUBLE_NUMBER .)
    TERMINATOR      reduce using rule 77 (int_float -> DOUBLE_NUMBER .)
    RPAREN          reduce using rule 77 (int_float -> DOUBLE_NUMBER .)
    RBRAC           reduce using rule 77 (int_float -> DOUBLE_NUMBER .)
    COMMA           reduce using rule 77 (int_float -> DOUBLE_NUMBER .)
    FUNTYPE         reduce using rule 77 (int_float -> DOUBLE_NUMBER .)
    KEYWORD_UNTIL   reduce using rule 77 (int_float -> DOUBLE_NUMBER .)
    KEYWORD_TO      reduce using rule 77 (int_float -> DOUBLE_NUMBER .)
    KEYWORD_BY      reduce using rule 77 (int_float -> DOUBLE_NUMBER .)


state 34

    (125) statement -> while_statement .

    KEYWORD_IF      reduce using rule 125 (statement -> while_statement .)
    KEYWORD_WHILE   reduce using rule 125 (statement -> while_statement .)
    KEYWORD_DO      reduce using rule 125 (statement -> while_statement .)
    KEYWORD_FOR     reduce using rule 125 (statement -> while_statement .)
    KEYWORD_OBJECT  reduce using rule 125 (statement -> while_statement .)
    BLOCKBEGIN      reduce using rule 125 (statement -> while_statement .)
    TERMINATOR      reduce using rule 125 (statement -> while_statement .)
    KEYWORD_RETURN  reduce using rule 125 (statement -> while_statement .)
    KEYWORD_PROTECTED reduce using rule 125 (statement -> while_statement .)
    KEYWORD_PRIVATE reduce using rule 125 (statement -> while_statement .)
    IDENTIFIER      reduce using rule 125 (statement -> while_statement .)
    PLUS            reduce using rule 125 (statement -> while_statement .)
    MINUS           reduce using rule 125 (statement -> while_statement .)
    TILDA           reduce using rule 125 (statement -> while_statement .)
    NOT             reduce using rule 125 (statement -> while_statement .)
    LPAREN          reduce using rule 125 (statement -> while_statement .)
    DOUBLE_NUMBER   reduce using rule 125 (statement -> while_statement .)
    INT_NUMBER      reduce using rule 125 (statement -> while_statement .)
    CHAR            reduce using rule 125 (statement -> while_statement .)
    STRING          reduce using rule 125 (statement -> while_statement .)
    BOOL_CONSTT     reduce using rule 125 (statement -> while_statement .)
    BOOL_CONSTF     reduce using rule 125 (statement -> while_statement .)
    KEYWORD_NULL    reduce using rule 125 (statement -> while_statement .)
    KEYWORD_DEF     reduce using rule 125 (statement -> while_statement .)
    KEYWORD_CLASS   reduce using rule 125 (statement -> while_statement .)
    KEYWORD_VAR     reduce using rule 125 (statement -> while_statement .)
    KEYWORD_VAL     reduce using rule 125 (statement -> while_statement .)
    BLOCKEND        reduce using rule 125 (statement -> while_statement .)
    KEYWORD_CASE    reduce using rule 125 (statement -> while_statement .)


state 35

    (74) c_literal -> BOOL_CONSTT .

    TIMES           reduce using rule 74 (c_literal -> BOOL_CONSTT .)
    DIVIDE          reduce using rule 74 (c_literal -> BOOL_CONSTT .)
    REMAINDER       reduce using rule 74 (c_literal -> BOOL_CONSTT .)
    PLUS            reduce using rule 74 (c_literal -> BOOL_CONSTT .)
    MINUS           reduce using rule 74 (c_literal -> BOOL_CONSTT .)
    LSHIFT          reduce using rule 74 (c_literal -> BOOL_CONSTT .)
    RSHIFT          reduce using rule 74 (c_literal -> BOOL_CONSTT .)
    GREATER         reduce using rule 74 (c_literal -> BOOL_CONSTT .)
    LESS            reduce using rule 74 (c_literal -> BOOL_CONSTT .)
    GEQ             reduce using rule 74 (c_literal -> BOOL_CONSTT .)
    LEQ             reduce using rule 74 (c_literal -> BOOL_CONSTT .)
    EQUAL           reduce using rule 74 (c_literal -> BOOL_CONSTT .)
    NEQUAL          reduce using rule 74 (c_literal -> BOOL_CONSTT .)
    AND_BITWISE     reduce using rule 74 (c_literal -> BOOL_CONSTT .)
    XOR             reduce using rule 74 (c_literal -> BOOL_CONSTT .)
    OR_BITWISE      reduce using rule 74 (c_literal -> BOOL_CONSTT .)
    AND             reduce using rule 74 (c_literal -> BOOL_CONSTT .)
    OR              reduce using rule 74 (c_literal -> BOOL_CONSTT .)
    KEYWORD_MATCH   reduce using rule 74 (c_literal -> BOOL_CONSTT .)
    TERMINATOR      reduce using rule 74 (c_literal -> BOOL_CONSTT .)
    RPAREN          reduce using rule 74 (c_literal -> BOOL_CONSTT .)
    RBRAC           reduce using rule 74 (c_literal -> BOOL_CONSTT .)
    COMMA           reduce using rule 74 (c_literal -> BOOL_CONSTT .)
    FUNTYPE         reduce using rule 74 (c_literal -> BOOL_CONSTT .)
    KEYWORD_UNTIL   reduce using rule 74 (c_literal -> BOOL_CONSTT .)
    KEYWORD_TO      reduce using rule 74 (c_literal -> BOOL_CONSTT .)
    KEYWORD_BY      reduce using rule 74 (c_literal -> BOOL_CONSTT .)


state 36

    (56) unary_expression -> PLUS . unary_expression
    (56) unary_expression -> . PLUS unary_expression
    (57) unary_expression -> . MINUS unary_expression
    (58) unary_expression -> . unary_expression_not_plus_minus
    (59) unary_expression_not_plus_minus -> . base_variable_set
    (60) unary_expression_not_plus_minus -> . TILDA unary_expression
    (61) unary_expression_not_plus_minus -> . NOT unary_expression
    (62) unary_expression_not_plus_minus -> . cast_expression
    (63) base_variable_set -> . variable_literal
    (64) base_variable_set -> . LPAREN expression RPAREN
    (67) cast_expression -> . LPAREN primitive_type RPAREN unary_expression
    (65) variable_literal -> . valid_variable
    (66) variable_literal -> . primary
    (24) valid_variable -> . name
    (25) valid_variable -> . array_access
    (68) primary -> . literal
    (69) primary -> . method_invocation
    (115) name -> . simple_name
    (116) name -> . qualified_name
    (26) array_access -> . name LBRAC expression RBRAC
    (70) literal -> . int_float
    (71) literal -> . c_literal
    (79) method_invocation -> . name LPAREN argument_list_opt RPAREN
    (117) simple_name -> . IDENTIFIER
    (118) qualified_name -> . name INST simple_name
    (77) int_float -> . DOUBLE_NUMBER
    (78) int_float -> . INT_NUMBER
    (72) c_literal -> . CHAR
    (73) c_literal -> . STRING
    (74) c_literal -> . BOOL_CONSTT
    (75) c_literal -> . BOOL_CONSTF
    (76) c_literal -> . KEYWORD_NULL

    PLUS            shift and go to state 36
    MINUS           shift and go to state 29
    TILDA           shift and go to state 72
    NOT             shift and go to state 57
    LPAREN          shift and go to state 94
    IDENTIFIER      shift and go to state 77
    DOUBLE_NUMBER   shift and go to state 33
    INT_NUMBER      shift and go to state 44
    CHAR            shift and go to state 63
    STRING          shift and go to state 76
    BOOL_CONSTT     shift and go to state 35
    BOOL_CONSTF     shift and go to state 30
    KEYWORD_NULL    shift and go to state 65

    qualified_name                 shift and go to state 79
    int_float                      shift and go to state 40
    c_literal                      shift and go to state 93
    variable_literal               shift and go to state 55
    unary_expression               shift and go to state 115
    base_variable_set              shift and go to state 88
    valid_variable                 shift and go to state 110
    array_access                   shift and go to state 28
    primary                        shift and go to state 62
    unary_expression_not_plus_minus shift and go to state 46
    literal                        shift and go to state 71
    method_invocation              shift and go to state 111
    cast_expression                shift and go to state 80
    simple_name                    shift and go to state 67
    name                           shift and go to state 112

state 37

    (133) expression_statement -> statement_expression . TERMINATOR

    TERMINATOR      shift and go to state 116


state 38

    (127) statement -> for_statement .

    KEYWORD_IF      reduce using rule 127 (statement -> for_statement .)
    KEYWORD_WHILE   reduce using rule 127 (statement -> for_statement .)
    KEYWORD_DO      reduce using rule 127 (statement -> for_statement .)
    KEYWORD_FOR     reduce using rule 127 (statement -> for_statement .)
    KEYWORD_OBJECT  reduce using rule 127 (statement -> for_statement .)
    BLOCKBEGIN      reduce using rule 127 (statement -> for_statement .)
    TERMINATOR      reduce using rule 127 (statement -> for_statement .)
    KEYWORD_RETURN  reduce using rule 127 (statement -> for_statement .)
    KEYWORD_PROTECTED reduce using rule 127 (statement -> for_statement .)
    KEYWORD_PRIVATE reduce using rule 127 (statement -> for_statement .)
    IDENTIFIER      reduce using rule 127 (statement -> for_statement .)
    PLUS            reduce using rule 127 (statement -> for_statement .)
    MINUS           reduce using rule 127 (statement -> for_statement .)
    TILDA           reduce using rule 127 (statement -> for_statement .)
    NOT             reduce using rule 127 (statement -> for_statement .)
    LPAREN          reduce using rule 127 (statement -> for_statement .)
    DOUBLE_NUMBER   reduce using rule 127 (statement -> for_statement .)
    INT_NUMBER      reduce using rule 127 (statement -> for_statement .)
    CHAR            reduce using rule 127 (statement -> for_statement .)
    STRING          reduce using rule 127 (statement -> for_statement .)
    BOOL_CONSTT     reduce using rule 127 (statement -> for_statement .)
    BOOL_CONSTF     reduce using rule 127 (statement -> for_statement .)
    KEYWORD_NULL    reduce using rule 127 (statement -> for_statement .)
    KEYWORD_DEF     reduce using rule 127 (statement -> for_statement .)
    KEYWORD_CLASS   reduce using rule 127 (statement -> for_statement .)
    KEYWORD_VAR     reduce using rule 127 (statement -> for_statement .)
    KEYWORD_VAL     reduce using rule 127 (statement -> for_statement .)
    BLOCKEND        reduce using rule 127 (statement -> for_statement .)
    KEYWORD_CASE    reduce using rule 127 (statement -> for_statement .)


state 39

    (13) block_statement -> local_variable_declaration_statement .

    KEYWORD_IF      reduce using rule 13 (block_statement -> local_variable_declaration_statement .)
    KEYWORD_WHILE   reduce using rule 13 (block_statement -> local_variable_declaration_statement .)
    KEYWORD_DO      reduce using rule 13 (block_statement -> local_variable_declaration_statement .)
    KEYWORD_FOR     reduce using rule 13 (block_statement -> local_variable_declaration_statement .)
    KEYWORD_OBJECT  reduce using rule 13 (block_statement -> local_variable_declaration_statement .)
    BLOCKBEGIN      reduce using rule 13 (block_statement -> local_variable_declaration_statement .)
    TERMINATOR      reduce using rule 13 (block_statement -> local_variable_declaration_statement .)
    KEYWORD_RETURN  reduce using rule 13 (block_statement -> local_variable_declaration_statement .)
    KEYWORD_PROTECTED reduce using rule 13 (block_statement -> local_variable_declaration_statement .)
    KEYWORD_PRIVATE reduce using rule 13 (block_statement -> local_variable_declaration_statement .)
    IDENTIFIER      reduce using rule 13 (block_statement -> local_variable_declaration_statement .)
    PLUS            reduce using rule 13 (block_statement -> local_variable_declaration_statement .)
    MINUS           reduce using rule 13 (block_statement -> local_variable_declaration_statement .)
    TILDA           reduce using rule 13 (block_statement -> local_variable_declaration_statement .)
    NOT             reduce using rule 13 (block_statement -> local_variable_declaration_statement .)
    LPAREN          reduce using rule 13 (block_statement -> local_variable_declaration_statement .)
    DOUBLE_NUMBER   reduce using rule 13 (block_statement -> local_variable_declaration_statement .)
    INT_NUMBER      reduce using rule 13 (block_statement -> local_variable_declaration_statement .)
    CHAR            reduce using rule 13 (block_statement -> local_variable_declaration_statement .)
    STRING          reduce using rule 13 (block_statement -> local_variable_declaration_statement .)
    BOOL_CONSTT     reduce using rule 13 (block_statement -> local_variable_declaration_statement .)
    BOOL_CONSTF     reduce using rule 13 (block_statement -> local_variable_declaration_statement .)
    KEYWORD_NULL    reduce using rule 13 (block_statement -> local_variable_declaration_statement .)
    KEYWORD_DEF     reduce using rule 13 (block_statement -> local_variable_declaration_statement .)
    KEYWORD_CLASS   reduce using rule 13 (block_statement -> local_variable_declaration_statement .)
    KEYWORD_VAR     reduce using rule 13 (block_statement -> local_variable_declaration_statement .)
    KEYWORD_VAL     reduce using rule 13 (block_statement -> local_variable_declaration_statement .)
    BLOCKEND        reduce using rule 13 (block_statement -> local_variable_declaration_statement .)
    KEYWORD_CASE    reduce using rule 13 (block_statement -> local_variable_declaration_statement .)


state 40

    (70) literal -> int_float .

    TIMES           reduce using rule 70 (literal -> int_float .)
    DIVIDE          reduce using rule 70 (literal -> int_float .)
    REMAINDER       reduce using rule 70 (literal -> int_float .)
    PLUS            reduce using rule 70 (literal -> int_float .)
    MINUS           reduce using rule 70 (literal -> int_float .)
    LSHIFT          reduce using rule 70 (literal -> int_float .)
    RSHIFT          reduce using rule 70 (literal -> int_float .)
    GREATER         reduce using rule 70 (literal -> int_float .)
    LESS            reduce using rule 70 (literal -> int_float .)
    GEQ             reduce using rule 70 (literal -> int_float .)
    LEQ             reduce using rule 70 (literal -> int_float .)
    EQUAL           reduce using rule 70 (literal -> int_float .)
    NEQUAL          reduce using rule 70 (literal -> int_float .)
    AND_BITWISE     reduce using rule 70 (literal -> int_float .)
    XOR             reduce using rule 70 (literal -> int_float .)
    OR_BITWISE      reduce using rule 70 (literal -> int_float .)
    AND             reduce using rule 70 (literal -> int_float .)
    OR              reduce using rule 70 (literal -> int_float .)
    KEYWORD_MATCH   reduce using rule 70 (literal -> int_float .)
    TERMINATOR      reduce using rule 70 (literal -> int_float .)
    RPAREN          reduce using rule 70 (literal -> int_float .)
    RBRAC           reduce using rule 70 (literal -> int_float .)
    COMMA           reduce using rule 70 (literal -> int_float .)
    FUNTYPE         reduce using rule 70 (literal -> int_float .)
    KEYWORD_UNTIL   reduce using rule 70 (literal -> int_float .)
    KEYWORD_TO      reduce using rule 70 (literal -> int_float .)
    KEYWORD_BY      reduce using rule 70 (literal -> int_float .)


state 41

    (16) block_statement -> SingletonObject .

    KEYWORD_IF      reduce using rule 16 (block_statement -> SingletonObject .)
    KEYWORD_WHILE   reduce using rule 16 (block_statement -> SingletonObject .)
    KEYWORD_DO      reduce using rule 16 (block_statement -> SingletonObject .)
    KEYWORD_FOR     reduce using rule 16 (block_statement -> SingletonObject .)
    KEYWORD_OBJECT  reduce using rule 16 (block_statement -> SingletonObject .)
    BLOCKBEGIN      reduce using rule 16 (block_statement -> SingletonObject .)
    TERMINATOR      reduce using rule 16 (block_statement -> SingletonObject .)
    KEYWORD_RETURN  reduce using rule 16 (block_statement -> SingletonObject .)
    KEYWORD_PROTECTED reduce using rule 16 (block_statement -> SingletonObject .)
    KEYWORD_PRIVATE reduce using rule 16 (block_statement -> SingletonObject .)
    IDENTIFIER      reduce using rule 16 (block_statement -> SingletonObject .)
    PLUS            reduce using rule 16 (block_statement -> SingletonObject .)
    MINUS           reduce using rule 16 (block_statement -> SingletonObject .)
    TILDA           reduce using rule 16 (block_statement -> SingletonObject .)
    NOT             reduce using rule 16 (block_statement -> SingletonObject .)
    LPAREN          reduce using rule 16 (block_statement -> SingletonObject .)
    DOUBLE_NUMBER   reduce using rule 16 (block_statement -> SingletonObject .)
    INT_NUMBER      reduce using rule 16 (block_statement -> SingletonObject .)
    CHAR            reduce using rule 16 (block_statement -> SingletonObject .)
    STRING          reduce using rule 16 (block_statement -> SingletonObject .)
    BOOL_CONSTT     reduce using rule 16 (block_statement -> SingletonObject .)
    BOOL_CONSTF     reduce using rule 16 (block_statement -> SingletonObject .)
    KEYWORD_NULL    reduce using rule 16 (block_statement -> SingletonObject .)
    KEYWORD_DEF     reduce using rule 16 (block_statement -> SingletonObject .)
    KEYWORD_CLASS   reduce using rule 16 (block_statement -> SingletonObject .)
    KEYWORD_VAR     reduce using rule 16 (block_statement -> SingletonObject .)
    KEYWORD_VAL     reduce using rule 16 (block_statement -> SingletonObject .)
    BLOCKEND        reduce using rule 16 (block_statement -> SingletonObject .)
    KEYWORD_CASE    reduce using rule 16 (block_statement -> SingletonObject .)


state 42

    (179) method_header -> method_header_name . LPAREN func_arguement_list_opt RPAREN COLON method_return_type ASOP

    LPAREN          shift and go to state 117


state 43

    (79) method_invocation -> name . LPAREN argument_list_opt RPAREN
    (24) valid_variable -> name .
    (26) array_access -> name . LBRAC expression RBRAC
    (118) qualified_name -> name . INST simple_name

    LPAREN          shift and go to state 120
    ASOP            reduce using rule 24 (valid_variable -> name .)
    TIMES           reduce using rule 24 (valid_variable -> name .)
    DIVIDE          reduce using rule 24 (valid_variable -> name .)
    REMAINDER       reduce using rule 24 (valid_variable -> name .)
    PLUS            reduce using rule 24 (valid_variable -> name .)
    MINUS           reduce using rule 24 (valid_variable -> name .)
    LSHIFT          reduce using rule 24 (valid_variable -> name .)
    RSHIFT          reduce using rule 24 (valid_variable -> name .)
    GREATER         reduce using rule 24 (valid_variable -> name .)
    LESS            reduce using rule 24 (valid_variable -> name .)
    GEQ             reduce using rule 24 (valid_variable -> name .)
    LEQ             reduce using rule 24 (valid_variable -> name .)
    EQUAL           reduce using rule 24 (valid_variable -> name .)
    NEQUAL          reduce using rule 24 (valid_variable -> name .)
    AND_BITWISE     reduce using rule 24 (valid_variable -> name .)
    XOR             reduce using rule 24 (valid_variable -> name .)
    OR_BITWISE      reduce using rule 24 (valid_variable -> name .)
    AND             reduce using rule 24 (valid_variable -> name .)
    OR              reduce using rule 24 (valid_variable -> name .)
    KEYWORD_MATCH   reduce using rule 24 (valid_variable -> name .)
    LBRAC           shift and go to state 118
    INST            shift and go to state 119


state 44

    (78) int_float -> INT_NUMBER .

    TIMES           reduce using rule 78 (int_float -> INT_NUMBER .)
    DIVIDE          reduce using rule 78 (int_float -> INT_NUMBER .)
    REMAINDER       reduce using rule 78 (int_float -> INT_NUMBER .)
    PLUS            reduce using rule 78 (int_float -> INT_NUMBER .)
    MINUS           reduce using rule 78 (int_float -> INT_NUMBER .)
    LSHIFT          reduce using rule 78 (int_float -> INT_NUMBER .)
    RSHIFT          reduce using rule 78 (int_float -> INT_NUMBER .)
    GREATER         reduce using rule 78 (int_float -> INT_NUMBER .)
    LESS            reduce using rule 78 (int_float -> INT_NUMBER .)
    GEQ             reduce using rule 78 (int_float -> INT_NUMBER .)
    LEQ             reduce using rule 78 (int_float -> INT_NUMBER .)
    EQUAL           reduce using rule 78 (int_float -> INT_NUMBER .)
    NEQUAL          reduce using rule 78 (int_float -> INT_NUMBER .)
    AND_BITWISE     reduce using rule 78 (int_float -> INT_NUMBER .)
    XOR             reduce using rule 78 (int_float -> INT_NUMBER .)
    OR_BITWISE      reduce using rule 78 (int_float -> INT_NUMBER .)
    AND             reduce using rule 78 (int_float -> INT_NUMBER .)
    OR              reduce using rule 78 (int_float -> INT_NUMBER .)
    KEYWORD_MATCH   reduce using rule 78 (int_float -> INT_NUMBER .)
    TERMINATOR      reduce using rule 78 (int_float -> INT_NUMBER .)
    RPAREN          reduce using rule 78 (int_float -> INT_NUMBER .)
    RBRAC           reduce using rule 78 (int_float -> INT_NUMBER .)
    COMMA           reduce using rule 78 (int_float -> INT_NUMBER .)
    FUNTYPE         reduce using rule 78 (int_float -> INT_NUMBER .)
    KEYWORD_UNTIL   reduce using rule 78 (int_float -> INT_NUMBER .)
    KEYWORD_TO      reduce using rule 78 (int_float -> INT_NUMBER .)
    KEYWORD_BY      reduce using rule 78 (int_float -> INT_NUMBER .)


state 45

    (52) multiplicative_expression -> unary_expression .

    TIMES           reduce using rule 52 (multiplicative_expression -> unary_expression .)
    DIVIDE          reduce using rule 52 (multiplicative_expression -> unary_expression .)
    REMAINDER       reduce using rule 52 (multiplicative_expression -> unary_expression .)
    PLUS            reduce using rule 52 (multiplicative_expression -> unary_expression .)
    MINUS           reduce using rule 52 (multiplicative_expression -> unary_expression .)
    LSHIFT          reduce using rule 52 (multiplicative_expression -> unary_expression .)
    RSHIFT          reduce using rule 52 (multiplicative_expression -> unary_expression .)
    GREATER         reduce using rule 52 (multiplicative_expression -> unary_expression .)
    LESS            reduce using rule 52 (multiplicative_expression -> unary_expression .)
    GEQ             reduce using rule 52 (multiplicative_expression -> unary_expression .)
    LEQ             reduce using rule 52 (multiplicative_expression -> unary_expression .)
    EQUAL           reduce using rule 52 (multiplicative_expression -> unary_expression .)
    NEQUAL          reduce using rule 52 (multiplicative_expression -> unary_expression .)
    AND_BITWISE     reduce using rule 52 (multiplicative_expression -> unary_expression .)
    XOR             reduce using rule 52 (multiplicative_expression -> unary_expression .)
    OR_BITWISE      reduce using rule 52 (multiplicative_expression -> unary_expression .)
    AND             reduce using rule 52 (multiplicative_expression -> unary_expression .)
    OR              reduce using rule 52 (multiplicative_expression -> unary_expression .)
    KEYWORD_MATCH   reduce using rule 52 (multiplicative_expression -> unary_expression .)
    TERMINATOR      reduce using rule 52 (multiplicative_expression -> unary_expression .)
    RPAREN          reduce using rule 52 (multiplicative_expression -> unary_expression .)
    RBRAC           reduce using rule 52 (multiplicative_expression -> unary_expression .)
    COMMA           reduce using rule 52 (multiplicative_expression -> unary_expression .)
    FUNTYPE         reduce using rule 52 (multiplicative_expression -> unary_expression .)
    KEYWORD_UNTIL   reduce using rule 52 (multiplicative_expression -> unary_expression .)
    KEYWORD_TO      reduce using rule 52 (multiplicative_expression -> unary_expression .)
    KEYWORD_BY      reduce using rule 52 (multiplicative_expression -> unary_expression .)


state 46

    (58) unary_expression -> unary_expression_not_plus_minus .

    TIMES           reduce using rule 58 (unary_expression -> unary_expression_not_plus_minus .)
    DIVIDE          reduce using rule 58 (unary_expression -> unary_expression_not_plus_minus .)
    REMAINDER       reduce using rule 58 (unary_expression -> unary_expression_not_plus_minus .)
    PLUS            reduce using rule 58 (unary_expression -> unary_expression_not_plus_minus .)
    MINUS           reduce using rule 58 (unary_expression -> unary_expression_not_plus_minus .)
    LSHIFT          reduce using rule 58 (unary_expression -> unary_expression_not_plus_minus .)
    RSHIFT          reduce using rule 58 (unary_expression -> unary_expression_not_plus_minus .)
    GREATER         reduce using rule 58 (unary_expression -> unary_expression_not_plus_minus .)
    LESS            reduce using rule 58 (unary_expression -> unary_expression_not_plus_minus .)
    GEQ             reduce using rule 58 (unary_expression -> unary_expression_not_plus_minus .)
    LEQ             reduce using rule 58 (unary_expression -> unary_expression_not_plus_minus .)
    EQUAL           reduce using rule 58 (unary_expression -> unary_expression_not_plus_minus .)
    NEQUAL          reduce using rule 58 (unary_expression -> unary_expression_not_plus_minus .)
    AND_BITWISE     reduce using rule 58 (unary_expression -> unary_expression_not_plus_minus .)
    XOR             reduce using rule 58 (unary_expression -> unary_expression_not_plus_minus .)
    OR_BITWISE      reduce using rule 58 (unary_expression -> unary_expression_not_plus_minus .)
    AND             reduce using rule 58 (unary_expression -> unary_expression_not_plus_minus .)
    OR              reduce using rule 58 (unary_expression -> unary_expression_not_plus_minus .)
    FUNTYPE         reduce using rule 58 (unary_expression -> unary_expression_not_plus_minus .)
    KEYWORD_MATCH   reduce using rule 58 (unary_expression -> unary_expression_not_plus_minus .)
    TERMINATOR      reduce using rule 58 (unary_expression -> unary_expression_not_plus_minus .)
    RPAREN          reduce using rule 58 (unary_expression -> unary_expression_not_plus_minus .)
    RBRAC           reduce using rule 58 (unary_expression -> unary_expression_not_plus_minus .)
    COMMA           reduce using rule 58 (unary_expression -> unary_expression_not_plus_minus .)
    KEYWORD_UNTIL   reduce using rule 58 (unary_expression -> unary_expression_not_plus_minus .)
    KEYWORD_TO      reduce using rule 58 (unary_expression -> unary_expression_not_plus_minus .)
    KEYWORD_BY      reduce using rule 58 (unary_expression -> unary_expression_not_plus_minus .)


state 47

    (132) normal_statement -> switch_statement .

    KEYWORD_IF      reduce using rule 132 (normal_statement -> switch_statement .)
    KEYWORD_WHILE   reduce using rule 132 (normal_statement -> switch_statement .)
    KEYWORD_DO      reduce using rule 132 (normal_statement -> switch_statement .)
    KEYWORD_FOR     reduce using rule 132 (normal_statement -> switch_statement .)
    KEYWORD_OBJECT  reduce using rule 132 (normal_statement -> switch_statement .)
    BLOCKBEGIN      reduce using rule 132 (normal_statement -> switch_statement .)
    TERMINATOR      reduce using rule 132 (normal_statement -> switch_statement .)
    KEYWORD_RETURN  reduce using rule 132 (normal_statement -> switch_statement .)
    KEYWORD_PROTECTED reduce using rule 132 (normal_statement -> switch_statement .)
    KEYWORD_PRIVATE reduce using rule 132 (normal_statement -> switch_statement .)
    IDENTIFIER      reduce using rule 132 (normal_statement -> switch_statement .)
    PLUS            reduce using rule 132 (normal_statement -> switch_statement .)
    MINUS           reduce using rule 132 (normal_statement -> switch_statement .)
    TILDA           reduce using rule 132 (normal_statement -> switch_statement .)
    NOT             reduce using rule 132 (normal_statement -> switch_statement .)
    LPAREN          reduce using rule 132 (normal_statement -> switch_statement .)
    DOUBLE_NUMBER   reduce using rule 132 (normal_statement -> switch_statement .)
    INT_NUMBER      reduce using rule 132 (normal_statement -> switch_statement .)
    CHAR            reduce using rule 132 (normal_statement -> switch_statement .)
    STRING          reduce using rule 132 (normal_statement -> switch_statement .)
    BOOL_CONSTT     reduce using rule 132 (normal_statement -> switch_statement .)
    BOOL_CONSTF     reduce using rule 132 (normal_statement -> switch_statement .)
    KEYWORD_NULL    reduce using rule 132 (normal_statement -> switch_statement .)
    KEYWORD_DEF     reduce using rule 132 (normal_statement -> switch_statement .)
    KEYWORD_CLASS   reduce using rule 132 (normal_statement -> switch_statement .)
    KEYWORD_VAR     reduce using rule 132 (normal_statement -> switch_statement .)
    KEYWORD_VAL     reduce using rule 132 (normal_statement -> switch_statement .)
    BLOCKEND        reduce using rule 132 (normal_statement -> switch_statement .)
    KEYWORD_CASE    reduce using rule 132 (normal_statement -> switch_statement .)
    KEYWORD_ELSE    reduce using rule 132 (normal_statement -> switch_statement .)


state 48

    (23) assignment -> valid_variable . assignment_operator assignment_expression
    (65) variable_literal -> valid_variable .
    (27) assignment_operator -> . ASOP

    TIMES           reduce using rule 65 (variable_literal -> valid_variable .)
    DIVIDE          reduce using rule 65 (variable_literal -> valid_variable .)
    REMAINDER       reduce using rule 65 (variable_literal -> valid_variable .)
    PLUS            reduce using rule 65 (variable_literal -> valid_variable .)
    MINUS           reduce using rule 65 (variable_literal -> valid_variable .)
    LSHIFT          reduce using rule 65 (variable_literal -> valid_variable .)
    RSHIFT          reduce using rule 65 (variable_literal -> valid_variable .)
    GREATER         reduce using rule 65 (variable_literal -> valid_variable .)
    LESS            reduce using rule 65 (variable_literal -> valid_variable .)
    GEQ             reduce using rule 65 (variable_literal -> valid_variable .)
    LEQ             reduce using rule 65 (variable_literal -> valid_variable .)
    EQUAL           reduce using rule 65 (variable_literal -> valid_variable .)
    NEQUAL          reduce using rule 65 (variable_literal -> valid_variable .)
    AND_BITWISE     reduce using rule 65 (variable_literal -> valid_variable .)
    XOR             reduce using rule 65 (variable_literal -> valid_variable .)
    OR_BITWISE      reduce using rule 65 (variable_literal -> valid_variable .)
    AND             reduce using rule 65 (variable_literal -> valid_variable .)
    OR              reduce using rule 65 (variable_literal -> valid_variable .)
    KEYWORD_MATCH   reduce using rule 65 (variable_literal -> valid_variable .)
    RPAREN          reduce using rule 65 (variable_literal -> valid_variable .)
    COMMA           reduce using rule 65 (variable_literal -> valid_variable .)
    TERMINATOR      reduce using rule 65 (variable_literal -> valid_variable .)
    KEYWORD_BY      reduce using rule 65 (variable_literal -> valid_variable .)
    RBRAC           reduce using rule 65 (variable_literal -> valid_variable .)
    FUNTYPE         reduce using rule 65 (variable_literal -> valid_variable .)
    KEYWORD_UNTIL   reduce using rule 65 (variable_literal -> valid_variable .)
    KEYWORD_TO      reduce using rule 65 (variable_literal -> valid_variable .)
    ASOP            shift and go to state 121

    assignment_operator            shift and go to state 122

state 49

    (22) assignment_expression -> conditional_or_expression .
    (29) conditional_or_expression -> conditional_or_expression . OR conditional_and_expression

    TERMINATOR      reduce using rule 22 (assignment_expression -> conditional_or_expression .)
    RPAREN          reduce using rule 22 (assignment_expression -> conditional_or_expression .)
    COMMA           reduce using rule 22 (assignment_expression -> conditional_or_expression .)
    RBRAC           reduce using rule 22 (assignment_expression -> conditional_or_expression .)
    KEYWORD_MATCH   reduce using rule 22 (assignment_expression -> conditional_or_expression .)
    FUNTYPE         reduce using rule 22 (assignment_expression -> conditional_or_expression .)
    KEYWORD_UNTIL   reduce using rule 22 (assignment_expression -> conditional_or_expression .)
    KEYWORD_TO      reduce using rule 22 (assignment_expression -> conditional_or_expression .)
    KEYWORD_BY      reduce using rule 22 (assignment_expression -> conditional_or_expression .)
    OR              shift and go to state 123


state 50

    (141) while_statement -> KEYWORD_WHILE . LPAREN expression RPAREN statement

    LPAREN          shift and go to state 124


state 51

    (126) statement -> do_while_statement .

    KEYWORD_IF      reduce using rule 126 (statement -> do_while_statement .)
    KEYWORD_WHILE   reduce using rule 126 (statement -> do_while_statement .)
    KEYWORD_DO      reduce using rule 126 (statement -> do_while_statement .)
    KEYWORD_FOR     reduce using rule 126 (statement -> do_while_statement .)
    KEYWORD_OBJECT  reduce using rule 126 (statement -> do_while_statement .)
    BLOCKBEGIN      reduce using rule 126 (statement -> do_while_statement .)
    TERMINATOR      reduce using rule 126 (statement -> do_while_statement .)
    KEYWORD_RETURN  reduce using rule 126 (statement -> do_while_statement .)
    KEYWORD_PROTECTED reduce using rule 126 (statement -> do_while_statement .)
    KEYWORD_PRIVATE reduce using rule 126 (statement -> do_while_statement .)
    IDENTIFIER      reduce using rule 126 (statement -> do_while_statement .)
    PLUS            reduce using rule 126 (statement -> do_while_statement .)
    MINUS           reduce using rule 126 (statement -> do_while_statement .)
    TILDA           reduce using rule 126 (statement -> do_while_statement .)
    NOT             reduce using rule 126 (statement -> do_while_statement .)
    LPAREN          reduce using rule 126 (statement -> do_while_statement .)
    DOUBLE_NUMBER   reduce using rule 126 (statement -> do_while_statement .)
    INT_NUMBER      reduce using rule 126 (statement -> do_while_statement .)
    CHAR            reduce using rule 126 (statement -> do_while_statement .)
    STRING          reduce using rule 126 (statement -> do_while_statement .)
    BOOL_CONSTT     reduce using rule 126 (statement -> do_while_statement .)
    BOOL_CONSTF     reduce using rule 126 (statement -> do_while_statement .)
    KEYWORD_NULL    reduce using rule 126 (statement -> do_while_statement .)
    KEYWORD_DEF     reduce using rule 126 (statement -> do_while_statement .)
    KEYWORD_CLASS   reduce using rule 126 (statement -> do_while_statement .)
    KEYWORD_VAR     reduce using rule 126 (statement -> do_while_statement .)
    KEYWORD_VAL     reduce using rule 126 (statement -> do_while_statement .)
    BLOCKEND        reduce using rule 126 (statement -> do_while_statement .)
    KEYWORD_CASE    reduce using rule 126 (statement -> do_while_statement .)


state 52

    (49) additive_expression -> multiplicative_expression .
    (53) multiplicative_expression -> multiplicative_expression . TIMES unary_expression
    (54) multiplicative_expression -> multiplicative_expression . DIVIDE unary_expression
    (55) multiplicative_expression -> multiplicative_expression . REMAINDER unary_expression

    PLUS            reduce using rule 49 (additive_expression -> multiplicative_expression .)
    MINUS           reduce using rule 49 (additive_expression -> multiplicative_expression .)
    LSHIFT          reduce using rule 49 (additive_expression -> multiplicative_expression .)
    RSHIFT          reduce using rule 49 (additive_expression -> multiplicative_expression .)
    GREATER         reduce using rule 49 (additive_expression -> multiplicative_expression .)
    LESS            reduce using rule 49 (additive_expression -> multiplicative_expression .)
    GEQ             reduce using rule 49 (additive_expression -> multiplicative_expression .)
    LEQ             reduce using rule 49 (additive_expression -> multiplicative_expression .)
    EQUAL           reduce using rule 49 (additive_expression -> multiplicative_expression .)
    NEQUAL          reduce using rule 49 (additive_expression -> multiplicative_expression .)
    AND_BITWISE     reduce using rule 49 (additive_expression -> multiplicative_expression .)
    XOR             reduce using rule 49 (additive_expression -> multiplicative_expression .)
    OR_BITWISE      reduce using rule 49 (additive_expression -> multiplicative_expression .)
    AND             reduce using rule 49 (additive_expression -> multiplicative_expression .)
    OR              reduce using rule 49 (additive_expression -> multiplicative_expression .)
    KEYWORD_MATCH   reduce using rule 49 (additive_expression -> multiplicative_expression .)
    RPAREN          reduce using rule 49 (additive_expression -> multiplicative_expression .)
    RBRAC           reduce using rule 49 (additive_expression -> multiplicative_expression .)
    TERMINATOR      reduce using rule 49 (additive_expression -> multiplicative_expression .)
    COMMA           reduce using rule 49 (additive_expression -> multiplicative_expression .)
    FUNTYPE         reduce using rule 49 (additive_expression -> multiplicative_expression .)
    KEYWORD_UNTIL   reduce using rule 49 (additive_expression -> multiplicative_expression .)
    KEYWORD_TO      reduce using rule 49 (additive_expression -> multiplicative_expression .)
    KEYWORD_BY      reduce using rule 49 (additive_expression -> multiplicative_expression .)
    TIMES           shift and go to state 127
    DIVIDE          shift and go to state 126
    REMAINDER       shift and go to state 125


state 53

    (163) empty_statement -> TERMINATOR .

    KEYWORD_IF      reduce using rule 163 (empty_statement -> TERMINATOR .)
    KEYWORD_WHILE   reduce using rule 163 (empty_statement -> TERMINATOR .)
    KEYWORD_DO      reduce using rule 163 (empty_statement -> TERMINATOR .)
    KEYWORD_FOR     reduce using rule 163 (empty_statement -> TERMINATOR .)
    KEYWORD_OBJECT  reduce using rule 163 (empty_statement -> TERMINATOR .)
    BLOCKBEGIN      reduce using rule 163 (empty_statement -> TERMINATOR .)
    TERMINATOR      reduce using rule 163 (empty_statement -> TERMINATOR .)
    KEYWORD_RETURN  reduce using rule 163 (empty_statement -> TERMINATOR .)
    KEYWORD_PROTECTED reduce using rule 163 (empty_statement -> TERMINATOR .)
    KEYWORD_PRIVATE reduce using rule 163 (empty_statement -> TERMINATOR .)
    IDENTIFIER      reduce using rule 163 (empty_statement -> TERMINATOR .)
    PLUS            reduce using rule 163 (empty_statement -> TERMINATOR .)
    MINUS           reduce using rule 163 (empty_statement -> TERMINATOR .)
    TILDA           reduce using rule 163 (empty_statement -> TERMINATOR .)
    NOT             reduce using rule 163 (empty_statement -> TERMINATOR .)
    LPAREN          reduce using rule 163 (empty_statement -> TERMINATOR .)
    DOUBLE_NUMBER   reduce using rule 163 (empty_statement -> TERMINATOR .)
    INT_NUMBER      reduce using rule 163 (empty_statement -> TERMINATOR .)
    CHAR            reduce using rule 163 (empty_statement -> TERMINATOR .)
    STRING          reduce using rule 163 (empty_statement -> TERMINATOR .)
    BOOL_CONSTT     reduce using rule 163 (empty_statement -> TERMINATOR .)
    BOOL_CONSTF     reduce using rule 163 (empty_statement -> TERMINATOR .)
    KEYWORD_NULL    reduce using rule 163 (empty_statement -> TERMINATOR .)
    KEYWORD_DEF     reduce using rule 163 (empty_statement -> TERMINATOR .)
    KEYWORD_CLASS   reduce using rule 163 (empty_statement -> TERMINATOR .)
    KEYWORD_VAR     reduce using rule 163 (empty_statement -> TERMINATOR .)
    KEYWORD_VAL     reduce using rule 163 (empty_statement -> TERMINATOR .)
    BLOCKEND        reduce using rule 163 (empty_statement -> TERMINATOR .)
    KEYWORD_CASE    reduce using rule 163 (empty_statement -> TERMINATOR .)
    KEYWORD_ELSE    reduce using rule 163 (empty_statement -> TERMINATOR .)


state 54

    (41) relational_expression -> shift_expression .
    (47) shift_expression -> shift_expression . LSHIFT additive_expression
    (48) shift_expression -> shift_expression . RSHIFT additive_expression

    GREATER         reduce using rule 41 (relational_expression -> shift_expression .)
    LESS            reduce using rule 41 (relational_expression -> shift_expression .)
    GEQ             reduce using rule 41 (relational_expression -> shift_expression .)
    LEQ             reduce using rule 41 (relational_expression -> shift_expression .)
    EQUAL           reduce using rule 41 (relational_expression -> shift_expression .)
    NEQUAL          reduce using rule 41 (relational_expression -> shift_expression .)
    AND_BITWISE     reduce using rule 41 (relational_expression -> shift_expression .)
    XOR             reduce using rule 41 (relational_expression -> shift_expression .)
    OR_BITWISE      reduce using rule 41 (relational_expression -> shift_expression .)
    AND             reduce using rule 41 (relational_expression -> shift_expression .)
    OR              reduce using rule 41 (relational_expression -> shift_expression .)
    RPAREN          reduce using rule 41 (relational_expression -> shift_expression .)
    COMMA           reduce using rule 41 (relational_expression -> shift_expression .)
    KEYWORD_MATCH   reduce using rule 41 (relational_expression -> shift_expression .)
    KEYWORD_BY      reduce using rule 41 (relational_expression -> shift_expression .)
    TERMINATOR      reduce using rule 41 (relational_expression -> shift_expression .)
    RBRAC           reduce using rule 41 (relational_expression -> shift_expression .)
    FUNTYPE         reduce using rule 41 (relational_expression -> shift_expression .)
    KEYWORD_UNTIL   reduce using rule 41 (relational_expression -> shift_expression .)
    KEYWORD_TO      reduce using rule 41 (relational_expression -> shift_expression .)
    LSHIFT          shift and go to state 129
    RSHIFT          shift and go to state 128


state 55

    (63) base_variable_set -> variable_literal .

    TIMES           reduce using rule 63 (base_variable_set -> variable_literal .)
    DIVIDE          reduce using rule 63 (base_variable_set -> variable_literal .)
    REMAINDER       reduce using rule 63 (base_variable_set -> variable_literal .)
    PLUS            reduce using rule 63 (base_variable_set -> variable_literal .)
    MINUS           reduce using rule 63 (base_variable_set -> variable_literal .)
    LSHIFT          reduce using rule 63 (base_variable_set -> variable_literal .)
    RSHIFT          reduce using rule 63 (base_variable_set -> variable_literal .)
    GREATER         reduce using rule 63 (base_variable_set -> variable_literal .)
    LESS            reduce using rule 63 (base_variable_set -> variable_literal .)
    GEQ             reduce using rule 63 (base_variable_set -> variable_literal .)
    LEQ             reduce using rule 63 (base_variable_set -> variable_literal .)
    EQUAL           reduce using rule 63 (base_variable_set -> variable_literal .)
    NEQUAL          reduce using rule 63 (base_variable_set -> variable_literal .)
    AND_BITWISE     reduce using rule 63 (base_variable_set -> variable_literal .)
    XOR             reduce using rule 63 (base_variable_set -> variable_literal .)
    OR_BITWISE      reduce using rule 63 (base_variable_set -> variable_literal .)
    AND             reduce using rule 63 (base_variable_set -> variable_literal .)
    OR              reduce using rule 63 (base_variable_set -> variable_literal .)
    KEYWORD_MATCH   reduce using rule 63 (base_variable_set -> variable_literal .)
    TERMINATOR      reduce using rule 63 (base_variable_set -> variable_literal .)
    RPAREN          reduce using rule 63 (base_variable_set -> variable_literal .)
    RBRAC           reduce using rule 63 (base_variable_set -> variable_literal .)
    COMMA           reduce using rule 63 (base_variable_set -> variable_literal .)
    FUNTYPE         reduce using rule 63 (base_variable_set -> variable_literal .)
    KEYWORD_UNTIL   reduce using rule 63 (base_variable_set -> variable_literal .)
    KEYWORD_TO      reduce using rule 63 (base_variable_set -> variable_literal .)
    KEYWORD_BY      reduce using rule 63 (base_variable_set -> variable_literal .)


state 56

    (28) conditional_or_expression -> conditional_and_expression .
    (31) conditional_and_expression -> conditional_and_expression . AND inclusive_or_expression

    OR              reduce using rule 28 (conditional_or_expression -> conditional_and_expression .)
    KEYWORD_MATCH   reduce using rule 28 (conditional_or_expression -> conditional_and_expression .)
    RPAREN          reduce using rule 28 (conditional_or_expression -> conditional_and_expression .)
    COMMA           reduce using rule 28 (conditional_or_expression -> conditional_and_expression .)
    TERMINATOR      reduce using rule 28 (conditional_or_expression -> conditional_and_expression .)
    FUNTYPE         reduce using rule 28 (conditional_or_expression -> conditional_and_expression .)
    KEYWORD_BY      reduce using rule 28 (conditional_or_expression -> conditional_and_expression .)
    KEYWORD_UNTIL   reduce using rule 28 (conditional_or_expression -> conditional_and_expression .)
    KEYWORD_TO      reduce using rule 28 (conditional_or_expression -> conditional_and_expression .)
    RBRAC           reduce using rule 28 (conditional_or_expression -> conditional_and_expression .)
    AND             shift and go to state 130


state 57

    (61) unary_expression_not_plus_minus -> NOT . unary_expression
    (56) unary_expression -> . PLUS unary_expression
    (57) unary_expression -> . MINUS unary_expression
    (58) unary_expression -> . unary_expression_not_plus_minus
    (59) unary_expression_not_plus_minus -> . base_variable_set
    (60) unary_expression_not_plus_minus -> . TILDA unary_expression
    (61) unary_expression_not_plus_minus -> . NOT unary_expression
    (62) unary_expression_not_plus_minus -> . cast_expression
    (63) base_variable_set -> . variable_literal
    (64) base_variable_set -> . LPAREN expression RPAREN
    (67) cast_expression -> . LPAREN primitive_type RPAREN unary_expression
    (65) variable_literal -> . valid_variable
    (66) variable_literal -> . primary
    (24) valid_variable -> . name
    (25) valid_variable -> . array_access
    (68) primary -> . literal
    (69) primary -> . method_invocation
    (115) name -> . simple_name
    (116) name -> . qualified_name
    (26) array_access -> . name LBRAC expression RBRAC
    (70) literal -> . int_float
    (71) literal -> . c_literal
    (79) method_invocation -> . name LPAREN argument_list_opt RPAREN
    (117) simple_name -> . IDENTIFIER
    (118) qualified_name -> . name INST simple_name
    (77) int_float -> . DOUBLE_NUMBER
    (78) int_float -> . INT_NUMBER
    (72) c_literal -> . CHAR
    (73) c_literal -> . STRING
    (74) c_literal -> . BOOL_CONSTT
    (75) c_literal -> . BOOL_CONSTF
    (76) c_literal -> . KEYWORD_NULL

    PLUS            shift and go to state 36
    MINUS           shift and go to state 29
    TILDA           shift and go to state 72
    NOT             shift and go to state 57
    LPAREN          shift and go to state 94
    IDENTIFIER      shift and go to state 77
    DOUBLE_NUMBER   shift and go to state 33
    INT_NUMBER      shift and go to state 44
    CHAR            shift and go to state 63
    STRING          shift and go to state 76
    BOOL_CONSTT     shift and go to state 35
    BOOL_CONSTF     shift and go to state 30
    KEYWORD_NULL    shift and go to state 65

    qualified_name                 shift and go to state 79
    int_float                      shift and go to state 40
    c_literal                      shift and go to state 93
    variable_literal               shift and go to state 55
    unary_expression               shift and go to state 131
    base_variable_set              shift and go to state 88
    valid_variable                 shift and go to state 110
    array_access                   shift and go to state 28
    primary                        shift and go to state 62
    unary_expression_not_plus_minus shift and go to state 46
    literal                        shift and go to state 71
    method_invocation              shift and go to state 111
    cast_expression                shift and go to state 80
    simple_name                    shift and go to state 67
    name                           shift and go to state 112

state 58

    (152) switch_statement -> expression . KEYWORD_MATCH switch_block

    KEYWORD_MATCH   shift and go to state 132


state 59

    (128) normal_statement -> block .

    KEYWORD_IF      reduce using rule 128 (normal_statement -> block .)
    KEYWORD_WHILE   reduce using rule 128 (normal_statement -> block .)
    KEYWORD_DO      reduce using rule 128 (normal_statement -> block .)
    KEYWORD_FOR     reduce using rule 128 (normal_statement -> block .)
    KEYWORD_OBJECT  reduce using rule 128 (normal_statement -> block .)
    BLOCKBEGIN      reduce using rule 128 (normal_statement -> block .)
    TERMINATOR      reduce using rule 128 (normal_statement -> block .)
    KEYWORD_RETURN  reduce using rule 128 (normal_statement -> block .)
    KEYWORD_PROTECTED reduce using rule 128 (normal_statement -> block .)
    KEYWORD_PRIVATE reduce using rule 128 (normal_statement -> block .)
    IDENTIFIER      reduce using rule 128 (normal_statement -> block .)
    PLUS            reduce using rule 128 (normal_statement -> block .)
    MINUS           reduce using rule 128 (normal_statement -> block .)
    TILDA           reduce using rule 128 (normal_statement -> block .)
    NOT             reduce using rule 128 (normal_statement -> block .)
    LPAREN          reduce using rule 128 (normal_statement -> block .)
    DOUBLE_NUMBER   reduce using rule 128 (normal_statement -> block .)
    INT_NUMBER      reduce using rule 128 (normal_statement -> block .)
    CHAR            reduce using rule 128 (normal_statement -> block .)
    STRING          reduce using rule 128 (normal_statement -> block .)
    BOOL_CONSTT     reduce using rule 128 (normal_statement -> block .)
    BOOL_CONSTF     reduce using rule 128 (normal_statement -> block .)
    KEYWORD_NULL    reduce using rule 128 (normal_statement -> block .)
    KEYWORD_DEF     reduce using rule 128 (normal_statement -> block .)
    KEYWORD_CLASS   reduce using rule 128 (normal_statement -> block .)
    KEYWORD_VAR     reduce using rule 128 (normal_statement -> block .)
    KEYWORD_VAL     reduce using rule 128 (normal_statement -> block .)
    BLOCKEND        reduce using rule 128 (normal_statement -> block .)
    KEYWORD_CASE    reduce using rule 128 (normal_statement -> block .)
    KEYWORD_ELSE    reduce using rule 128 (normal_statement -> block .)


state 60

    (124) statement -> if_then_else_statement .

    KEYWORD_IF      reduce using rule 124 (statement -> if_then_else_statement .)
    KEYWORD_WHILE   reduce using rule 124 (statement -> if_then_else_statement .)
    KEYWORD_DO      reduce using rule 124 (statement -> if_then_else_statement .)
    KEYWORD_FOR     reduce using rule 124 (statement -> if_then_else_statement .)
    KEYWORD_OBJECT  reduce using rule 124 (statement -> if_then_else_statement .)
    BLOCKBEGIN      reduce using rule 124 (statement -> if_then_else_statement .)
    TERMINATOR      reduce using rule 124 (statement -> if_then_else_statement .)
    KEYWORD_RETURN  reduce using rule 124 (statement -> if_then_else_statement .)
    KEYWORD_PROTECTED reduce using rule 124 (statement -> if_then_else_statement .)
    KEYWORD_PRIVATE reduce using rule 124 (statement -> if_then_else_statement .)
    IDENTIFIER      reduce using rule 124 (statement -> if_then_else_statement .)
    PLUS            reduce using rule 124 (statement -> if_then_else_statement .)
    MINUS           reduce using rule 124 (statement -> if_then_else_statement .)
    TILDA           reduce using rule 124 (statement -> if_then_else_statement .)
    NOT             reduce using rule 124 (statement -> if_then_else_statement .)
    LPAREN          reduce using rule 124 (statement -> if_then_else_statement .)
    DOUBLE_NUMBER   reduce using rule 124 (statement -> if_then_else_statement .)
    INT_NUMBER      reduce using rule 124 (statement -> if_then_else_statement .)
    CHAR            reduce using rule 124 (statement -> if_then_else_statement .)
    STRING          reduce using rule 124 (statement -> if_then_else_statement .)
    BOOL_CONSTT     reduce using rule 124 (statement -> if_then_else_statement .)
    BOOL_CONSTF     reduce using rule 124 (statement -> if_then_else_statement .)
    KEYWORD_NULL    reduce using rule 124 (statement -> if_then_else_statement .)
    KEYWORD_DEF     reduce using rule 124 (statement -> if_then_else_statement .)
    KEYWORD_CLASS   reduce using rule 124 (statement -> if_then_else_statement .)
    KEYWORD_VAR     reduce using rule 124 (statement -> if_then_else_statement .)
    KEYWORD_VAL     reduce using rule 124 (statement -> if_then_else_statement .)
    BLOCKEND        reduce using rule 124 (statement -> if_then_else_statement .)
    KEYWORD_CASE    reduce using rule 124 (statement -> if_then_else_statement .)


state 61

    (32) inclusive_or_expression -> exclusive_or_expression .
    (35) exclusive_or_expression -> exclusive_or_expression . XOR and_expression

    OR_BITWISE      reduce using rule 32 (inclusive_or_expression -> exclusive_or_expression .)
    AND             reduce using rule 32 (inclusive_or_expression -> exclusive_or_expression .)
    OR              reduce using rule 32 (inclusive_or_expression -> exclusive_or_expression .)
    KEYWORD_MATCH   reduce using rule 32 (inclusive_or_expression -> exclusive_or_expression .)
    TERMINATOR      reduce using rule 32 (inclusive_or_expression -> exclusive_or_expression .)
    RPAREN          reduce using rule 32 (inclusive_or_expression -> exclusive_or_expression .)
    RBRAC           reduce using rule 32 (inclusive_or_expression -> exclusive_or_expression .)
    COMMA           reduce using rule 32 (inclusive_or_expression -> exclusive_or_expression .)
    FUNTYPE         reduce using rule 32 (inclusive_or_expression -> exclusive_or_expression .)
    KEYWORD_UNTIL   reduce using rule 32 (inclusive_or_expression -> exclusive_or_expression .)
    KEYWORD_TO      reduce using rule 32 (inclusive_or_expression -> exclusive_or_expression .)
    KEYWORD_BY      reduce using rule 32 (inclusive_or_expression -> exclusive_or_expression .)
    XOR             shift and go to state 133


state 62

    (66) variable_literal -> primary .

    TIMES           reduce using rule 66 (variable_literal -> primary .)
    DIVIDE          reduce using rule 66 (variable_literal -> primary .)
    REMAINDER       reduce using rule 66 (variable_literal -> primary .)
    PLUS            reduce using rule 66 (variable_literal -> primary .)
    MINUS           reduce using rule 66 (variable_literal -> primary .)
    LSHIFT          reduce using rule 66 (variable_literal -> primary .)
    RSHIFT          reduce using rule 66 (variable_literal -> primary .)
    GREATER         reduce using rule 66 (variable_literal -> primary .)
    LESS            reduce using rule 66 (variable_literal -> primary .)
    GEQ             reduce using rule 66 (variable_literal -> primary .)
    LEQ             reduce using rule 66 (variable_literal -> primary .)
    EQUAL           reduce using rule 66 (variable_literal -> primary .)
    NEQUAL          reduce using rule 66 (variable_literal -> primary .)
    AND_BITWISE     reduce using rule 66 (variable_literal -> primary .)
    XOR             reduce using rule 66 (variable_literal -> primary .)
    OR_BITWISE      reduce using rule 66 (variable_literal -> primary .)
    AND             reduce using rule 66 (variable_literal -> primary .)
    OR              reduce using rule 66 (variable_literal -> primary .)
    KEYWORD_MATCH   reduce using rule 66 (variable_literal -> primary .)
    TERMINATOR      reduce using rule 66 (variable_literal -> primary .)
    RPAREN          reduce using rule 66 (variable_literal -> primary .)
    RBRAC           reduce using rule 66 (variable_literal -> primary .)
    COMMA           reduce using rule 66 (variable_literal -> primary .)
    FUNTYPE         reduce using rule 66 (variable_literal -> primary .)
    KEYWORD_UNTIL   reduce using rule 66 (variable_literal -> primary .)
    KEYWORD_TO      reduce using rule 66 (variable_literal -> primary .)
    KEYWORD_BY      reduce using rule 66 (variable_literal -> primary .)


state 63

    (72) c_literal -> CHAR .

    TIMES           reduce using rule 72 (c_literal -> CHAR .)
    DIVIDE          reduce using rule 72 (c_literal -> CHAR .)
    REMAINDER       reduce using rule 72 (c_literal -> CHAR .)
    PLUS            reduce using rule 72 (c_literal -> CHAR .)
    MINUS           reduce using rule 72 (c_literal -> CHAR .)
    LSHIFT          reduce using rule 72 (c_literal -> CHAR .)
    RSHIFT          reduce using rule 72 (c_literal -> CHAR .)
    GREATER         reduce using rule 72 (c_literal -> CHAR .)
    LESS            reduce using rule 72 (c_literal -> CHAR .)
    GEQ             reduce using rule 72 (c_literal -> CHAR .)
    LEQ             reduce using rule 72 (c_literal -> CHAR .)
    EQUAL           reduce using rule 72 (c_literal -> CHAR .)
    NEQUAL          reduce using rule 72 (c_literal -> CHAR .)
    AND_BITWISE     reduce using rule 72 (c_literal -> CHAR .)
    XOR             reduce using rule 72 (c_literal -> CHAR .)
    OR_BITWISE      reduce using rule 72 (c_literal -> CHAR .)
    AND             reduce using rule 72 (c_literal -> CHAR .)
    OR              reduce using rule 72 (c_literal -> CHAR .)
    KEYWORD_MATCH   reduce using rule 72 (c_literal -> CHAR .)
    TERMINATOR      reduce using rule 72 (c_literal -> CHAR .)
    RPAREN          reduce using rule 72 (c_literal -> CHAR .)
    RBRAC           reduce using rule 72 (c_literal -> CHAR .)
    COMMA           reduce using rule 72 (c_literal -> CHAR .)
    FUNTYPE         reduce using rule 72 (c_literal -> CHAR .)
    KEYWORD_UNTIL   reduce using rule 72 (c_literal -> CHAR .)
    KEYWORD_TO      reduce using rule 72 (c_literal -> CHAR .)
    KEYWORD_BY      reduce using rule 72 (c_literal -> CHAR .)


state 64

    (123) statement -> if_then_statement .

    KEYWORD_IF      reduce using rule 123 (statement -> if_then_statement .)
    KEYWORD_WHILE   reduce using rule 123 (statement -> if_then_statement .)
    KEYWORD_DO      reduce using rule 123 (statement -> if_then_statement .)
    KEYWORD_FOR     reduce using rule 123 (statement -> if_then_statement .)
    KEYWORD_OBJECT  reduce using rule 123 (statement -> if_then_statement .)
    BLOCKBEGIN      reduce using rule 123 (statement -> if_then_statement .)
    TERMINATOR      reduce using rule 123 (statement -> if_then_statement .)
    KEYWORD_RETURN  reduce using rule 123 (statement -> if_then_statement .)
    KEYWORD_PROTECTED reduce using rule 123 (statement -> if_then_statement .)
    KEYWORD_PRIVATE reduce using rule 123 (statement -> if_then_statement .)
    IDENTIFIER      reduce using rule 123 (statement -> if_then_statement .)
    PLUS            reduce using rule 123 (statement -> if_then_statement .)
    MINUS           reduce using rule 123 (statement -> if_then_statement .)
    TILDA           reduce using rule 123 (statement -> if_then_statement .)
    NOT             reduce using rule 123 (statement -> if_then_statement .)
    LPAREN          reduce using rule 123 (statement -> if_then_statement .)
    DOUBLE_NUMBER   reduce using rule 123 (statement -> if_then_statement .)
    INT_NUMBER      reduce using rule 123 (statement -> if_then_statement .)
    CHAR            reduce using rule 123 (statement -> if_then_statement .)
    STRING          reduce using rule 123 (statement -> if_then_statement .)
    BOOL_CONSTT     reduce using rule 123 (statement -> if_then_statement .)
    BOOL_CONSTF     reduce using rule 123 (statement -> if_then_statement .)
    KEYWORD_NULL    reduce using rule 123 (statement -> if_then_statement .)
    KEYWORD_DEF     reduce using rule 123 (statement -> if_then_statement .)
    KEYWORD_CLASS   reduce using rule 123 (statement -> if_then_statement .)
    KEYWORD_VAR     reduce using rule 123 (statement -> if_then_statement .)
    KEYWORD_VAL     reduce using rule 123 (statement -> if_then_statement .)
    BLOCKEND        reduce using rule 123 (statement -> if_then_statement .)
    KEYWORD_CASE    reduce using rule 123 (statement -> if_then_statement .)


state 65

    (76) c_literal -> KEYWORD_NULL .

    TIMES           reduce using rule 76 (c_literal -> KEYWORD_NULL .)
    DIVIDE          reduce using rule 76 (c_literal -> KEYWORD_NULL .)
    REMAINDER       reduce using rule 76 (c_literal -> KEYWORD_NULL .)
    PLUS            reduce using rule 76 (c_literal -> KEYWORD_NULL .)
    MINUS           reduce using rule 76 (c_literal -> KEYWORD_NULL .)
    LSHIFT          reduce using rule 76 (c_literal -> KEYWORD_NULL .)
    RSHIFT          reduce using rule 76 (c_literal -> KEYWORD_NULL .)
    GREATER         reduce using rule 76 (c_literal -> KEYWORD_NULL .)
    LESS            reduce using rule 76 (c_literal -> KEYWORD_NULL .)
    GEQ             reduce using rule 76 (c_literal -> KEYWORD_NULL .)
    LEQ             reduce using rule 76 (c_literal -> KEYWORD_NULL .)
    EQUAL           reduce using rule 76 (c_literal -> KEYWORD_NULL .)
    NEQUAL          reduce using rule 76 (c_literal -> KEYWORD_NULL .)
    AND_BITWISE     reduce using rule 76 (c_literal -> KEYWORD_NULL .)
    XOR             reduce using rule 76 (c_literal -> KEYWORD_NULL .)
    OR_BITWISE      reduce using rule 76 (c_literal -> KEYWORD_NULL .)
    AND             reduce using rule 76 (c_literal -> KEYWORD_NULL .)
    OR              reduce using rule 76 (c_literal -> KEYWORD_NULL .)
    KEYWORD_MATCH   reduce using rule 76 (c_literal -> KEYWORD_NULL .)
    TERMINATOR      reduce using rule 76 (c_literal -> KEYWORD_NULL .)
    RPAREN          reduce using rule 76 (c_literal -> KEYWORD_NULL .)
    RBRAC           reduce using rule 76 (c_literal -> KEYWORD_NULL .)
    COMMA           reduce using rule 76 (c_literal -> KEYWORD_NULL .)
    FUNTYPE         reduce using rule 76 (c_literal -> KEYWORD_NULL .)
    KEYWORD_UNTIL   reduce using rule 76 (c_literal -> KEYWORD_NULL .)
    KEYWORD_TO      reduce using rule 76 (c_literal -> KEYWORD_NULL .)
    KEYWORD_BY      reduce using rule 76 (c_literal -> KEYWORD_NULL .)


state 66

    (46) shift_expression -> additive_expression .
    (50) additive_expression -> additive_expression . PLUS multiplicative_expression
    (51) additive_expression -> additive_expression . MINUS multiplicative_expression

    LSHIFT          reduce using rule 46 (shift_expression -> additive_expression .)
    RSHIFT          reduce using rule 46 (shift_expression -> additive_expression .)
    GREATER         reduce using rule 46 (shift_expression -> additive_expression .)
    LESS            reduce using rule 46 (shift_expression -> additive_expression .)
    GEQ             reduce using rule 46 (shift_expression -> additive_expression .)
    LEQ             reduce using rule 46 (shift_expression -> additive_expression .)
    EQUAL           reduce using rule 46 (shift_expression -> additive_expression .)
    NEQUAL          reduce using rule 46 (shift_expression -> additive_expression .)
    AND_BITWISE     reduce using rule 46 (shift_expression -> additive_expression .)
    XOR             reduce using rule 46 (shift_expression -> additive_expression .)
    OR_BITWISE      reduce using rule 46 (shift_expression -> additive_expression .)
    AND             reduce using rule 46 (shift_expression -> additive_expression .)
    OR              reduce using rule 46 (shift_expression -> additive_expression .)
    RPAREN          reduce using rule 46 (shift_expression -> additive_expression .)
    KEYWORD_UNTIL   reduce using rule 46 (shift_expression -> additive_expression .)
    KEYWORD_TO      reduce using rule 46 (shift_expression -> additive_expression .)
    KEYWORD_MATCH   reduce using rule 46 (shift_expression -> additive_expression .)
    TERMINATOR      reduce using rule 46 (shift_expression -> additive_expression .)
    RBRAC           reduce using rule 46 (shift_expression -> additive_expression .)
    COMMA           reduce using rule 46 (shift_expression -> additive_expression .)
    FUNTYPE         reduce using rule 46 (shift_expression -> additive_expression .)
    KEYWORD_BY      reduce using rule 46 (shift_expression -> additive_expression .)
    PLUS            shift and go to state 134
    MINUS           shift and go to state 135


state 67

    (115) name -> simple_name .

    LPAREN          reduce using rule 115 (name -> simple_name .)
    LBRAC           reduce using rule 115 (name -> simple_name .)
    INST            reduce using rule 115 (name -> simple_name .)
    ASOP            reduce using rule 115 (name -> simple_name .)
    TIMES           reduce using rule 115 (name -> simple_name .)
    DIVIDE          reduce using rule 115 (name -> simple_name .)
    REMAINDER       reduce using rule 115 (name -> simple_name .)
    PLUS            reduce using rule 115 (name -> simple_name .)
    MINUS           reduce using rule 115 (name -> simple_name .)
    LSHIFT          reduce using rule 115 (name -> simple_name .)
    RSHIFT          reduce using rule 115 (name -> simple_name .)
    GREATER         reduce using rule 115 (name -> simple_name .)
    LESS            reduce using rule 115 (name -> simple_name .)
    GEQ             reduce using rule 115 (name -> simple_name .)
    LEQ             reduce using rule 115 (name -> simple_name .)
    EQUAL           reduce using rule 115 (name -> simple_name .)
    NEQUAL          reduce using rule 115 (name -> simple_name .)
    AND_BITWISE     reduce using rule 115 (name -> simple_name .)
    XOR             reduce using rule 115 (name -> simple_name .)
    OR_BITWISE      reduce using rule 115 (name -> simple_name .)
    AND             reduce using rule 115 (name -> simple_name .)
    OR              reduce using rule 115 (name -> simple_name .)
    KEYWORD_MATCH   reduce using rule 115 (name -> simple_name .)
    TERMINATOR      reduce using rule 115 (name -> simple_name .)
    RPAREN          reduce using rule 115 (name -> simple_name .)
    RBRAC           reduce using rule 115 (name -> simple_name .)
    COMMA           reduce using rule 115 (name -> simple_name .)
    FUNTYPE         reduce using rule 115 (name -> simple_name .)
    KEYWORD_UNTIL   reduce using rule 115 (name -> simple_name .)
    KEYWORD_TO      reduce using rule 115 (name -> simple_name .)
    KEYWORD_BY      reduce using rule 115 (name -> simple_name .)


state 68

    (164) return_statement -> KEYWORD_RETURN . expression_optional TERMINATOR
    (19) expression_optional -> . expression
    (20) expression_optional -> . empty
    (18) expression -> . assignment_expression
    (186) empty -> .
    (21) assignment_expression -> . assignment
    (22) assignment_expression -> . conditional_or_expression
    (23) assignment -> . valid_variable assignment_operator assignment_expression
    (28) conditional_or_expression -> . conditional_and_expression
    (29) conditional_or_expression -> . conditional_or_expression OR conditional_and_expression
    (24) valid_variable -> . name
    (25) valid_variable -> . array_access
    (30) conditional_and_expression -> . inclusive_or_expression
    (31) conditional_and_expression -> . conditional_and_expression AND inclusive_or_expression
    (115) name -> . simple_name
    (116) name -> . qualified_name
    (26) array_access -> . name LBRAC expression RBRAC
    (32) inclusive_or_expression -> . exclusive_or_expression
    (33) inclusive_or_expression -> . inclusive_or_expression OR_BITWISE exclusive_or_expression
    (117) simple_name -> . IDENTIFIER
    (118) qualified_name -> . name INST simple_name
    (34) exclusive_or_expression -> . and_expression
    (35) exclusive_or_expression -> . exclusive_or_expression XOR and_expression
    (36) and_expression -> . equality_expression
    (37) and_expression -> . and_expression AND_BITWISE equality_expression
    (38) equality_expression -> . relational_expression
    (39) equality_expression -> . equality_expression EQUAL relational_expression
    (40) equality_expression -> . equality_expression NEQUAL relational_expression
    (41) relational_expression -> . shift_expression
    (42) relational_expression -> . relational_expression GREATER shift_expression
    (43) relational_expression -> . relational_expression LESS shift_expression
    (44) relational_expression -> . relational_expression GEQ shift_expression
    (45) relational_expression -> . relational_expression LEQ shift_expression
    (46) shift_expression -> . additive_expression
    (47) shift_expression -> . shift_expression LSHIFT additive_expression
    (48) shift_expression -> . shift_expression RSHIFT additive_expression
    (49) additive_expression -> . multiplicative_expression
    (50) additive_expression -> . additive_expression PLUS multiplicative_expression
    (51) additive_expression -> . additive_expression MINUS multiplicative_expression
    (52) multiplicative_expression -> . unary_expression
    (53) multiplicative_expression -> . multiplicative_expression TIMES unary_expression
    (54) multiplicative_expression -> . multiplicative_expression DIVIDE unary_expression
    (55) multiplicative_expression -> . multiplicative_expression REMAINDER unary_expression
    (56) unary_expression -> . PLUS unary_expression
    (57) unary_expression -> . MINUS unary_expression
    (58) unary_expression -> . unary_expression_not_plus_minus
    (59) unary_expression_not_plus_minus -> . base_variable_set
    (60) unary_expression_not_plus_minus -> . TILDA unary_expression
    (61) unary_expression_not_plus_minus -> . NOT unary_expression
    (62) unary_expression_not_plus_minus -> . cast_expression
    (63) base_variable_set -> . variable_literal
    (64) base_variable_set -> . LPAREN expression RPAREN
    (67) cast_expression -> . LPAREN primitive_type RPAREN unary_expression
    (65) variable_literal -> . valid_variable
    (66) variable_literal -> . primary
    (68) primary -> . literal
    (69) primary -> . method_invocation
    (70) literal -> . int_float
    (71) literal -> . c_literal
    (79) method_invocation -> . name LPAREN argument_list_opt RPAREN
    (77) int_float -> . DOUBLE_NUMBER
    (78) int_float -> . INT_NUMBER
    (72) c_literal -> . CHAR
    (73) c_literal -> . STRING
    (74) c_literal -> . BOOL_CONSTT
    (75) c_literal -> . BOOL_CONSTF
    (76) c_literal -> . KEYWORD_NULL

    TERMINATOR      reduce using rule 186 (empty -> .)
    IDENTIFIER      shift and go to state 77
    PLUS            shift and go to state 36
    MINUS           shift and go to state 29
    TILDA           shift and go to state 72
    NOT             shift and go to state 57
    LPAREN          shift and go to state 94
    DOUBLE_NUMBER   shift and go to state 33
    INT_NUMBER      shift and go to state 44
    CHAR            shift and go to state 63
    STRING          shift and go to state 76
    BOOL_CONSTT     shift and go to state 35
    BOOL_CONSTF     shift and go to state 30
    KEYWORD_NULL    shift and go to state 65

    unary_expression               shift and go to state 45
    exclusive_or_expression        shift and go to state 61
    primary                        shift and go to state 62
    unary_expression_not_plus_minus shift and go to state 46
    array_access                   shift and go to state 28
    additive_expression            shift and go to state 66
    simple_name                    shift and go to state 67
    c_literal                      shift and go to state 93
    expression_optional            shift and go to state 136
    base_variable_set              shift and go to state 88
    valid_variable                 shift and go to state 48
    inclusive_or_expression        shift and go to state 32
    literal                        shift and go to state 71
    and_expression                 shift and go to state 87
    relational_expression          shift and go to state 73
    cast_expression                shift and go to state 80
    conditional_or_expression      shift and go to state 49
    empty                          shift and go to state 137
    assignment_expression          shift and go to state 91
    qualified_name                 shift and go to state 79
    assignment                     shift and go to state 138
    multiplicative_expression      shift and go to state 52
    method_invocation              shift and go to state 111
    shift_expression               shift and go to state 54
    equality_expression            shift and go to state 82
    int_float                      shift and go to state 40
    variable_literal               shift and go to state 55
    name                           shift and go to state 139
    expression                     shift and go to state 140
    conditional_and_expression     shift and go to state 56

state 69

    (17) block_statement -> method_declaration .

    KEYWORD_IF      reduce using rule 17 (block_statement -> method_declaration .)
    KEYWORD_WHILE   reduce using rule 17 (block_statement -> method_declaration .)
    KEYWORD_DO      reduce using rule 17 (block_statement -> method_declaration .)
    KEYWORD_FOR     reduce using rule 17 (block_statement -> method_declaration .)
    KEYWORD_OBJECT  reduce using rule 17 (block_statement -> method_declaration .)
    BLOCKBEGIN      reduce using rule 17 (block_statement -> method_declaration .)
    TERMINATOR      reduce using rule 17 (block_statement -> method_declaration .)
    KEYWORD_RETURN  reduce using rule 17 (block_statement -> method_declaration .)
    KEYWORD_PROTECTED reduce using rule 17 (block_statement -> method_declaration .)
    KEYWORD_PRIVATE reduce using rule 17 (block_statement -> method_declaration .)
    IDENTIFIER      reduce using rule 17 (block_statement -> method_declaration .)
    PLUS            reduce using rule 17 (block_statement -> method_declaration .)
    MINUS           reduce using rule 17 (block_statement -> method_declaration .)
    TILDA           reduce using rule 17 (block_statement -> method_declaration .)
    NOT             reduce using rule 17 (block_statement -> method_declaration .)
    LPAREN          reduce using rule 17 (block_statement -> method_declaration .)
    DOUBLE_NUMBER   reduce using rule 17 (block_statement -> method_declaration .)
    INT_NUMBER      reduce using rule 17 (block_statement -> method_declaration .)
    CHAR            reduce using rule 17 (block_statement -> method_declaration .)
    STRING          reduce using rule 17 (block_statement -> method_declaration .)
    BOOL_CONSTT     reduce using rule 17 (block_statement -> method_declaration .)
    BOOL_CONSTF     reduce using rule 17 (block_statement -> method_declaration .)
    KEYWORD_NULL    reduce using rule 17 (block_statement -> method_declaration .)
    KEYWORD_DEF     reduce using rule 17 (block_statement -> method_declaration .)
    KEYWORD_CLASS   reduce using rule 17 (block_statement -> method_declaration .)
    KEYWORD_VAR     reduce using rule 17 (block_statement -> method_declaration .)
    KEYWORD_VAL     reduce using rule 17 (block_statement -> method_declaration .)
    BLOCKEND        reduce using rule 17 (block_statement -> method_declaration .)
    KEYWORD_CASE    reduce using rule 17 (block_statement -> method_declaration .)


state 70

    (11) block_statements -> block_statement .

    KEYWORD_IF      reduce using rule 11 (block_statements -> block_statement .)
    KEYWORD_WHILE   reduce using rule 11 (block_statements -> block_statement .)
    KEYWORD_DO      reduce using rule 11 (block_statements -> block_statement .)
    KEYWORD_FOR     reduce using rule 11 (block_statements -> block_statement .)
    KEYWORD_OBJECT  reduce using rule 11 (block_statements -> block_statement .)
    BLOCKBEGIN      reduce using rule 11 (block_statements -> block_statement .)
    TERMINATOR      reduce using rule 11 (block_statements -> block_statement .)
    KEYWORD_RETURN  reduce using rule 11 (block_statements -> block_statement .)
    KEYWORD_PROTECTED reduce using rule 11 (block_statements -> block_statement .)
    KEYWORD_PRIVATE reduce using rule 11 (block_statements -> block_statement .)
    IDENTIFIER      reduce using rule 11 (block_statements -> block_statement .)
    PLUS            reduce using rule 11 (block_statements -> block_statement .)
    MINUS           reduce using rule 11 (block_statements -> block_statement .)
    TILDA           reduce using rule 11 (block_statements -> block_statement .)
    NOT             reduce using rule 11 (block_statements -> block_statement .)
    LPAREN          reduce using rule 11 (block_statements -> block_statement .)
    DOUBLE_NUMBER   reduce using rule 11 (block_statements -> block_statement .)
    INT_NUMBER      reduce using rule 11 (block_statements -> block_statement .)
    CHAR            reduce using rule 11 (block_statements -> block_statement .)
    STRING          reduce using rule 11 (block_statements -> block_statement .)
    BOOL_CONSTT     reduce using rule 11 (block_statements -> block_statement .)
    BOOL_CONSTF     reduce using rule 11 (block_statements -> block_statement .)
    KEYWORD_NULL    reduce using rule 11 (block_statements -> block_statement .)
    KEYWORD_DEF     reduce using rule 11 (block_statements -> block_statement .)
    KEYWORD_CLASS   reduce using rule 11 (block_statements -> block_statement .)
    KEYWORD_VAR     reduce using rule 11 (block_statements -> block_statement .)
    KEYWORD_VAL     reduce using rule 11 (block_statements -> block_statement .)
    BLOCKEND        reduce using rule 11 (block_statements -> block_statement .)
    KEYWORD_CASE    reduce using rule 11 (block_statements -> block_statement .)


state 71

    (68) primary -> literal .

    TIMES           reduce using rule 68 (primary -> literal .)
    DIVIDE          reduce using rule 68 (primary -> literal .)
    REMAINDER       reduce using rule 68 (primary -> literal .)
    PLUS            reduce using rule 68 (primary -> literal .)
    MINUS           reduce using rule 68 (primary -> literal .)
    LSHIFT          reduce using rule 68 (primary -> literal .)
    RSHIFT          reduce using rule 68 (primary -> literal .)
    GREATER         reduce using rule 68 (primary -> literal .)
    LESS            reduce using rule 68 (primary -> literal .)
    GEQ             reduce using rule 68 (primary -> literal .)
    LEQ             reduce using rule 68 (primary -> literal .)
    EQUAL           reduce using rule 68 (primary -> literal .)
    NEQUAL          reduce using rule 68 (primary -> literal .)
    AND_BITWISE     reduce using rule 68 (primary -> literal .)
    XOR             reduce using rule 68 (primary -> literal .)
    OR_BITWISE      reduce using rule 68 (primary -> literal .)
    AND             reduce using rule 68 (primary -> literal .)
    OR              reduce using rule 68 (primary -> literal .)
    KEYWORD_MATCH   reduce using rule 68 (primary -> literal .)
    TERMINATOR      reduce using rule 68 (primary -> literal .)
    RPAREN          reduce using rule 68 (primary -> literal .)
    RBRAC           reduce using rule 68 (primary -> literal .)
    COMMA           reduce using rule 68 (primary -> literal .)
    FUNTYPE         reduce using rule 68 (primary -> literal .)
    KEYWORD_UNTIL   reduce using rule 68 (primary -> literal .)
    KEYWORD_TO      reduce using rule 68 (primary -> literal .)
    KEYWORD_BY      reduce using rule 68 (primary -> literal .)


state 72

    (60) unary_expression_not_plus_minus -> TILDA . unary_expression
    (56) unary_expression -> . PLUS unary_expression
    (57) unary_expression -> . MINUS unary_expression
    (58) unary_expression -> . unary_expression_not_plus_minus
    (59) unary_expression_not_plus_minus -> . base_variable_set
    (60) unary_expression_not_plus_minus -> . TILDA unary_expression
    (61) unary_expression_not_plus_minus -> . NOT unary_expression
    (62) unary_expression_not_plus_minus -> . cast_expression
    (63) base_variable_set -> . variable_literal
    (64) base_variable_set -> . LPAREN expression RPAREN
    (67) cast_expression -> . LPAREN primitive_type RPAREN unary_expression
    (65) variable_literal -> . valid_variable
    (66) variable_literal -> . primary
    (24) valid_variable -> . name
    (25) valid_variable -> . array_access
    (68) primary -> . literal
    (69) primary -> . method_invocation
    (115) name -> . simple_name
    (116) name -> . qualified_name
    (26) array_access -> . name LBRAC expression RBRAC
    (70) literal -> . int_float
    (71) literal -> . c_literal
    (79) method_invocation -> . name LPAREN argument_list_opt RPAREN
    (117) simple_name -> . IDENTIFIER
    (118) qualified_name -> . name INST simple_name
    (77) int_float -> . DOUBLE_NUMBER
    (78) int_float -> . INT_NUMBER
    (72) c_literal -> . CHAR
    (73) c_literal -> . STRING
    (74) c_literal -> . BOOL_CONSTT
    (75) c_literal -> . BOOL_CONSTF
    (76) c_literal -> . KEYWORD_NULL

    PLUS            shift and go to state 36
    MINUS           shift and go to state 29
    TILDA           shift and go to state 72
    NOT             shift and go to state 57
    LPAREN          shift and go to state 94
    IDENTIFIER      shift and go to state 77
    DOUBLE_NUMBER   shift and go to state 33
    INT_NUMBER      shift and go to state 44
    CHAR            shift and go to state 63
    STRING          shift and go to state 76
    BOOL_CONSTT     shift and go to state 35
    BOOL_CONSTF     shift and go to state 30
    KEYWORD_NULL    shift and go to state 65

    qualified_name                 shift and go to state 79
    int_float                      shift and go to state 40
    c_literal                      shift and go to state 93
    variable_literal               shift and go to state 55
    unary_expression               shift and go to state 141
    base_variable_set              shift and go to state 88
    valid_variable                 shift and go to state 110
    array_access                   shift and go to state 28
    primary                        shift and go to state 62
    unary_expression_not_plus_minus shift and go to state 46
    literal                        shift and go to state 71
    method_invocation              shift and go to state 111
    cast_expression                shift and go to state 80
    simple_name                    shift and go to state 67
    name                           shift and go to state 112

state 73

    (38) equality_expression -> relational_expression .
    (42) relational_expression -> relational_expression . GREATER shift_expression
    (43) relational_expression -> relational_expression . LESS shift_expression
    (44) relational_expression -> relational_expression . GEQ shift_expression
    (45) relational_expression -> relational_expression . LEQ shift_expression

    EQUAL           reduce using rule 38 (equality_expression -> relational_expression .)
    NEQUAL          reduce using rule 38 (equality_expression -> relational_expression .)
    AND_BITWISE     reduce using rule 38 (equality_expression -> relational_expression .)
    XOR             reduce using rule 38 (equality_expression -> relational_expression .)
    OR_BITWISE      reduce using rule 38 (equality_expression -> relational_expression .)
    AND             reduce using rule 38 (equality_expression -> relational_expression .)
    OR              reduce using rule 38 (equality_expression -> relational_expression .)
    KEYWORD_MATCH   reduce using rule 38 (equality_expression -> relational_expression .)
    TERMINATOR      reduce using rule 38 (equality_expression -> relational_expression .)
    RPAREN          reduce using rule 38 (equality_expression -> relational_expression .)
    RBRAC           reduce using rule 38 (equality_expression -> relational_expression .)
    COMMA           reduce using rule 38 (equality_expression -> relational_expression .)
    FUNTYPE         reduce using rule 38 (equality_expression -> relational_expression .)
    KEYWORD_UNTIL   reduce using rule 38 (equality_expression -> relational_expression .)
    KEYWORD_TO      reduce using rule 38 (equality_expression -> relational_expression .)
    KEYWORD_BY      reduce using rule 38 (equality_expression -> relational_expression .)
    GREATER         shift and go to state 143
    LESS            shift and go to state 144
    GEQ             shift and go to state 142
    LEQ             shift and go to state 145


state 74

    (14) block_statement -> statement .

    KEYWORD_IF      reduce using rule 14 (block_statement -> statement .)
    KEYWORD_WHILE   reduce using rule 14 (block_statement -> statement .)
    KEYWORD_DO      reduce using rule 14 (block_statement -> statement .)
    KEYWORD_FOR     reduce using rule 14 (block_statement -> statement .)
    KEYWORD_OBJECT  reduce using rule 14 (block_statement -> statement .)
    BLOCKBEGIN      reduce using rule 14 (block_statement -> statement .)
    TERMINATOR      reduce using rule 14 (block_statement -> statement .)
    KEYWORD_RETURN  reduce using rule 14 (block_statement -> statement .)
    KEYWORD_PROTECTED reduce using rule 14 (block_statement -> statement .)
    KEYWORD_PRIVATE reduce using rule 14 (block_statement -> statement .)
    IDENTIFIER      reduce using rule 14 (block_statement -> statement .)
    PLUS            reduce using rule 14 (block_statement -> statement .)
    MINUS           reduce using rule 14 (block_statement -> statement .)
    TILDA           reduce using rule 14 (block_statement -> statement .)
    NOT             reduce using rule 14 (block_statement -> statement .)
    LPAREN          reduce using rule 14 (block_statement -> statement .)
    DOUBLE_NUMBER   reduce using rule 14 (block_statement -> statement .)
    INT_NUMBER      reduce using rule 14 (block_statement -> statement .)
    CHAR            reduce using rule 14 (block_statement -> statement .)
    STRING          reduce using rule 14 (block_statement -> statement .)
    BOOL_CONSTT     reduce using rule 14 (block_statement -> statement .)
    BOOL_CONSTF     reduce using rule 14 (block_statement -> statement .)
    KEYWORD_NULL    reduce using rule 14 (block_statement -> statement .)
    KEYWORD_DEF     reduce using rule 14 (block_statement -> statement .)
    KEYWORD_CLASS   reduce using rule 14 (block_statement -> statement .)
    KEYWORD_VAR     reduce using rule 14 (block_statement -> statement .)
    KEYWORD_VAL     reduce using rule 14 (block_statement -> statement .)
    BLOCKEND        reduce using rule 14 (block_statement -> statement .)
    KEYWORD_CASE    reduce using rule 14 (block_statement -> statement .)


state 75

    (135) statement_expression -> method_invocation .
    (69) primary -> method_invocation .

    TERMINATOR      reduce using rule 135 (statement_expression -> method_invocation .)
    TIMES           reduce using rule 69 (primary -> method_invocation .)
    DIVIDE          reduce using rule 69 (primary -> method_invocation .)
    REMAINDER       reduce using rule 69 (primary -> method_invocation .)
    PLUS            reduce using rule 69 (primary -> method_invocation .)
    MINUS           reduce using rule 69 (primary -> method_invocation .)
    LSHIFT          reduce using rule 69 (primary -> method_invocation .)
    RSHIFT          reduce using rule 69 (primary -> method_invocation .)
    GREATER         reduce using rule 69 (primary -> method_invocation .)
    LESS            reduce using rule 69 (primary -> method_invocation .)
    GEQ             reduce using rule 69 (primary -> method_invocation .)
    LEQ             reduce using rule 69 (primary -> method_invocation .)
    EQUAL           reduce using rule 69 (primary -> method_invocation .)
    NEQUAL          reduce using rule 69 (primary -> method_invocation .)
    AND_BITWISE     reduce using rule 69 (primary -> method_invocation .)
    XOR             reduce using rule 69 (primary -> method_invocation .)
    OR_BITWISE      reduce using rule 69 (primary -> method_invocation .)
    AND             reduce using rule 69 (primary -> method_invocation .)
    OR              reduce using rule 69 (primary -> method_invocation .)
    KEYWORD_MATCH   reduce using rule 69 (primary -> method_invocation .)


state 76

    (73) c_literal -> STRING .

    TIMES           reduce using rule 73 (c_literal -> STRING .)
    DIVIDE          reduce using rule 73 (c_literal -> STRING .)
    REMAINDER       reduce using rule 73 (c_literal -> STRING .)
    PLUS            reduce using rule 73 (c_literal -> STRING .)
    MINUS           reduce using rule 73 (c_literal -> STRING .)
    LSHIFT          reduce using rule 73 (c_literal -> STRING .)
    RSHIFT          reduce using rule 73 (c_literal -> STRING .)
    GREATER         reduce using rule 73 (c_literal -> STRING .)
    LESS            reduce using rule 73 (c_literal -> STRING .)
    GEQ             reduce using rule 73 (c_literal -> STRING .)
    LEQ             reduce using rule 73 (c_literal -> STRING .)
    EQUAL           reduce using rule 73 (c_literal -> STRING .)
    NEQUAL          reduce using rule 73 (c_literal -> STRING .)
    AND_BITWISE     reduce using rule 73 (c_literal -> STRING .)
    XOR             reduce using rule 73 (c_literal -> STRING .)
    OR_BITWISE      reduce using rule 73 (c_literal -> STRING .)
    AND             reduce using rule 73 (c_literal -> STRING .)
    OR              reduce using rule 73 (c_literal -> STRING .)
    KEYWORD_MATCH   reduce using rule 73 (c_literal -> STRING .)
    TERMINATOR      reduce using rule 73 (c_literal -> STRING .)
    RPAREN          reduce using rule 73 (c_literal -> STRING .)
    RBRAC           reduce using rule 73 (c_literal -> STRING .)
    COMMA           reduce using rule 73 (c_literal -> STRING .)
    FUNTYPE         reduce using rule 73 (c_literal -> STRING .)
    KEYWORD_UNTIL   reduce using rule 73 (c_literal -> STRING .)
    KEYWORD_TO      reduce using rule 73 (c_literal -> STRING .)
    KEYWORD_BY      reduce using rule 73 (c_literal -> STRING .)


state 77

    (117) simple_name -> IDENTIFIER .

    LPAREN          reduce using rule 117 (simple_name -> IDENTIFIER .)
    LBRAC           reduce using rule 117 (simple_name -> IDENTIFIER .)
    INST            reduce using rule 117 (simple_name -> IDENTIFIER .)
    ASOP            reduce using rule 117 (simple_name -> IDENTIFIER .)
    TIMES           reduce using rule 117 (simple_name -> IDENTIFIER .)
    DIVIDE          reduce using rule 117 (simple_name -> IDENTIFIER .)
    REMAINDER       reduce using rule 117 (simple_name -> IDENTIFIER .)
    PLUS            reduce using rule 117 (simple_name -> IDENTIFIER .)
    MINUS           reduce using rule 117 (simple_name -> IDENTIFIER .)
    LSHIFT          reduce using rule 117 (simple_name -> IDENTIFIER .)
    RSHIFT          reduce using rule 117 (simple_name -> IDENTIFIER .)
    GREATER         reduce using rule 117 (simple_name -> IDENTIFIER .)
    LESS            reduce using rule 117 (simple_name -> IDENTIFIER .)
    GEQ             reduce using rule 117 (simple_name -> IDENTIFIER .)
    LEQ             reduce using rule 117 (simple_name -> IDENTIFIER .)
    EQUAL           reduce using rule 117 (simple_name -> IDENTIFIER .)
    NEQUAL          reduce using rule 117 (simple_name -> IDENTIFIER .)
    AND_BITWISE     reduce using rule 117 (simple_name -> IDENTIFIER .)
    XOR             reduce using rule 117 (simple_name -> IDENTIFIER .)
    OR_BITWISE      reduce using rule 117 (simple_name -> IDENTIFIER .)
    AND             reduce using rule 117 (simple_name -> IDENTIFIER .)
    OR              reduce using rule 117 (simple_name -> IDENTIFIER .)
    KEYWORD_MATCH   reduce using rule 117 (simple_name -> IDENTIFIER .)
    TERMINATOR      reduce using rule 117 (simple_name -> IDENTIFIER .)
    RPAREN          reduce using rule 117 (simple_name -> IDENTIFIER .)
    RBRAC           reduce using rule 117 (simple_name -> IDENTIFIER .)
    COMMA           reduce using rule 117 (simple_name -> IDENTIFIER .)
    FUNTYPE         reduce using rule 117 (simple_name -> IDENTIFIER .)
    KEYWORD_UNTIL   reduce using rule 117 (simple_name -> IDENTIFIER .)
    KEYWORD_TO      reduce using rule 117 (simple_name -> IDENTIFIER .)
    KEYWORD_BY      reduce using rule 117 (simple_name -> IDENTIFIER .)


state 78

    (10) block_statements_opt -> empty .
    (87) modifier_opts -> empty .

    BLOCKEND        reduce using rule 10 (block_statements_opt -> empty .)
    KEYWORD_DEF     reduce using rule 87 (modifier_opts -> empty .)
    KEYWORD_CLASS   reduce using rule 87 (modifier_opts -> empty .)
    KEYWORD_VAR     reduce using rule 87 (modifier_opts -> empty .)
    KEYWORD_VAL     reduce using rule 87 (modifier_opts -> empty .)


state 79

    (116) name -> qualified_name .

    LPAREN          reduce using rule 116 (name -> qualified_name .)
    LBRAC           reduce using rule 116 (name -> qualified_name .)
    INST            reduce using rule 116 (name -> qualified_name .)
    ASOP            reduce using rule 116 (name -> qualified_name .)
    TIMES           reduce using rule 116 (name -> qualified_name .)
    DIVIDE          reduce using rule 116 (name -> qualified_name .)
    REMAINDER       reduce using rule 116 (name -> qualified_name .)
    PLUS            reduce using rule 116 (name -> qualified_name .)
    MINUS           reduce using rule 116 (name -> qualified_name .)
    LSHIFT          reduce using rule 116 (name -> qualified_name .)
    RSHIFT          reduce using rule 116 (name -> qualified_name .)
    GREATER         reduce using rule 116 (name -> qualified_name .)
    LESS            reduce using rule 116 (name -> qualified_name .)
    GEQ             reduce using rule 116 (name -> qualified_name .)
    LEQ             reduce using rule 116 (name -> qualified_name .)
    EQUAL           reduce using rule 116 (name -> qualified_name .)
    NEQUAL          reduce using rule 116 (name -> qualified_name .)
    AND_BITWISE     reduce using rule 116 (name -> qualified_name .)
    XOR             reduce using rule 116 (name -> qualified_name .)
    OR_BITWISE      reduce using rule 116 (name -> qualified_name .)
    AND             reduce using rule 116 (name -> qualified_name .)
    OR              reduce using rule 116 (name -> qualified_name .)
    KEYWORD_MATCH   reduce using rule 116 (name -> qualified_name .)
    TERMINATOR      reduce using rule 116 (name -> qualified_name .)
    RPAREN          reduce using rule 116 (name -> qualified_name .)
    RBRAC           reduce using rule 116 (name -> qualified_name .)
    COMMA           reduce using rule 116 (name -> qualified_name .)
    FUNTYPE         reduce using rule 116 (name -> qualified_name .)
    KEYWORD_UNTIL   reduce using rule 116 (name -> qualified_name .)
    KEYWORD_TO      reduce using rule 116 (name -> qualified_name .)
    KEYWORD_BY      reduce using rule 116 (name -> qualified_name .)


state 80

    (62) unary_expression_not_plus_minus -> cast_expression .

    TIMES           reduce using rule 62 (unary_expression_not_plus_minus -> cast_expression .)
    DIVIDE          reduce using rule 62 (unary_expression_not_plus_minus -> cast_expression .)
    REMAINDER       reduce using rule 62 (unary_expression_not_plus_minus -> cast_expression .)
    PLUS            reduce using rule 62 (unary_expression_not_plus_minus -> cast_expression .)
    MINUS           reduce using rule 62 (unary_expression_not_plus_minus -> cast_expression .)
    LSHIFT          reduce using rule 62 (unary_expression_not_plus_minus -> cast_expression .)
    RSHIFT          reduce using rule 62 (unary_expression_not_plus_minus -> cast_expression .)
    GREATER         reduce using rule 62 (unary_expression_not_plus_minus -> cast_expression .)
    LESS            reduce using rule 62 (unary_expression_not_plus_minus -> cast_expression .)
    GEQ             reduce using rule 62 (unary_expression_not_plus_minus -> cast_expression .)
    LEQ             reduce using rule 62 (unary_expression_not_plus_minus -> cast_expression .)
    EQUAL           reduce using rule 62 (unary_expression_not_plus_minus -> cast_expression .)
    NEQUAL          reduce using rule 62 (unary_expression_not_plus_minus -> cast_expression .)
    AND_BITWISE     reduce using rule 62 (unary_expression_not_plus_minus -> cast_expression .)
    XOR             reduce using rule 62 (unary_expression_not_plus_minus -> cast_expression .)
    OR_BITWISE      reduce using rule 62 (unary_expression_not_plus_minus -> cast_expression .)
    AND             reduce using rule 62 (unary_expression_not_plus_minus -> cast_expression .)
    OR              reduce using rule 62 (unary_expression_not_plus_minus -> cast_expression .)
    KEYWORD_MATCH   reduce using rule 62 (unary_expression_not_plus_minus -> cast_expression .)
    TERMINATOR      reduce using rule 62 (unary_expression_not_plus_minus -> cast_expression .)
    RPAREN          reduce using rule 62 (unary_expression_not_plus_minus -> cast_expression .)
    RBRAC           reduce using rule 62 (unary_expression_not_plus_minus -> cast_expression .)
    COMMA           reduce using rule 62 (unary_expression_not_plus_minus -> cast_expression .)
    FUNTYPE         reduce using rule 62 (unary_expression_not_plus_minus -> cast_expression .)
    KEYWORD_UNTIL   reduce using rule 62 (unary_expression_not_plus_minus -> cast_expression .)
    KEYWORD_TO      reduce using rule 62 (unary_expression_not_plus_minus -> cast_expression .)
    KEYWORD_BY      reduce using rule 62 (unary_expression_not_plus_minus -> cast_expression .)


state 81

    (136) if_then_statement -> KEYWORD_IF . LPAREN expression RPAREN statement
    (137) if_then_else_statement -> KEYWORD_IF . LPAREN expression RPAREN if_then_else_intermediate KEYWORD_ELSE statement

    LPAREN          shift and go to state 146


state 82

    (36) and_expression -> equality_expression .
    (39) equality_expression -> equality_expression . EQUAL relational_expression
    (40) equality_expression -> equality_expression . NEQUAL relational_expression

    AND_BITWISE     reduce using rule 36 (and_expression -> equality_expression .)
    XOR             reduce using rule 36 (and_expression -> equality_expression .)
    OR_BITWISE      reduce using rule 36 (and_expression -> equality_expression .)
    AND             reduce using rule 36 (and_expression -> equality_expression .)
    OR              reduce using rule 36 (and_expression -> equality_expression .)
    KEYWORD_BY      reduce using rule 36 (and_expression -> equality_expression .)
    TERMINATOR      reduce using rule 36 (and_expression -> equality_expression .)
    RPAREN          reduce using rule 36 (and_expression -> equality_expression .)
    KEYWORD_MATCH   reduce using rule 36 (and_expression -> equality_expression .)
    RBRAC           reduce using rule 36 (and_expression -> equality_expression .)
    COMMA           reduce using rule 36 (and_expression -> equality_expression .)
    FUNTYPE         reduce using rule 36 (and_expression -> equality_expression .)
    KEYWORD_UNTIL   reduce using rule 36 (and_expression -> equality_expression .)
    KEYWORD_TO      reduce using rule 36 (and_expression -> equality_expression .)
    EQUAL           shift and go to state 148
    NEQUAL          shift and go to state 147


state 83

    (178) method_declaration -> method_header . method_body
    (185) method_body -> . block
    (8) block -> . BLOCKBEGIN block_statements_opt BLOCKEND

    BLOCKBEGIN      shift and go to state 15

    method_body                    shift and go to state 149
    block                          shift and go to state 150

state 84

    (130) normal_statement -> empty_statement .

    KEYWORD_IF      reduce using rule 130 (normal_statement -> empty_statement .)
    KEYWORD_WHILE   reduce using rule 130 (normal_statement -> empty_statement .)
    KEYWORD_DO      reduce using rule 130 (normal_statement -> empty_statement .)
    KEYWORD_FOR     reduce using rule 130 (normal_statement -> empty_statement .)
    KEYWORD_OBJECT  reduce using rule 130 (normal_statement -> empty_statement .)
    BLOCKBEGIN      reduce using rule 130 (normal_statement -> empty_statement .)
    TERMINATOR      reduce using rule 130 (normal_statement -> empty_statement .)
    KEYWORD_RETURN  reduce using rule 130 (normal_statement -> empty_statement .)
    KEYWORD_PROTECTED reduce using rule 130 (normal_statement -> empty_statement .)
    KEYWORD_PRIVATE reduce using rule 130 (normal_statement -> empty_statement .)
    IDENTIFIER      reduce using rule 130 (normal_statement -> empty_statement .)
    PLUS            reduce using rule 130 (normal_statement -> empty_statement .)
    MINUS           reduce using rule 130 (normal_statement -> empty_statement .)
    TILDA           reduce using rule 130 (normal_statement -> empty_statement .)
    NOT             reduce using rule 130 (normal_statement -> empty_statement .)
    LPAREN          reduce using rule 130 (normal_statement -> empty_statement .)
    DOUBLE_NUMBER   reduce using rule 130 (normal_statement -> empty_statement .)
    INT_NUMBER      reduce using rule 130 (normal_statement -> empty_statement .)
    CHAR            reduce using rule 130 (normal_statement -> empty_statement .)
    STRING          reduce using rule 130 (normal_statement -> empty_statement .)
    BOOL_CONSTT     reduce using rule 130 (normal_statement -> empty_statement .)
    BOOL_CONSTF     reduce using rule 130 (normal_statement -> empty_statement .)
    KEYWORD_NULL    reduce using rule 130 (normal_statement -> empty_statement .)
    KEYWORD_DEF     reduce using rule 130 (normal_statement -> empty_statement .)
    KEYWORD_CLASS   reduce using rule 130 (normal_statement -> empty_statement .)
    KEYWORD_VAR     reduce using rule 130 (normal_statement -> empty_statement .)
    KEYWORD_VAL     reduce using rule 130 (normal_statement -> empty_statement .)
    BLOCKEND        reduce using rule 130 (normal_statement -> empty_statement .)
    KEYWORD_CASE    reduce using rule 130 (normal_statement -> empty_statement .)
    KEYWORD_ELSE    reduce using rule 130 (normal_statement -> empty_statement .)


state 85

    (90) local_variable_declaration_statement -> local_variable_declaration . TERMINATOR

    TERMINATOR      shift and go to state 151


state 86

    (122) statement -> normal_statement .

    KEYWORD_IF      reduce using rule 122 (statement -> normal_statement .)
    KEYWORD_WHILE   reduce using rule 122 (statement -> normal_statement .)
    KEYWORD_DO      reduce using rule 122 (statement -> normal_statement .)
    KEYWORD_FOR     reduce using rule 122 (statement -> normal_statement .)
    KEYWORD_OBJECT  reduce using rule 122 (statement -> normal_statement .)
    BLOCKBEGIN      reduce using rule 122 (statement -> normal_statement .)
    TERMINATOR      reduce using rule 122 (statement -> normal_statement .)
    KEYWORD_RETURN  reduce using rule 122 (statement -> normal_statement .)
    KEYWORD_PROTECTED reduce using rule 122 (statement -> normal_statement .)
    KEYWORD_PRIVATE reduce using rule 122 (statement -> normal_statement .)
    IDENTIFIER      reduce using rule 122 (statement -> normal_statement .)
    PLUS            reduce using rule 122 (statement -> normal_statement .)
    MINUS           reduce using rule 122 (statement -> normal_statement .)
    TILDA           reduce using rule 122 (statement -> normal_statement .)
    NOT             reduce using rule 122 (statement -> normal_statement .)
    LPAREN          reduce using rule 122 (statement -> normal_statement .)
    DOUBLE_NUMBER   reduce using rule 122 (statement -> normal_statement .)
    INT_NUMBER      reduce using rule 122 (statement -> normal_statement .)
    CHAR            reduce using rule 122 (statement -> normal_statement .)
    STRING          reduce using rule 122 (statement -> normal_statement .)
    BOOL_CONSTT     reduce using rule 122 (statement -> normal_statement .)
    BOOL_CONSTF     reduce using rule 122 (statement -> normal_statement .)
    KEYWORD_NULL    reduce using rule 122 (statement -> normal_statement .)
    KEYWORD_DEF     reduce using rule 122 (statement -> normal_statement .)
    KEYWORD_CLASS   reduce using rule 122 (statement -> normal_statement .)
    KEYWORD_VAR     reduce using rule 122 (statement -> normal_statement .)
    KEYWORD_VAL     reduce using rule 122 (statement -> normal_statement .)
    BLOCKEND        reduce using rule 122 (statement -> normal_statement .)
    KEYWORD_CASE    reduce using rule 122 (statement -> normal_statement .)


state 87

    (34) exclusive_or_expression -> and_expression .
    (37) and_expression -> and_expression . AND_BITWISE equality_expression

    XOR             reduce using rule 34 (exclusive_or_expression -> and_expression .)
    OR_BITWISE      reduce using rule 34 (exclusive_or_expression -> and_expression .)
    AND             reduce using rule 34 (exclusive_or_expression -> and_expression .)
    OR              reduce using rule 34 (exclusive_or_expression -> and_expression .)
    KEYWORD_MATCH   reduce using rule 34 (exclusive_or_expression -> and_expression .)
    TERMINATOR      reduce using rule 34 (exclusive_or_expression -> and_expression .)
    RPAREN          reduce using rule 34 (exclusive_or_expression -> and_expression .)
    COMMA           reduce using rule 34 (exclusive_or_expression -> and_expression .)
    FUNTYPE         reduce using rule 34 (exclusive_or_expression -> and_expression .)
    RBRAC           reduce using rule 34 (exclusive_or_expression -> and_expression .)
    KEYWORD_UNTIL   reduce using rule 34 (exclusive_or_expression -> and_expression .)
    KEYWORD_TO      reduce using rule 34 (exclusive_or_expression -> and_expression .)
    KEYWORD_BY      reduce using rule 34 (exclusive_or_expression -> and_expression .)
    AND_BITWISE     shift and go to state 152


state 88

    (59) unary_expression_not_plus_minus -> base_variable_set .

    TIMES           reduce using rule 59 (unary_expression_not_plus_minus -> base_variable_set .)
    DIVIDE          reduce using rule 59 (unary_expression_not_plus_minus -> base_variable_set .)
    REMAINDER       reduce using rule 59 (unary_expression_not_plus_minus -> base_variable_set .)
    PLUS            reduce using rule 59 (unary_expression_not_plus_minus -> base_variable_set .)
    MINUS           reduce using rule 59 (unary_expression_not_plus_minus -> base_variable_set .)
    LSHIFT          reduce using rule 59 (unary_expression_not_plus_minus -> base_variable_set .)
    RSHIFT          reduce using rule 59 (unary_expression_not_plus_minus -> base_variable_set .)
    GREATER         reduce using rule 59 (unary_expression_not_plus_minus -> base_variable_set .)
    LESS            reduce using rule 59 (unary_expression_not_plus_minus -> base_variable_set .)
    GEQ             reduce using rule 59 (unary_expression_not_plus_minus -> base_variable_set .)
    LEQ             reduce using rule 59 (unary_expression_not_plus_minus -> base_variable_set .)
    EQUAL           reduce using rule 59 (unary_expression_not_plus_minus -> base_variable_set .)
    NEQUAL          reduce using rule 59 (unary_expression_not_plus_minus -> base_variable_set .)
    AND_BITWISE     reduce using rule 59 (unary_expression_not_plus_minus -> base_variable_set .)
    XOR             reduce using rule 59 (unary_expression_not_plus_minus -> base_variable_set .)
    OR_BITWISE      reduce using rule 59 (unary_expression_not_plus_minus -> base_variable_set .)
    AND             reduce using rule 59 (unary_expression_not_plus_minus -> base_variable_set .)
    OR              reduce using rule 59 (unary_expression_not_plus_minus -> base_variable_set .)
    KEYWORD_MATCH   reduce using rule 59 (unary_expression_not_plus_minus -> base_variable_set .)
    TERMINATOR      reduce using rule 59 (unary_expression_not_plus_minus -> base_variable_set .)
    RPAREN          reduce using rule 59 (unary_expression_not_plus_minus -> base_variable_set .)
    RBRAC           reduce using rule 59 (unary_expression_not_plus_minus -> base_variable_set .)
    COMMA           reduce using rule 59 (unary_expression_not_plus_minus -> base_variable_set .)
    FUNTYPE         reduce using rule 59 (unary_expression_not_plus_minus -> base_variable_set .)
    KEYWORD_UNTIL   reduce using rule 59 (unary_expression_not_plus_minus -> base_variable_set .)
    KEYWORD_TO      reduce using rule 59 (unary_expression_not_plus_minus -> base_variable_set .)
    KEYWORD_BY      reduce using rule 59 (unary_expression_not_plus_minus -> base_variable_set .)


state 89

    (131) normal_statement -> return_statement .

    KEYWORD_IF      reduce using rule 131 (normal_statement -> return_statement .)
    KEYWORD_WHILE   reduce using rule 131 (normal_statement -> return_statement .)
    KEYWORD_DO      reduce using rule 131 (normal_statement -> return_statement .)
    KEYWORD_FOR     reduce using rule 131 (normal_statement -> return_statement .)
    KEYWORD_OBJECT  reduce using rule 131 (normal_statement -> return_statement .)
    BLOCKBEGIN      reduce using rule 131 (normal_statement -> return_statement .)
    TERMINATOR      reduce using rule 131 (normal_statement -> return_statement .)
    KEYWORD_RETURN  reduce using rule 131 (normal_statement -> return_statement .)
    KEYWORD_PROTECTED reduce using rule 131 (normal_statement -> return_statement .)
    KEYWORD_PRIVATE reduce using rule 131 (normal_statement -> return_statement .)
    IDENTIFIER      reduce using rule 131 (normal_statement -> return_statement .)
    PLUS            reduce using rule 131 (normal_statement -> return_statement .)
    MINUS           reduce using rule 131 (normal_statement -> return_statement .)
    TILDA           reduce using rule 131 (normal_statement -> return_statement .)
    NOT             reduce using rule 131 (normal_statement -> return_statement .)
    LPAREN          reduce using rule 131 (normal_statement -> return_statement .)
    DOUBLE_NUMBER   reduce using rule 131 (normal_statement -> return_statement .)
    INT_NUMBER      reduce using rule 131 (normal_statement -> return_statement .)
    CHAR            reduce using rule 131 (normal_statement -> return_statement .)
    STRING          reduce using rule 131 (normal_statement -> return_statement .)
    BOOL_CONSTT     reduce using rule 131 (normal_statement -> return_statement .)
    BOOL_CONSTF     reduce using rule 131 (normal_statement -> return_statement .)
    KEYWORD_NULL    reduce using rule 131 (normal_statement -> return_statement .)
    KEYWORD_DEF     reduce using rule 131 (normal_statement -> return_statement .)
    KEYWORD_CLASS   reduce using rule 131 (normal_statement -> return_statement .)
    KEYWORD_VAR     reduce using rule 131 (normal_statement -> return_statement .)
    KEYWORD_VAL     reduce using rule 131 (normal_statement -> return_statement .)
    BLOCKEND        reduce using rule 131 (normal_statement -> return_statement .)
    KEYWORD_CASE    reduce using rule 131 (normal_statement -> return_statement .)
    KEYWORD_ELSE    reduce using rule 131 (normal_statement -> return_statement .)


state 90

    (9) block_statements_opt -> block_statements .
    (12) block_statements -> block_statements . block_statement
    (13) block_statement -> . local_variable_declaration_statement
    (14) block_statement -> . statement
    (15) block_statement -> . class_declaration
    (16) block_statement -> . SingletonObject
    (17) block_statement -> . method_declaration
    (90) local_variable_declaration_statement -> . local_variable_declaration TERMINATOR
    (122) statement -> . normal_statement
    (123) statement -> . if_then_statement
    (124) statement -> . if_then_else_statement
    (125) statement -> . while_statement
    (126) statement -> . do_while_statement
    (127) statement -> . for_statement
    (165) class_declaration -> . class_header class_body
    (5) SingletonObject -> . ObjectDeclare block
    (178) method_declaration -> . method_header method_body
    (91) local_variable_declaration -> . modifier_opts declaration_keyword variable_declaration_body
    (128) normal_statement -> . block
    (129) normal_statement -> . expression_statement
    (130) normal_statement -> . empty_statement
    (131) normal_statement -> . return_statement
    (132) normal_statement -> . switch_statement
    (136) if_then_statement -> . KEYWORD_IF LPAREN expression RPAREN statement
    (137) if_then_else_statement -> . KEYWORD_IF LPAREN expression RPAREN if_then_else_intermediate KEYWORD_ELSE statement
    (141) while_statement -> . KEYWORD_WHILE LPAREN expression RPAREN statement
    (142) do_while_statement -> . KEYWORD_DO statement KEYWORD_WHILE LPAREN expression RPAREN TERMINATOR
    (143) for_statement -> . KEYWORD_FOR LPAREN for_logic RPAREN statement
    (166) class_header -> . class_header_name class_header_extends_opt
    (6) ObjectDeclare -> . KEYWORD_OBJECT IDENTIFIER
    (7) ObjectDeclare -> . KEYWORD_OBJECT IDENTIFIER KEYWORD_EXTENDS IDENTIFIER
    (179) method_header -> . method_header_name LPAREN func_arguement_list_opt RPAREN COLON method_return_type ASOP
    (86) modifier_opts -> . modifier
    (87) modifier_opts -> . empty
    (8) block -> . BLOCKBEGIN block_statements_opt BLOCKEND
    (133) expression_statement -> . statement_expression TERMINATOR
    (163) empty_statement -> . TERMINATOR
    (164) return_statement -> . KEYWORD_RETURN expression_optional TERMINATOR
    (152) switch_statement -> . expression KEYWORD_MATCH switch_block
    (167) class_header_name -> . class_header_name1 LPAREN constructor_arguement_list_opt RPAREN
    (182) method_header_name -> . modifier_opts KEYWORD_DEF IDENTIFIER
    (84) modifier -> . KEYWORD_PROTECTED
    (85) modifier -> . KEYWORD_PRIVATE
    (186) empty -> .
    (134) statement_expression -> . assignment
    (135) statement_expression -> . method_invocation
    (18) expression -> . assignment_expression
    (168) class_header_name1 -> . modifier_opts KEYWORD_CLASS name
    (23) assignment -> . valid_variable assignment_operator assignment_expression
    (79) method_invocation -> . name LPAREN argument_list_opt RPAREN
    (21) assignment_expression -> . assignment
    (22) assignment_expression -> . conditional_or_expression
    (24) valid_variable -> . name
    (25) valid_variable -> . array_access
    (115) name -> . simple_name
    (116) name -> . qualified_name
    (28) conditional_or_expression -> . conditional_and_expression
    (29) conditional_or_expression -> . conditional_or_expression OR conditional_and_expression
    (26) array_access -> . name LBRAC expression RBRAC
    (117) simple_name -> . IDENTIFIER
    (118) qualified_name -> . name INST simple_name
    (30) conditional_and_expression -> . inclusive_or_expression
    (31) conditional_and_expression -> . conditional_and_expression AND inclusive_or_expression
    (32) inclusive_or_expression -> . exclusive_or_expression
    (33) inclusive_or_expression -> . inclusive_or_expression OR_BITWISE exclusive_or_expression
    (34) exclusive_or_expression -> . and_expression
    (35) exclusive_or_expression -> . exclusive_or_expression XOR and_expression
    (36) and_expression -> . equality_expression
    (37) and_expression -> . and_expression AND_BITWISE equality_expression
    (38) equality_expression -> . relational_expression
    (39) equality_expression -> . equality_expression EQUAL relational_expression
    (40) equality_expression -> . equality_expression NEQUAL relational_expression
    (41) relational_expression -> . shift_expression
    (42) relational_expression -> . relational_expression GREATER shift_expression
    (43) relational_expression -> . relational_expression LESS shift_expression
    (44) relational_expression -> . relational_expression GEQ shift_expression
    (45) relational_expression -> . relational_expression LEQ shift_expression
    (46) shift_expression -> . additive_expression
    (47) shift_expression -> . shift_expression LSHIFT additive_expression
    (48) shift_expression -> . shift_expression RSHIFT additive_expression
    (49) additive_expression -> . multiplicative_expression
    (50) additive_expression -> . additive_expression PLUS multiplicative_expression
    (51) additive_expression -> . additive_expression MINUS multiplicative_expression
    (52) multiplicative_expression -> . unary_expression
    (53) multiplicative_expression -> . multiplicative_expression TIMES unary_expression
    (54) multiplicative_expression -> . multiplicative_expression DIVIDE unary_expression
    (55) multiplicative_expression -> . multiplicative_expression REMAINDER unary_expression
    (56) unary_expression -> . PLUS unary_expression
    (57) unary_expression -> . MINUS unary_expression
    (58) unary_expression -> . unary_expression_not_plus_minus
    (59) unary_expression_not_plus_minus -> . base_variable_set
    (60) unary_expression_not_plus_minus -> . TILDA unary_expression
    (61) unary_expression_not_plus_minus -> . NOT unary_expression
    (62) unary_expression_not_plus_minus -> . cast_expression
    (63) base_variable_set -> . variable_literal
    (64) base_variable_set -> . LPAREN expression RPAREN
    (67) cast_expression -> . LPAREN primitive_type RPAREN unary_expression
    (65) variable_literal -> . valid_variable
    (66) variable_literal -> . primary
    (68) primary -> . literal
    (69) primary -> . method_invocation
    (70) literal -> . int_float
    (71) literal -> . c_literal
    (77) int_float -> . DOUBLE_NUMBER
    (78) int_float -> . INT_NUMBER
    (72) c_literal -> . CHAR
    (73) c_literal -> . STRING
    (74) c_literal -> . BOOL_CONSTT
    (75) c_literal -> . BOOL_CONSTF
    (76) c_literal -> . KEYWORD_NULL

    BLOCKEND        reduce using rule 9 (block_statements_opt -> block_statements .)
    KEYWORD_IF      shift and go to state 81
    KEYWORD_WHILE   shift and go to state 50
    KEYWORD_DO      shift and go to state 98
    KEYWORD_FOR     shift and go to state 97
    KEYWORD_OBJECT  shift and go to state 3
    BLOCKBEGIN      shift and go to state 15
    TERMINATOR      shift and go to state 53
    KEYWORD_RETURN  shift and go to state 68
    KEYWORD_PROTECTED shift and go to state 12
    KEYWORD_PRIVATE shift and go to state 9
    KEYWORD_DEF     reduce using rule 186 (empty -> .)
    KEYWORD_CLASS   reduce using rule 186 (empty -> .)
    KEYWORD_VAR     reduce using rule 186 (empty -> .)
    KEYWORD_VAL     reduce using rule 186 (empty -> .)
    IDENTIFIER      shift and go to state 77
    PLUS            shift and go to state 36
    MINUS           shift and go to state 29
    TILDA           shift and go to state 72
    NOT             shift and go to state 57
    LPAREN          shift and go to state 94
    DOUBLE_NUMBER   shift and go to state 33
    INT_NUMBER      shift and go to state 44
    CHAR            shift and go to state 63
    STRING          shift and go to state 76
    BOOL_CONSTT     shift and go to state 35
    BOOL_CONSTF     shift and go to state 30
    KEYWORD_NULL    shift and go to state 65

    expression_statement           shift and go to state 27
    unary_expression               shift and go to state 45
    method_header                  shift and go to state 83
    exclusive_or_expression        shift and go to state 61
    normal_statement               shift and go to state 86
    ObjectDeclare                  shift and go to state 1
    class_header_name1             shift and go to state 2
    unary_expression_not_plus_minus shift and go to state 46
    if_then_statement              shift and go to state 64
    array_access                   shift and go to state 28
    switch_statement               shift and go to state 47
    assignment_expression          shift and go to state 91
    qualified_name                 shift and go to state 79
    base_variable_set              shift and go to state 88
    valid_variable                 shift and go to state 48
    inclusive_or_expression        shift and go to state 32
    class_header_name              shift and go to state 5
    method_declaration             shift and go to state 69
    cast_expression                shift and go to state 80
    block_statement                shift and go to state 153
    shift_expression               shift and go to state 54
    return_statement               shift and go to state 89
    while_statement                shift and go to state 34
    and_expression                 shift and go to state 87
    statement                      shift and go to state 74
    literal                        shift and go to state 71
    statement_expression           shift and go to state 37
    method_invocation              shift and go to state 75
    simple_name                    shift and go to state 67
    conditional_or_expression      shift and go to state 49
    c_literal                      shift and go to state 93
    empty                          shift and go to state 6
    relational_expression          shift and go to state 73
    for_statement                  shift and go to state 38
    local_variable_declaration_statement shift and go to state 39
    do_while_statement             shift and go to state 51
    int_float                      shift and go to state 40
    assignment                     shift and go to state 92
    multiplicative_expression      shift and go to state 52
    primary                        shift and go to state 62
    additive_expression            shift and go to state 66
    SingletonObject                shift and go to state 41
    method_header_name             shift and go to state 42
    class_header                   shift and go to state 10
    modifier_opts                  shift and go to state 95
    equality_expression            shift and go to state 82
    variable_literal               shift and go to state 55
    name                           shift and go to state 43
    empty_statement                shift and go to state 84
    class_declaration              shift and go to state 96
    local_variable_declaration     shift and go to state 85
    modifier                       shift and go to state 14
    expression                     shift and go to state 58
    conditional_and_expression     shift and go to state 56
    block                          shift and go to state 59
    if_then_else_statement         shift and go to state 60

state 91

    (18) expression -> assignment_expression .

    COMMA           reduce using rule 18 (expression -> assignment_expression .)
    RPAREN          reduce using rule 18 (expression -> assignment_expression .)
    RBRAC           reduce using rule 18 (expression -> assignment_expression .)
    KEYWORD_MATCH   reduce using rule 18 (expression -> assignment_expression .)
    TERMINATOR      reduce using rule 18 (expression -> assignment_expression .)
    KEYWORD_BY      reduce using rule 18 (expression -> assignment_expression .)
    FUNTYPE         reduce using rule 18 (expression -> assignment_expression .)
    KEYWORD_UNTIL   reduce using rule 18 (expression -> assignment_expression .)
    KEYWORD_TO      reduce using rule 18 (expression -> assignment_expression .)


state 92

    (134) statement_expression -> assignment .
    (21) assignment_expression -> assignment .

    TERMINATOR      reduce using rule 134 (statement_expression -> assignment .)
    KEYWORD_MATCH   reduce using rule 21 (assignment_expression -> assignment .)


state 93

    (71) literal -> c_literal .

    TIMES           reduce using rule 71 (literal -> c_literal .)
    DIVIDE          reduce using rule 71 (literal -> c_literal .)
    REMAINDER       reduce using rule 71 (literal -> c_literal .)
    PLUS            reduce using rule 71 (literal -> c_literal .)
    MINUS           reduce using rule 71 (literal -> c_literal .)
    LSHIFT          reduce using rule 71 (literal -> c_literal .)
    RSHIFT          reduce using rule 71 (literal -> c_literal .)
    GREATER         reduce using rule 71 (literal -> c_literal .)
    LESS            reduce using rule 71 (literal -> c_literal .)
    GEQ             reduce using rule 71 (literal -> c_literal .)
    LEQ             reduce using rule 71 (literal -> c_literal .)
    EQUAL           reduce using rule 71 (literal -> c_literal .)
    NEQUAL          reduce using rule 71 (literal -> c_literal .)
    AND_BITWISE     reduce using rule 71 (literal -> c_literal .)
    XOR             reduce using rule 71 (literal -> c_literal .)
    OR_BITWISE      reduce using rule 71 (literal -> c_literal .)
    AND             reduce using rule 71 (literal -> c_literal .)
    OR              reduce using rule 71 (literal -> c_literal .)
    KEYWORD_MATCH   reduce using rule 71 (literal -> c_literal .)
    TERMINATOR      reduce using rule 71 (literal -> c_literal .)
    RPAREN          reduce using rule 71 (literal -> c_literal .)
    RBRAC           reduce using rule 71 (literal -> c_literal .)
    COMMA           reduce using rule 71 (literal -> c_literal .)
    FUNTYPE         reduce using rule 71 (literal -> c_literal .)
    KEYWORD_UNTIL   reduce using rule 71 (literal -> c_literal .)
    KEYWORD_TO      reduce using rule 71 (literal -> c_literal .)
    KEYWORD_BY      reduce using rule 71 (literal -> c_literal .)


state 94

    (64) base_variable_set -> LPAREN . expression RPAREN
    (67) cast_expression -> LPAREN . primitive_type RPAREN unary_expression
    (18) expression -> . assignment_expression
    (106) primitive_type -> . TYPE_INT
    (107) primitive_type -> . TYPE_DOUBLE
    (108) primitive_type -> . TYPE_CHAR
    (109) primitive_type -> . TYPE_STRING
    (110) primitive_type -> . TYPE_BOOLEAN
    (21) assignment_expression -> . assignment
    (22) assignment_expression -> . conditional_or_expression
    (23) assignment -> . valid_variable assignment_operator assignment_expression
    (28) conditional_or_expression -> . conditional_and_expression
    (29) conditional_or_expression -> . conditional_or_expression OR conditional_and_expression
    (24) valid_variable -> . name
    (25) valid_variable -> . array_access
    (30) conditional_and_expression -> . inclusive_or_expression
    (31) conditional_and_expression -> . conditional_and_expression AND inclusive_or_expression
    (115) name -> . simple_name
    (116) name -> . qualified_name
    (26) array_access -> . name LBRAC expression RBRAC
    (32) inclusive_or_expression -> . exclusive_or_expression
    (33) inclusive_or_expression -> . inclusive_or_expression OR_BITWISE exclusive_or_expression
    (117) simple_name -> . IDENTIFIER
    (118) qualified_name -> . name INST simple_name
    (34) exclusive_or_expression -> . and_expression
    (35) exclusive_or_expression -> . exclusive_or_expression XOR and_expression
    (36) and_expression -> . equality_expression
    (37) and_expression -> . and_expression AND_BITWISE equality_expression
    (38) equality_expression -> . relational_expression
    (39) equality_expression -> . equality_expression EQUAL relational_expression
    (40) equality_expression -> . equality_expression NEQUAL relational_expression
    (41) relational_expression -> . shift_expression
    (42) relational_expression -> . relational_expression GREATER shift_expression
    (43) relational_expression -> . relational_expression LESS shift_expression
    (44) relational_expression -> . relational_expression GEQ shift_expression
    (45) relational_expression -> . relational_expression LEQ shift_expression
    (46) shift_expression -> . additive_expression
    (47) shift_expression -> . shift_expression LSHIFT additive_expression
    (48) shift_expression -> . shift_expression RSHIFT additive_expression
    (49) additive_expression -> . multiplicative_expression
    (50) additive_expression -> . additive_expression PLUS multiplicative_expression
    (51) additive_expression -> . additive_expression MINUS multiplicative_expression
    (52) multiplicative_expression -> . unary_expression
    (53) multiplicative_expression -> . multiplicative_expression TIMES unary_expression
    (54) multiplicative_expression -> . multiplicative_expression DIVIDE unary_expression
    (55) multiplicative_expression -> . multiplicative_expression REMAINDER unary_expression
    (56) unary_expression -> . PLUS unary_expression
    (57) unary_expression -> . MINUS unary_expression
    (58) unary_expression -> . unary_expression_not_plus_minus
    (59) unary_expression_not_plus_minus -> . base_variable_set
    (60) unary_expression_not_plus_minus -> . TILDA unary_expression
    (61) unary_expression_not_plus_minus -> . NOT unary_expression
    (62) unary_expression_not_plus_minus -> . cast_expression
    (63) base_variable_set -> . variable_literal
    (64) base_variable_set -> . LPAREN expression RPAREN
    (67) cast_expression -> . LPAREN primitive_type RPAREN unary_expression
    (65) variable_literal -> . valid_variable
    (66) variable_literal -> . primary
    (68) primary -> . literal
    (69) primary -> . method_invocation
    (70) literal -> . int_float
    (71) literal -> . c_literal
    (79) method_invocation -> . name LPAREN argument_list_opt RPAREN
    (77) int_float -> . DOUBLE_NUMBER
    (78) int_float -> . INT_NUMBER
    (72) c_literal -> . CHAR
    (73) c_literal -> . STRING
    (74) c_literal -> . BOOL_CONSTT
    (75) c_literal -> . BOOL_CONSTF
    (76) c_literal -> . KEYWORD_NULL

    TYPE_INT        shift and go to state 154
    TYPE_DOUBLE     shift and go to state 159
    TYPE_CHAR       shift and go to state 156
    TYPE_STRING     shift and go to state 155
    TYPE_BOOLEAN    shift and go to state 158
    IDENTIFIER      shift and go to state 77
    PLUS            shift and go to state 36
    MINUS           shift and go to state 29
    TILDA           shift and go to state 72
    NOT             shift and go to state 57
    LPAREN          shift and go to state 94
    DOUBLE_NUMBER   shift and go to state 33
    INT_NUMBER      shift and go to state 44
    CHAR            shift and go to state 63
    STRING          shift and go to state 76
    BOOL_CONSTT     shift and go to state 35
    BOOL_CONSTF     shift and go to state 30
    KEYWORD_NULL    shift and go to state 65

    unary_expression               shift and go to state 45
    exclusive_or_expression        shift and go to state 61
    primary                        shift and go to state 62
    unary_expression_not_plus_minus shift and go to state 46
    array_access                   shift and go to state 28
    additive_expression            shift and go to state 66
    simple_name                    shift and go to state 67
    c_literal                      shift and go to state 93
    base_variable_set              shift and go to state 88
    valid_variable                 shift and go to state 48
    inclusive_or_expression        shift and go to state 32
    literal                        shift and go to state 71
    primitive_type                 shift and go to state 157
    and_expression                 shift and go to state 87
    relational_expression          shift and go to state 73
    cast_expression                shift and go to state 80
    conditional_or_expression      shift and go to state 49
    assignment_expression          shift and go to state 91
    qualified_name                 shift and go to state 79
    assignment                     shift and go to state 138
    multiplicative_expression      shift and go to state 52
    method_invocation              shift and go to state 111
    shift_expression               shift and go to state 54
    equality_expression            shift and go to state 82
    int_float                      shift and go to state 40
    variable_literal               shift and go to state 55
    name                           shift and go to state 139
    expression                     shift and go to state 160
    conditional_and_expression     shift and go to state 56

state 95

    (91) local_variable_declaration -> modifier_opts . declaration_keyword variable_declaration_body
    (182) method_header_name -> modifier_opts . KEYWORD_DEF IDENTIFIER
    (168) class_header_name1 -> modifier_opts . KEYWORD_CLASS name
    (88) declaration_keyword -> . KEYWORD_VAR
    (89) declaration_keyword -> . KEYWORD_VAL

    KEYWORD_DEF     shift and go to state 162
    KEYWORD_CLASS   shift and go to state 26
    KEYWORD_VAR     shift and go to state 100
    KEYWORD_VAL     shift and go to state 103

    declaration_keyword            shift and go to state 161

state 96

    (15) block_statement -> class_declaration .

    KEYWORD_IF      reduce using rule 15 (block_statement -> class_declaration .)
    KEYWORD_WHILE   reduce using rule 15 (block_statement -> class_declaration .)
    KEYWORD_DO      reduce using rule 15 (block_statement -> class_declaration .)
    KEYWORD_FOR     reduce using rule 15 (block_statement -> class_declaration .)
    KEYWORD_OBJECT  reduce using rule 15 (block_statement -> class_declaration .)
    BLOCKBEGIN      reduce using rule 15 (block_statement -> class_declaration .)
    TERMINATOR      reduce using rule 15 (block_statement -> class_declaration .)
    KEYWORD_RETURN  reduce using rule 15 (block_statement -> class_declaration .)
    KEYWORD_PROTECTED reduce using rule 15 (block_statement -> class_declaration .)
    KEYWORD_PRIVATE reduce using rule 15 (block_statement -> class_declaration .)
    IDENTIFIER      reduce using rule 15 (block_statement -> class_declaration .)
    PLUS            reduce using rule 15 (block_statement -> class_declaration .)
    MINUS           reduce using rule 15 (block_statement -> class_declaration .)
    TILDA           reduce using rule 15 (block_statement -> class_declaration .)
    NOT             reduce using rule 15 (block_statement -> class_declaration .)
    LPAREN          reduce using rule 15 (block_statement -> class_declaration .)
    DOUBLE_NUMBER   reduce using rule 15 (block_statement -> class_declaration .)
    INT_NUMBER      reduce using rule 15 (block_statement -> class_declaration .)
    CHAR            reduce using rule 15 (block_statement -> class_declaration .)
    STRING          reduce using rule 15 (block_statement -> class_declaration .)
    BOOL_CONSTT     reduce using rule 15 (block_statement -> class_declaration .)
    BOOL_CONSTF     reduce using rule 15 (block_statement -> class_declaration .)
    KEYWORD_NULL    reduce using rule 15 (block_statement -> class_declaration .)
    KEYWORD_DEF     reduce using rule 15 (block_statement -> class_declaration .)
    KEYWORD_CLASS   reduce using rule 15 (block_statement -> class_declaration .)
    KEYWORD_VAR     reduce using rule 15 (block_statement -> class_declaration .)
    KEYWORD_VAL     reduce using rule 15 (block_statement -> class_declaration .)
    BLOCKEND        reduce using rule 15 (block_statement -> class_declaration .)
    KEYWORD_CASE    reduce using rule 15 (block_statement -> class_declaration .)


state 97

    (143) for_statement -> KEYWORD_FOR . LPAREN for_logic RPAREN statement

    LPAREN          shift and go to state 163


state 98

    (142) do_while_statement -> KEYWORD_DO . statement KEYWORD_WHILE LPAREN expression RPAREN TERMINATOR
    (122) statement -> . normal_statement
    (123) statement -> . if_then_statement
    (124) statement -> . if_then_else_statement
    (125) statement -> . while_statement
    (126) statement -> . do_while_statement
    (127) statement -> . for_statement
    (128) normal_statement -> . block
    (129) normal_statement -> . expression_statement
    (130) normal_statement -> . empty_statement
    (131) normal_statement -> . return_statement
    (132) normal_statement -> . switch_statement
    (136) if_then_statement -> . KEYWORD_IF LPAREN expression RPAREN statement
    (137) if_then_else_statement -> . KEYWORD_IF LPAREN expression RPAREN if_then_else_intermediate KEYWORD_ELSE statement
    (141) while_statement -> . KEYWORD_WHILE LPAREN expression RPAREN statement
    (142) do_while_statement -> . KEYWORD_DO statement KEYWORD_WHILE LPAREN expression RPAREN TERMINATOR
    (143) for_statement -> . KEYWORD_FOR LPAREN for_logic RPAREN statement
    (8) block -> . BLOCKBEGIN block_statements_opt BLOCKEND
    (133) expression_statement -> . statement_expression TERMINATOR
    (163) empty_statement -> . TERMINATOR
    (164) return_statement -> . KEYWORD_RETURN expression_optional TERMINATOR
    (152) switch_statement -> . expression KEYWORD_MATCH switch_block
    (134) statement_expression -> . assignment
    (135) statement_expression -> . method_invocation
    (18) expression -> . assignment_expression
    (23) assignment -> . valid_variable assignment_operator assignment_expression
    (79) method_invocation -> . name LPAREN argument_list_opt RPAREN
    (21) assignment_expression -> . assignment
    (22) assignment_expression -> . conditional_or_expression
    (24) valid_variable -> . name
    (25) valid_variable -> . array_access
    (115) name -> . simple_name
    (116) name -> . qualified_name
    (28) conditional_or_expression -> . conditional_and_expression
    (29) conditional_or_expression -> . conditional_or_expression OR conditional_and_expression
    (26) array_access -> . name LBRAC expression RBRAC
    (117) simple_name -> . IDENTIFIER
    (118) qualified_name -> . name INST simple_name
    (30) conditional_and_expression -> . inclusive_or_expression
    (31) conditional_and_expression -> . conditional_and_expression AND inclusive_or_expression
    (32) inclusive_or_expression -> . exclusive_or_expression
    (33) inclusive_or_expression -> . inclusive_or_expression OR_BITWISE exclusive_or_expression
    (34) exclusive_or_expression -> . and_expression
    (35) exclusive_or_expression -> . exclusive_or_expression XOR and_expression
    (36) and_expression -> . equality_expression
    (37) and_expression -> . and_expression AND_BITWISE equality_expression
    (38) equality_expression -> . relational_expression
    (39) equality_expression -> . equality_expression EQUAL relational_expression
    (40) equality_expression -> . equality_expression NEQUAL relational_expression
    (41) relational_expression -> . shift_expression
    (42) relational_expression -> . relational_expression GREATER shift_expression
    (43) relational_expression -> . relational_expression LESS shift_expression
    (44) relational_expression -> . relational_expression GEQ shift_expression
    (45) relational_expression -> . relational_expression LEQ shift_expression
    (46) shift_expression -> . additive_expression
    (47) shift_expression -> . shift_expression LSHIFT additive_expression
    (48) shift_expression -> . shift_expression RSHIFT additive_expression
    (49) additive_expression -> . multiplicative_expression
    (50) additive_expression -> . additive_expression PLUS multiplicative_expression
    (51) additive_expression -> . additive_expression MINUS multiplicative_expression
    (52) multiplicative_expression -> . unary_expression
    (53) multiplicative_expression -> . multiplicative_expression TIMES unary_expression
    (54) multiplicative_expression -> . multiplicative_expression DIVIDE unary_expression
    (55) multiplicative_expression -> . multiplicative_expression REMAINDER unary_expression
    (56) unary_expression -> . PLUS unary_expression
    (57) unary_expression -> . MINUS unary_expression
    (58) unary_expression -> . unary_expression_not_plus_minus
    (59) unary_expression_not_plus_minus -> . base_variable_set
    (60) unary_expression_not_plus_minus -> . TILDA unary_expression
    (61) unary_expression_not_plus_minus -> . NOT unary_expression
    (62) unary_expression_not_plus_minus -> . cast_expression
    (63) base_variable_set -> . variable_literal
    (64) base_variable_set -> . LPAREN expression RPAREN
    (67) cast_expression -> . LPAREN primitive_type RPAREN unary_expression
    (65) variable_literal -> . valid_variable
    (66) variable_literal -> . primary
    (68) primary -> . literal
    (69) primary -> . method_invocation
    (70) literal -> . int_float
    (71) literal -> . c_literal
    (77) int_float -> . DOUBLE_NUMBER
    (78) int_float -> . INT_NUMBER
    (72) c_literal -> . CHAR
    (73) c_literal -> . STRING
    (74) c_literal -> . BOOL_CONSTT
    (75) c_literal -> . BOOL_CONSTF
    (76) c_literal -> . KEYWORD_NULL

    KEYWORD_IF      shift and go to state 81
    KEYWORD_WHILE   shift and go to state 50
    KEYWORD_DO      shift and go to state 98
    KEYWORD_FOR     shift and go to state 97
    BLOCKBEGIN      shift and go to state 15
    TERMINATOR      shift and go to state 53
    KEYWORD_RETURN  shift and go to state 68
    IDENTIFIER      shift and go to state 77
    PLUS            shift and go to state 36
    MINUS           shift and go to state 29
    TILDA           shift and go to state 72
    NOT             shift and go to state 57
    LPAREN          shift and go to state 94
    DOUBLE_NUMBER   shift and go to state 33
    INT_NUMBER      shift and go to state 44
    CHAR            shift and go to state 63
    STRING          shift and go to state 76
    BOOL_CONSTT     shift and go to state 35
    BOOL_CONSTF     shift and go to state 30
    KEYWORD_NULL    shift and go to state 65

    expression_statement           shift and go to state 27
    unary_expression               shift and go to state 45
    exclusive_or_expression        shift and go to state 61
    normal_statement               shift and go to state 86
    primary                        shift and go to state 62
    unary_expression_not_plus_minus shift and go to state 46
    if_then_statement              shift and go to state 64
    array_access                   shift and go to state 28
    switch_statement               shift and go to state 47
    assignment_expression          shift and go to state 91
    qualified_name                 shift and go to state 79
    base_variable_set              shift and go to state 88
    valid_variable                 shift and go to state 48
    inclusive_or_expression        shift and go to state 32
    literal                        shift and go to state 71
    return_statement               shift and go to state 89
    while_statement                shift and go to state 34
    and_expression                 shift and go to state 87
    statement                      shift and go to state 164
    statement_expression           shift and go to state 37
    method_invocation              shift and go to state 75
    simple_name                    shift and go to state 67
    conditional_or_expression      shift and go to state 49
    relational_expression          shift and go to state 73
    for_statement                  shift and go to state 38
    do_while_statement             shift and go to state 51
    assignment                     shift and go to state 92
    multiplicative_expression      shift and go to state 52
    c_literal                      shift and go to state 93
    additive_expression            shift and go to state 66
    cast_expression                shift and go to state 80
    shift_expression               shift and go to state 54
    equality_expression            shift and go to state 82
    int_float                      shift and go to state 40
    variable_literal               shift and go to state 55
    name                           shift and go to state 43
    empty_statement                shift and go to state 84
    expression                     shift and go to state 58
    conditional_and_expression     shift and go to state 56
    block                          shift and go to state 59
    if_then_else_statement         shift and go to state 60

state 99

    (167) class_header_name -> class_header_name1 LPAREN constructor_arguement_list_opt . RPAREN

    RPAREN          shift and go to state 165


state 100

    (88) declaration_keyword -> KEYWORD_VAR .

    IDENTIFIER      reduce using rule 88 (declaration_keyword -> KEYWORD_VAR .)
    LPAREN          reduce using rule 88 (declaration_keyword -> KEYWORD_VAR .)


state 101

    (176) constructor_arguement_list_declarator -> declaration_keyword . IDENTIFIER COLON type

    IDENTIFIER      shift and go to state 166


state 102

    (172) constructor_arguement_list_opt -> constructor_arguement_list .
    (175) constructor_arguement_list -> constructor_arguement_list . COMMA constructor_arguement_list_declarator

    RPAREN          reduce using rule 172 (constructor_arguement_list_opt -> constructor_arguement_list .)
    COMMA           shift and go to state 167


state 103

    (89) declaration_keyword -> KEYWORD_VAL .

    IDENTIFIER      reduce using rule 89 (declaration_keyword -> KEYWORD_VAL .)
    LPAREN          reduce using rule 89 (declaration_keyword -> KEYWORD_VAL .)


state 104

    (174) constructor_arguement_list -> constructor_arguement_list_declarator .

    COMMA           reduce using rule 174 (constructor_arguement_list -> constructor_arguement_list_declarator .)
    RPAREN          reduce using rule 174 (constructor_arguement_list -> constructor_arguement_list_declarator .)


state 105

    (173) constructor_arguement_list_opt -> empty .

    RPAREN          reduce using rule 173 (constructor_arguement_list_opt -> empty .)


state 106

    (7) ObjectDeclare -> KEYWORD_OBJECT IDENTIFIER KEYWORD_EXTENDS . IDENTIFIER

    IDENTIFIER      shift and go to state 168


state 107

    (171) class_header_extends -> KEYWORD_EXTENDS name . LPAREN func_arguement_list_opt RPAREN
    (118) qualified_name -> name . INST simple_name

    LPAREN          shift and go to state 169
    INST            shift and go to state 119


state 108

    (168) class_header_name1 -> modifier_opts KEYWORD_CLASS name .
    (118) qualified_name -> name . INST simple_name

    LPAREN          reduce using rule 168 (class_header_name1 -> modifier_opts KEYWORD_CLASS name .)
    INST            shift and go to state 119


state 109

    (57) unary_expression -> MINUS unary_expression .

    TIMES           reduce using rule 57 (unary_expression -> MINUS unary_expression .)
    DIVIDE          reduce using rule 57 (unary_expression -> MINUS unary_expression .)
    REMAINDER       reduce using rule 57 (unary_expression -> MINUS unary_expression .)
    PLUS            reduce using rule 57 (unary_expression -> MINUS unary_expression .)
    MINUS           reduce using rule 57 (unary_expression -> MINUS unary_expression .)
    LSHIFT          reduce using rule 57 (unary_expression -> MINUS unary_expression .)
    RSHIFT          reduce using rule 57 (unary_expression -> MINUS unary_expression .)
    GREATER         reduce using rule 57 (unary_expression -> MINUS unary_expression .)
    LESS            reduce using rule 57 (unary_expression -> MINUS unary_expression .)
    GEQ             reduce using rule 57 (unary_expression -> MINUS unary_expression .)
    LEQ             reduce using rule 57 (unary_expression -> MINUS unary_expression .)
    EQUAL           reduce using rule 57 (unary_expression -> MINUS unary_expression .)
    NEQUAL          reduce using rule 57 (unary_expression -> MINUS unary_expression .)
    AND_BITWISE     reduce using rule 57 (unary_expression -> MINUS unary_expression .)
    XOR             reduce using rule 57 (unary_expression -> MINUS unary_expression .)
    OR_BITWISE      reduce using rule 57 (unary_expression -> MINUS unary_expression .)
    AND             reduce using rule 57 (unary_expression -> MINUS unary_expression .)
    OR              reduce using rule 57 (unary_expression -> MINUS unary_expression .)
    FUNTYPE         reduce using rule 57 (unary_expression -> MINUS unary_expression .)
    KEYWORD_MATCH   reduce using rule 57 (unary_expression -> MINUS unary_expression .)
    TERMINATOR      reduce using rule 57 (unary_expression -> MINUS unary_expression .)
    RPAREN          reduce using rule 57 (unary_expression -> MINUS unary_expression .)
    RBRAC           reduce using rule 57 (unary_expression -> MINUS unary_expression .)
    COMMA           reduce using rule 57 (unary_expression -> MINUS unary_expression .)
    KEYWORD_UNTIL   reduce using rule 57 (unary_expression -> MINUS unary_expression .)
    KEYWORD_TO      reduce using rule 57 (unary_expression -> MINUS unary_expression .)
    KEYWORD_BY      reduce using rule 57 (unary_expression -> MINUS unary_expression .)


state 110

    (65) variable_literal -> valid_variable .

    TIMES           reduce using rule 65 (variable_literal -> valid_variable .)
    DIVIDE          reduce using rule 65 (variable_literal -> valid_variable .)
    REMAINDER       reduce using rule 65 (variable_literal -> valid_variable .)
    PLUS            reduce using rule 65 (variable_literal -> valid_variable .)
    MINUS           reduce using rule 65 (variable_literal -> valid_variable .)
    LSHIFT          reduce using rule 65 (variable_literal -> valid_variable .)
    RSHIFT          reduce using rule 65 (variable_literal -> valid_variable .)
    GREATER         reduce using rule 65 (variable_literal -> valid_variable .)
    LESS            reduce using rule 65 (variable_literal -> valid_variable .)
    GEQ             reduce using rule 65 (variable_literal -> valid_variable .)
    LEQ             reduce using rule 65 (variable_literal -> valid_variable .)
    EQUAL           reduce using rule 65 (variable_literal -> valid_variable .)
    NEQUAL          reduce using rule 65 (variable_literal -> valid_variable .)
    AND_BITWISE     reduce using rule 65 (variable_literal -> valid_variable .)
    XOR             reduce using rule 65 (variable_literal -> valid_variable .)
    OR_BITWISE      reduce using rule 65 (variable_literal -> valid_variable .)
    AND             reduce using rule 65 (variable_literal -> valid_variable .)
    OR              reduce using rule 65 (variable_literal -> valid_variable .)
    KEYWORD_MATCH   reduce using rule 65 (variable_literal -> valid_variable .)
    TERMINATOR      reduce using rule 65 (variable_literal -> valid_variable .)
    RPAREN          reduce using rule 65 (variable_literal -> valid_variable .)
    RBRAC           reduce using rule 65 (variable_literal -> valid_variable .)
    COMMA           reduce using rule 65 (variable_literal -> valid_variable .)
    FUNTYPE         reduce using rule 65 (variable_literal -> valid_variable .)
    KEYWORD_UNTIL   reduce using rule 65 (variable_literal -> valid_variable .)
    KEYWORD_TO      reduce using rule 65 (variable_literal -> valid_variable .)
    KEYWORD_BY      reduce using rule 65 (variable_literal -> valid_variable .)


state 111

    (69) primary -> method_invocation .

    TIMES           reduce using rule 69 (primary -> method_invocation .)
    DIVIDE          reduce using rule 69 (primary -> method_invocation .)
    REMAINDER       reduce using rule 69 (primary -> method_invocation .)
    PLUS            reduce using rule 69 (primary -> method_invocation .)
    MINUS           reduce using rule 69 (primary -> method_invocation .)
    LSHIFT          reduce using rule 69 (primary -> method_invocation .)
    RSHIFT          reduce using rule 69 (primary -> method_invocation .)
    GREATER         reduce using rule 69 (primary -> method_invocation .)
    LESS            reduce using rule 69 (primary -> method_invocation .)
    GEQ             reduce using rule 69 (primary -> method_invocation .)
    LEQ             reduce using rule 69 (primary -> method_invocation .)
    EQUAL           reduce using rule 69 (primary -> method_invocation .)
    NEQUAL          reduce using rule 69 (primary -> method_invocation .)
    AND_BITWISE     reduce using rule 69 (primary -> method_invocation .)
    XOR             reduce using rule 69 (primary -> method_invocation .)
    OR_BITWISE      reduce using rule 69 (primary -> method_invocation .)
    AND             reduce using rule 69 (primary -> method_invocation .)
    OR              reduce using rule 69 (primary -> method_invocation .)
    KEYWORD_MATCH   reduce using rule 69 (primary -> method_invocation .)
    TERMINATOR      reduce using rule 69 (primary -> method_invocation .)
    RPAREN          reduce using rule 69 (primary -> method_invocation .)
    RBRAC           reduce using rule 69 (primary -> method_invocation .)
    COMMA           reduce using rule 69 (primary -> method_invocation .)
    FUNTYPE         reduce using rule 69 (primary -> method_invocation .)
    KEYWORD_UNTIL   reduce using rule 69 (primary -> method_invocation .)
    KEYWORD_TO      reduce using rule 69 (primary -> method_invocation .)
    KEYWORD_BY      reduce using rule 69 (primary -> method_invocation .)


state 112

    (24) valid_variable -> name .
    (26) array_access -> name . LBRAC expression RBRAC
    (79) method_invocation -> name . LPAREN argument_list_opt RPAREN
    (118) qualified_name -> name . INST simple_name

    TIMES           reduce using rule 24 (valid_variable -> name .)
    DIVIDE          reduce using rule 24 (valid_variable -> name .)
    REMAINDER       reduce using rule 24 (valid_variable -> name .)
    PLUS            reduce using rule 24 (valid_variable -> name .)
    MINUS           reduce using rule 24 (valid_variable -> name .)
    LSHIFT          reduce using rule 24 (valid_variable -> name .)
    RSHIFT          reduce using rule 24 (valid_variable -> name .)
    GREATER         reduce using rule 24 (valid_variable -> name .)
    LESS            reduce using rule 24 (valid_variable -> name .)
    GEQ             reduce using rule 24 (valid_variable -> name .)
    LEQ             reduce using rule 24 (valid_variable -> name .)
    EQUAL           reduce using rule 24 (valid_variable -> name .)
    NEQUAL          reduce using rule 24 (valid_variable -> name .)
    AND_BITWISE     reduce using rule 24 (valid_variable -> name .)
    XOR             reduce using rule 24 (valid_variable -> name .)
    OR_BITWISE      reduce using rule 24 (valid_variable -> name .)
    AND             reduce using rule 24 (valid_variable -> name .)
    OR              reduce using rule 24 (valid_variable -> name .)
    KEYWORD_MATCH   reduce using rule 24 (valid_variable -> name .)
    TERMINATOR      reduce using rule 24 (valid_variable -> name .)
    RPAREN          reduce using rule 24 (valid_variable -> name .)
    RBRAC           reduce using rule 24 (valid_variable -> name .)
    COMMA           reduce using rule 24 (valid_variable -> name .)
    FUNTYPE         reduce using rule 24 (valid_variable -> name .)
    KEYWORD_UNTIL   reduce using rule 24 (valid_variable -> name .)
    KEYWORD_TO      reduce using rule 24 (valid_variable -> name .)
    KEYWORD_BY      reduce using rule 24 (valid_variable -> name .)
    LBRAC           shift and go to state 118
    LPAREN          shift and go to state 120
    INST            shift and go to state 119


state 113

    (8) block -> BLOCKBEGIN block_statements_opt BLOCKEND .

    KEYWORD_IF      reduce using rule 8 (block -> BLOCKBEGIN block_statements_opt BLOCKEND .)
    KEYWORD_WHILE   reduce using rule 8 (block -> BLOCKBEGIN block_statements_opt BLOCKEND .)
    KEYWORD_DO      reduce using rule 8 (block -> BLOCKBEGIN block_statements_opt BLOCKEND .)
    KEYWORD_FOR     reduce using rule 8 (block -> BLOCKBEGIN block_statements_opt BLOCKEND .)
    KEYWORD_OBJECT  reduce using rule 8 (block -> BLOCKBEGIN block_statements_opt BLOCKEND .)
    BLOCKBEGIN      reduce using rule 8 (block -> BLOCKBEGIN block_statements_opt BLOCKEND .)
    TERMINATOR      reduce using rule 8 (block -> BLOCKBEGIN block_statements_opt BLOCKEND .)
    KEYWORD_RETURN  reduce using rule 8 (block -> BLOCKBEGIN block_statements_opt BLOCKEND .)
    KEYWORD_PROTECTED reduce using rule 8 (block -> BLOCKBEGIN block_statements_opt BLOCKEND .)
    KEYWORD_PRIVATE reduce using rule 8 (block -> BLOCKBEGIN block_statements_opt BLOCKEND .)
    IDENTIFIER      reduce using rule 8 (block -> BLOCKBEGIN block_statements_opt BLOCKEND .)
    PLUS            reduce using rule 8 (block -> BLOCKBEGIN block_statements_opt BLOCKEND .)
    MINUS           reduce using rule 8 (block -> BLOCKBEGIN block_statements_opt BLOCKEND .)
    TILDA           reduce using rule 8 (block -> BLOCKBEGIN block_statements_opt BLOCKEND .)
    NOT             reduce using rule 8 (block -> BLOCKBEGIN block_statements_opt BLOCKEND .)
    LPAREN          reduce using rule 8 (block -> BLOCKBEGIN block_statements_opt BLOCKEND .)
    DOUBLE_NUMBER   reduce using rule 8 (block -> BLOCKBEGIN block_statements_opt BLOCKEND .)
    INT_NUMBER      reduce using rule 8 (block -> BLOCKBEGIN block_statements_opt BLOCKEND .)
    CHAR            reduce using rule 8 (block -> BLOCKBEGIN block_statements_opt BLOCKEND .)
    STRING          reduce using rule 8 (block -> BLOCKBEGIN block_statements_opt BLOCKEND .)
    BOOL_CONSTT     reduce using rule 8 (block -> BLOCKBEGIN block_statements_opt BLOCKEND .)
    BOOL_CONSTF     reduce using rule 8 (block -> BLOCKBEGIN block_statements_opt BLOCKEND .)
    KEYWORD_NULL    reduce using rule 8 (block -> BLOCKBEGIN block_statements_opt BLOCKEND .)
    KEYWORD_DEF     reduce using rule 8 (block -> BLOCKBEGIN block_statements_opt BLOCKEND .)
    KEYWORD_CLASS   reduce using rule 8 (block -> BLOCKBEGIN block_statements_opt BLOCKEND .)
    KEYWORD_VAR     reduce using rule 8 (block -> BLOCKBEGIN block_statements_opt BLOCKEND .)
    KEYWORD_VAL     reduce using rule 8 (block -> BLOCKBEGIN block_statements_opt BLOCKEND .)
    BLOCKEND        reduce using rule 8 (block -> BLOCKBEGIN block_statements_opt BLOCKEND .)
    KEYWORD_CASE    reduce using rule 8 (block -> BLOCKBEGIN block_statements_opt BLOCKEND .)
    KEYWORD_ELSE    reduce using rule 8 (block -> BLOCKBEGIN block_statements_opt BLOCKEND .)
    $end            reduce using rule 8 (block -> BLOCKBEGIN block_statements_opt BLOCKEND .)


state 114

    (33) inclusive_or_expression -> inclusive_or_expression OR_BITWISE . exclusive_or_expression
    (34) exclusive_or_expression -> . and_expression
    (35) exclusive_or_expression -> . exclusive_or_expression XOR and_expression
    (36) and_expression -> . equality_expression
    (37) and_expression -> . and_expression AND_BITWISE equality_expression
    (38) equality_expression -> . relational_expression
    (39) equality_expression -> . equality_expression EQUAL relational_expression
    (40) equality_expression -> . equality_expression NEQUAL relational_expression
    (41) relational_expression -> . shift_expression
    (42) relational_expression -> . relational_expression GREATER shift_expression
    (43) relational_expression -> . relational_expression LESS shift_expression
    (44) relational_expression -> . relational_expression GEQ shift_expression
    (45) relational_expression -> . relational_expression LEQ shift_expression
    (46) shift_expression -> . additive_expression
    (47) shift_expression -> . shift_expression LSHIFT additive_expression
    (48) shift_expression -> . shift_expression RSHIFT additive_expression
    (49) additive_expression -> . multiplicative_expression
    (50) additive_expression -> . additive_expression PLUS multiplicative_expression
    (51) additive_expression -> . additive_expression MINUS multiplicative_expression
    (52) multiplicative_expression -> . unary_expression
    (53) multiplicative_expression -> . multiplicative_expression TIMES unary_expression
    (54) multiplicative_expression -> . multiplicative_expression DIVIDE unary_expression
    (55) multiplicative_expression -> . multiplicative_expression REMAINDER unary_expression
    (56) unary_expression -> . PLUS unary_expression
    (57) unary_expression -> . MINUS unary_expression
    (58) unary_expression -> . unary_expression_not_plus_minus
    (59) unary_expression_not_plus_minus -> . base_variable_set
    (60) unary_expression_not_plus_minus -> . TILDA unary_expression
    (61) unary_expression_not_plus_minus -> . NOT unary_expression
    (62) unary_expression_not_plus_minus -> . cast_expression
    (63) base_variable_set -> . variable_literal
    (64) base_variable_set -> . LPAREN expression RPAREN
    (67) cast_expression -> . LPAREN primitive_type RPAREN unary_expression
    (65) variable_literal -> . valid_variable
    (66) variable_literal -> . primary
    (24) valid_variable -> . name
    (25) valid_variable -> . array_access
    (68) primary -> . literal
    (69) primary -> . method_invocation
    (115) name -> . simple_name
    (116) name -> . qualified_name
    (26) array_access -> . name LBRAC expression RBRAC
    (70) literal -> . int_float
    (71) literal -> . c_literal
    (79) method_invocation -> . name LPAREN argument_list_opt RPAREN
    (117) simple_name -> . IDENTIFIER
    (118) qualified_name -> . name INST simple_name
    (77) int_float -> . DOUBLE_NUMBER
    (78) int_float -> . INT_NUMBER
    (72) c_literal -> . CHAR
    (73) c_literal -> . STRING
    (74) c_literal -> . BOOL_CONSTT
    (75) c_literal -> . BOOL_CONSTF
    (76) c_literal -> . KEYWORD_NULL

    PLUS            shift and go to state 36
    MINUS           shift and go to state 29
    TILDA           shift and go to state 72
    NOT             shift and go to state 57
    LPAREN          shift and go to state 94
    IDENTIFIER      shift and go to state 77
    DOUBLE_NUMBER   shift and go to state 33
    INT_NUMBER      shift and go to state 44
    CHAR            shift and go to state 63
    STRING          shift and go to state 76
    BOOL_CONSTT     shift and go to state 35
    BOOL_CONSTF     shift and go to state 30
    KEYWORD_NULL    shift and go to state 65

    unary_expression               shift and go to state 45
    exclusive_or_expression        shift and go to state 170
    primary                        shift and go to state 62
    unary_expression_not_plus_minus shift and go to state 46
    array_access                   shift and go to state 28
    additive_expression            shift and go to state 66
    simple_name                    shift and go to state 67
    c_literal                      shift and go to state 93
    base_variable_set              shift and go to state 88
    valid_variable                 shift and go to state 110
    literal                        shift and go to state 71
    and_expression                 shift and go to state 87
    method_invocation              shift and go to state 111
    relational_expression          shift and go to state 73
    qualified_name                 shift and go to state 79
    multiplicative_expression      shift and go to state 52
    cast_expression                shift and go to state 80
    shift_expression               shift and go to state 54
    equality_expression            shift and go to state 82
    int_float                      shift and go to state 40
    variable_literal               shift and go to state 55
    name                           shift and go to state 112

state 115

    (56) unary_expression -> PLUS unary_expression .

    TIMES           reduce using rule 56 (unary_expression -> PLUS unary_expression .)
    DIVIDE          reduce using rule 56 (unary_expression -> PLUS unary_expression .)
    REMAINDER       reduce using rule 56 (unary_expression -> PLUS unary_expression .)
    PLUS            reduce using rule 56 (unary_expression -> PLUS unary_expression .)
    MINUS           reduce using rule 56 (unary_expression -> PLUS unary_expression .)
    LSHIFT          reduce using rule 56 (unary_expression -> PLUS unary_expression .)
    RSHIFT          reduce using rule 56 (unary_expression -> PLUS unary_expression .)
    GREATER         reduce using rule 56 (unary_expression -> PLUS unary_expression .)
    LESS            reduce using rule 56 (unary_expression -> PLUS unary_expression .)
    GEQ             reduce using rule 56 (unary_expression -> PLUS unary_expression .)
    LEQ             reduce using rule 56 (unary_expression -> PLUS unary_expression .)
    EQUAL           reduce using rule 56 (unary_expression -> PLUS unary_expression .)
    NEQUAL          reduce using rule 56 (unary_expression -> PLUS unary_expression .)
    AND_BITWISE     reduce using rule 56 (unary_expression -> PLUS unary_expression .)
    XOR             reduce using rule 56 (unary_expression -> PLUS unary_expression .)
    OR_BITWISE      reduce using rule 56 (unary_expression -> PLUS unary_expression .)
    AND             reduce using rule 56 (unary_expression -> PLUS unary_expression .)
    OR              reduce using rule 56 (unary_expression -> PLUS unary_expression .)
    FUNTYPE         reduce using rule 56 (unary_expression -> PLUS unary_expression .)
    KEYWORD_MATCH   reduce using rule 56 (unary_expression -> PLUS unary_expression .)
    TERMINATOR      reduce using rule 56 (unary_expression -> PLUS unary_expression .)
    RPAREN          reduce using rule 56 (unary_expression -> PLUS unary_expression .)
    RBRAC           reduce using rule 56 (unary_expression -> PLUS unary_expression .)
    COMMA           reduce using rule 56 (unary_expression -> PLUS unary_expression .)
    KEYWORD_UNTIL   reduce using rule 56 (unary_expression -> PLUS unary_expression .)
    KEYWORD_TO      reduce using rule 56 (unary_expression -> PLUS unary_expression .)
    KEYWORD_BY      reduce using rule 56 (unary_expression -> PLUS unary_expression .)


state 116

    (133) expression_statement -> statement_expression TERMINATOR .

    KEYWORD_IF      reduce using rule 133 (expression_statement -> statement_expression TERMINATOR .)
    KEYWORD_WHILE   reduce using rule 133 (expression_statement -> statement_expression TERMINATOR .)
    KEYWORD_DO      reduce using rule 133 (expression_statement -> statement_expression TERMINATOR .)
    KEYWORD_FOR     reduce using rule 133 (expression_statement -> statement_expression TERMINATOR .)
    KEYWORD_OBJECT  reduce using rule 133 (expression_statement -> statement_expression TERMINATOR .)
    BLOCKBEGIN      reduce using rule 133 (expression_statement -> statement_expression TERMINATOR .)
    TERMINATOR      reduce using rule 133 (expression_statement -> statement_expression TERMINATOR .)
    KEYWORD_RETURN  reduce using rule 133 (expression_statement -> statement_expression TERMINATOR .)
    KEYWORD_PROTECTED reduce using rule 133 (expression_statement -> statement_expression TERMINATOR .)
    KEYWORD_PRIVATE reduce using rule 133 (expression_statement -> statement_expression TERMINATOR .)
    IDENTIFIER      reduce using rule 133 (expression_statement -> statement_expression TERMINATOR .)
    PLUS            reduce using rule 133 (expression_statement -> statement_expression TERMINATOR .)
    MINUS           reduce using rule 133 (expression_statement -> statement_expression TERMINATOR .)
    TILDA           reduce using rule 133 (expression_statement -> statement_expression TERMINATOR .)
    NOT             reduce using rule 133 (expression_statement -> statement_expression TERMINATOR .)
    LPAREN          reduce using rule 133 (expression_statement -> statement_expression TERMINATOR .)
    DOUBLE_NUMBER   reduce using rule 133 (expression_statement -> statement_expression TERMINATOR .)
    INT_NUMBER      reduce using rule 133 (expression_statement -> statement_expression TERMINATOR .)
    CHAR            reduce using rule 133 (expression_statement -> statement_expression TERMINATOR .)
    STRING          reduce using rule 133 (expression_statement -> statement_expression TERMINATOR .)
    BOOL_CONSTT     reduce using rule 133 (expression_statement -> statement_expression TERMINATOR .)
    BOOL_CONSTF     reduce using rule 133 (expression_statement -> statement_expression TERMINATOR .)
    KEYWORD_NULL    reduce using rule 133 (expression_statement -> statement_expression TERMINATOR .)
    KEYWORD_DEF     reduce using rule 133 (expression_statement -> statement_expression TERMINATOR .)
    KEYWORD_CLASS   reduce using rule 133 (expression_statement -> statement_expression TERMINATOR .)
    KEYWORD_VAR     reduce using rule 133 (expression_statement -> statement_expression TERMINATOR .)
    KEYWORD_VAL     reduce using rule 133 (expression_statement -> statement_expression TERMINATOR .)
    BLOCKEND        reduce using rule 133 (expression_statement -> statement_expression TERMINATOR .)
    KEYWORD_CASE    reduce using rule 133 (expression_statement -> statement_expression TERMINATOR .)
    KEYWORD_ELSE    reduce using rule 133 (expression_statement -> statement_expression TERMINATOR .)


state 117

    (179) method_header -> method_header_name LPAREN . func_arguement_list_opt RPAREN COLON method_return_type ASOP
    (183) func_arguement_list_opt -> . variable_declarators
    (184) func_arguement_list_opt -> . empty
    (100) variable_declarators -> . variable_declarator
    (101) variable_declarators -> . variable_declarators COMMA variable_declarator
    (186) empty -> .
    (102) variable_declarator -> . variable_declarator_id
    (103) variable_declarator_id -> . IDENTIFIER COLON type

    RPAREN          reduce using rule 186 (empty -> .)
    IDENTIFIER      shift and go to state 175

    func_arguement_list_opt        shift and go to state 171
    variable_declarators           shift and go to state 173
    variable_declarator            shift and go to state 174
    variable_declarator_id         shift and go to state 172
    empty                          shift and go to state 176

state 118

    (26) array_access -> name LBRAC . expression RBRAC
    (18) expression -> . assignment_expression
    (21) assignment_expression -> . assignment
    (22) assignment_expression -> . conditional_or_expression
    (23) assignment -> . valid_variable assignment_operator assignment_expression
    (28) conditional_or_expression -> . conditional_and_expression
    (29) conditional_or_expression -> . conditional_or_expression OR conditional_and_expression
    (24) valid_variable -> . name
    (25) valid_variable -> . array_access
    (30) conditional_and_expression -> . inclusive_or_expression
    (31) conditional_and_expression -> . conditional_and_expression AND inclusive_or_expression
    (115) name -> . simple_name
    (116) name -> . qualified_name
    (26) array_access -> . name LBRAC expression RBRAC
    (32) inclusive_or_expression -> . exclusive_or_expression
    (33) inclusive_or_expression -> . inclusive_or_expression OR_BITWISE exclusive_or_expression
    (117) simple_name -> . IDENTIFIER
    (118) qualified_name -> . name INST simple_name
    (34) exclusive_or_expression -> . and_expression
    (35) exclusive_or_expression -> . exclusive_or_expression XOR and_expression
    (36) and_expression -> . equality_expression
    (37) and_expression -> . and_expression AND_BITWISE equality_expression
    (38) equality_expression -> . relational_expression
    (39) equality_expression -> . equality_expression EQUAL relational_expression
    (40) equality_expression -> . equality_expression NEQUAL relational_expression
    (41) relational_expression -> . shift_expression
    (42) relational_expression -> . relational_expression GREATER shift_expression
    (43) relational_expression -> . relational_expression LESS shift_expression
    (44) relational_expression -> . relational_expression GEQ shift_expression
    (45) relational_expression -> . relational_expression LEQ shift_expression
    (46) shift_expression -> . additive_expression
    (47) shift_expression -> . shift_expression LSHIFT additive_expression
    (48) shift_expression -> . shift_expression RSHIFT additive_expression
    (49) additive_expression -> . multiplicative_expression
    (50) additive_expression -> . additive_expression PLUS multiplicative_expression
    (51) additive_expression -> . additive_expression MINUS multiplicative_expression
    (52) multiplicative_expression -> . unary_expression
    (53) multiplicative_expression -> . multiplicative_expression TIMES unary_expression
    (54) multiplicative_expression -> . multiplicative_expression DIVIDE unary_expression
    (55) multiplicative_expression -> . multiplicative_expression REMAINDER unary_expression
    (56) unary_expression -> . PLUS unary_expression
    (57) unary_expression -> . MINUS unary_expression
    (58) unary_expression -> . unary_expression_not_plus_minus
    (59) unary_expression_not_plus_minus -> . base_variable_set
    (60) unary_expression_not_plus_minus -> . TILDA unary_expression
    (61) unary_expression_not_plus_minus -> . NOT unary_expression
    (62) unary_expression_not_plus_minus -> . cast_expression
    (63) base_variable_set -> . variable_literal
    (64) base_variable_set -> . LPAREN expression RPAREN
    (67) cast_expression -> . LPAREN primitive_type RPAREN unary_expression
    (65) variable_literal -> . valid_variable
    (66) variable_literal -> . primary
    (68) primary -> . literal
    (69) primary -> . method_invocation
    (70) literal -> . int_float
    (71) literal -> . c_literal
    (79) method_invocation -> . name LPAREN argument_list_opt RPAREN
    (77) int_float -> . DOUBLE_NUMBER
    (78) int_float -> . INT_NUMBER
    (72) c_literal -> . CHAR
    (73) c_literal -> . STRING
    (74) c_literal -> . BOOL_CONSTT
    (75) c_literal -> . BOOL_CONSTF
    (76) c_literal -> . KEYWORD_NULL

    IDENTIFIER      shift and go to state 77
    PLUS            shift and go to state 36
    MINUS           shift and go to state 29
    TILDA           shift and go to state 72
    NOT             shift and go to state 57
    LPAREN          shift and go to state 94
    DOUBLE_NUMBER   shift and go to state 33
    INT_NUMBER      shift and go to state 44
    CHAR            shift and go to state 63
    STRING          shift and go to state 76
    BOOL_CONSTT     shift and go to state 35
    BOOL_CONSTF     shift and go to state 30
    KEYWORD_NULL    shift and go to state 65

    unary_expression               shift and go to state 45
    exclusive_or_expression        shift and go to state 61
    primary                        shift and go to state 62
    unary_expression_not_plus_minus shift and go to state 46
    array_access                   shift and go to state 28
    additive_expression            shift and go to state 66
    simple_name                    shift and go to state 67
    c_literal                      shift and go to state 93
    base_variable_set              shift and go to state 88
    valid_variable                 shift and go to state 48
    inclusive_or_expression        shift and go to state 32
    literal                        shift and go to state 71
    and_expression                 shift and go to state 87
    relational_expression          shift and go to state 73
    cast_expression                shift and go to state 80
    conditional_or_expression      shift and go to state 49
    assignment_expression          shift and go to state 91
    qualified_name                 shift and go to state 79
    assignment                     shift and go to state 138
    multiplicative_expression      shift and go to state 52
    method_invocation              shift and go to state 111
    shift_expression               shift and go to state 54
    equality_expression            shift and go to state 82
    int_float                      shift and go to state 40
    variable_literal               shift and go to state 55
    name                           shift and go to state 139
    expression                     shift and go to state 177
    conditional_and_expression     shift and go to state 56

state 119

    (118) qualified_name -> name INST . simple_name
    (117) simple_name -> . IDENTIFIER

    IDENTIFIER      shift and go to state 77

    simple_name                    shift and go to state 178

state 120

    (79) method_invocation -> name LPAREN . argument_list_opt RPAREN
    (80) argument_list_opt -> . argument_list
    (81) argument_list_opt -> . empty
    (82) argument_list -> . expression
    (83) argument_list -> . argument_list COMMA expression
    (186) empty -> .
    (18) expression -> . assignment_expression
    (21) assignment_expression -> . assignment
    (22) assignment_expression -> . conditional_or_expression
    (23) assignment -> . valid_variable assignment_operator assignment_expression
    (28) conditional_or_expression -> . conditional_and_expression
    (29) conditional_or_expression -> . conditional_or_expression OR conditional_and_expression
    (24) valid_variable -> . name
    (25) valid_variable -> . array_access
    (30) conditional_and_expression -> . inclusive_or_expression
    (31) conditional_and_expression -> . conditional_and_expression AND inclusive_or_expression
    (115) name -> . simple_name
    (116) name -> . qualified_name
    (26) array_access -> . name LBRAC expression RBRAC
    (32) inclusive_or_expression -> . exclusive_or_expression
    (33) inclusive_or_expression -> . inclusive_or_expression OR_BITWISE exclusive_or_expression
    (117) simple_name -> . IDENTIFIER
    (118) qualified_name -> . name INST simple_name
    (34) exclusive_or_expression -> . and_expression
    (35) exclusive_or_expression -> . exclusive_or_expression XOR and_expression
    (36) and_expression -> . equality_expression
    (37) and_expression -> . and_expression AND_BITWISE equality_expression
    (38) equality_expression -> . relational_expression
    (39) equality_expression -> . equality_expression EQUAL relational_expression
    (40) equality_expression -> . equality_expression NEQUAL relational_expression
    (41) relational_expression -> . shift_expression
    (42) relational_expression -> . relational_expression GREATER shift_expression
    (43) relational_expression -> . relational_expression LESS shift_expression
    (44) relational_expression -> . relational_expression GEQ shift_expression
    (45) relational_expression -> . relational_expression LEQ shift_expression
    (46) shift_expression -> . additive_expression
    (47) shift_expression -> . shift_expression LSHIFT additive_expression
    (48) shift_expression -> . shift_expression RSHIFT additive_expression
    (49) additive_expression -> . multiplicative_expression
    (50) additive_expression -> . additive_expression PLUS multiplicative_expression
    (51) additive_expression -> . additive_expression MINUS multiplicative_expression
    (52) multiplicative_expression -> . unary_expression
    (53) multiplicative_expression -> . multiplicative_expression TIMES unary_expression
    (54) multiplicative_expression -> . multiplicative_expression DIVIDE unary_expression
    (55) multiplicative_expression -> . multiplicative_expression REMAINDER unary_expression
    (56) unary_expression -> . PLUS unary_expression
    (57) unary_expression -> . MINUS unary_expression
    (58) unary_expression -> . unary_expression_not_plus_minus
    (59) unary_expression_not_plus_minus -> . base_variable_set
    (60) unary_expression_not_plus_minus -> . TILDA unary_expression
    (61) unary_expression_not_plus_minus -> . NOT unary_expression
    (62) unary_expression_not_plus_minus -> . cast_expression
    (63) base_variable_set -> . variable_literal
    (64) base_variable_set -> . LPAREN expression RPAREN
    (67) cast_expression -> . LPAREN primitive_type RPAREN unary_expression
    (65) variable_literal -> . valid_variable
    (66) variable_literal -> . primary
    (68) primary -> . literal
    (69) primary -> . method_invocation
    (70) literal -> . int_float
    (71) literal -> . c_literal
    (79) method_invocation -> . name LPAREN argument_list_opt RPAREN
    (77) int_float -> . DOUBLE_NUMBER
    (78) int_float -> . INT_NUMBER
    (72) c_literal -> . CHAR
    (73) c_literal -> . STRING
    (74) c_literal -> . BOOL_CONSTT
    (75) c_literal -> . BOOL_CONSTF
    (76) c_literal -> . KEYWORD_NULL

    RPAREN          reduce using rule 186 (empty -> .)
    IDENTIFIER      shift and go to state 77
    PLUS            shift and go to state 36
    MINUS           shift and go to state 29
    TILDA           shift and go to state 72
    NOT             shift and go to state 57
    LPAREN          shift and go to state 94
    DOUBLE_NUMBER   shift and go to state 33
    INT_NUMBER      shift and go to state 44
    CHAR            shift and go to state 63
    STRING          shift and go to state 76
    BOOL_CONSTT     shift and go to state 35
    BOOL_CONSTF     shift and go to state 30
    KEYWORD_NULL    shift and go to state 65

    and_expression                 shift and go to state 87
    exclusive_or_expression        shift and go to state 61
    primary                        shift and go to state 62
    unary_expression_not_plus_minus shift and go to state 46
    array_access                   shift and go to state 28
    additive_expression            shift and go to state 66
    simple_name                    shift and go to state 67
    c_literal                      shift and go to state 93
    unary_expression               shift and go to state 45
    base_variable_set              shift and go to state 88
    valid_variable                 shift and go to state 48
    inclusive_or_expression        shift and go to state 32
    literal                        shift and go to state 71
    relational_expression          shift and go to state 73
    cast_expression                shift and go to state 80
    conditional_or_expression      shift and go to state 49
    empty                          shift and go to state 180
    argument_list                  shift and go to state 179
    assignment_expression          shift and go to state 91
    qualified_name                 shift and go to state 79
    assignment                     shift and go to state 138
    multiplicative_expression      shift and go to state 52
    method_invocation              shift and go to state 111
    shift_expression               shift and go to state 54
    equality_expression            shift and go to state 82
    int_float                      shift and go to state 40
    variable_literal               shift and go to state 55
    name                           shift and go to state 139
    argument_list_opt              shift and go to state 181
    expression                     shift and go to state 182
    conditional_and_expression     shift and go to state 56

state 121

    (27) assignment_operator -> ASOP .

    IDENTIFIER      reduce using rule 27 (assignment_operator -> ASOP .)
    PLUS            reduce using rule 27 (assignment_operator -> ASOP .)
    MINUS           reduce using rule 27 (assignment_operator -> ASOP .)
    TILDA           reduce using rule 27 (assignment_operator -> ASOP .)
    NOT             reduce using rule 27 (assignment_operator -> ASOP .)
    LPAREN          reduce using rule 27 (assignment_operator -> ASOP .)
    DOUBLE_NUMBER   reduce using rule 27 (assignment_operator -> ASOP .)
    INT_NUMBER      reduce using rule 27 (assignment_operator -> ASOP .)
    CHAR            reduce using rule 27 (assignment_operator -> ASOP .)
    STRING          reduce using rule 27 (assignment_operator -> ASOP .)
    BOOL_CONSTT     reduce using rule 27 (assignment_operator -> ASOP .)
    BOOL_CONSTF     reduce using rule 27 (assignment_operator -> ASOP .)
    KEYWORD_NULL    reduce using rule 27 (assignment_operator -> ASOP .)


state 122

    (23) assignment -> valid_variable assignment_operator . assignment_expression
    (21) assignment_expression -> . assignment
    (22) assignment_expression -> . conditional_or_expression
    (23) assignment -> . valid_variable assignment_operator assignment_expression
    (28) conditional_or_expression -> . conditional_and_expression
    (29) conditional_or_expression -> . conditional_or_expression OR conditional_and_expression
    (24) valid_variable -> . name
    (25) valid_variable -> . array_access
    (30) conditional_and_expression -> . inclusive_or_expression
    (31) conditional_and_expression -> . conditional_and_expression AND inclusive_or_expression
    (115) name -> . simple_name
    (116) name -> . qualified_name
    (26) array_access -> . name LBRAC expression RBRAC
    (32) inclusive_or_expression -> . exclusive_or_expression
    (33) inclusive_or_expression -> . inclusive_or_expression OR_BITWISE exclusive_or_expression
    (117) simple_name -> . IDENTIFIER
    (118) qualified_name -> . name INST simple_name
    (34) exclusive_or_expression -> . and_expression
    (35) exclusive_or_expression -> . exclusive_or_expression XOR and_expression
    (36) and_expression -> . equality_expression
    (37) and_expression -> . and_expression AND_BITWISE equality_expression
    (38) equality_expression -> . relational_expression
    (39) equality_expression -> . equality_expression EQUAL relational_expression
    (40) equality_expression -> . equality_expression NEQUAL relational_expression
    (41) relational_expression -> . shift_expression
    (42) relational_expression -> . relational_expression GREATER shift_expression
    (43) relational_expression -> . relational_expression LESS shift_expression
    (44) relational_expression -> . relational_expression GEQ shift_expression
    (45) relational_expression -> . relational_expression LEQ shift_expression
    (46) shift_expression -> . additive_expression
    (47) shift_expression -> . shift_expression LSHIFT additive_expression
    (48) shift_expression -> . shift_expression RSHIFT additive_expression
    (49) additive_expression -> . multiplicative_expression
    (50) additive_expression -> . additive_expression PLUS multiplicative_expression
    (51) additive_expression -> . additive_expression MINUS multiplicative_expression
    (52) multiplicative_expression -> . unary_expression
    (53) multiplicative_expression -> . multiplicative_expression TIMES unary_expression
    (54) multiplicative_expression -> . multiplicative_expression DIVIDE unary_expression
    (55) multiplicative_expression -> . multiplicative_expression REMAINDER unary_expression
    (56) unary_expression -> . PLUS unary_expression
    (57) unary_expression -> . MINUS unary_expression
    (58) unary_expression -> . unary_expression_not_plus_minus
    (59) unary_expression_not_plus_minus -> . base_variable_set
    (60) unary_expression_not_plus_minus -> . TILDA unary_expression
    (61) unary_expression_not_plus_minus -> . NOT unary_expression
    (62) unary_expression_not_plus_minus -> . cast_expression
    (63) base_variable_set -> . variable_literal
    (64) base_variable_set -> . LPAREN expression RPAREN
    (67) cast_expression -> . LPAREN primitive_type RPAREN unary_expression
    (65) variable_literal -> . valid_variable
    (66) variable_literal -> . primary
    (68) primary -> . literal
    (69) primary -> . method_invocation
    (70) literal -> . int_float
    (71) literal -> . c_literal
    (79) method_invocation -> . name LPAREN argument_list_opt RPAREN
    (77) int_float -> . DOUBLE_NUMBER
    (78) int_float -> . INT_NUMBER
    (72) c_literal -> . CHAR
    (73) c_literal -> . STRING
    (74) c_literal -> . BOOL_CONSTT
    (75) c_literal -> . BOOL_CONSTF
    (76) c_literal -> . KEYWORD_NULL

    IDENTIFIER      shift and go to state 77
    PLUS            shift and go to state 36
    MINUS           shift and go to state 29
    TILDA           shift and go to state 72
    NOT             shift and go to state 57
    LPAREN          shift and go to state 94
    DOUBLE_NUMBER   shift and go to state 33
    INT_NUMBER      shift and go to state 44
    CHAR            shift and go to state 63
    STRING          shift and go to state 76
    BOOL_CONSTT     shift and go to state 35
    BOOL_CONSTF     shift and go to state 30
    KEYWORD_NULL    shift and go to state 65

    unary_expression               shift and go to state 45
    exclusive_or_expression        shift and go to state 61
    primary                        shift and go to state 62
    unary_expression_not_plus_minus shift and go to state 46
    array_access                   shift and go to state 28
    additive_expression            shift and go to state 66
    simple_name                    shift and go to state 67
    c_literal                      shift and go to state 93
    base_variable_set              shift and go to state 88
    valid_variable                 shift and go to state 48
    inclusive_or_expression        shift and go to state 32
    literal                        shift and go to state 71
    and_expression                 shift and go to state 87
    relational_expression          shift and go to state 73
    cast_expression                shift and go to state 80
    conditional_or_expression      shift and go to state 49
    assignment_expression          shift and go to state 183
    qualified_name                 shift and go to state 79
    assignment                     shift and go to state 138
    multiplicative_expression      shift and go to state 52
    method_invocation              shift and go to state 111
    shift_expression               shift and go to state 54
    equality_expression            shift and go to state 82
    int_float                      shift and go to state 40
    variable_literal               shift and go to state 55
    name                           shift and go to state 139
    conditional_and_expression     shift and go to state 56

state 123

    (29) conditional_or_expression -> conditional_or_expression OR . conditional_and_expression
    (30) conditional_and_expression -> . inclusive_or_expression
    (31) conditional_and_expression -> . conditional_and_expression AND inclusive_or_expression
    (32) inclusive_or_expression -> . exclusive_or_expression
    (33) inclusive_or_expression -> . inclusive_or_expression OR_BITWISE exclusive_or_expression
    (34) exclusive_or_expression -> . and_expression
    (35) exclusive_or_expression -> . exclusive_or_expression XOR and_expression
    (36) and_expression -> . equality_expression
    (37) and_expression -> . and_expression AND_BITWISE equality_expression
    (38) equality_expression -> . relational_expression
    (39) equality_expression -> . equality_expression EQUAL relational_expression
    (40) equality_expression -> . equality_expression NEQUAL relational_expression
    (41) relational_expression -> . shift_expression
    (42) relational_expression -> . relational_expression GREATER shift_expression
    (43) relational_expression -> . relational_expression LESS shift_expression
    (44) relational_expression -> . relational_expression GEQ shift_expression
    (45) relational_expression -> . relational_expression LEQ shift_expression
    (46) shift_expression -> . additive_expression
    (47) shift_expression -> . shift_expression LSHIFT additive_expression
    (48) shift_expression -> . shift_expression RSHIFT additive_expression
    (49) additive_expression -> . multiplicative_expression
    (50) additive_expression -> . additive_expression PLUS multiplicative_expression
    (51) additive_expression -> . additive_expression MINUS multiplicative_expression
    (52) multiplicative_expression -> . unary_expression
    (53) multiplicative_expression -> . multiplicative_expression TIMES unary_expression
    (54) multiplicative_expression -> . multiplicative_expression DIVIDE unary_expression
    (55) multiplicative_expression -> . multiplicative_expression REMAINDER unary_expression
    (56) unary_expression -> . PLUS unary_expression
    (57) unary_expression -> . MINUS unary_expression
    (58) unary_expression -> . unary_expression_not_plus_minus
    (59) unary_expression_not_plus_minus -> . base_variable_set
    (60) unary_expression_not_plus_minus -> . TILDA unary_expression
    (61) unary_expression_not_plus_minus -> . NOT unary_expression
    (62) unary_expression_not_plus_minus -> . cast_expression
    (63) base_variable_set -> . variable_literal
    (64) base_variable_set -> . LPAREN expression RPAREN
    (67) cast_expression -> . LPAREN primitive_type RPAREN unary_expression
    (65) variable_literal -> . valid_variable
    (66) variable_literal -> . primary
    (24) valid_variable -> . name
    (25) valid_variable -> . array_access
    (68) primary -> . literal
    (69) primary -> . method_invocation
    (115) name -> . simple_name
    (116) name -> . qualified_name
    (26) array_access -> . name LBRAC expression RBRAC
    (70) literal -> . int_float
    (71) literal -> . c_literal
    (79) method_invocation -> . name LPAREN argument_list_opt RPAREN
    (117) simple_name -> . IDENTIFIER
    (118) qualified_name -> . name INST simple_name
    (77) int_float -> . DOUBLE_NUMBER
    (78) int_float -> . INT_NUMBER
    (72) c_literal -> . CHAR
    (73) c_literal -> . STRING
    (74) c_literal -> . BOOL_CONSTT
    (75) c_literal -> . BOOL_CONSTF
    (76) c_literal -> . KEYWORD_NULL

    PLUS            shift and go to state 36
    MINUS           shift and go to state 29
    TILDA           shift and go to state 72
    NOT             shift and go to state 57
    LPAREN          shift and go to state 94
    IDENTIFIER      shift and go to state 77
    DOUBLE_NUMBER   shift and go to state 33
    INT_NUMBER      shift and go to state 44
    CHAR            shift and go to state 63
    STRING          shift and go to state 76
    BOOL_CONSTT     shift and go to state 35
    BOOL_CONSTF     shift and go to state 30
    KEYWORD_NULL    shift and go to state 65

    unary_expression               shift and go to state 45
    exclusive_or_expression        shift and go to state 61
    primary                        shift and go to state 62
    unary_expression_not_plus_minus shift and go to state 46
    array_access                   shift and go to state 28
    additive_expression            shift and go to state 66
    simple_name                    shift and go to state 67
    c_literal                      shift and go to state 93
    base_variable_set              shift and go to state 88
    valid_variable                 shift and go to state 110
    inclusive_or_expression        shift and go to state 32
    literal                        shift and go to state 71
    and_expression                 shift and go to state 87
    cast_expression                shift and go to state 80
    relational_expression          shift and go to state 73
    qualified_name                 shift and go to state 79
    multiplicative_expression      shift and go to state 52
    method_invocation              shift and go to state 111
    shift_expression               shift and go to state 54
    equality_expression            shift and go to state 82
    int_float                      shift and go to state 40
    variable_literal               shift and go to state 55
    name                           shift and go to state 112
    conditional_and_expression     shift and go to state 184

state 124

    (141) while_statement -> KEYWORD_WHILE LPAREN . expression RPAREN statement
    (18) expression -> . assignment_expression
    (21) assignment_expression -> . assignment
    (22) assignment_expression -> . conditional_or_expression
    (23) assignment -> . valid_variable assignment_operator assignment_expression
    (28) conditional_or_expression -> . conditional_and_expression
    (29) conditional_or_expression -> . conditional_or_expression OR conditional_and_expression
    (24) valid_variable -> . name
    (25) valid_variable -> . array_access
    (30) conditional_and_expression -> . inclusive_or_expression
    (31) conditional_and_expression -> . conditional_and_expression AND inclusive_or_expression
    (115) name -> . simple_name
    (116) name -> . qualified_name
    (26) array_access -> . name LBRAC expression RBRAC
    (32) inclusive_or_expression -> . exclusive_or_expression
    (33) inclusive_or_expression -> . inclusive_or_expression OR_BITWISE exclusive_or_expression
    (117) simple_name -> . IDENTIFIER
    (118) qualified_name -> . name INST simple_name
    (34) exclusive_or_expression -> . and_expression
    (35) exclusive_or_expression -> . exclusive_or_expression XOR and_expression
    (36) and_expression -> . equality_expression
    (37) and_expression -> . and_expression AND_BITWISE equality_expression
    (38) equality_expression -> . relational_expression
    (39) equality_expression -> . equality_expression EQUAL relational_expression
    (40) equality_expression -> . equality_expression NEQUAL relational_expression
    (41) relational_expression -> . shift_expression
    (42) relational_expression -> . relational_expression GREATER shift_expression
    (43) relational_expression -> . relational_expression LESS shift_expression
    (44) relational_expression -> . relational_expression GEQ shift_expression
    (45) relational_expression -> . relational_expression LEQ shift_expression
    (46) shift_expression -> . additive_expression
    (47) shift_expression -> . shift_expression LSHIFT additive_expression
    (48) shift_expression -> . shift_expression RSHIFT additive_expression
    (49) additive_expression -> . multiplicative_expression
    (50) additive_expression -> . additive_expression PLUS multiplicative_expression
    (51) additive_expression -> . additive_expression MINUS multiplicative_expression
    (52) multiplicative_expression -> . unary_expression
    (53) multiplicative_expression -> . multiplicative_expression TIMES unary_expression
    (54) multiplicative_expression -> . multiplicative_expression DIVIDE unary_expression
    (55) multiplicative_expression -> . multiplicative_expression REMAINDER unary_expression
    (56) unary_expression -> . PLUS unary_expression
    (57) unary_expression -> . MINUS unary_expression
    (58) unary_expression -> . unary_expression_not_plus_minus
    (59) unary_expression_not_plus_minus -> . base_variable_set
    (60) unary_expression_not_plus_minus -> . TILDA unary_expression
    (61) unary_expression_not_plus_minus -> . NOT unary_expression
    (62) unary_expression_not_plus_minus -> . cast_expression
    (63) base_variable_set -> . variable_literal
    (64) base_variable_set -> . LPAREN expression RPAREN
    (67) cast_expression -> . LPAREN primitive_type RPAREN unary_expression
    (65) variable_literal -> . valid_variable
    (66) variable_literal -> . primary
    (68) primary -> . literal
    (69) primary -> . method_invocation
    (70) literal -> . int_float
    (71) literal -> . c_literal
    (79) method_invocation -> . name LPAREN argument_list_opt RPAREN
    (77) int_float -> . DOUBLE_NUMBER
    (78) int_float -> . INT_NUMBER
    (72) c_literal -> . CHAR
    (73) c_literal -> . STRING
    (74) c_literal -> . BOOL_CONSTT
    (75) c_literal -> . BOOL_CONSTF
    (76) c_literal -> . KEYWORD_NULL

    IDENTIFIER      shift and go to state 77
    PLUS            shift and go to state 36
    MINUS           shift and go to state 29
    TILDA           shift and go to state 72
    NOT             shift and go to state 57
    LPAREN          shift and go to state 94
    DOUBLE_NUMBER   shift and go to state 33
    INT_NUMBER      shift and go to state 44
    CHAR            shift and go to state 63
    STRING          shift and go to state 76
    BOOL_CONSTT     shift and go to state 35
    BOOL_CONSTF     shift and go to state 30
    KEYWORD_NULL    shift and go to state 65

    unary_expression               shift and go to state 45
    exclusive_or_expression        shift and go to state 61
    primary                        shift and go to state 62
    unary_expression_not_plus_minus shift and go to state 46
    array_access                   shift and go to state 28
    additive_expression            shift and go to state 66
    simple_name                    shift and go to state 67
    c_literal                      shift and go to state 93
    base_variable_set              shift and go to state 88
    valid_variable                 shift and go to state 48
    inclusive_or_expression        shift and go to state 32
    literal                        shift and go to state 71
    and_expression                 shift and go to state 87
    relational_expression          shift and go to state 73
    cast_expression                shift and go to state 80
    conditional_or_expression      shift and go to state 49
    assignment_expression          shift and go to state 91
    qualified_name                 shift and go to state 79
    assignment                     shift and go to state 138
    multiplicative_expression      shift and go to state 52
    method_invocation              shift and go to state 111
    shift_expression               shift and go to state 54
    equality_expression            shift and go to state 82
    int_float                      shift and go to state 40
    variable_literal               shift and go to state 55
    name                           shift and go to state 139
    expression                     shift and go to state 185
    conditional_and_expression     shift and go to state 56

state 125

    (55) multiplicative_expression -> multiplicative_expression REMAINDER . unary_expression
    (56) unary_expression -> . PLUS unary_expression
    (57) unary_expression -> . MINUS unary_expression
    (58) unary_expression -> . unary_expression_not_plus_minus
    (59) unary_expression_not_plus_minus -> . base_variable_set
    (60) unary_expression_not_plus_minus -> . TILDA unary_expression
    (61) unary_expression_not_plus_minus -> . NOT unary_expression
    (62) unary_expression_not_plus_minus -> . cast_expression
    (63) base_variable_set -> . variable_literal
    (64) base_variable_set -> . LPAREN expression RPAREN
    (67) cast_expression -> . LPAREN primitive_type RPAREN unary_expression
    (65) variable_literal -> . valid_variable
    (66) variable_literal -> . primary
    (24) valid_variable -> . name
    (25) valid_variable -> . array_access
    (68) primary -> . literal
    (69) primary -> . method_invocation
    (115) name -> . simple_name
    (116) name -> . qualified_name
    (26) array_access -> . name LBRAC expression RBRAC
    (70) literal -> . int_float
    (71) literal -> . c_literal
    (79) method_invocation -> . name LPAREN argument_list_opt RPAREN
    (117) simple_name -> . IDENTIFIER
    (118) qualified_name -> . name INST simple_name
    (77) int_float -> . DOUBLE_NUMBER
    (78) int_float -> . INT_NUMBER
    (72) c_literal -> . CHAR
    (73) c_literal -> . STRING
    (74) c_literal -> . BOOL_CONSTT
    (75) c_literal -> . BOOL_CONSTF
    (76) c_literal -> . KEYWORD_NULL

    PLUS            shift and go to state 36
    MINUS           shift and go to state 29
    TILDA           shift and go to state 72
    NOT             shift and go to state 57
    LPAREN          shift and go to state 94
    IDENTIFIER      shift and go to state 77
    DOUBLE_NUMBER   shift and go to state 33
    INT_NUMBER      shift and go to state 44
    CHAR            shift and go to state 63
    STRING          shift and go to state 76
    BOOL_CONSTT     shift and go to state 35
    BOOL_CONSTF     shift and go to state 30
    KEYWORD_NULL    shift and go to state 65

    qualified_name                 shift and go to state 79
    int_float                      shift and go to state 40
    c_literal                      shift and go to state 93
    variable_literal               shift and go to state 55
    unary_expression               shift and go to state 186
    base_variable_set              shift and go to state 88
    valid_variable                 shift and go to state 110
    array_access                   shift and go to state 28
    primary                        shift and go to state 62
    unary_expression_not_plus_minus shift and go to state 46
    literal                        shift and go to state 71
    method_invocation              shift and go to state 111
    cast_expression                shift and go to state 80
    simple_name                    shift and go to state 67
    name                           shift and go to state 112

state 126

    (54) multiplicative_expression -> multiplicative_expression DIVIDE . unary_expression
    (56) unary_expression -> . PLUS unary_expression
    (57) unary_expression -> . MINUS unary_expression
    (58) unary_expression -> . unary_expression_not_plus_minus
    (59) unary_expression_not_plus_minus -> . base_variable_set
    (60) unary_expression_not_plus_minus -> . TILDA unary_expression
    (61) unary_expression_not_plus_minus -> . NOT unary_expression
    (62) unary_expression_not_plus_minus -> . cast_expression
    (63) base_variable_set -> . variable_literal
    (64) base_variable_set -> . LPAREN expression RPAREN
    (67) cast_expression -> . LPAREN primitive_type RPAREN unary_expression
    (65) variable_literal -> . valid_variable
    (66) variable_literal -> . primary
    (24) valid_variable -> . name
    (25) valid_variable -> . array_access
    (68) primary -> . literal
    (69) primary -> . method_invocation
    (115) name -> . simple_name
    (116) name -> . qualified_name
    (26) array_access -> . name LBRAC expression RBRAC
    (70) literal -> . int_float
    (71) literal -> . c_literal
    (79) method_invocation -> . name LPAREN argument_list_opt RPAREN
    (117) simple_name -> . IDENTIFIER
    (118) qualified_name -> . name INST simple_name
    (77) int_float -> . DOUBLE_NUMBER
    (78) int_float -> . INT_NUMBER
    (72) c_literal -> . CHAR
    (73) c_literal -> . STRING
    (74) c_literal -> . BOOL_CONSTT
    (75) c_literal -> . BOOL_CONSTF
    (76) c_literal -> . KEYWORD_NULL

    PLUS            shift and go to state 36
    MINUS           shift and go to state 29
    TILDA           shift and go to state 72
    NOT             shift and go to state 57
    LPAREN          shift and go to state 94
    IDENTIFIER      shift and go to state 77
    DOUBLE_NUMBER   shift and go to state 33
    INT_NUMBER      shift and go to state 44
    CHAR            shift and go to state 63
    STRING          shift and go to state 76
    BOOL_CONSTT     shift and go to state 35
    BOOL_CONSTF     shift and go to state 30
    KEYWORD_NULL    shift and go to state 65

    qualified_name                 shift and go to state 79
    int_float                      shift and go to state 40
    c_literal                      shift and go to state 93
    variable_literal               shift and go to state 55
    unary_expression               shift and go to state 187
    base_variable_set              shift and go to state 88
    valid_variable                 shift and go to state 110
    array_access                   shift and go to state 28
    primary                        shift and go to state 62
    unary_expression_not_plus_minus shift and go to state 46
    literal                        shift and go to state 71
    method_invocation              shift and go to state 111
    cast_expression                shift and go to state 80
    simple_name                    shift and go to state 67
    name                           shift and go to state 112

state 127

    (53) multiplicative_expression -> multiplicative_expression TIMES . unary_expression
    (56) unary_expression -> . PLUS unary_expression
    (57) unary_expression -> . MINUS unary_expression
    (58) unary_expression -> . unary_expression_not_plus_minus
    (59) unary_expression_not_plus_minus -> . base_variable_set
    (60) unary_expression_not_plus_minus -> . TILDA unary_expression
    (61) unary_expression_not_plus_minus -> . NOT unary_expression
    (62) unary_expression_not_plus_minus -> . cast_expression
    (63) base_variable_set -> . variable_literal
    (64) base_variable_set -> . LPAREN expression RPAREN
    (67) cast_expression -> . LPAREN primitive_type RPAREN unary_expression
    (65) variable_literal -> . valid_variable
    (66) variable_literal -> . primary
    (24) valid_variable -> . name
    (25) valid_variable -> . array_access
    (68) primary -> . literal
    (69) primary -> . method_invocation
    (115) name -> . simple_name
    (116) name -> . qualified_name
    (26) array_access -> . name LBRAC expression RBRAC
    (70) literal -> . int_float
    (71) literal -> . c_literal
    (79) method_invocation -> . name LPAREN argument_list_opt RPAREN
    (117) simple_name -> . IDENTIFIER
    (118) qualified_name -> . name INST simple_name
    (77) int_float -> . DOUBLE_NUMBER
    (78) int_float -> . INT_NUMBER
    (72) c_literal -> . CHAR
    (73) c_literal -> . STRING
    (74) c_literal -> . BOOL_CONSTT
    (75) c_literal -> . BOOL_CONSTF
    (76) c_literal -> . KEYWORD_NULL

    PLUS            shift and go to state 36
    MINUS           shift and go to state 29
    TILDA           shift and go to state 72
    NOT             shift and go to state 57
    LPAREN          shift and go to state 94
    IDENTIFIER      shift and go to state 77
    DOUBLE_NUMBER   shift and go to state 33
    INT_NUMBER      shift and go to state 44
    CHAR            shift and go to state 63
    STRING          shift and go to state 76
    BOOL_CONSTT     shift and go to state 35
    BOOL_CONSTF     shift and go to state 30
    KEYWORD_NULL    shift and go to state 65

    qualified_name                 shift and go to state 79
    int_float                      shift and go to state 40
    c_literal                      shift and go to state 93
    variable_literal               shift and go to state 55
    unary_expression               shift and go to state 188
    base_variable_set              shift and go to state 88
    valid_variable                 shift and go to state 110
    array_access                   shift and go to state 28
    primary                        shift and go to state 62
    unary_expression_not_plus_minus shift and go to state 46
    literal                        shift and go to state 71
    method_invocation              shift and go to state 111
    cast_expression                shift and go to state 80
    simple_name                    shift and go to state 67
    name                           shift and go to state 112

state 128

    (48) shift_expression -> shift_expression RSHIFT . additive_expression
    (49) additive_expression -> . multiplicative_expression
    (50) additive_expression -> . additive_expression PLUS multiplicative_expression
    (51) additive_expression -> . additive_expression MINUS multiplicative_expression
    (52) multiplicative_expression -> . unary_expression
    (53) multiplicative_expression -> . multiplicative_expression TIMES unary_expression
    (54) multiplicative_expression -> . multiplicative_expression DIVIDE unary_expression
    (55) multiplicative_expression -> . multiplicative_expression REMAINDER unary_expression
    (56) unary_expression -> . PLUS unary_expression
    (57) unary_expression -> . MINUS unary_expression
    (58) unary_expression -> . unary_expression_not_plus_minus
    (59) unary_expression_not_plus_minus -> . base_variable_set
    (60) unary_expression_not_plus_minus -> . TILDA unary_expression
    (61) unary_expression_not_plus_minus -> . NOT unary_expression
    (62) unary_expression_not_plus_minus -> . cast_expression
    (63) base_variable_set -> . variable_literal
    (64) base_variable_set -> . LPAREN expression RPAREN
    (67) cast_expression -> . LPAREN primitive_type RPAREN unary_expression
    (65) variable_literal -> . valid_variable
    (66) variable_literal -> . primary
    (24) valid_variable -> . name
    (25) valid_variable -> . array_access
    (68) primary -> . literal
    (69) primary -> . method_invocation
    (115) name -> . simple_name
    (116) name -> . qualified_name
    (26) array_access -> . name LBRAC expression RBRAC
    (70) literal -> . int_float
    (71) literal -> . c_literal
    (79) method_invocation -> . name LPAREN argument_list_opt RPAREN
    (117) simple_name -> . IDENTIFIER
    (118) qualified_name -> . name INST simple_name
    (77) int_float -> . DOUBLE_NUMBER
    (78) int_float -> . INT_NUMBER
    (72) c_literal -> . CHAR
    (73) c_literal -> . STRING
    (74) c_literal -> . BOOL_CONSTT
    (75) c_literal -> . BOOL_CONSTF
    (76) c_literal -> . KEYWORD_NULL

    PLUS            shift and go to state 36
    MINUS           shift and go to state 29
    TILDA           shift and go to state 72
    NOT             shift and go to state 57
    LPAREN          shift and go to state 94
    IDENTIFIER      shift and go to state 77
    DOUBLE_NUMBER   shift and go to state 33
    INT_NUMBER      shift and go to state 44
    CHAR            shift and go to state 63
    STRING          shift and go to state 76
    BOOL_CONSTT     shift and go to state 35
    BOOL_CONSTF     shift and go to state 30
    KEYWORD_NULL    shift and go to state 65

    qualified_name                 shift and go to state 79
    int_float                      shift and go to state 40
    c_literal                      shift and go to state 93
    variable_literal               shift and go to state 55
    base_variable_set              shift and go to state 88
    unary_expression               shift and go to state 45
    valid_variable                 shift and go to state 110
    array_access                   shift and go to state 28
    multiplicative_expression      shift and go to state 52
    primary                        shift and go to state 62
    unary_expression_not_plus_minus shift and go to state 46
    literal                        shift and go to state 71
    method_invocation              shift and go to state 111
    cast_expression                shift and go to state 80
    simple_name                    shift and go to state 67
    additive_expression            shift and go to state 189
    name                           shift and go to state 112

state 129

    (47) shift_expression -> shift_expression LSHIFT . additive_expression
    (49) additive_expression -> . multiplicative_expression
    (50) additive_expression -> . additive_expression PLUS multiplicative_expression
    (51) additive_expression -> . additive_expression MINUS multiplicative_expression
    (52) multiplicative_expression -> . unary_expression
    (53) multiplicative_expression -> . multiplicative_expression TIMES unary_expression
    (54) multiplicative_expression -> . multiplicative_expression DIVIDE unary_expression
    (55) multiplicative_expression -> . multiplicative_expression REMAINDER unary_expression
    (56) unary_expression -> . PLUS unary_expression
    (57) unary_expression -> . MINUS unary_expression
    (58) unary_expression -> . unary_expression_not_plus_minus
    (59) unary_expression_not_plus_minus -> . base_variable_set
    (60) unary_expression_not_plus_minus -> . TILDA unary_expression
    (61) unary_expression_not_plus_minus -> . NOT unary_expression
    (62) unary_expression_not_plus_minus -> . cast_expression
    (63) base_variable_set -> . variable_literal
    (64) base_variable_set -> . LPAREN expression RPAREN
    (67) cast_expression -> . LPAREN primitive_type RPAREN unary_expression
    (65) variable_literal -> . valid_variable
    (66) variable_literal -> . primary
    (24) valid_variable -> . name
    (25) valid_variable -> . array_access
    (68) primary -> . literal
    (69) primary -> . method_invocation
    (115) name -> . simple_name
    (116) name -> . qualified_name
    (26) array_access -> . name LBRAC expression RBRAC
    (70) literal -> . int_float
    (71) literal -> . c_literal
    (79) method_invocation -> . name LPAREN argument_list_opt RPAREN
    (117) simple_name -> . IDENTIFIER
    (118) qualified_name -> . name INST simple_name
    (77) int_float -> . DOUBLE_NUMBER
    (78) int_float -> . INT_NUMBER
    (72) c_literal -> . CHAR
    (73) c_literal -> . STRING
    (74) c_literal -> . BOOL_CONSTT
    (75) c_literal -> . BOOL_CONSTF
    (76) c_literal -> . KEYWORD_NULL

    PLUS            shift and go to state 36
    MINUS           shift and go to state 29
    TILDA           shift and go to state 72
    NOT             shift and go to state 57
    LPAREN          shift and go to state 94
    IDENTIFIER      shift and go to state 77
    DOUBLE_NUMBER   shift and go to state 33
    INT_NUMBER      shift and go to state 44
    CHAR            shift and go to state 63
    STRING          shift and go to state 76
    BOOL_CONSTT     shift and go to state 35
    BOOL_CONSTF     shift and go to state 30
    KEYWORD_NULL    shift and go to state 65

    qualified_name                 shift and go to state 79
    int_float                      shift and go to state 40
    c_literal                      shift and go to state 93
    variable_literal               shift and go to state 55
    base_variable_set              shift and go to state 88
    unary_expression               shift and go to state 45
    valid_variable                 shift and go to state 110
    array_access                   shift and go to state 28
    multiplicative_expression      shift and go to state 52
    primary                        shift and go to state 62
    unary_expression_not_plus_minus shift and go to state 46
    literal                        shift and go to state 71
    method_invocation              shift and go to state 111
    cast_expression                shift and go to state 80
    simple_name                    shift and go to state 67
    additive_expression            shift and go to state 190
    name                           shift and go to state 112

state 130

    (31) conditional_and_expression -> conditional_and_expression AND . inclusive_or_expression
    (32) inclusive_or_expression -> . exclusive_or_expression
    (33) inclusive_or_expression -> . inclusive_or_expression OR_BITWISE exclusive_or_expression
    (34) exclusive_or_expression -> . and_expression
    (35) exclusive_or_expression -> . exclusive_or_expression XOR and_expression
    (36) and_expression -> . equality_expression
    (37) and_expression -> . and_expression AND_BITWISE equality_expression
    (38) equality_expression -> . relational_expression
    (39) equality_expression -> . equality_expression EQUAL relational_expression
    (40) equality_expression -> . equality_expression NEQUAL relational_expression
    (41) relational_expression -> . shift_expression
    (42) relational_expression -> . relational_expression GREATER shift_expression
    (43) relational_expression -> . relational_expression LESS shift_expression
    (44) relational_expression -> . relational_expression GEQ shift_expression
    (45) relational_expression -> . relational_expression LEQ shift_expression
    (46) shift_expression -> . additive_expression
    (47) shift_expression -> . shift_expression LSHIFT additive_expression
    (48) shift_expression -> . shift_expression RSHIFT additive_expression
    (49) additive_expression -> . multiplicative_expression
    (50) additive_expression -> . additive_expression PLUS multiplicative_expression
    (51) additive_expression -> . additive_expression MINUS multiplicative_expression
    (52) multiplicative_expression -> . unary_expression
    (53) multiplicative_expression -> . multiplicative_expression TIMES unary_expression
    (54) multiplicative_expression -> . multiplicative_expression DIVIDE unary_expression
    (55) multiplicative_expression -> . multiplicative_expression REMAINDER unary_expression
    (56) unary_expression -> . PLUS unary_expression
    (57) unary_expression -> . MINUS unary_expression
    (58) unary_expression -> . unary_expression_not_plus_minus
    (59) unary_expression_not_plus_minus -> . base_variable_set
    (60) unary_expression_not_plus_minus -> . TILDA unary_expression
    (61) unary_expression_not_plus_minus -> . NOT unary_expression
    (62) unary_expression_not_plus_minus -> . cast_expression
    (63) base_variable_set -> . variable_literal
    (64) base_variable_set -> . LPAREN expression RPAREN
    (67) cast_expression -> . LPAREN primitive_type RPAREN unary_expression
    (65) variable_literal -> . valid_variable
    (66) variable_literal -> . primary
    (24) valid_variable -> . name
    (25) valid_variable -> . array_access
    (68) primary -> . literal
    (69) primary -> . method_invocation
    (115) name -> . simple_name
    (116) name -> . qualified_name
    (26) array_access -> . name LBRAC expression RBRAC
    (70) literal -> . int_float
    (71) literal -> . c_literal
    (79) method_invocation -> . name LPAREN argument_list_opt RPAREN
    (117) simple_name -> . IDENTIFIER
    (118) qualified_name -> . name INST simple_name
    (77) int_float -> . DOUBLE_NUMBER
    (78) int_float -> . INT_NUMBER
    (72) c_literal -> . CHAR
    (73) c_literal -> . STRING
    (74) c_literal -> . BOOL_CONSTT
    (75) c_literal -> . BOOL_CONSTF
    (76) c_literal -> . KEYWORD_NULL

    PLUS            shift and go to state 36
    MINUS           shift and go to state 29
    TILDA           shift and go to state 72
    NOT             shift and go to state 57
    LPAREN          shift and go to state 94
    IDENTIFIER      shift and go to state 77
    DOUBLE_NUMBER   shift and go to state 33
    INT_NUMBER      shift and go to state 44
    CHAR            shift and go to state 63
    STRING          shift and go to state 76
    BOOL_CONSTT     shift and go to state 35
    BOOL_CONSTF     shift and go to state 30
    KEYWORD_NULL    shift and go to state 65

    unary_expression               shift and go to state 45
    exclusive_or_expression        shift and go to state 61
    primary                        shift and go to state 62
    unary_expression_not_plus_minus shift and go to state 46
    array_access                   shift and go to state 28
    additive_expression            shift and go to state 66
    simple_name                    shift and go to state 67
    c_literal                      shift and go to state 93
    base_variable_set              shift and go to state 88
    valid_variable                 shift and go to state 110
    inclusive_or_expression        shift and go to state 191
    literal                        shift and go to state 71
    and_expression                 shift and go to state 87
    method_invocation              shift and go to state 111
    relational_expression          shift and go to state 73
    qualified_name                 shift and go to state 79
    multiplicative_expression      shift and go to state 52
    cast_expression                shift and go to state 80
    shift_expression               shift and go to state 54
    equality_expression            shift and go to state 82
    int_float                      shift and go to state 40
    variable_literal               shift and go to state 55
    name                           shift and go to state 112

state 131

    (61) unary_expression_not_plus_minus -> NOT unary_expression .

    TIMES           reduce using rule 61 (unary_expression_not_plus_minus -> NOT unary_expression .)
    DIVIDE          reduce using rule 61 (unary_expression_not_plus_minus -> NOT unary_expression .)
    REMAINDER       reduce using rule 61 (unary_expression_not_plus_minus -> NOT unary_expression .)
    PLUS            reduce using rule 61 (unary_expression_not_plus_minus -> NOT unary_expression .)
    MINUS           reduce using rule 61 (unary_expression_not_plus_minus -> NOT unary_expression .)
    LSHIFT          reduce using rule 61 (unary_expression_not_plus_minus -> NOT unary_expression .)
    RSHIFT          reduce using rule 61 (unary_expression_not_plus_minus -> NOT unary_expression .)
    GREATER         reduce using rule 61 (unary_expression_not_plus_minus -> NOT unary_expression .)
    LESS            reduce using rule 61 (unary_expression_not_plus_minus -> NOT unary_expression .)
    GEQ             reduce using rule 61 (unary_expression_not_plus_minus -> NOT unary_expression .)
    LEQ             reduce using rule 61 (unary_expression_not_plus_minus -> NOT unary_expression .)
    EQUAL           reduce using rule 61 (unary_expression_not_plus_minus -> NOT unary_expression .)
    NEQUAL          reduce using rule 61 (unary_expression_not_plus_minus -> NOT unary_expression .)
    AND_BITWISE     reduce using rule 61 (unary_expression_not_plus_minus -> NOT unary_expression .)
    XOR             reduce using rule 61 (unary_expression_not_plus_minus -> NOT unary_expression .)
    OR_BITWISE      reduce using rule 61 (unary_expression_not_plus_minus -> NOT unary_expression .)
    AND             reduce using rule 61 (unary_expression_not_plus_minus -> NOT unary_expression .)
    OR              reduce using rule 61 (unary_expression_not_plus_minus -> NOT unary_expression .)
    KEYWORD_MATCH   reduce using rule 61 (unary_expression_not_plus_minus -> NOT unary_expression .)
    TERMINATOR      reduce using rule 61 (unary_expression_not_plus_minus -> NOT unary_expression .)
    RPAREN          reduce using rule 61 (unary_expression_not_plus_minus -> NOT unary_expression .)
    RBRAC           reduce using rule 61 (unary_expression_not_plus_minus -> NOT unary_expression .)
    COMMA           reduce using rule 61 (unary_expression_not_plus_minus -> NOT unary_expression .)
    FUNTYPE         reduce using rule 61 (unary_expression_not_plus_minus -> NOT unary_expression .)
    KEYWORD_UNTIL   reduce using rule 61 (unary_expression_not_plus_minus -> NOT unary_expression .)
    KEYWORD_TO      reduce using rule 61 (unary_expression_not_plus_minus -> NOT unary_expression .)
    KEYWORD_BY      reduce using rule 61 (unary_expression_not_plus_minus -> NOT unary_expression .)


state 132

    (152) switch_statement -> expression KEYWORD_MATCH . switch_block
    (153) switch_block -> . BLOCKBEGIN BLOCKEND
    (154) switch_block -> . BLOCKBEGIN switch_block_statements BLOCKEND
    (155) switch_block -> . BLOCKBEGIN switch_labels BLOCKEND
    (156) switch_block -> . BLOCKBEGIN switch_block_statements switch_labels BLOCKEND

    BLOCKBEGIN      shift and go to state 192

    switch_block                   shift and go to state 193

state 133

    (35) exclusive_or_expression -> exclusive_or_expression XOR . and_expression
    (36) and_expression -> . equality_expression
    (37) and_expression -> . and_expression AND_BITWISE equality_expression
    (38) equality_expression -> . relational_expression
    (39) equality_expression -> . equality_expression EQUAL relational_expression
    (40) equality_expression -> . equality_expression NEQUAL relational_expression
    (41) relational_expression -> . shift_expression
    (42) relational_expression -> . relational_expression GREATER shift_expression
    (43) relational_expression -> . relational_expression LESS shift_expression
    (44) relational_expression -> . relational_expression GEQ shift_expression
    (45) relational_expression -> . relational_expression LEQ shift_expression
    (46) shift_expression -> . additive_expression
    (47) shift_expression -> . shift_expression LSHIFT additive_expression
    (48) shift_expression -> . shift_expression RSHIFT additive_expression
    (49) additive_expression -> . multiplicative_expression
    (50) additive_expression -> . additive_expression PLUS multiplicative_expression
    (51) additive_expression -> . additive_expression MINUS multiplicative_expression
    (52) multiplicative_expression -> . unary_expression
    (53) multiplicative_expression -> . multiplicative_expression TIMES unary_expression
    (54) multiplicative_expression -> . multiplicative_expression DIVIDE unary_expression
    (55) multiplicative_expression -> . multiplicative_expression REMAINDER unary_expression
    (56) unary_expression -> . PLUS unary_expression
    (57) unary_expression -> . MINUS unary_expression
    (58) unary_expression -> . unary_expression_not_plus_minus
    (59) unary_expression_not_plus_minus -> . base_variable_set
    (60) unary_expression_not_plus_minus -> . TILDA unary_expression
    (61) unary_expression_not_plus_minus -> . NOT unary_expression
    (62) unary_expression_not_plus_minus -> . cast_expression
    (63) base_variable_set -> . variable_literal
    (64) base_variable_set -> . LPAREN expression RPAREN
    (67) cast_expression -> . LPAREN primitive_type RPAREN unary_expression
    (65) variable_literal -> . valid_variable
    (66) variable_literal -> . primary
    (24) valid_variable -> . name
    (25) valid_variable -> . array_access
    (68) primary -> . literal
    (69) primary -> . method_invocation
    (115) name -> . simple_name
    (116) name -> . qualified_name
    (26) array_access -> . name LBRAC expression RBRAC
    (70) literal -> . int_float
    (71) literal -> . c_literal
    (79) method_invocation -> . name LPAREN argument_list_opt RPAREN
    (117) simple_name -> . IDENTIFIER
    (118) qualified_name -> . name INST simple_name
    (77) int_float -> . DOUBLE_NUMBER
    (78) int_float -> . INT_NUMBER
    (72) c_literal -> . CHAR
    (73) c_literal -> . STRING
    (74) c_literal -> . BOOL_CONSTT
    (75) c_literal -> . BOOL_CONSTF
    (76) c_literal -> . KEYWORD_NULL

    PLUS            shift and go to state 36
    MINUS           shift and go to state 29
    TILDA           shift and go to state 72
    NOT             shift and go to state 57
    LPAREN          shift and go to state 94
    IDENTIFIER      shift and go to state 77
    DOUBLE_NUMBER   shift and go to state 33
    INT_NUMBER      shift and go to state 44
    CHAR            shift and go to state 63
    STRING          shift and go to state 76
    BOOL_CONSTT     shift and go to state 35
    BOOL_CONSTF     shift and go to state 30
    KEYWORD_NULL    shift and go to state 65

    unary_expression               shift and go to state 45
    primary                        shift and go to state 62
    unary_expression_not_plus_minus shift and go to state 46
    array_access                   shift and go to state 28
    and_expression                 shift and go to state 194
    simple_name                    shift and go to state 67
    c_literal                      shift and go to state 93
    base_variable_set              shift and go to state 88
    valid_variable                 shift and go to state 110
    literal                        shift and go to state 71
    additive_expression            shift and go to state 66
    method_invocation              shift and go to state 111
    relational_expression          shift and go to state 73
    qualified_name                 shift and go to state 79
    multiplicative_expression      shift and go to state 52
    cast_expression                shift and go to state 80
    shift_expression               shift and go to state 54
    equality_expression            shift and go to state 82
    int_float                      shift and go to state 40
    variable_literal               shift and go to state 55
    name                           shift and go to state 112

state 134

    (50) additive_expression -> additive_expression PLUS . multiplicative_expression
    (52) multiplicative_expression -> . unary_expression
    (53) multiplicative_expression -> . multiplicative_expression TIMES unary_expression
    (54) multiplicative_expression -> . multiplicative_expression DIVIDE unary_expression
    (55) multiplicative_expression -> . multiplicative_expression REMAINDER unary_expression
    (56) unary_expression -> . PLUS unary_expression
    (57) unary_expression -> . MINUS unary_expression
    (58) unary_expression -> . unary_expression_not_plus_minus
    (59) unary_expression_not_plus_minus -> . base_variable_set
    (60) unary_expression_not_plus_minus -> . TILDA unary_expression
    (61) unary_expression_not_plus_minus -> . NOT unary_expression
    (62) unary_expression_not_plus_minus -> . cast_expression
    (63) base_variable_set -> . variable_literal
    (64) base_variable_set -> . LPAREN expression RPAREN
    (67) cast_expression -> . LPAREN primitive_type RPAREN unary_expression
    (65) variable_literal -> . valid_variable
    (66) variable_literal -> . primary
    (24) valid_variable -> . name
    (25) valid_variable -> . array_access
    (68) primary -> . literal
    (69) primary -> . method_invocation
    (115) name -> . simple_name
    (116) name -> . qualified_name
    (26) array_access -> . name LBRAC expression RBRAC
    (70) literal -> . int_float
    (71) literal -> . c_literal
    (79) method_invocation -> . name LPAREN argument_list_opt RPAREN
    (117) simple_name -> . IDENTIFIER
    (118) qualified_name -> . name INST simple_name
    (77) int_float -> . DOUBLE_NUMBER
    (78) int_float -> . INT_NUMBER
    (72) c_literal -> . CHAR
    (73) c_literal -> . STRING
    (74) c_literal -> . BOOL_CONSTT
    (75) c_literal -> . BOOL_CONSTF
    (76) c_literal -> . KEYWORD_NULL

    PLUS            shift and go to state 36
    MINUS           shift and go to state 29
    TILDA           shift and go to state 72
    NOT             shift and go to state 57
    LPAREN          shift and go to state 94
    IDENTIFIER      shift and go to state 77
    DOUBLE_NUMBER   shift and go to state 33
    INT_NUMBER      shift and go to state 44
    CHAR            shift and go to state 63
    STRING          shift and go to state 76
    BOOL_CONSTT     shift and go to state 35
    BOOL_CONSTF     shift and go to state 30
    KEYWORD_NULL    shift and go to state 65

    qualified_name                 shift and go to state 79
    int_float                      shift and go to state 40
    c_literal                      shift and go to state 93
    variable_literal               shift and go to state 55
    base_variable_set              shift and go to state 88
    unary_expression               shift and go to state 45
    valid_variable                 shift and go to state 110
    array_access                   shift and go to state 28
    multiplicative_expression      shift and go to state 195
    primary                        shift and go to state 62
    unary_expression_not_plus_minus shift and go to state 46
    literal                        shift and go to state 71
    method_invocation              shift and go to state 111
    cast_expression                shift and go to state 80
    simple_name                    shift and go to state 67
    name                           shift and go to state 112

state 135

    (51) additive_expression -> additive_expression MINUS . multiplicative_expression
    (52) multiplicative_expression -> . unary_expression
    (53) multiplicative_expression -> . multiplicative_expression TIMES unary_expression
    (54) multiplicative_expression -> . multiplicative_expression DIVIDE unary_expression
    (55) multiplicative_expression -> . multiplicative_expression REMAINDER unary_expression
    (56) unary_expression -> . PLUS unary_expression
    (57) unary_expression -> . MINUS unary_expression
    (58) unary_expression -> . unary_expression_not_plus_minus
    (59) unary_expression_not_plus_minus -> . base_variable_set
    (60) unary_expression_not_plus_minus -> . TILDA unary_expression
    (61) unary_expression_not_plus_minus -> . NOT unary_expression
    (62) unary_expression_not_plus_minus -> . cast_expression
    (63) base_variable_set -> . variable_literal
    (64) base_variable_set -> . LPAREN expression RPAREN
    (67) cast_expression -> . LPAREN primitive_type RPAREN unary_expression
    (65) variable_literal -> . valid_variable
    (66) variable_literal -> . primary
    (24) valid_variable -> . name
    (25) valid_variable -> . array_access
    (68) primary -> . literal
    (69) primary -> . method_invocation
    (115) name -> . simple_name
    (116) name -> . qualified_name
    (26) array_access -> . name LBRAC expression RBRAC
    (70) literal -> . int_float
    (71) literal -> . c_literal
    (79) method_invocation -> . name LPAREN argument_list_opt RPAREN
    (117) simple_name -> . IDENTIFIER
    (118) qualified_name -> . name INST simple_name
    (77) int_float -> . DOUBLE_NUMBER
    (78) int_float -> . INT_NUMBER
    (72) c_literal -> . CHAR
    (73) c_literal -> . STRING
    (74) c_literal -> . BOOL_CONSTT
    (75) c_literal -> . BOOL_CONSTF
    (76) c_literal -> . KEYWORD_NULL

    PLUS            shift and go to state 36
    MINUS           shift and go to state 29
    TILDA           shift and go to state 72
    NOT             shift and go to state 57
    LPAREN          shift and go to state 94
    IDENTIFIER      shift and go to state 77
    DOUBLE_NUMBER   shift and go to state 33
    INT_NUMBER      shift and go to state 44
    CHAR            shift and go to state 63
    STRING          shift and go to state 76
    BOOL_CONSTT     shift and go to state 35
    BOOL_CONSTF     shift and go to state 30
    KEYWORD_NULL    shift and go to state 65

    qualified_name                 shift and go to state 79
    int_float                      shift and go to state 40
    c_literal                      shift and go to state 93
    variable_literal               shift and go to state 55
    base_variable_set              shift and go to state 88
    unary_expression               shift and go to state 45
    valid_variable                 shift and go to state 110
    array_access                   shift and go to state 28
    multiplicative_expression      shift and go to state 196
    primary                        shift and go to state 62
    unary_expression_not_plus_minus shift and go to state 46
    literal                        shift and go to state 71
    method_invocation              shift and go to state 111
    cast_expression                shift and go to state 80
    simple_name                    shift and go to state 67
    name                           shift and go to state 112

state 136

    (164) return_statement -> KEYWORD_RETURN expression_optional . TERMINATOR

    TERMINATOR      shift and go to state 197


state 137

    (20) expression_optional -> empty .

    TERMINATOR      reduce using rule 20 (expression_optional -> empty .)


state 138

    (21) assignment_expression -> assignment .

    TERMINATOR      reduce using rule 21 (assignment_expression -> assignment .)
    RPAREN          reduce using rule 21 (assignment_expression -> assignment .)
    COMMA           reduce using rule 21 (assignment_expression -> assignment .)
    RBRAC           reduce using rule 21 (assignment_expression -> assignment .)
    KEYWORD_MATCH   reduce using rule 21 (assignment_expression -> assignment .)
    FUNTYPE         reduce using rule 21 (assignment_expression -> assignment .)
    KEYWORD_UNTIL   reduce using rule 21 (assignment_expression -> assignment .)
    KEYWORD_TO      reduce using rule 21 (assignment_expression -> assignment .)
    KEYWORD_BY      reduce using rule 21 (assignment_expression -> assignment .)


state 139

    (24) valid_variable -> name .
    (26) array_access -> name . LBRAC expression RBRAC
    (118) qualified_name -> name . INST simple_name
    (79) method_invocation -> name . LPAREN argument_list_opt RPAREN

    ASOP            reduce using rule 24 (valid_variable -> name .)
    TIMES           reduce using rule 24 (valid_variable -> name .)
    DIVIDE          reduce using rule 24 (valid_variable -> name .)
    REMAINDER       reduce using rule 24 (valid_variable -> name .)
    PLUS            reduce using rule 24 (valid_variable -> name .)
    MINUS           reduce using rule 24 (valid_variable -> name .)
    LSHIFT          reduce using rule 24 (valid_variable -> name .)
    RSHIFT          reduce using rule 24 (valid_variable -> name .)
    GREATER         reduce using rule 24 (valid_variable -> name .)
    LESS            reduce using rule 24 (valid_variable -> name .)
    GEQ             reduce using rule 24 (valid_variable -> name .)
    LEQ             reduce using rule 24 (valid_variable -> name .)
    EQUAL           reduce using rule 24 (valid_variable -> name .)
    NEQUAL          reduce using rule 24 (valid_variable -> name .)
    AND_BITWISE     reduce using rule 24 (valid_variable -> name .)
    XOR             reduce using rule 24 (valid_variable -> name .)
    OR_BITWISE      reduce using rule 24 (valid_variable -> name .)
    AND             reduce using rule 24 (valid_variable -> name .)
    OR              reduce using rule 24 (valid_variable -> name .)
    RPAREN          reduce using rule 24 (valid_variable -> name .)
    COMMA           reduce using rule 24 (valid_variable -> name .)
    TERMINATOR      reduce using rule 24 (valid_variable -> name .)
    KEYWORD_MATCH   reduce using rule 24 (valid_variable -> name .)
    RBRAC           reduce using rule 24 (valid_variable -> name .)
    FUNTYPE         reduce using rule 24 (valid_variable -> name .)
    KEYWORD_UNTIL   reduce using rule 24 (valid_variable -> name .)
    KEYWORD_TO      reduce using rule 24 (valid_variable -> name .)
    KEYWORD_BY      reduce using rule 24 (valid_variable -> name .)
    LBRAC           shift and go to state 118
    INST            shift and go to state 119
    LPAREN          shift and go to state 120


state 140

    (19) expression_optional -> expression .

    TERMINATOR      reduce using rule 19 (expression_optional -> expression .)


state 141

    (60) unary_expression_not_plus_minus -> TILDA unary_expression .

    TIMES           reduce using rule 60 (unary_expression_not_plus_minus -> TILDA unary_expression .)
    DIVIDE          reduce using rule 60 (unary_expression_not_plus_minus -> TILDA unary_expression .)
    REMAINDER       reduce using rule 60 (unary_expression_not_plus_minus -> TILDA unary_expression .)
    PLUS            reduce using rule 60 (unary_expression_not_plus_minus -> TILDA unary_expression .)
    MINUS           reduce using rule 60 (unary_expression_not_plus_minus -> TILDA unary_expression .)
    LSHIFT          reduce using rule 60 (unary_expression_not_plus_minus -> TILDA unary_expression .)
    RSHIFT          reduce using rule 60 (unary_expression_not_plus_minus -> TILDA unary_expression .)
    GREATER         reduce using rule 60 (unary_expression_not_plus_minus -> TILDA unary_expression .)
    LESS            reduce using rule 60 (unary_expression_not_plus_minus -> TILDA unary_expression .)
    GEQ             reduce using rule 60 (unary_expression_not_plus_minus -> TILDA unary_expression .)
    LEQ             reduce using rule 60 (unary_expression_not_plus_minus -> TILDA unary_expression .)
    EQUAL           reduce using rule 60 (unary_expression_not_plus_minus -> TILDA unary_expression .)
    NEQUAL          reduce using rule 60 (unary_expression_not_plus_minus -> TILDA unary_expression .)
    AND_BITWISE     reduce using rule 60 (unary_expression_not_plus_minus -> TILDA unary_expression .)
    XOR             reduce using rule 60 (unary_expression_not_plus_minus -> TILDA unary_expression .)
    OR_BITWISE      reduce using rule 60 (unary_expression_not_plus_minus -> TILDA unary_expression .)
    AND             reduce using rule 60 (unary_expression_not_plus_minus -> TILDA unary_expression .)
    OR              reduce using rule 60 (unary_expression_not_plus_minus -> TILDA unary_expression .)
    KEYWORD_MATCH   reduce using rule 60 (unary_expression_not_plus_minus -> TILDA unary_expression .)
    TERMINATOR      reduce using rule 60 (unary_expression_not_plus_minus -> TILDA unary_expression .)
    RPAREN          reduce using rule 60 (unary_expression_not_plus_minus -> TILDA unary_expression .)
    RBRAC           reduce using rule 60 (unary_expression_not_plus_minus -> TILDA unary_expression .)
    COMMA           reduce using rule 60 (unary_expression_not_plus_minus -> TILDA unary_expression .)
    FUNTYPE         reduce using rule 60 (unary_expression_not_plus_minus -> TILDA unary_expression .)
    KEYWORD_UNTIL   reduce using rule 60 (unary_expression_not_plus_minus -> TILDA unary_expression .)
    KEYWORD_TO      reduce using rule 60 (unary_expression_not_plus_minus -> TILDA unary_expression .)
    KEYWORD_BY      reduce using rule 60 (unary_expression_not_plus_minus -> TILDA unary_expression .)


state 142

    (44) relational_expression -> relational_expression GEQ . shift_expression
    (46) shift_expression -> . additive_expression
    (47) shift_expression -> . shift_expression LSHIFT additive_expression
    (48) shift_expression -> . shift_expression RSHIFT additive_expression
    (49) additive_expression -> . multiplicative_expression
    (50) additive_expression -> . additive_expression PLUS multiplicative_expression
    (51) additive_expression -> . additive_expression MINUS multiplicative_expression
    (52) multiplicative_expression -> . unary_expression
    (53) multiplicative_expression -> . multiplicative_expression TIMES unary_expression
    (54) multiplicative_expression -> . multiplicative_expression DIVIDE unary_expression
    (55) multiplicative_expression -> . multiplicative_expression REMAINDER unary_expression
    (56) unary_expression -> . PLUS unary_expression
    (57) unary_expression -> . MINUS unary_expression
    (58) unary_expression -> . unary_expression_not_plus_minus
    (59) unary_expression_not_plus_minus -> . base_variable_set
    (60) unary_expression_not_plus_minus -> . TILDA unary_expression
    (61) unary_expression_not_plus_minus -> . NOT unary_expression
    (62) unary_expression_not_plus_minus -> . cast_expression
    (63) base_variable_set -> . variable_literal
    (64) base_variable_set -> . LPAREN expression RPAREN
    (67) cast_expression -> . LPAREN primitive_type RPAREN unary_expression
    (65) variable_literal -> . valid_variable
    (66) variable_literal -> . primary
    (24) valid_variable -> . name
    (25) valid_variable -> . array_access
    (68) primary -> . literal
    (69) primary -> . method_invocation
    (115) name -> . simple_name
    (116) name -> . qualified_name
    (26) array_access -> . name LBRAC expression RBRAC
    (70) literal -> . int_float
    (71) literal -> . c_literal
    (79) method_invocation -> . name LPAREN argument_list_opt RPAREN
    (117) simple_name -> . IDENTIFIER
    (118) qualified_name -> . name INST simple_name
    (77) int_float -> . DOUBLE_NUMBER
    (78) int_float -> . INT_NUMBER
    (72) c_literal -> . CHAR
    (73) c_literal -> . STRING
    (74) c_literal -> . BOOL_CONSTT
    (75) c_literal -> . BOOL_CONSTF
    (76) c_literal -> . KEYWORD_NULL

    PLUS            shift and go to state 36
    MINUS           shift and go to state 29
    TILDA           shift and go to state 72
    NOT             shift and go to state 57
    LPAREN          shift and go to state 94
    IDENTIFIER      shift and go to state 77
    DOUBLE_NUMBER   shift and go to state 33
    INT_NUMBER      shift and go to state 44
    CHAR            shift and go to state 63
    STRING          shift and go to state 76
    BOOL_CONSTT     shift and go to state 35
    BOOL_CONSTF     shift and go to state 30
    KEYWORD_NULL    shift and go to state 65

    unary_expression               shift and go to state 45
    primary                        shift and go to state 62
    unary_expression_not_plus_minus shift and go to state 46
    array_access                   shift and go to state 28
    additive_expression            shift and go to state 66
    simple_name                    shift and go to state 67
    c_literal                      shift and go to state 93
    base_variable_set              shift and go to state 88
    valid_variable                 shift and go to state 110
    literal                        shift and go to state 71
    method_invocation              shift and go to state 111
    qualified_name                 shift and go to state 79
    multiplicative_expression      shift and go to state 52
    cast_expression                shift and go to state 80
    shift_expression               shift and go to state 198
    int_float                      shift and go to state 40
    variable_literal               shift and go to state 55
    name                           shift and go to state 112

state 143

    (42) relational_expression -> relational_expression GREATER . shift_expression
    (46) shift_expression -> . additive_expression
    (47) shift_expression -> . shift_expression LSHIFT additive_expression
    (48) shift_expression -> . shift_expression RSHIFT additive_expression
    (49) additive_expression -> . multiplicative_expression
    (50) additive_expression -> . additive_expression PLUS multiplicative_expression
    (51) additive_expression -> . additive_expression MINUS multiplicative_expression
    (52) multiplicative_expression -> . unary_expression
    (53) multiplicative_expression -> . multiplicative_expression TIMES unary_expression
    (54) multiplicative_expression -> . multiplicative_expression DIVIDE unary_expression
    (55) multiplicative_expression -> . multiplicative_expression REMAINDER unary_expression
    (56) unary_expression -> . PLUS unary_expression
    (57) unary_expression -> . MINUS unary_expression
    (58) unary_expression -> . unary_expression_not_plus_minus
    (59) unary_expression_not_plus_minus -> . base_variable_set
    (60) unary_expression_not_plus_minus -> . TILDA unary_expression
    (61) unary_expression_not_plus_minus -> . NOT unary_expression
    (62) unary_expression_not_plus_minus -> . cast_expression
    (63) base_variable_set -> . variable_literal
    (64) base_variable_set -> . LPAREN expression RPAREN
    (67) cast_expression -> . LPAREN primitive_type RPAREN unary_expression
    (65) variable_literal -> . valid_variable
    (66) variable_literal -> . primary
    (24) valid_variable -> . name
    (25) valid_variable -> . array_access
    (68) primary -> . literal
    (69) primary -> . method_invocation
    (115) name -> . simple_name
    (116) name -> . qualified_name
    (26) array_access -> . name LBRAC expression RBRAC
    (70) literal -> . int_float
    (71) literal -> . c_literal
    (79) method_invocation -> . name LPAREN argument_list_opt RPAREN
    (117) simple_name -> . IDENTIFIER
    (118) qualified_name -> . name INST simple_name
    (77) int_float -> . DOUBLE_NUMBER
    (78) int_float -> . INT_NUMBER
    (72) c_literal -> . CHAR
    (73) c_literal -> . STRING
    (74) c_literal -> . BOOL_CONSTT
    (75) c_literal -> . BOOL_CONSTF
    (76) c_literal -> . KEYWORD_NULL

    PLUS            shift and go to state 36
    MINUS           shift and go to state 29
    TILDA           shift and go to state 72
    NOT             shift and go to state 57
    LPAREN          shift and go to state 94
    IDENTIFIER      shift and go to state 77
    DOUBLE_NUMBER   shift and go to state 33
    INT_NUMBER      shift and go to state 44
    CHAR            shift and go to state 63
    STRING          shift and go to state 76
    BOOL_CONSTT     shift and go to state 35
    BOOL_CONSTF     shift and go to state 30
    KEYWORD_NULL    shift and go to state 65

    unary_expression               shift and go to state 45
    primary                        shift and go to state 62
    unary_expression_not_plus_minus shift and go to state 46
    array_access                   shift and go to state 28
    additive_expression            shift and go to state 66
    simple_name                    shift and go to state 67
    c_literal                      shift and go to state 93
    base_variable_set              shift and go to state 88
    valid_variable                 shift and go to state 110
    literal                        shift and go to state 71
    method_invocation              shift and go to state 111
    qualified_name                 shift and go to state 79
    multiplicative_expression      shift and go to state 52
    cast_expression                shift and go to state 80
    shift_expression               shift and go to state 199
    int_float                      shift and go to state 40
    variable_literal               shift and go to state 55
    name                           shift and go to state 112

state 144

    (43) relational_expression -> relational_expression LESS . shift_expression
    (46) shift_expression -> . additive_expression
    (47) shift_expression -> . shift_expression LSHIFT additive_expression
    (48) shift_expression -> . shift_expression RSHIFT additive_expression
    (49) additive_expression -> . multiplicative_expression
    (50) additive_expression -> . additive_expression PLUS multiplicative_expression
    (51) additive_expression -> . additive_expression MINUS multiplicative_expression
    (52) multiplicative_expression -> . unary_expression
    (53) multiplicative_expression -> . multiplicative_expression TIMES unary_expression
    (54) multiplicative_expression -> . multiplicative_expression DIVIDE unary_expression
    (55) multiplicative_expression -> . multiplicative_expression REMAINDER unary_expression
    (56) unary_expression -> . PLUS unary_expression
    (57) unary_expression -> . MINUS unary_expression
    (58) unary_expression -> . unary_expression_not_plus_minus
    (59) unary_expression_not_plus_minus -> . base_variable_set
    (60) unary_expression_not_plus_minus -> . TILDA unary_expression
    (61) unary_expression_not_plus_minus -> . NOT unary_expression
    (62) unary_expression_not_plus_minus -> . cast_expression
    (63) base_variable_set -> . variable_literal
    (64) base_variable_set -> . LPAREN expression RPAREN
    (67) cast_expression -> . LPAREN primitive_type RPAREN unary_expression
    (65) variable_literal -> . valid_variable
    (66) variable_literal -> . primary
    (24) valid_variable -> . name
    (25) valid_variable -> . array_access
    (68) primary -> . literal
    (69) primary -> . method_invocation
    (115) name -> . simple_name
    (116) name -> . qualified_name
    (26) array_access -> . name LBRAC expression RBRAC
    (70) literal -> . int_float
    (71) literal -> . c_literal
    (79) method_invocation -> . name LPAREN argument_list_opt RPAREN
    (117) simple_name -> . IDENTIFIER
    (118) qualified_name -> . name INST simple_name
    (77) int_float -> . DOUBLE_NUMBER
    (78) int_float -> . INT_NUMBER
    (72) c_literal -> . CHAR
    (73) c_literal -> . STRING
    (74) c_literal -> . BOOL_CONSTT
    (75) c_literal -> . BOOL_CONSTF
    (76) c_literal -> . KEYWORD_NULL

    PLUS            shift and go to state 36
    MINUS           shift and go to state 29
    TILDA           shift and go to state 72
    NOT             shift and go to state 57
    LPAREN          shift and go to state 94
    IDENTIFIER      shift and go to state 77
    DOUBLE_NUMBER   shift and go to state 33
    INT_NUMBER      shift and go to state 44
    CHAR            shift and go to state 63
    STRING          shift and go to state 76
    BOOL_CONSTT     shift and go to state 35
    BOOL_CONSTF     shift and go to state 30
    KEYWORD_NULL    shift and go to state 65

    unary_expression               shift and go to state 45
    primary                        shift and go to state 62
    unary_expression_not_plus_minus shift and go to state 46
    array_access                   shift and go to state 28
    additive_expression            shift and go to state 66
    simple_name                    shift and go to state 67
    c_literal                      shift and go to state 93
    base_variable_set              shift and go to state 88
    valid_variable                 shift and go to state 110
    literal                        shift and go to state 71
    method_invocation              shift and go to state 111
    qualified_name                 shift and go to state 79
    multiplicative_expression      shift and go to state 52
    cast_expression                shift and go to state 80
    shift_expression               shift and go to state 200
    int_float                      shift and go to state 40
    variable_literal               shift and go to state 55
    name                           shift and go to state 112

state 145

    (45) relational_expression -> relational_expression LEQ . shift_expression
    (46) shift_expression -> . additive_expression
    (47) shift_expression -> . shift_expression LSHIFT additive_expression
    (48) shift_expression -> . shift_expression RSHIFT additive_expression
    (49) additive_expression -> . multiplicative_expression
    (50) additive_expression -> . additive_expression PLUS multiplicative_expression
    (51) additive_expression -> . additive_expression MINUS multiplicative_expression
    (52) multiplicative_expression -> . unary_expression
    (53) multiplicative_expression -> . multiplicative_expression TIMES unary_expression
    (54) multiplicative_expression -> . multiplicative_expression DIVIDE unary_expression
    (55) multiplicative_expression -> . multiplicative_expression REMAINDER unary_expression
    (56) unary_expression -> . PLUS unary_expression
    (57) unary_expression -> . MINUS unary_expression
    (58) unary_expression -> . unary_expression_not_plus_minus
    (59) unary_expression_not_plus_minus -> . base_variable_set
    (60) unary_expression_not_plus_minus -> . TILDA unary_expression
    (61) unary_expression_not_plus_minus -> . NOT unary_expression
    (62) unary_expression_not_plus_minus -> . cast_expression
    (63) base_variable_set -> . variable_literal
    (64) base_variable_set -> . LPAREN expression RPAREN
    (67) cast_expression -> . LPAREN primitive_type RPAREN unary_expression
    (65) variable_literal -> . valid_variable
    (66) variable_literal -> . primary
    (24) valid_variable -> . name
    (25) valid_variable -> . array_access
    (68) primary -> . literal
    (69) primary -> . method_invocation
    (115) name -> . simple_name
    (116) name -> . qualified_name
    (26) array_access -> . name LBRAC expression RBRAC
    (70) literal -> . int_float
    (71) literal -> . c_literal
    (79) method_invocation -> . name LPAREN argument_list_opt RPAREN
    (117) simple_name -> . IDENTIFIER
    (118) qualified_name -> . name INST simple_name
    (77) int_float -> . DOUBLE_NUMBER
    (78) int_float -> . INT_NUMBER
    (72) c_literal -> . CHAR
    (73) c_literal -> . STRING
    (74) c_literal -> . BOOL_CONSTT
    (75) c_literal -> . BOOL_CONSTF
    (76) c_literal -> . KEYWORD_NULL

    PLUS            shift and go to state 36
    MINUS           shift and go to state 29
    TILDA           shift and go to state 72
    NOT             shift and go to state 57
    LPAREN          shift and go to state 94
    IDENTIFIER      shift and go to state 77
    DOUBLE_NUMBER   shift and go to state 33
    INT_NUMBER      shift and go to state 44
    CHAR            shift and go to state 63
    STRING          shift and go to state 76
    BOOL_CONSTT     shift and go to state 35
    BOOL_CONSTF     shift and go to state 30
    KEYWORD_NULL    shift and go to state 65

    unary_expression               shift and go to state 45
    primary                        shift and go to state 62
    unary_expression_not_plus_minus shift and go to state 46
    array_access                   shift and go to state 28
    additive_expression            shift and go to state 66
    simple_name                    shift and go to state 67
    c_literal                      shift and go to state 93
    base_variable_set              shift and go to state 88
    valid_variable                 shift and go to state 110
    literal                        shift and go to state 71
    method_invocation              shift and go to state 111
    qualified_name                 shift and go to state 79
    multiplicative_expression      shift and go to state 52
    cast_expression                shift and go to state 80
    shift_expression               shift and go to state 201
    int_float                      shift and go to state 40
    variable_literal               shift and go to state 55
    name                           shift and go to state 112

state 146

    (136) if_then_statement -> KEYWORD_IF LPAREN . expression RPAREN statement
    (137) if_then_else_statement -> KEYWORD_IF LPAREN . expression RPAREN if_then_else_intermediate KEYWORD_ELSE statement
    (18) expression -> . assignment_expression
    (21) assignment_expression -> . assignment
    (22) assignment_expression -> . conditional_or_expression
    (23) assignment -> . valid_variable assignment_operator assignment_expression
    (28) conditional_or_expression -> . conditional_and_expression
    (29) conditional_or_expression -> . conditional_or_expression OR conditional_and_expression
    (24) valid_variable -> . name
    (25) valid_variable -> . array_access
    (30) conditional_and_expression -> . inclusive_or_expression
    (31) conditional_and_expression -> . conditional_and_expression AND inclusive_or_expression
    (115) name -> . simple_name
    (116) name -> . qualified_name
    (26) array_access -> . name LBRAC expression RBRAC
    (32) inclusive_or_expression -> . exclusive_or_expression
    (33) inclusive_or_expression -> . inclusive_or_expression OR_BITWISE exclusive_or_expression
    (117) simple_name -> . IDENTIFIER
    (118) qualified_name -> . name INST simple_name
    (34) exclusive_or_expression -> . and_expression
    (35) exclusive_or_expression -> . exclusive_or_expression XOR and_expression
    (36) and_expression -> . equality_expression
    (37) and_expression -> . and_expression AND_BITWISE equality_expression
    (38) equality_expression -> . relational_expression
    (39) equality_expression -> . equality_expression EQUAL relational_expression
    (40) equality_expression -> . equality_expression NEQUAL relational_expression
    (41) relational_expression -> . shift_expression
    (42) relational_expression -> . relational_expression GREATER shift_expression
    (43) relational_expression -> . relational_expression LESS shift_expression
    (44) relational_expression -> . relational_expression GEQ shift_expression
    (45) relational_expression -> . relational_expression LEQ shift_expression
    (46) shift_expression -> . additive_expression
    (47) shift_expression -> . shift_expression LSHIFT additive_expression
    (48) shift_expression -> . shift_expression RSHIFT additive_expression
    (49) additive_expression -> . multiplicative_expression
    (50) additive_expression -> . additive_expression PLUS multiplicative_expression
    (51) additive_expression -> . additive_expression MINUS multiplicative_expression
    (52) multiplicative_expression -> . unary_expression
    (53) multiplicative_expression -> . multiplicative_expression TIMES unary_expression
    (54) multiplicative_expression -> . multiplicative_expression DIVIDE unary_expression
    (55) multiplicative_expression -> . multiplicative_expression REMAINDER unary_expression
    (56) unary_expression -> . PLUS unary_expression
    (57) unary_expression -> . MINUS unary_expression
    (58) unary_expression -> . unary_expression_not_plus_minus
    (59) unary_expression_not_plus_minus -> . base_variable_set
    (60) unary_expression_not_plus_minus -> . TILDA unary_expression
    (61) unary_expression_not_plus_minus -> . NOT unary_expression
    (62) unary_expression_not_plus_minus -> . cast_expression
    (63) base_variable_set -> . variable_literal
    (64) base_variable_set -> . LPAREN expression RPAREN
    (67) cast_expression -> . LPAREN primitive_type RPAREN unary_expression
    (65) variable_literal -> . valid_variable
    (66) variable_literal -> . primary
    (68) primary -> . literal
    (69) primary -> . method_invocation
    (70) literal -> . int_float
    (71) literal -> . c_literal
    (79) method_invocation -> . name LPAREN argument_list_opt RPAREN
    (77) int_float -> . DOUBLE_NUMBER
    (78) int_float -> . INT_NUMBER
    (72) c_literal -> . CHAR
    (73) c_literal -> . STRING
    (74) c_literal -> . BOOL_CONSTT
    (75) c_literal -> . BOOL_CONSTF
    (76) c_literal -> . KEYWORD_NULL

    IDENTIFIER      shift and go to state 77
    PLUS            shift and go to state 36
    MINUS           shift and go to state 29
    TILDA           shift and go to state 72
    NOT             shift and go to state 57
    LPAREN          shift and go to state 94
    DOUBLE_NUMBER   shift and go to state 33
    INT_NUMBER      shift and go to state 44
    CHAR            shift and go to state 63
    STRING          shift and go to state 76
    BOOL_CONSTT     shift and go to state 35
    BOOL_CONSTF     shift and go to state 30
    KEYWORD_NULL    shift and go to state 65

    unary_expression               shift and go to state 45
    exclusive_or_expression        shift and go to state 61
    primary                        shift and go to state 62
    unary_expression_not_plus_minus shift and go to state 46
    array_access                   shift and go to state 28
    additive_expression            shift and go to state 66
    simple_name                    shift and go to state 67
    c_literal                      shift and go to state 93
    base_variable_set              shift and go to state 88
    valid_variable                 shift and go to state 48
    inclusive_or_expression        shift and go to state 32
    literal                        shift and go to state 71
    and_expression                 shift and go to state 87
    relational_expression          shift and go to state 73
    cast_expression                shift and go to state 80
    conditional_or_expression      shift and go to state 49
    assignment_expression          shift and go to state 91
    qualified_name                 shift and go to state 79
    assignment                     shift and go to state 138
    multiplicative_expression      shift and go to state 52
    method_invocation              shift and go to state 111
    shift_expression               shift and go to state 54
    equality_expression            shift and go to state 82
    int_float                      shift and go to state 40
    variable_literal               shift and go to state 55
    name                           shift and go to state 139
    expression                     shift and go to state 202
    conditional_and_expression     shift and go to state 56

state 147

    (40) equality_expression -> equality_expression NEQUAL . relational_expression
    (41) relational_expression -> . shift_expression
    (42) relational_expression -> . relational_expression GREATER shift_expression
    (43) relational_expression -> . relational_expression LESS shift_expression
    (44) relational_expression -> . relational_expression GEQ shift_expression
    (45) relational_expression -> . relational_expression LEQ shift_expression
    (46) shift_expression -> . additive_expression
    (47) shift_expression -> . shift_expression LSHIFT additive_expression
    (48) shift_expression -> . shift_expression RSHIFT additive_expression
    (49) additive_expression -> . multiplicative_expression
    (50) additive_expression -> . additive_expression PLUS multiplicative_expression
    (51) additive_expression -> . additive_expression MINUS multiplicative_expression
    (52) multiplicative_expression -> . unary_expression
    (53) multiplicative_expression -> . multiplicative_expression TIMES unary_expression
    (54) multiplicative_expression -> . multiplicative_expression DIVIDE unary_expression
    (55) multiplicative_expression -> . multiplicative_expression REMAINDER unary_expression
    (56) unary_expression -> . PLUS unary_expression
    (57) unary_expression -> . MINUS unary_expression
    (58) unary_expression -> . unary_expression_not_plus_minus
    (59) unary_expression_not_plus_minus -> . base_variable_set
    (60) unary_expression_not_plus_minus -> . TILDA unary_expression
    (61) unary_expression_not_plus_minus -> . NOT unary_expression
    (62) unary_expression_not_plus_minus -> . cast_expression
    (63) base_variable_set -> . variable_literal
    (64) base_variable_set -> . LPAREN expression RPAREN
    (67) cast_expression -> . LPAREN primitive_type RPAREN unary_expression
    (65) variable_literal -> . valid_variable
    (66) variable_literal -> . primary
    (24) valid_variable -> . name
    (25) valid_variable -> . array_access
    (68) primary -> . literal
    (69) primary -> . method_invocation
    (115) name -> . simple_name
    (116) name -> . qualified_name
    (26) array_access -> . name LBRAC expression RBRAC
    (70) literal -> . int_float
    (71) literal -> . c_literal
    (79) method_invocation -> . name LPAREN argument_list_opt RPAREN
    (117) simple_name -> . IDENTIFIER
    (118) qualified_name -> . name INST simple_name
    (77) int_float -> . DOUBLE_NUMBER
    (78) int_float -> . INT_NUMBER
    (72) c_literal -> . CHAR
    (73) c_literal -> . STRING
    (74) c_literal -> . BOOL_CONSTT
    (75) c_literal -> . BOOL_CONSTF
    (76) c_literal -> . KEYWORD_NULL

    PLUS            shift and go to state 36
    MINUS           shift and go to state 29
    TILDA           shift and go to state 72
    NOT             shift and go to state 57
    LPAREN          shift and go to state 94
    IDENTIFIER      shift and go to state 77
    DOUBLE_NUMBER   shift and go to state 33
    INT_NUMBER      shift and go to state 44
    CHAR            shift and go to state 63
    STRING          shift and go to state 76
    BOOL_CONSTT     shift and go to state 35
    BOOL_CONSTF     shift and go to state 30
    KEYWORD_NULL    shift and go to state 65

    unary_expression               shift and go to state 45
    primary                        shift and go to state 62
    unary_expression_not_plus_minus shift and go to state 46
    array_access                   shift and go to state 28
    additive_expression            shift and go to state 66
    simple_name                    shift and go to state 67
    c_literal                      shift and go to state 93
    base_variable_set              shift and go to state 88
    valid_variable                 shift and go to state 110
    literal                        shift and go to state 71
    relational_expression          shift and go to state 203
    method_invocation              shift and go to state 111
    qualified_name                 shift and go to state 79
    multiplicative_expression      shift and go to state 52
    cast_expression                shift and go to state 80
    shift_expression               shift and go to state 54
    int_float                      shift and go to state 40
    variable_literal               shift and go to state 55
    name                           shift and go to state 112

state 148

    (39) equality_expression -> equality_expression EQUAL . relational_expression
    (41) relational_expression -> . shift_expression
    (42) relational_expression -> . relational_expression GREATER shift_expression
    (43) relational_expression -> . relational_expression LESS shift_expression
    (44) relational_expression -> . relational_expression GEQ shift_expression
    (45) relational_expression -> . relational_expression LEQ shift_expression
    (46) shift_expression -> . additive_expression
    (47) shift_expression -> . shift_expression LSHIFT additive_expression
    (48) shift_expression -> . shift_expression RSHIFT additive_expression
    (49) additive_expression -> . multiplicative_expression
    (50) additive_expression -> . additive_expression PLUS multiplicative_expression
    (51) additive_expression -> . additive_expression MINUS multiplicative_expression
    (52) multiplicative_expression -> . unary_expression
    (53) multiplicative_expression -> . multiplicative_expression TIMES unary_expression
    (54) multiplicative_expression -> . multiplicative_expression DIVIDE unary_expression
    (55) multiplicative_expression -> . multiplicative_expression REMAINDER unary_expression
    (56) unary_expression -> . PLUS unary_expression
    (57) unary_expression -> . MINUS unary_expression
    (58) unary_expression -> . unary_expression_not_plus_minus
    (59) unary_expression_not_plus_minus -> . base_variable_set
    (60) unary_expression_not_plus_minus -> . TILDA unary_expression
    (61) unary_expression_not_plus_minus -> . NOT unary_expression
    (62) unary_expression_not_plus_minus -> . cast_expression
    (63) base_variable_set -> . variable_literal
    (64) base_variable_set -> . LPAREN expression RPAREN
    (67) cast_expression -> . LPAREN primitive_type RPAREN unary_expression
    (65) variable_literal -> . valid_variable
    (66) variable_literal -> . primary
    (24) valid_variable -> . name
    (25) valid_variable -> . array_access
    (68) primary -> . literal
    (69) primary -> . method_invocation
    (115) name -> . simple_name
    (116) name -> . qualified_name
    (26) array_access -> . name LBRAC expression RBRAC
    (70) literal -> . int_float
    (71) literal -> . c_literal
    (79) method_invocation -> . name LPAREN argument_list_opt RPAREN
    (117) simple_name -> . IDENTIFIER
    (118) qualified_name -> . name INST simple_name
    (77) int_float -> . DOUBLE_NUMBER
    (78) int_float -> . INT_NUMBER
    (72) c_literal -> . CHAR
    (73) c_literal -> . STRING
    (74) c_literal -> . BOOL_CONSTT
    (75) c_literal -> . BOOL_CONSTF
    (76) c_literal -> . KEYWORD_NULL

    PLUS            shift and go to state 36
    MINUS           shift and go to state 29
    TILDA           shift and go to state 72
    NOT             shift and go to state 57
    LPAREN          shift and go to state 94
    IDENTIFIER      shift and go to state 77
    DOUBLE_NUMBER   shift and go to state 33
    INT_NUMBER      shift and go to state 44
    CHAR            shift and go to state 63
    STRING          shift and go to state 76
    BOOL_CONSTT     shift and go to state 35
    BOOL_CONSTF     shift and go to state 30
    KEYWORD_NULL    shift and go to state 65

    unary_expression               shift and go to state 45
    primary                        shift and go to state 62
    unary_expression_not_plus_minus shift and go to state 46
    array_access                   shift and go to state 28
    additive_expression            shift and go to state 66
    simple_name                    shift and go to state 67
    c_literal                      shift and go to state 93
    base_variable_set              shift and go to state 88
    valid_variable                 shift and go to state 110
    literal                        shift and go to state 71
    relational_expression          shift and go to state 204
    method_invocation              shift and go to state 111
    qualified_name                 shift and go to state 79
    multiplicative_expression      shift and go to state 52
    cast_expression                shift and go to state 80
    shift_expression               shift and go to state 54
    int_float                      shift and go to state 40
    variable_literal               shift and go to state 55
    name                           shift and go to state 112

state 149

    (178) method_declaration -> method_header method_body .

    KEYWORD_IF      reduce using rule 178 (method_declaration -> method_header method_body .)
    KEYWORD_WHILE   reduce using rule 178 (method_declaration -> method_header method_body .)
    KEYWORD_DO      reduce using rule 178 (method_declaration -> method_header method_body .)
    KEYWORD_FOR     reduce using rule 178 (method_declaration -> method_header method_body .)
    KEYWORD_OBJECT  reduce using rule 178 (method_declaration -> method_header method_body .)
    BLOCKBEGIN      reduce using rule 178 (method_declaration -> method_header method_body .)
    TERMINATOR      reduce using rule 178 (method_declaration -> method_header method_body .)
    KEYWORD_RETURN  reduce using rule 178 (method_declaration -> method_header method_body .)
    KEYWORD_PROTECTED reduce using rule 178 (method_declaration -> method_header method_body .)
    KEYWORD_PRIVATE reduce using rule 178 (method_declaration -> method_header method_body .)
    IDENTIFIER      reduce using rule 178 (method_declaration -> method_header method_body .)
    PLUS            reduce using rule 178 (method_declaration -> method_header method_body .)
    MINUS           reduce using rule 178 (method_declaration -> method_header method_body .)
    TILDA           reduce using rule 178 (method_declaration -> method_header method_body .)
    NOT             reduce using rule 178 (method_declaration -> method_header method_body .)
    LPAREN          reduce using rule 178 (method_declaration -> method_header method_body .)
    DOUBLE_NUMBER   reduce using rule 178 (method_declaration -> method_header method_body .)
    INT_NUMBER      reduce using rule 178 (method_declaration -> method_header method_body .)
    CHAR            reduce using rule 178 (method_declaration -> method_header method_body .)
    STRING          reduce using rule 178 (method_declaration -> method_header method_body .)
    BOOL_CONSTT     reduce using rule 178 (method_declaration -> method_header method_body .)
    BOOL_CONSTF     reduce using rule 178 (method_declaration -> method_header method_body .)
    KEYWORD_NULL    reduce using rule 178 (method_declaration -> method_header method_body .)
    KEYWORD_DEF     reduce using rule 178 (method_declaration -> method_header method_body .)
    KEYWORD_CLASS   reduce using rule 178 (method_declaration -> method_header method_body .)
    KEYWORD_VAR     reduce using rule 178 (method_declaration -> method_header method_body .)
    KEYWORD_VAL     reduce using rule 178 (method_declaration -> method_header method_body .)
    BLOCKEND        reduce using rule 178 (method_declaration -> method_header method_body .)
    KEYWORD_CASE    reduce using rule 178 (method_declaration -> method_header method_body .)


state 150

    (185) method_body -> block .

    KEYWORD_IF      reduce using rule 185 (method_body -> block .)
    KEYWORD_WHILE   reduce using rule 185 (method_body -> block .)
    KEYWORD_DO      reduce using rule 185 (method_body -> block .)
    KEYWORD_FOR     reduce using rule 185 (method_body -> block .)
    KEYWORD_OBJECT  reduce using rule 185 (method_body -> block .)
    BLOCKBEGIN      reduce using rule 185 (method_body -> block .)
    TERMINATOR      reduce using rule 185 (method_body -> block .)
    KEYWORD_RETURN  reduce using rule 185 (method_body -> block .)
    KEYWORD_PROTECTED reduce using rule 185 (method_body -> block .)
    KEYWORD_PRIVATE reduce using rule 185 (method_body -> block .)
    IDENTIFIER      reduce using rule 185 (method_body -> block .)
    PLUS            reduce using rule 185 (method_body -> block .)
    MINUS           reduce using rule 185 (method_body -> block .)
    TILDA           reduce using rule 185 (method_body -> block .)
    NOT             reduce using rule 185 (method_body -> block .)
    LPAREN          reduce using rule 185 (method_body -> block .)
    DOUBLE_NUMBER   reduce using rule 185 (method_body -> block .)
    INT_NUMBER      reduce using rule 185 (method_body -> block .)
    CHAR            reduce using rule 185 (method_body -> block .)
    STRING          reduce using rule 185 (method_body -> block .)
    BOOL_CONSTT     reduce using rule 185 (method_body -> block .)
    BOOL_CONSTF     reduce using rule 185 (method_body -> block .)
    KEYWORD_NULL    reduce using rule 185 (method_body -> block .)
    KEYWORD_DEF     reduce using rule 185 (method_body -> block .)
    KEYWORD_CLASS   reduce using rule 185 (method_body -> block .)
    KEYWORD_VAR     reduce using rule 185 (method_body -> block .)
    KEYWORD_VAL     reduce using rule 185 (method_body -> block .)
    BLOCKEND        reduce using rule 185 (method_body -> block .)
    KEYWORD_CASE    reduce using rule 185 (method_body -> block .)


state 151

    (90) local_variable_declaration_statement -> local_variable_declaration TERMINATOR .

    KEYWORD_IF      reduce using rule 90 (local_variable_declaration_statement -> local_variable_declaration TERMINATOR .)
    KEYWORD_WHILE   reduce using rule 90 (local_variable_declaration_statement -> local_variable_declaration TERMINATOR .)
    KEYWORD_DO      reduce using rule 90 (local_variable_declaration_statement -> local_variable_declaration TERMINATOR .)
    KEYWORD_FOR     reduce using rule 90 (local_variable_declaration_statement -> local_variable_declaration TERMINATOR .)
    KEYWORD_OBJECT  reduce using rule 90 (local_variable_declaration_statement -> local_variable_declaration TERMINATOR .)
    BLOCKBEGIN      reduce using rule 90 (local_variable_declaration_statement -> local_variable_declaration TERMINATOR .)
    TERMINATOR      reduce using rule 90 (local_variable_declaration_statement -> local_variable_declaration TERMINATOR .)
    KEYWORD_RETURN  reduce using rule 90 (local_variable_declaration_statement -> local_variable_declaration TERMINATOR .)
    KEYWORD_PROTECTED reduce using rule 90 (local_variable_declaration_statement -> local_variable_declaration TERMINATOR .)
    KEYWORD_PRIVATE reduce using rule 90 (local_variable_declaration_statement -> local_variable_declaration TERMINATOR .)
    IDENTIFIER      reduce using rule 90 (local_variable_declaration_statement -> local_variable_declaration TERMINATOR .)
    PLUS            reduce using rule 90 (local_variable_declaration_statement -> local_variable_declaration TERMINATOR .)
    MINUS           reduce using rule 90 (local_variable_declaration_statement -> local_variable_declaration TERMINATOR .)
    TILDA           reduce using rule 90 (local_variable_declaration_statement -> local_variable_declaration TERMINATOR .)
    NOT             reduce using rule 90 (local_variable_declaration_statement -> local_variable_declaration TERMINATOR .)
    LPAREN          reduce using rule 90 (local_variable_declaration_statement -> local_variable_declaration TERMINATOR .)
    DOUBLE_NUMBER   reduce using rule 90 (local_variable_declaration_statement -> local_variable_declaration TERMINATOR .)
    INT_NUMBER      reduce using rule 90 (local_variable_declaration_statement -> local_variable_declaration TERMINATOR .)
    CHAR            reduce using rule 90 (local_variable_declaration_statement -> local_variable_declaration TERMINATOR .)
    STRING          reduce using rule 90 (local_variable_declaration_statement -> local_variable_declaration TERMINATOR .)
    BOOL_CONSTT     reduce using rule 90 (local_variable_declaration_statement -> local_variable_declaration TERMINATOR .)
    BOOL_CONSTF     reduce using rule 90 (local_variable_declaration_statement -> local_variable_declaration TERMINATOR .)
    KEYWORD_NULL    reduce using rule 90 (local_variable_declaration_statement -> local_variable_declaration TERMINATOR .)
    KEYWORD_DEF     reduce using rule 90 (local_variable_declaration_statement -> local_variable_declaration TERMINATOR .)
    KEYWORD_CLASS   reduce using rule 90 (local_variable_declaration_statement -> local_variable_declaration TERMINATOR .)
    KEYWORD_VAR     reduce using rule 90 (local_variable_declaration_statement -> local_variable_declaration TERMINATOR .)
    KEYWORD_VAL     reduce using rule 90 (local_variable_declaration_statement -> local_variable_declaration TERMINATOR .)
    BLOCKEND        reduce using rule 90 (local_variable_declaration_statement -> local_variable_declaration TERMINATOR .)
    KEYWORD_CASE    reduce using rule 90 (local_variable_declaration_statement -> local_variable_declaration TERMINATOR .)


state 152

    (37) and_expression -> and_expression AND_BITWISE . equality_expression
    (38) equality_expression -> . relational_expression
    (39) equality_expression -> . equality_expression EQUAL relational_expression
    (40) equality_expression -> . equality_expression NEQUAL relational_expression
    (41) relational_expression -> . shift_expression
    (42) relational_expression -> . relational_expression GREATER shift_expression
    (43) relational_expression -> . relational_expression LESS shift_expression
    (44) relational_expression -> . relational_expression GEQ shift_expression
    (45) relational_expression -> . relational_expression LEQ shift_expression
    (46) shift_expression -> . additive_expression
    (47) shift_expression -> . shift_expression LSHIFT additive_expression
    (48) shift_expression -> . shift_expression RSHIFT additive_expression
    (49) additive_expression -> . multiplicative_expression
    (50) additive_expression -> . additive_expression PLUS multiplicative_expression
    (51) additive_expression -> . additive_expression MINUS multiplicative_expression
    (52) multiplicative_expression -> . unary_expression
    (53) multiplicative_expression -> . multiplicative_expression TIMES unary_expression
    (54) multiplicative_expression -> . multiplicative_expression DIVIDE unary_expression
    (55) multiplicative_expression -> . multiplicative_expression REMAINDER unary_expression
    (56) unary_expression -> . PLUS unary_expression
    (57) unary_expression -> . MINUS unary_expression
    (58) unary_expression -> . unary_expression_not_plus_minus
    (59) unary_expression_not_plus_minus -> . base_variable_set
    (60) unary_expression_not_plus_minus -> . TILDA unary_expression
    (61) unary_expression_not_plus_minus -> . NOT unary_expression
    (62) unary_expression_not_plus_minus -> . cast_expression
    (63) base_variable_set -> . variable_literal
    (64) base_variable_set -> . LPAREN expression RPAREN
    (67) cast_expression -> . LPAREN primitive_type RPAREN unary_expression
    (65) variable_literal -> . valid_variable
    (66) variable_literal -> . primary
    (24) valid_variable -> . name
    (25) valid_variable -> . array_access
    (68) primary -> . literal
    (69) primary -> . method_invocation
    (115) name -> . simple_name
    (116) name -> . qualified_name
    (26) array_access -> . name LBRAC expression RBRAC
    (70) literal -> . int_float
    (71) literal -> . c_literal
    (79) method_invocation -> . name LPAREN argument_list_opt RPAREN
    (117) simple_name -> . IDENTIFIER
    (118) qualified_name -> . name INST simple_name
    (77) int_float -> . DOUBLE_NUMBER
    (78) int_float -> . INT_NUMBER
    (72) c_literal -> . CHAR
    (73) c_literal -> . STRING
    (74) c_literal -> . BOOL_CONSTT
    (75) c_literal -> . BOOL_CONSTF
    (76) c_literal -> . KEYWORD_NULL

    PLUS            shift and go to state 36
    MINUS           shift and go to state 29
    TILDA           shift and go to state 72
    NOT             shift and go to state 57
    LPAREN          shift and go to state 94
    IDENTIFIER      shift and go to state 77
    DOUBLE_NUMBER   shift and go to state 33
    INT_NUMBER      shift and go to state 44
    CHAR            shift and go to state 63
    STRING          shift and go to state 76
    BOOL_CONSTT     shift and go to state 35
    BOOL_CONSTF     shift and go to state 30
    KEYWORD_NULL    shift and go to state 65

    unary_expression               shift and go to state 45
    primary                        shift and go to state 62
    unary_expression_not_plus_minus shift and go to state 46
    array_access                   shift and go to state 28
    simple_name                    shift and go to state 67
    c_literal                      shift and go to state 93
    base_variable_set              shift and go to state 88
    valid_variable                 shift and go to state 110
    literal                        shift and go to state 71
    additive_expression            shift and go to state 66
    method_invocation              shift and go to state 111
    relational_expression          shift and go to state 73
    qualified_name                 shift and go to state 79
    multiplicative_expression      shift and go to state 52
    cast_expression                shift and go to state 80
    shift_expression               shift and go to state 54
    equality_expression            shift and go to state 205
    int_float                      shift and go to state 40
    variable_literal               shift and go to state 55
    name                           shift and go to state 112

state 153

    (12) block_statements -> block_statements block_statement .

    KEYWORD_IF      reduce using rule 12 (block_statements -> block_statements block_statement .)
    KEYWORD_WHILE   reduce using rule 12 (block_statements -> block_statements block_statement .)
    KEYWORD_DO      reduce using rule 12 (block_statements -> block_statements block_statement .)
    KEYWORD_FOR     reduce using rule 12 (block_statements -> block_statements block_statement .)
    KEYWORD_OBJECT  reduce using rule 12 (block_statements -> block_statements block_statement .)
    BLOCKBEGIN      reduce using rule 12 (block_statements -> block_statements block_statement .)
    TERMINATOR      reduce using rule 12 (block_statements -> block_statements block_statement .)
    KEYWORD_RETURN  reduce using rule 12 (block_statements -> block_statements block_statement .)
    KEYWORD_PROTECTED reduce using rule 12 (block_statements -> block_statements block_statement .)
    KEYWORD_PRIVATE reduce using rule 12 (block_statements -> block_statements block_statement .)
    IDENTIFIER      reduce using rule 12 (block_statements -> block_statements block_statement .)
    PLUS            reduce using rule 12 (block_statements -> block_statements block_statement .)
    MINUS           reduce using rule 12 (block_statements -> block_statements block_statement .)
    TILDA           reduce using rule 12 (block_statements -> block_statements block_statement .)
    NOT             reduce using rule 12 (block_statements -> block_statements block_statement .)
    LPAREN          reduce using rule 12 (block_statements -> block_statements block_statement .)
    DOUBLE_NUMBER   reduce using rule 12 (block_statements -> block_statements block_statement .)
    INT_NUMBER      reduce using rule 12 (block_statements -> block_statements block_statement .)
    CHAR            reduce using rule 12 (block_statements -> block_statements block_statement .)
    STRING          reduce using rule 12 (block_statements -> block_statements block_statement .)
    BOOL_CONSTT     reduce using rule 12 (block_statements -> block_statements block_statement .)
    BOOL_CONSTF     reduce using rule 12 (block_statements -> block_statements block_statement .)
    KEYWORD_NULL    reduce using rule 12 (block_statements -> block_statements block_statement .)
    KEYWORD_DEF     reduce using rule 12 (block_statements -> block_statements block_statement .)
    KEYWORD_CLASS   reduce using rule 12 (block_statements -> block_statements block_statement .)
    KEYWORD_VAR     reduce using rule 12 (block_statements -> block_statements block_statement .)
    KEYWORD_VAL     reduce using rule 12 (block_statements -> block_statements block_statement .)
    BLOCKEND        reduce using rule 12 (block_statements -> block_statements block_statement .)
    KEYWORD_CASE    reduce using rule 12 (block_statements -> block_statements block_statement .)


state 154

    (106) primitive_type -> TYPE_INT .

    RBRAC           reduce using rule 106 (primitive_type -> TYPE_INT .)
    COMMA           reduce using rule 106 (primitive_type -> TYPE_INT .)
    RPAREN          reduce using rule 106 (primitive_type -> TYPE_INT .)
    ASOP            reduce using rule 106 (primitive_type -> TYPE_INT .)


state 155

    (109) primitive_type -> TYPE_STRING .

    RBRAC           reduce using rule 109 (primitive_type -> TYPE_STRING .)
    COMMA           reduce using rule 109 (primitive_type -> TYPE_STRING .)
    RPAREN          reduce using rule 109 (primitive_type -> TYPE_STRING .)
    ASOP            reduce using rule 109 (primitive_type -> TYPE_STRING .)


state 156

    (108) primitive_type -> TYPE_CHAR .

    RBRAC           reduce using rule 108 (primitive_type -> TYPE_CHAR .)
    COMMA           reduce using rule 108 (primitive_type -> TYPE_CHAR .)
    RPAREN          reduce using rule 108 (primitive_type -> TYPE_CHAR .)
    ASOP            reduce using rule 108 (primitive_type -> TYPE_CHAR .)


state 157

    (67) cast_expression -> LPAREN primitive_type . RPAREN unary_expression

    RPAREN          shift and go to state 206


state 158

    (110) primitive_type -> TYPE_BOOLEAN .

    RBRAC           reduce using rule 110 (primitive_type -> TYPE_BOOLEAN .)
    COMMA           reduce using rule 110 (primitive_type -> TYPE_BOOLEAN .)
    RPAREN          reduce using rule 110 (primitive_type -> TYPE_BOOLEAN .)
    ASOP            reduce using rule 110 (primitive_type -> TYPE_BOOLEAN .)


state 159

    (107) primitive_type -> TYPE_DOUBLE .

    RBRAC           reduce using rule 107 (primitive_type -> TYPE_DOUBLE .)
    COMMA           reduce using rule 107 (primitive_type -> TYPE_DOUBLE .)
    RPAREN          reduce using rule 107 (primitive_type -> TYPE_DOUBLE .)
    ASOP            reduce using rule 107 (primitive_type -> TYPE_DOUBLE .)


state 160

    (64) base_variable_set -> LPAREN expression . RPAREN

    RPAREN          shift and go to state 207


state 161

    (91) local_variable_declaration -> modifier_opts declaration_keyword . variable_declaration_body
    (97) variable_declaration_body -> . variable_declarator ASOP variable_declaration_initializer
    (98) variable_declaration_body -> . LPAREN variable_declarators RPAREN ASOP LPAREN variable_arguement_list RPAREN
    (99) variable_declaration_body -> . IDENTIFIER ASOP LPAREN func_arguement_list_opt RPAREN FUNTYPE expression
    (102) variable_declarator -> . variable_declarator_id
    (103) variable_declarator_id -> . IDENTIFIER COLON type

    LPAREN          shift and go to state 210
    IDENTIFIER      shift and go to state 211

    variable_declaration_body      shift and go to state 208
    variable_declarator            shift and go to state 209
    variable_declarator_id         shift and go to state 172

state 162

    (182) method_header_name -> modifier_opts KEYWORD_DEF . IDENTIFIER

    IDENTIFIER      shift and go to state 212


state 163

    (143) for_statement -> KEYWORD_FOR LPAREN . for_logic RPAREN statement
    (144) for_logic -> . for_update
    (145) for_logic -> . for_update TERMINATOR for_logic
    (146) for_update -> . for_loop for_step_opts
    (147) for_loop -> . IDENTIFIER CHOOSE expression for_untilTo expression

    IDENTIFIER      shift and go to state 216

    for_loop                       shift and go to state 213
    for_logic                      shift and go to state 214
    for_update                     shift and go to state 215

state 164

    (142) do_while_statement -> KEYWORD_DO statement . KEYWORD_WHILE LPAREN expression RPAREN TERMINATOR

    KEYWORD_WHILE   shift and go to state 217


state 165

    (167) class_header_name -> class_header_name1 LPAREN constructor_arguement_list_opt RPAREN .

    KEYWORD_EXTENDS reduce using rule 167 (class_header_name -> class_header_name1 LPAREN constructor_arguement_list_opt RPAREN .)
    BLOCKBEGIN      reduce using rule 167 (class_header_name -> class_header_name1 LPAREN constructor_arguement_list_opt RPAREN .)


state 166

    (176) constructor_arguement_list_declarator -> declaration_keyword IDENTIFIER . COLON type

    COLON           shift and go to state 218


state 167

    (175) constructor_arguement_list -> constructor_arguement_list COMMA . constructor_arguement_list_declarator
    (176) constructor_arguement_list_declarator -> . declaration_keyword IDENTIFIER COLON type
    (88) declaration_keyword -> . KEYWORD_VAR
    (89) declaration_keyword -> . KEYWORD_VAL

    KEYWORD_VAR     shift and go to state 100
    KEYWORD_VAL     shift and go to state 103

    declaration_keyword            shift and go to state 101
    constructor_arguement_list_declarator shift and go to state 219

state 168

    (7) ObjectDeclare -> KEYWORD_OBJECT IDENTIFIER KEYWORD_EXTENDS IDENTIFIER .

    BLOCKBEGIN      reduce using rule 7 (ObjectDeclare -> KEYWORD_OBJECT IDENTIFIER KEYWORD_EXTENDS IDENTIFIER .)


state 169

    (171) class_header_extends -> KEYWORD_EXTENDS name LPAREN . func_arguement_list_opt RPAREN
    (183) func_arguement_list_opt -> . variable_declarators
    (184) func_arguement_list_opt -> . empty
    (100) variable_declarators -> . variable_declarator
    (101) variable_declarators -> . variable_declarators COMMA variable_declarator
    (186) empty -> .
    (102) variable_declarator -> . variable_declarator_id
    (103) variable_declarator_id -> . IDENTIFIER COLON type

    RPAREN          reduce using rule 186 (empty -> .)
    IDENTIFIER      shift and go to state 175

    func_arguement_list_opt        shift and go to state 220
    variable_declarators           shift and go to state 173
    variable_declarator            shift and go to state 174
    variable_declarator_id         shift and go to state 172
    empty                          shift and go to state 176

state 170

    (33) inclusive_or_expression -> inclusive_or_expression OR_BITWISE exclusive_or_expression .
    (35) exclusive_or_expression -> exclusive_or_expression . XOR and_expression

    OR_BITWISE      reduce using rule 33 (inclusive_or_expression -> inclusive_or_expression OR_BITWISE exclusive_or_expression .)
    AND             reduce using rule 33 (inclusive_or_expression -> inclusive_or_expression OR_BITWISE exclusive_or_expression .)
    OR              reduce using rule 33 (inclusive_or_expression -> inclusive_or_expression OR_BITWISE exclusive_or_expression .)
    KEYWORD_MATCH   reduce using rule 33 (inclusive_or_expression -> inclusive_or_expression OR_BITWISE exclusive_or_expression .)
    TERMINATOR      reduce using rule 33 (inclusive_or_expression -> inclusive_or_expression OR_BITWISE exclusive_or_expression .)
    RPAREN          reduce using rule 33 (inclusive_or_expression -> inclusive_or_expression OR_BITWISE exclusive_or_expression .)
    RBRAC           reduce using rule 33 (inclusive_or_expression -> inclusive_or_expression OR_BITWISE exclusive_or_expression .)
    COMMA           reduce using rule 33 (inclusive_or_expression -> inclusive_or_expression OR_BITWISE exclusive_or_expression .)
    FUNTYPE         reduce using rule 33 (inclusive_or_expression -> inclusive_or_expression OR_BITWISE exclusive_or_expression .)
    KEYWORD_UNTIL   reduce using rule 33 (inclusive_or_expression -> inclusive_or_expression OR_BITWISE exclusive_or_expression .)
    KEYWORD_TO      reduce using rule 33 (inclusive_or_expression -> inclusive_or_expression OR_BITWISE exclusive_or_expression .)
    KEYWORD_BY      reduce using rule 33 (inclusive_or_expression -> inclusive_or_expression OR_BITWISE exclusive_or_expression .)
    XOR             shift and go to state 133


state 171

    (179) method_header -> method_header_name LPAREN func_arguement_list_opt . RPAREN COLON method_return_type ASOP

    RPAREN          shift and go to state 221


state 172

    (102) variable_declarator -> variable_declarator_id .

    ASOP            reduce using rule 102 (variable_declarator -> variable_declarator_id .)
    RPAREN          reduce using rule 102 (variable_declarator -> variable_declarator_id .)
    COMMA           reduce using rule 102 (variable_declarator -> variable_declarator_id .)


state 173

    (183) func_arguement_list_opt -> variable_declarators .
    (101) variable_declarators -> variable_declarators . COMMA variable_declarator

    RPAREN          reduce using rule 183 (func_arguement_list_opt -> variable_declarators .)
    COMMA           shift and go to state 222


state 174

    (100) variable_declarators -> variable_declarator .

    COMMA           reduce using rule 100 (variable_declarators -> variable_declarator .)
    RPAREN          reduce using rule 100 (variable_declarators -> variable_declarator .)


state 175

    (103) variable_declarator_id -> IDENTIFIER . COLON type

    COLON           shift and go to state 223


state 176

    (184) func_arguement_list_opt -> empty .

    RPAREN          reduce using rule 184 (func_arguement_list_opt -> empty .)


state 177

    (26) array_access -> name LBRAC expression . RBRAC

    RBRAC           shift and go to state 224


state 178

    (118) qualified_name -> name INST simple_name .

    INST            reduce using rule 118 (qualified_name -> name INST simple_name .)
    COMMA           reduce using rule 118 (qualified_name -> name INST simple_name .)
    RPAREN          reduce using rule 118 (qualified_name -> name INST simple_name .)
    ASOP            reduce using rule 118 (qualified_name -> name INST simple_name .)
    LPAREN          reduce using rule 118 (qualified_name -> name INST simple_name .)
    LBRAC           reduce using rule 118 (qualified_name -> name INST simple_name .)
    TIMES           reduce using rule 118 (qualified_name -> name INST simple_name .)
    DIVIDE          reduce using rule 118 (qualified_name -> name INST simple_name .)
    REMAINDER       reduce using rule 118 (qualified_name -> name INST simple_name .)
    PLUS            reduce using rule 118 (qualified_name -> name INST simple_name .)
    MINUS           reduce using rule 118 (qualified_name -> name INST simple_name .)
    LSHIFT          reduce using rule 118 (qualified_name -> name INST simple_name .)
    RSHIFT          reduce using rule 118 (qualified_name -> name INST simple_name .)
    GREATER         reduce using rule 118 (qualified_name -> name INST simple_name .)
    LESS            reduce using rule 118 (qualified_name -> name INST simple_name .)
    GEQ             reduce using rule 118 (qualified_name -> name INST simple_name .)
    LEQ             reduce using rule 118 (qualified_name -> name INST simple_name .)
    EQUAL           reduce using rule 118 (qualified_name -> name INST simple_name .)
    NEQUAL          reduce using rule 118 (qualified_name -> name INST simple_name .)
    AND_BITWISE     reduce using rule 118 (qualified_name -> name INST simple_name .)
    XOR             reduce using rule 118 (qualified_name -> name INST simple_name .)
    OR_BITWISE      reduce using rule 118 (qualified_name -> name INST simple_name .)
    AND             reduce using rule 118 (qualified_name -> name INST simple_name .)
    OR              reduce using rule 118 (qualified_name -> name INST simple_name .)
    KEYWORD_MATCH   reduce using rule 118 (qualified_name -> name INST simple_name .)
    TERMINATOR      reduce using rule 118 (qualified_name -> name INST simple_name .)
    RBRAC           reduce using rule 118 (qualified_name -> name INST simple_name .)
    FUNTYPE         reduce using rule 118 (qualified_name -> name INST simple_name .)
    KEYWORD_UNTIL   reduce using rule 118 (qualified_name -> name INST simple_name .)
    KEYWORD_TO      reduce using rule 118 (qualified_name -> name INST simple_name .)
    KEYWORD_BY      reduce using rule 118 (qualified_name -> name INST simple_name .)


state 179

    (80) argument_list_opt -> argument_list .
    (83) argument_list -> argument_list . COMMA expression

    RPAREN          reduce using rule 80 (argument_list_opt -> argument_list .)
    COMMA           shift and go to state 225


state 180

    (81) argument_list_opt -> empty .

    RPAREN          reduce using rule 81 (argument_list_opt -> empty .)


state 181

    (79) method_invocation -> name LPAREN argument_list_opt . RPAREN

    RPAREN          shift and go to state 226


state 182

    (82) argument_list -> expression .

    COMMA           reduce using rule 82 (argument_list -> expression .)
    RPAREN          reduce using rule 82 (argument_list -> expression .)


state 183

    (23) assignment -> valid_variable assignment_operator assignment_expression .

    COMMA           reduce using rule 23 (assignment -> valid_variable assignment_operator assignment_expression .)
    RPAREN          reduce using rule 23 (assignment -> valid_variable assignment_operator assignment_expression .)
    TERMINATOR      reduce using rule 23 (assignment -> valid_variable assignment_operator assignment_expression .)
    KEYWORD_MATCH   reduce using rule 23 (assignment -> valid_variable assignment_operator assignment_expression .)
    RBRAC           reduce using rule 23 (assignment -> valid_variable assignment_operator assignment_expression .)
    FUNTYPE         reduce using rule 23 (assignment -> valid_variable assignment_operator assignment_expression .)
    KEYWORD_UNTIL   reduce using rule 23 (assignment -> valid_variable assignment_operator assignment_expression .)
    KEYWORD_TO      reduce using rule 23 (assignment -> valid_variable assignment_operator assignment_expression .)
    KEYWORD_BY      reduce using rule 23 (assignment -> valid_variable assignment_operator assignment_expression .)


state 184

    (29) conditional_or_expression -> conditional_or_expression OR conditional_and_expression .
    (31) conditional_and_expression -> conditional_and_expression . AND inclusive_or_expression

    OR              reduce using rule 29 (conditional_or_expression -> conditional_or_expression OR conditional_and_expression .)
    KEYWORD_MATCH   reduce using rule 29 (conditional_or_expression -> conditional_or_expression OR conditional_and_expression .)
    RPAREN          reduce using rule 29 (conditional_or_expression -> conditional_or_expression OR conditional_and_expression .)
    COMMA           reduce using rule 29 (conditional_or_expression -> conditional_or_expression OR conditional_and_expression .)
    TERMINATOR      reduce using rule 29 (conditional_or_expression -> conditional_or_expression OR conditional_and_expression .)
    FUNTYPE         reduce using rule 29 (conditional_or_expression -> conditional_or_expression OR conditional_and_expression .)
    KEYWORD_BY      reduce using rule 29 (conditional_or_expression -> conditional_or_expression OR conditional_and_expression .)
    KEYWORD_UNTIL   reduce using rule 29 (conditional_or_expression -> conditional_or_expression OR conditional_and_expression .)
    KEYWORD_TO      reduce using rule 29 (conditional_or_expression -> conditional_or_expression OR conditional_and_expression .)
    RBRAC           reduce using rule 29 (conditional_or_expression -> conditional_or_expression OR conditional_and_expression .)
    AND             shift and go to state 130


state 185

    (141) while_statement -> KEYWORD_WHILE LPAREN expression . RPAREN statement

    RPAREN          shift and go to state 227


state 186

    (55) multiplicative_expression -> multiplicative_expression REMAINDER unary_expression .

    TIMES           reduce using rule 55 (multiplicative_expression -> multiplicative_expression REMAINDER unary_expression .)
    DIVIDE          reduce using rule 55 (multiplicative_expression -> multiplicative_expression REMAINDER unary_expression .)
    REMAINDER       reduce using rule 55 (multiplicative_expression -> multiplicative_expression REMAINDER unary_expression .)
    PLUS            reduce using rule 55 (multiplicative_expression -> multiplicative_expression REMAINDER unary_expression .)
    MINUS           reduce using rule 55 (multiplicative_expression -> multiplicative_expression REMAINDER unary_expression .)
    LSHIFT          reduce using rule 55 (multiplicative_expression -> multiplicative_expression REMAINDER unary_expression .)
    RSHIFT          reduce using rule 55 (multiplicative_expression -> multiplicative_expression REMAINDER unary_expression .)
    GREATER         reduce using rule 55 (multiplicative_expression -> multiplicative_expression REMAINDER unary_expression .)
    LESS            reduce using rule 55 (multiplicative_expression -> multiplicative_expression REMAINDER unary_expression .)
    GEQ             reduce using rule 55 (multiplicative_expression -> multiplicative_expression REMAINDER unary_expression .)
    LEQ             reduce using rule 55 (multiplicative_expression -> multiplicative_expression REMAINDER unary_expression .)
    EQUAL           reduce using rule 55 (multiplicative_expression -> multiplicative_expression REMAINDER unary_expression .)
    NEQUAL          reduce using rule 55 (multiplicative_expression -> multiplicative_expression REMAINDER unary_expression .)
    AND_BITWISE     reduce using rule 55 (multiplicative_expression -> multiplicative_expression REMAINDER unary_expression .)
    XOR             reduce using rule 55 (multiplicative_expression -> multiplicative_expression REMAINDER unary_expression .)
    OR_BITWISE      reduce using rule 55 (multiplicative_expression -> multiplicative_expression REMAINDER unary_expression .)
    AND             reduce using rule 55 (multiplicative_expression -> multiplicative_expression REMAINDER unary_expression .)
    OR              reduce using rule 55 (multiplicative_expression -> multiplicative_expression REMAINDER unary_expression .)
    KEYWORD_MATCH   reduce using rule 55 (multiplicative_expression -> multiplicative_expression REMAINDER unary_expression .)
    TERMINATOR      reduce using rule 55 (multiplicative_expression -> multiplicative_expression REMAINDER unary_expression .)
    RPAREN          reduce using rule 55 (multiplicative_expression -> multiplicative_expression REMAINDER unary_expression .)
    RBRAC           reduce using rule 55 (multiplicative_expression -> multiplicative_expression REMAINDER unary_expression .)
    COMMA           reduce using rule 55 (multiplicative_expression -> multiplicative_expression REMAINDER unary_expression .)
    FUNTYPE         reduce using rule 55 (multiplicative_expression -> multiplicative_expression REMAINDER unary_expression .)
    KEYWORD_UNTIL   reduce using rule 55 (multiplicative_expression -> multiplicative_expression REMAINDER unary_expression .)
    KEYWORD_TO      reduce using rule 55 (multiplicative_expression -> multiplicative_expression REMAINDER unary_expression .)
    KEYWORD_BY      reduce using rule 55 (multiplicative_expression -> multiplicative_expression REMAINDER unary_expression .)


state 187

    (54) multiplicative_expression -> multiplicative_expression DIVIDE unary_expression .

    TIMES           reduce using rule 54 (multiplicative_expression -> multiplicative_expression DIVIDE unary_expression .)
    DIVIDE          reduce using rule 54 (multiplicative_expression -> multiplicative_expression DIVIDE unary_expression .)
    REMAINDER       reduce using rule 54 (multiplicative_expression -> multiplicative_expression DIVIDE unary_expression .)
    PLUS            reduce using rule 54 (multiplicative_expression -> multiplicative_expression DIVIDE unary_expression .)
    MINUS           reduce using rule 54 (multiplicative_expression -> multiplicative_expression DIVIDE unary_expression .)
    LSHIFT          reduce using rule 54 (multiplicative_expression -> multiplicative_expression DIVIDE unary_expression .)
    RSHIFT          reduce using rule 54 (multiplicative_expression -> multiplicative_expression DIVIDE unary_expression .)
    GREATER         reduce using rule 54 (multiplicative_expression -> multiplicative_expression DIVIDE unary_expression .)
    LESS            reduce using rule 54 (multiplicative_expression -> multiplicative_expression DIVIDE unary_expression .)
    GEQ             reduce using rule 54 (multiplicative_expression -> multiplicative_expression DIVIDE unary_expression .)
    LEQ             reduce using rule 54 (multiplicative_expression -> multiplicative_expression DIVIDE unary_expression .)
    EQUAL           reduce using rule 54 (multiplicative_expression -> multiplicative_expression DIVIDE unary_expression .)
    NEQUAL          reduce using rule 54 (multiplicative_expression -> multiplicative_expression DIVIDE unary_expression .)
    AND_BITWISE     reduce using rule 54 (multiplicative_expression -> multiplicative_expression DIVIDE unary_expression .)
    XOR             reduce using rule 54 (multiplicative_expression -> multiplicative_expression DIVIDE unary_expression .)
    OR_BITWISE      reduce using rule 54 (multiplicative_expression -> multiplicative_expression DIVIDE unary_expression .)
    AND             reduce using rule 54 (multiplicative_expression -> multiplicative_expression DIVIDE unary_expression .)
    OR              reduce using rule 54 (multiplicative_expression -> multiplicative_expression DIVIDE unary_expression .)
    KEYWORD_MATCH   reduce using rule 54 (multiplicative_expression -> multiplicative_expression DIVIDE unary_expression .)
    TERMINATOR      reduce using rule 54 (multiplicative_expression -> multiplicative_expression DIVIDE unary_expression .)
    RPAREN          reduce using rule 54 (multiplicative_expression -> multiplicative_expression DIVIDE unary_expression .)
    RBRAC           reduce using rule 54 (multiplicative_expression -> multiplicative_expression DIVIDE unary_expression .)
    COMMA           reduce using rule 54 (multiplicative_expression -> multiplicative_expression DIVIDE unary_expression .)
    FUNTYPE         reduce using rule 54 (multiplicative_expression -> multiplicative_expression DIVIDE unary_expression .)
    KEYWORD_UNTIL   reduce using rule 54 (multiplicative_expression -> multiplicative_expression DIVIDE unary_expression .)
    KEYWORD_TO      reduce using rule 54 (multiplicative_expression -> multiplicative_expression DIVIDE unary_expression .)
    KEYWORD_BY      reduce using rule 54 (multiplicative_expression -> multiplicative_expression DIVIDE unary_expression .)


state 188

    (53) multiplicative_expression -> multiplicative_expression TIMES unary_expression .

    TIMES           reduce using rule 53 (multiplicative_expression -> multiplicative_expression TIMES unary_expression .)
    DIVIDE          reduce using rule 53 (multiplicative_expression -> multiplicative_expression TIMES unary_expression .)
    REMAINDER       reduce using rule 53 (multiplicative_expression -> multiplicative_expression TIMES unary_expression .)
    PLUS            reduce using rule 53 (multiplicative_expression -> multiplicative_expression TIMES unary_expression .)
    MINUS           reduce using rule 53 (multiplicative_expression -> multiplicative_expression TIMES unary_expression .)
    LSHIFT          reduce using rule 53 (multiplicative_expression -> multiplicative_expression TIMES unary_expression .)
    RSHIFT          reduce using rule 53 (multiplicative_expression -> multiplicative_expression TIMES unary_expression .)
    GREATER         reduce using rule 53 (multiplicative_expression -> multiplicative_expression TIMES unary_expression .)
    LESS            reduce using rule 53 (multiplicative_expression -> multiplicative_expression TIMES unary_expression .)
    GEQ             reduce using rule 53 (multiplicative_expression -> multiplicative_expression TIMES unary_expression .)
    LEQ             reduce using rule 53 (multiplicative_expression -> multiplicative_expression TIMES unary_expression .)
    EQUAL           reduce using rule 53 (multiplicative_expression -> multiplicative_expression TIMES unary_expression .)
    NEQUAL          reduce using rule 53 (multiplicative_expression -> multiplicative_expression TIMES unary_expression .)
    AND_BITWISE     reduce using rule 53 (multiplicative_expression -> multiplicative_expression TIMES unary_expression .)
    XOR             reduce using rule 53 (multiplicative_expression -> multiplicative_expression TIMES unary_expression .)
    OR_BITWISE      reduce using rule 53 (multiplicative_expression -> multiplicative_expression TIMES unary_expression .)
    AND             reduce using rule 53 (multiplicative_expression -> multiplicative_expression TIMES unary_expression .)
    OR              reduce using rule 53 (multiplicative_expression -> multiplicative_expression TIMES unary_expression .)
    KEYWORD_MATCH   reduce using rule 53 (multiplicative_expression -> multiplicative_expression TIMES unary_expression .)
    TERMINATOR      reduce using rule 53 (multiplicative_expression -> multiplicative_expression TIMES unary_expression .)
    RPAREN          reduce using rule 53 (multiplicative_expression -> multiplicative_expression TIMES unary_expression .)
    RBRAC           reduce using rule 53 (multiplicative_expression -> multiplicative_expression TIMES unary_expression .)
    COMMA           reduce using rule 53 (multiplicative_expression -> multiplicative_expression TIMES unary_expression .)
    FUNTYPE         reduce using rule 53 (multiplicative_expression -> multiplicative_expression TIMES unary_expression .)
    KEYWORD_UNTIL   reduce using rule 53 (multiplicative_expression -> multiplicative_expression TIMES unary_expression .)
    KEYWORD_TO      reduce using rule 53 (multiplicative_expression -> multiplicative_expression TIMES unary_expression .)
    KEYWORD_BY      reduce using rule 53 (multiplicative_expression -> multiplicative_expression TIMES unary_expression .)


state 189

    (48) shift_expression -> shift_expression RSHIFT additive_expression .
    (50) additive_expression -> additive_expression . PLUS multiplicative_expression
    (51) additive_expression -> additive_expression . MINUS multiplicative_expression

    LSHIFT          reduce using rule 48 (shift_expression -> shift_expression RSHIFT additive_expression .)
    RSHIFT          reduce using rule 48 (shift_expression -> shift_expression RSHIFT additive_expression .)
    GREATER         reduce using rule 48 (shift_expression -> shift_expression RSHIFT additive_expression .)
    LESS            reduce using rule 48 (shift_expression -> shift_expression RSHIFT additive_expression .)
    GEQ             reduce using rule 48 (shift_expression -> shift_expression RSHIFT additive_expression .)
    LEQ             reduce using rule 48 (shift_expression -> shift_expression RSHIFT additive_expression .)
    EQUAL           reduce using rule 48 (shift_expression -> shift_expression RSHIFT additive_expression .)
    NEQUAL          reduce using rule 48 (shift_expression -> shift_expression RSHIFT additive_expression .)
    AND_BITWISE     reduce using rule 48 (shift_expression -> shift_expression RSHIFT additive_expression .)
    XOR             reduce using rule 48 (shift_expression -> shift_expression RSHIFT additive_expression .)
    OR_BITWISE      reduce using rule 48 (shift_expression -> shift_expression RSHIFT additive_expression .)
    AND             reduce using rule 48 (shift_expression -> shift_expression RSHIFT additive_expression .)
    OR              reduce using rule 48 (shift_expression -> shift_expression RSHIFT additive_expression .)
    RPAREN          reduce using rule 48 (shift_expression -> shift_expression RSHIFT additive_expression .)
    KEYWORD_UNTIL   reduce using rule 48 (shift_expression -> shift_expression RSHIFT additive_expression .)
    KEYWORD_TO      reduce using rule 48 (shift_expression -> shift_expression RSHIFT additive_expression .)
    KEYWORD_MATCH   reduce using rule 48 (shift_expression -> shift_expression RSHIFT additive_expression .)
    TERMINATOR      reduce using rule 48 (shift_expression -> shift_expression RSHIFT additive_expression .)
    RBRAC           reduce using rule 48 (shift_expression -> shift_expression RSHIFT additive_expression .)
    COMMA           reduce using rule 48 (shift_expression -> shift_expression RSHIFT additive_expression .)
    FUNTYPE         reduce using rule 48 (shift_expression -> shift_expression RSHIFT additive_expression .)
    KEYWORD_BY      reduce using rule 48 (shift_expression -> shift_expression RSHIFT additive_expression .)
    PLUS            shift and go to state 134
    MINUS           shift and go to state 135


state 190

    (47) shift_expression -> shift_expression LSHIFT additive_expression .
    (50) additive_expression -> additive_expression . PLUS multiplicative_expression
    (51) additive_expression -> additive_expression . MINUS multiplicative_expression

    LSHIFT          reduce using rule 47 (shift_expression -> shift_expression LSHIFT additive_expression .)
    RSHIFT          reduce using rule 47 (shift_expression -> shift_expression LSHIFT additive_expression .)
    GREATER         reduce using rule 47 (shift_expression -> shift_expression LSHIFT additive_expression .)
    LESS            reduce using rule 47 (shift_expression -> shift_expression LSHIFT additive_expression .)
    GEQ             reduce using rule 47 (shift_expression -> shift_expression LSHIFT additive_expression .)
    LEQ             reduce using rule 47 (shift_expression -> shift_expression LSHIFT additive_expression .)
    EQUAL           reduce using rule 47 (shift_expression -> shift_expression LSHIFT additive_expression .)
    NEQUAL          reduce using rule 47 (shift_expression -> shift_expression LSHIFT additive_expression .)
    AND_BITWISE     reduce using rule 47 (shift_expression -> shift_expression LSHIFT additive_expression .)
    XOR             reduce using rule 47 (shift_expression -> shift_expression LSHIFT additive_expression .)
    OR_BITWISE      reduce using rule 47 (shift_expression -> shift_expression LSHIFT additive_expression .)
    AND             reduce using rule 47 (shift_expression -> shift_expression LSHIFT additive_expression .)
    OR              reduce using rule 47 (shift_expression -> shift_expression LSHIFT additive_expression .)
    RPAREN          reduce using rule 47 (shift_expression -> shift_expression LSHIFT additive_expression .)
    KEYWORD_UNTIL   reduce using rule 47 (shift_expression -> shift_expression LSHIFT additive_expression .)
    KEYWORD_TO      reduce using rule 47 (shift_expression -> shift_expression LSHIFT additive_expression .)
    KEYWORD_MATCH   reduce using rule 47 (shift_expression -> shift_expression LSHIFT additive_expression .)
    TERMINATOR      reduce using rule 47 (shift_expression -> shift_expression LSHIFT additive_expression .)
    RBRAC           reduce using rule 47 (shift_expression -> shift_expression LSHIFT additive_expression .)
    COMMA           reduce using rule 47 (shift_expression -> shift_expression LSHIFT additive_expression .)
    FUNTYPE         reduce using rule 47 (shift_expression -> shift_expression LSHIFT additive_expression .)
    KEYWORD_BY      reduce using rule 47 (shift_expression -> shift_expression LSHIFT additive_expression .)
    PLUS            shift and go to state 134
    MINUS           shift and go to state 135


state 191

    (31) conditional_and_expression -> conditional_and_expression AND inclusive_or_expression .
    (33) inclusive_or_expression -> inclusive_or_expression . OR_BITWISE exclusive_or_expression

    AND             reduce using rule 31 (conditional_and_expression -> conditional_and_expression AND inclusive_or_expression .)
    OR              reduce using rule 31 (conditional_and_expression -> conditional_and_expression AND inclusive_or_expression .)
    KEYWORD_MATCH   reduce using rule 31 (conditional_and_expression -> conditional_and_expression AND inclusive_or_expression .)
    KEYWORD_BY      reduce using rule 31 (conditional_and_expression -> conditional_and_expression AND inclusive_or_expression .)
    TERMINATOR      reduce using rule 31 (conditional_and_expression -> conditional_and_expression AND inclusive_or_expression .)
    RPAREN          reduce using rule 31 (conditional_and_expression -> conditional_and_expression AND inclusive_or_expression .)
    COMMA           reduce using rule 31 (conditional_and_expression -> conditional_and_expression AND inclusive_or_expression .)
    FUNTYPE         reduce using rule 31 (conditional_and_expression -> conditional_and_expression AND inclusive_or_expression .)
    KEYWORD_UNTIL   reduce using rule 31 (conditional_and_expression -> conditional_and_expression AND inclusive_or_expression .)
    KEYWORD_TO      reduce using rule 31 (conditional_and_expression -> conditional_and_expression AND inclusive_or_expression .)
    RBRAC           reduce using rule 31 (conditional_and_expression -> conditional_and_expression AND inclusive_or_expression .)
    OR_BITWISE      shift and go to state 114


state 192

    (153) switch_block -> BLOCKBEGIN . BLOCKEND
    (154) switch_block -> BLOCKBEGIN . switch_block_statements BLOCKEND
    (155) switch_block -> BLOCKBEGIN . switch_labels BLOCKEND
    (156) switch_block -> BLOCKBEGIN . switch_block_statements switch_labels BLOCKEND
    (157) switch_block_statements -> . switch_block_statement
    (158) switch_block_statements -> . switch_block_statements switch_block_statement
    (160) switch_labels -> . switch_label
    (161) switch_labels -> . switch_labels switch_label
    (159) switch_block_statement -> . switch_labels block_statements
    (162) switch_label -> . KEYWORD_CASE expression FUNTYPE

    BLOCKEND        shift and go to state 231
    KEYWORD_CASE    shift and go to state 230

    switch_block_statements        shift and go to state 232
    switch_labels                  shift and go to state 228
    switch_label                   shift and go to state 229
    switch_block_statement         shift and go to state 233

state 193

    (152) switch_statement -> expression KEYWORD_MATCH switch_block .

    KEYWORD_IF      reduce using rule 152 (switch_statement -> expression KEYWORD_MATCH switch_block .)
    KEYWORD_WHILE   reduce using rule 152 (switch_statement -> expression KEYWORD_MATCH switch_block .)
    KEYWORD_DO      reduce using rule 152 (switch_statement -> expression KEYWORD_MATCH switch_block .)
    KEYWORD_FOR     reduce using rule 152 (switch_statement -> expression KEYWORD_MATCH switch_block .)
    KEYWORD_OBJECT  reduce using rule 152 (switch_statement -> expression KEYWORD_MATCH switch_block .)
    BLOCKBEGIN      reduce using rule 152 (switch_statement -> expression KEYWORD_MATCH switch_block .)
    TERMINATOR      reduce using rule 152 (switch_statement -> expression KEYWORD_MATCH switch_block .)
    KEYWORD_RETURN  reduce using rule 152 (switch_statement -> expression KEYWORD_MATCH switch_block .)
    KEYWORD_PROTECTED reduce using rule 152 (switch_statement -> expression KEYWORD_MATCH switch_block .)
    KEYWORD_PRIVATE reduce using rule 152 (switch_statement -> expression KEYWORD_MATCH switch_block .)
    IDENTIFIER      reduce using rule 152 (switch_statement -> expression KEYWORD_MATCH switch_block .)
    PLUS            reduce using rule 152 (switch_statement -> expression KEYWORD_MATCH switch_block .)
    MINUS           reduce using rule 152 (switch_statement -> expression KEYWORD_MATCH switch_block .)
    TILDA           reduce using rule 152 (switch_statement -> expression KEYWORD_MATCH switch_block .)
    NOT             reduce using rule 152 (switch_statement -> expression KEYWORD_MATCH switch_block .)
    LPAREN          reduce using rule 152 (switch_statement -> expression KEYWORD_MATCH switch_block .)
    DOUBLE_NUMBER   reduce using rule 152 (switch_statement -> expression KEYWORD_MATCH switch_block .)
    INT_NUMBER      reduce using rule 152 (switch_statement -> expression KEYWORD_MATCH switch_block .)
    CHAR            reduce using rule 152 (switch_statement -> expression KEYWORD_MATCH switch_block .)
    STRING          reduce using rule 152 (switch_statement -> expression KEYWORD_MATCH switch_block .)
    BOOL_CONSTT     reduce using rule 152 (switch_statement -> expression KEYWORD_MATCH switch_block .)
    BOOL_CONSTF     reduce using rule 152 (switch_statement -> expression KEYWORD_MATCH switch_block .)
    KEYWORD_NULL    reduce using rule 152 (switch_statement -> expression KEYWORD_MATCH switch_block .)
    KEYWORD_DEF     reduce using rule 152 (switch_statement -> expression KEYWORD_MATCH switch_block .)
    KEYWORD_CLASS   reduce using rule 152 (switch_statement -> expression KEYWORD_MATCH switch_block .)
    KEYWORD_VAR     reduce using rule 152 (switch_statement -> expression KEYWORD_MATCH switch_block .)
    KEYWORD_VAL     reduce using rule 152 (switch_statement -> expression KEYWORD_MATCH switch_block .)
    BLOCKEND        reduce using rule 152 (switch_statement -> expression KEYWORD_MATCH switch_block .)
    KEYWORD_CASE    reduce using rule 152 (switch_statement -> expression KEYWORD_MATCH switch_block .)
    KEYWORD_ELSE    reduce using rule 152 (switch_statement -> expression KEYWORD_MATCH switch_block .)


state 194

    (35) exclusive_or_expression -> exclusive_or_expression XOR and_expression .
    (37) and_expression -> and_expression . AND_BITWISE equality_expression

    XOR             reduce using rule 35 (exclusive_or_expression -> exclusive_or_expression XOR and_expression .)
    OR_BITWISE      reduce using rule 35 (exclusive_or_expression -> exclusive_or_expression XOR and_expression .)
    AND             reduce using rule 35 (exclusive_or_expression -> exclusive_or_expression XOR and_expression .)
    OR              reduce using rule 35 (exclusive_or_expression -> exclusive_or_expression XOR and_expression .)
    KEYWORD_MATCH   reduce using rule 35 (exclusive_or_expression -> exclusive_or_expression XOR and_expression .)
    TERMINATOR      reduce using rule 35 (exclusive_or_expression -> exclusive_or_expression XOR and_expression .)
    RPAREN          reduce using rule 35 (exclusive_or_expression -> exclusive_or_expression XOR and_expression .)
    COMMA           reduce using rule 35 (exclusive_or_expression -> exclusive_or_expression XOR and_expression .)
    FUNTYPE         reduce using rule 35 (exclusive_or_expression -> exclusive_or_expression XOR and_expression .)
    RBRAC           reduce using rule 35 (exclusive_or_expression -> exclusive_or_expression XOR and_expression .)
    KEYWORD_UNTIL   reduce using rule 35 (exclusive_or_expression -> exclusive_or_expression XOR and_expression .)
    KEYWORD_TO      reduce using rule 35 (exclusive_or_expression -> exclusive_or_expression XOR and_expression .)
    KEYWORD_BY      reduce using rule 35 (exclusive_or_expression -> exclusive_or_expression XOR and_expression .)
    AND_BITWISE     shift and go to state 152


state 195

    (50) additive_expression -> additive_expression PLUS multiplicative_expression .
    (53) multiplicative_expression -> multiplicative_expression . TIMES unary_expression
    (54) multiplicative_expression -> multiplicative_expression . DIVIDE unary_expression
    (55) multiplicative_expression -> multiplicative_expression . REMAINDER unary_expression

    PLUS            reduce using rule 50 (additive_expression -> additive_expression PLUS multiplicative_expression .)
    MINUS           reduce using rule 50 (additive_expression -> additive_expression PLUS multiplicative_expression .)
    LSHIFT          reduce using rule 50 (additive_expression -> additive_expression PLUS multiplicative_expression .)
    RSHIFT          reduce using rule 50 (additive_expression -> additive_expression PLUS multiplicative_expression .)
    GREATER         reduce using rule 50 (additive_expression -> additive_expression PLUS multiplicative_expression .)
    LESS            reduce using rule 50 (additive_expression -> additive_expression PLUS multiplicative_expression .)
    GEQ             reduce using rule 50 (additive_expression -> additive_expression PLUS multiplicative_expression .)
    LEQ             reduce using rule 50 (additive_expression -> additive_expression PLUS multiplicative_expression .)
    EQUAL           reduce using rule 50 (additive_expression -> additive_expression PLUS multiplicative_expression .)
    NEQUAL          reduce using rule 50 (additive_expression -> additive_expression PLUS multiplicative_expression .)
    AND_BITWISE     reduce using rule 50 (additive_expression -> additive_expression PLUS multiplicative_expression .)
    XOR             reduce using rule 50 (additive_expression -> additive_expression PLUS multiplicative_expression .)
    OR_BITWISE      reduce using rule 50 (additive_expression -> additive_expression PLUS multiplicative_expression .)
    AND             reduce using rule 50 (additive_expression -> additive_expression PLUS multiplicative_expression .)
    OR              reduce using rule 50 (additive_expression -> additive_expression PLUS multiplicative_expression .)
    KEYWORD_MATCH   reduce using rule 50 (additive_expression -> additive_expression PLUS multiplicative_expression .)
    RPAREN          reduce using rule 50 (additive_expression -> additive_expression PLUS multiplicative_expression .)
    RBRAC           reduce using rule 50 (additive_expression -> additive_expression PLUS multiplicative_expression .)
    TERMINATOR      reduce using rule 50 (additive_expression -> additive_expression PLUS multiplicative_expression .)
    COMMA           reduce using rule 50 (additive_expression -> additive_expression PLUS multiplicative_expression .)
    FUNTYPE         reduce using rule 50 (additive_expression -> additive_expression PLUS multiplicative_expression .)
    KEYWORD_UNTIL   reduce using rule 50 (additive_expression -> additive_expression PLUS multiplicative_expression .)
    KEYWORD_TO      reduce using rule 50 (additive_expression -> additive_expression PLUS multiplicative_expression .)
    KEYWORD_BY      reduce using rule 50 (additive_expression -> additive_expression PLUS multiplicative_expression .)
    TIMES           shift and go to state 127
    DIVIDE          shift and go to state 126
    REMAINDER       shift and go to state 125


state 196

    (51) additive_expression -> additive_expression MINUS multiplicative_expression .
    (53) multiplicative_expression -> multiplicative_expression . TIMES unary_expression
    (54) multiplicative_expression -> multiplicative_expression . DIVIDE unary_expression
    (55) multiplicative_expression -> multiplicative_expression . REMAINDER unary_expression

    PLUS            reduce using rule 51 (additive_expression -> additive_expression MINUS multiplicative_expression .)
    MINUS           reduce using rule 51 (additive_expression -> additive_expression MINUS multiplicative_expression .)
    LSHIFT          reduce using rule 51 (additive_expression -> additive_expression MINUS multiplicative_expression .)
    RSHIFT          reduce using rule 51 (additive_expression -> additive_expression MINUS multiplicative_expression .)
    GREATER         reduce using rule 51 (additive_expression -> additive_expression MINUS multiplicative_expression .)
    LESS            reduce using rule 51 (additive_expression -> additive_expression MINUS multiplicative_expression .)
    GEQ             reduce using rule 51 (additive_expression -> additive_expression MINUS multiplicative_expression .)
    LEQ             reduce using rule 51 (additive_expression -> additive_expression MINUS multiplicative_expression .)
    EQUAL           reduce using rule 51 (additive_expression -> additive_expression MINUS multiplicative_expression .)
    NEQUAL          reduce using rule 51 (additive_expression -> additive_expression MINUS multiplicative_expression .)
    AND_BITWISE     reduce using rule 51 (additive_expression -> additive_expression MINUS multiplicative_expression .)
    XOR             reduce using rule 51 (additive_expression -> additive_expression MINUS multiplicative_expression .)
    OR_BITWISE      reduce using rule 51 (additive_expression -> additive_expression MINUS multiplicative_expression .)
    AND             reduce using rule 51 (additive_expression -> additive_expression MINUS multiplicative_expression .)
    OR              reduce using rule 51 (additive_expression -> additive_expression MINUS multiplicative_expression .)
    KEYWORD_MATCH   reduce using rule 51 (additive_expression -> additive_expression MINUS multiplicative_expression .)
    RPAREN          reduce using rule 51 (additive_expression -> additive_expression MINUS multiplicative_expression .)
    RBRAC           reduce using rule 51 (additive_expression -> additive_expression MINUS multiplicative_expression .)
    TERMINATOR      reduce using rule 51 (additive_expression -> additive_expression MINUS multiplicative_expression .)
    COMMA           reduce using rule 51 (additive_expression -> additive_expression MINUS multiplicative_expression .)
    FUNTYPE         reduce using rule 51 (additive_expression -> additive_expression MINUS multiplicative_expression .)
    KEYWORD_UNTIL   reduce using rule 51 (additive_expression -> additive_expression MINUS multiplicative_expression .)
    KEYWORD_TO      reduce using rule 51 (additive_expression -> additive_expression MINUS multiplicative_expression .)
    KEYWORD_BY      reduce using rule 51 (additive_expression -> additive_expression MINUS multiplicative_expression .)
    TIMES           shift and go to state 127
    DIVIDE          shift and go to state 126
    REMAINDER       shift and go to state 125


state 197

    (164) return_statement -> KEYWORD_RETURN expression_optional TERMINATOR .

    KEYWORD_IF      reduce using rule 164 (return_statement -> KEYWORD_RETURN expression_optional TERMINATOR .)
    KEYWORD_WHILE   reduce using rule 164 (return_statement -> KEYWORD_RETURN expression_optional TERMINATOR .)
    KEYWORD_DO      reduce using rule 164 (return_statement -> KEYWORD_RETURN expression_optional TERMINATOR .)
    KEYWORD_FOR     reduce using rule 164 (return_statement -> KEYWORD_RETURN expression_optional TERMINATOR .)
    KEYWORD_OBJECT  reduce using rule 164 (return_statement -> KEYWORD_RETURN expression_optional TERMINATOR .)
    BLOCKBEGIN      reduce using rule 164 (return_statement -> KEYWORD_RETURN expression_optional TERMINATOR .)
    TERMINATOR      reduce using rule 164 (return_statement -> KEYWORD_RETURN expression_optional TERMINATOR .)
    KEYWORD_RETURN  reduce using rule 164 (return_statement -> KEYWORD_RETURN expression_optional TERMINATOR .)
    KEYWORD_PROTECTED reduce using rule 164 (return_statement -> KEYWORD_RETURN expression_optional TERMINATOR .)
    KEYWORD_PRIVATE reduce using rule 164 (return_statement -> KEYWORD_RETURN expression_optional TERMINATOR .)
    IDENTIFIER      reduce using rule 164 (return_statement -> KEYWORD_RETURN expression_optional TERMINATOR .)
    PLUS            reduce using rule 164 (return_statement -> KEYWORD_RETURN expression_optional TERMINATOR .)
    MINUS           reduce using rule 164 (return_statement -> KEYWORD_RETURN expression_optional TERMINATOR .)
    TILDA           reduce using rule 164 (return_statement -> KEYWORD_RETURN expression_optional TERMINATOR .)
    NOT             reduce using rule 164 (return_statement -> KEYWORD_RETURN expression_optional TERMINATOR .)
    LPAREN          reduce using rule 164 (return_statement -> KEYWORD_RETURN expression_optional TERMINATOR .)
    DOUBLE_NUMBER   reduce using rule 164 (return_statement -> KEYWORD_RETURN expression_optional TERMINATOR .)
    INT_NUMBER      reduce using rule 164 (return_statement -> KEYWORD_RETURN expression_optional TERMINATOR .)
    CHAR            reduce using rule 164 (return_statement -> KEYWORD_RETURN expression_optional TERMINATOR .)
    STRING          reduce using rule 164 (return_statement -> KEYWORD_RETURN expression_optional TERMINATOR .)
    BOOL_CONSTT     reduce using rule 164 (return_statement -> KEYWORD_RETURN expression_optional TERMINATOR .)
    BOOL_CONSTF     reduce using rule 164 (return_statement -> KEYWORD_RETURN expression_optional TERMINATOR .)
    KEYWORD_NULL    reduce using rule 164 (return_statement -> KEYWORD_RETURN expression_optional TERMINATOR .)
    KEYWORD_DEF     reduce using rule 164 (return_statement -> KEYWORD_RETURN expression_optional TERMINATOR .)
    KEYWORD_CLASS   reduce using rule 164 (return_statement -> KEYWORD_RETURN expression_optional TERMINATOR .)
    KEYWORD_VAR     reduce using rule 164 (return_statement -> KEYWORD_RETURN expression_optional TERMINATOR .)
    KEYWORD_VAL     reduce using rule 164 (return_statement -> KEYWORD_RETURN expression_optional TERMINATOR .)
    BLOCKEND        reduce using rule 164 (return_statement -> KEYWORD_RETURN expression_optional TERMINATOR .)
    KEYWORD_CASE    reduce using rule 164 (return_statement -> KEYWORD_RETURN expression_optional TERMINATOR .)
    KEYWORD_ELSE    reduce using rule 164 (return_statement -> KEYWORD_RETURN expression_optional TERMINATOR .)


state 198

    (44) relational_expression -> relational_expression GEQ shift_expression .
    (47) shift_expression -> shift_expression . LSHIFT additive_expression
    (48) shift_expression -> shift_expression . RSHIFT additive_expression

    GREATER         reduce using rule 44 (relational_expression -> relational_expression GEQ shift_expression .)
    LESS            reduce using rule 44 (relational_expression -> relational_expression GEQ shift_expression .)
    GEQ             reduce using rule 44 (relational_expression -> relational_expression GEQ shift_expression .)
    LEQ             reduce using rule 44 (relational_expression -> relational_expression GEQ shift_expression .)
    EQUAL           reduce using rule 44 (relational_expression -> relational_expression GEQ shift_expression .)
    NEQUAL          reduce using rule 44 (relational_expression -> relational_expression GEQ shift_expression .)
    AND_BITWISE     reduce using rule 44 (relational_expression -> relational_expression GEQ shift_expression .)
    XOR             reduce using rule 44 (relational_expression -> relational_expression GEQ shift_expression .)
    OR_BITWISE      reduce using rule 44 (relational_expression -> relational_expression GEQ shift_expression .)
    AND             reduce using rule 44 (relational_expression -> relational_expression GEQ shift_expression .)
    OR              reduce using rule 44 (relational_expression -> relational_expression GEQ shift_expression .)
    RPAREN          reduce using rule 44 (relational_expression -> relational_expression GEQ shift_expression .)
    COMMA           reduce using rule 44 (relational_expression -> relational_expression GEQ shift_expression .)
    KEYWORD_MATCH   reduce using rule 44 (relational_expression -> relational_expression GEQ shift_expression .)
    KEYWORD_BY      reduce using rule 44 (relational_expression -> relational_expression GEQ shift_expression .)
    TERMINATOR      reduce using rule 44 (relational_expression -> relational_expression GEQ shift_expression .)
    RBRAC           reduce using rule 44 (relational_expression -> relational_expression GEQ shift_expression .)
    FUNTYPE         reduce using rule 44 (relational_expression -> relational_expression GEQ shift_expression .)
    KEYWORD_UNTIL   reduce using rule 44 (relational_expression -> relational_expression GEQ shift_expression .)
    KEYWORD_TO      reduce using rule 44 (relational_expression -> relational_expression GEQ shift_expression .)
    LSHIFT          shift and go to state 129
    RSHIFT          shift and go to state 128


state 199

    (42) relational_expression -> relational_expression GREATER shift_expression .
    (47) shift_expression -> shift_expression . LSHIFT additive_expression
    (48) shift_expression -> shift_expression . RSHIFT additive_expression

    GREATER         reduce using rule 42 (relational_expression -> relational_expression GREATER shift_expression .)
    LESS            reduce using rule 42 (relational_expression -> relational_expression GREATER shift_expression .)
    GEQ             reduce using rule 42 (relational_expression -> relational_expression GREATER shift_expression .)
    LEQ             reduce using rule 42 (relational_expression -> relational_expression GREATER shift_expression .)
    EQUAL           reduce using rule 42 (relational_expression -> relational_expression GREATER shift_expression .)
    NEQUAL          reduce using rule 42 (relational_expression -> relational_expression GREATER shift_expression .)
    AND_BITWISE     reduce using rule 42 (relational_expression -> relational_expression GREATER shift_expression .)
    XOR             reduce using rule 42 (relational_expression -> relational_expression GREATER shift_expression .)
    OR_BITWISE      reduce using rule 42 (relational_expression -> relational_expression GREATER shift_expression .)
    AND             reduce using rule 42 (relational_expression -> relational_expression GREATER shift_expression .)
    OR              reduce using rule 42 (relational_expression -> relational_expression GREATER shift_expression .)
    RPAREN          reduce using rule 42 (relational_expression -> relational_expression GREATER shift_expression .)
    COMMA           reduce using rule 42 (relational_expression -> relational_expression GREATER shift_expression .)
    KEYWORD_MATCH   reduce using rule 42 (relational_expression -> relational_expression GREATER shift_expression .)
    KEYWORD_BY      reduce using rule 42 (relational_expression -> relational_expression GREATER shift_expression .)
    TERMINATOR      reduce using rule 42 (relational_expression -> relational_expression GREATER shift_expression .)
    RBRAC           reduce using rule 42 (relational_expression -> relational_expression GREATER shift_expression .)
    FUNTYPE         reduce using rule 42 (relational_expression -> relational_expression GREATER shift_expression .)
    KEYWORD_UNTIL   reduce using rule 42 (relational_expression -> relational_expression GREATER shift_expression .)
    KEYWORD_TO      reduce using rule 42 (relational_expression -> relational_expression GREATER shift_expression .)
    LSHIFT          shift and go to state 129
    RSHIFT          shift and go to state 128


state 200

    (43) relational_expression -> relational_expression LESS shift_expression .
    (47) shift_expression -> shift_expression . LSHIFT additive_expression
    (48) shift_expression -> shift_expression . RSHIFT additive_expression

    GREATER         reduce using rule 43 (relational_expression -> relational_expression LESS shift_expression .)
    LESS            reduce using rule 43 (relational_expression -> relational_expression LESS shift_expression .)
    GEQ             reduce using rule 43 (relational_expression -> relational_expression LESS shift_expression .)
    LEQ             reduce using rule 43 (relational_expression -> relational_expression LESS shift_expression .)
    EQUAL           reduce using rule 43 (relational_expression -> relational_expression LESS shift_expression .)
    NEQUAL          reduce using rule 43 (relational_expression -> relational_expression LESS shift_expression .)
    AND_BITWISE     reduce using rule 43 (relational_expression -> relational_expression LESS shift_expression .)
    XOR             reduce using rule 43 (relational_expression -> relational_expression LESS shift_expression .)
    OR_BITWISE      reduce using rule 43 (relational_expression -> relational_expression LESS shift_expression .)
    AND             reduce using rule 43 (relational_expression -> relational_expression LESS shift_expression .)
    OR              reduce using rule 43 (relational_expression -> relational_expression LESS shift_expression .)
    RPAREN          reduce using rule 43 (relational_expression -> relational_expression LESS shift_expression .)
    COMMA           reduce using rule 43 (relational_expression -> relational_expression LESS shift_expression .)
    KEYWORD_MATCH   reduce using rule 43 (relational_expression -> relational_expression LESS shift_expression .)
    KEYWORD_BY      reduce using rule 43 (relational_expression -> relational_expression LESS shift_expression .)
    TERMINATOR      reduce using rule 43 (relational_expression -> relational_expression LESS shift_expression .)
    RBRAC           reduce using rule 43 (relational_expression -> relational_expression LESS shift_expression .)
    FUNTYPE         reduce using rule 43 (relational_expression -> relational_expression LESS shift_expression .)
    KEYWORD_UNTIL   reduce using rule 43 (relational_expression -> relational_expression LESS shift_expression .)
    KEYWORD_TO      reduce using rule 43 (relational_expression -> relational_expression LESS shift_expression .)
    LSHIFT          shift and go to state 129
    RSHIFT          shift and go to state 128


state 201

    (45) relational_expression -> relational_expression LEQ shift_expression .
    (47) shift_expression -> shift_expression . LSHIFT additive_expression
    (48) shift_expression -> shift_expression . RSHIFT additive_expression

    GREATER         reduce using rule 45 (relational_expression -> relational_expression LEQ shift_expression .)
    LESS            reduce using rule 45 (relational_expression -> relational_expression LEQ shift_expression .)
    GEQ             reduce using rule 45 (relational_expression -> relational_expression LEQ shift_expression .)
    LEQ             reduce using rule 45 (relational_expression -> relational_expression LEQ shift_expression .)
    EQUAL           reduce using rule 45 (relational_expression -> relational_expression LEQ shift_expression .)
    NEQUAL          reduce using rule 45 (relational_expression -> relational_expression LEQ shift_expression .)
    AND_BITWISE     reduce using rule 45 (relational_expression -> relational_expression LEQ shift_expression .)
    XOR             reduce using rule 45 (relational_expression -> relational_expression LEQ shift_expression .)
    OR_BITWISE      reduce using rule 45 (relational_expression -> relational_expression LEQ shift_expression .)
    AND             reduce using rule 45 (relational_expression -> relational_expression LEQ shift_expression .)
    OR              reduce using rule 45 (relational_expression -> relational_expression LEQ shift_expression .)
    RPAREN          reduce using rule 45 (relational_expression -> relational_expression LEQ shift_expression .)
    COMMA           reduce using rule 45 (relational_expression -> relational_expression LEQ shift_expression .)
    KEYWORD_MATCH   reduce using rule 45 (relational_expression -> relational_expression LEQ shift_expression .)
    KEYWORD_BY      reduce using rule 45 (relational_expression -> relational_expression LEQ shift_expression .)
    TERMINATOR      reduce using rule 45 (relational_expression -> relational_expression LEQ shift_expression .)
    RBRAC           reduce using rule 45 (relational_expression -> relational_expression LEQ shift_expression .)
    FUNTYPE         reduce using rule 45 (relational_expression -> relational_expression LEQ shift_expression .)
    KEYWORD_UNTIL   reduce using rule 45 (relational_expression -> relational_expression LEQ shift_expression .)
    KEYWORD_TO      reduce using rule 45 (relational_expression -> relational_expression LEQ shift_expression .)
    LSHIFT          shift and go to state 129
    RSHIFT          shift and go to state 128


state 202

    (136) if_then_statement -> KEYWORD_IF LPAREN expression . RPAREN statement
    (137) if_then_else_statement -> KEYWORD_IF LPAREN expression . RPAREN if_then_else_intermediate KEYWORD_ELSE statement

    RPAREN          shift and go to state 234


state 203

    (40) equality_expression -> equality_expression NEQUAL relational_expression .
    (42) relational_expression -> relational_expression . GREATER shift_expression
    (43) relational_expression -> relational_expression . LESS shift_expression
    (44) relational_expression -> relational_expression . GEQ shift_expression
    (45) relational_expression -> relational_expression . LEQ shift_expression

    EQUAL           reduce using rule 40 (equality_expression -> equality_expression NEQUAL relational_expression .)
    NEQUAL          reduce using rule 40 (equality_expression -> equality_expression NEQUAL relational_expression .)
    AND_BITWISE     reduce using rule 40 (equality_expression -> equality_expression NEQUAL relational_expression .)
    XOR             reduce using rule 40 (equality_expression -> equality_expression NEQUAL relational_expression .)
    OR_BITWISE      reduce using rule 40 (equality_expression -> equality_expression NEQUAL relational_expression .)
    AND             reduce using rule 40 (equality_expression -> equality_expression NEQUAL relational_expression .)
    OR              reduce using rule 40 (equality_expression -> equality_expression NEQUAL relational_expression .)
    KEYWORD_MATCH   reduce using rule 40 (equality_expression -> equality_expression NEQUAL relational_expression .)
    TERMINATOR      reduce using rule 40 (equality_expression -> equality_expression NEQUAL relational_expression .)
    RPAREN          reduce using rule 40 (equality_expression -> equality_expression NEQUAL relational_expression .)
    RBRAC           reduce using rule 40 (equality_expression -> equality_expression NEQUAL relational_expression .)
    COMMA           reduce using rule 40 (equality_expression -> equality_expression NEQUAL relational_expression .)
    FUNTYPE         reduce using rule 40 (equality_expression -> equality_expression NEQUAL relational_expression .)
    KEYWORD_UNTIL   reduce using rule 40 (equality_expression -> equality_expression NEQUAL relational_expression .)
    KEYWORD_TO      reduce using rule 40 (equality_expression -> equality_expression NEQUAL relational_expression .)
    KEYWORD_BY      reduce using rule 40 (equality_expression -> equality_expression NEQUAL relational_expression .)
    GREATER         shift and go to state 143
    LESS            shift and go to state 144
    GEQ             shift and go to state 142
    LEQ             shift and go to state 145


state 204

    (39) equality_expression -> equality_expression EQUAL relational_expression .
    (42) relational_expression -> relational_expression . GREATER shift_expression
    (43) relational_expression -> relational_expression . LESS shift_expression
    (44) relational_expression -> relational_expression . GEQ shift_expression
    (45) relational_expression -> relational_expression . LEQ shift_expression

    EQUAL           reduce using rule 39 (equality_expression -> equality_expression EQUAL relational_expression .)
    NEQUAL          reduce using rule 39 (equality_expression -> equality_expression EQUAL relational_expression .)
    AND_BITWISE     reduce using rule 39 (equality_expression -> equality_expression EQUAL relational_expression .)
    XOR             reduce using rule 39 (equality_expression -> equality_expression EQUAL relational_expression .)
    OR_BITWISE      reduce using rule 39 (equality_expression -> equality_expression EQUAL relational_expression .)
    AND             reduce using rule 39 (equality_expression -> equality_expression EQUAL relational_expression .)
    OR              reduce using rule 39 (equality_expression -> equality_expression EQUAL relational_expression .)
    KEYWORD_MATCH   reduce using rule 39 (equality_expression -> equality_expression EQUAL relational_expression .)
    TERMINATOR      reduce using rule 39 (equality_expression -> equality_expression EQUAL relational_expression .)
    RPAREN          reduce using rule 39 (equality_expression -> equality_expression EQUAL relational_expression .)
    RBRAC           reduce using rule 39 (equality_expression -> equality_expression EQUAL relational_expression .)
    COMMA           reduce using rule 39 (equality_expression -> equality_expression EQUAL relational_expression .)
    FUNTYPE         reduce using rule 39 (equality_expression -> equality_expression EQUAL relational_expression .)
    KEYWORD_UNTIL   reduce using rule 39 (equality_expression -> equality_expression EQUAL relational_expression .)
    KEYWORD_TO      reduce using rule 39 (equality_expression -> equality_expression EQUAL relational_expression .)
    KEYWORD_BY      reduce using rule 39 (equality_expression -> equality_expression EQUAL relational_expression .)
    GREATER         shift and go to state 143
    LESS            shift and go to state 144
    GEQ             shift and go to state 142
    LEQ             shift and go to state 145


state 205

    (37) and_expression -> and_expression AND_BITWISE equality_expression .
    (39) equality_expression -> equality_expression . EQUAL relational_expression
    (40) equality_expression -> equality_expression . NEQUAL relational_expression

    AND_BITWISE     reduce using rule 37 (and_expression -> and_expression AND_BITWISE equality_expression .)
    XOR             reduce using rule 37 (and_expression -> and_expression AND_BITWISE equality_expression .)
    OR_BITWISE      reduce using rule 37 (and_expression -> and_expression AND_BITWISE equality_expression .)
    AND             reduce using rule 37 (and_expression -> and_expression AND_BITWISE equality_expression .)
    OR              reduce using rule 37 (and_expression -> and_expression AND_BITWISE equality_expression .)
    KEYWORD_BY      reduce using rule 37 (and_expression -> and_expression AND_BITWISE equality_expression .)
    TERMINATOR      reduce using rule 37 (and_expression -> and_expression AND_BITWISE equality_expression .)
    RPAREN          reduce using rule 37 (and_expression -> and_expression AND_BITWISE equality_expression .)
    KEYWORD_MATCH   reduce using rule 37 (and_expression -> and_expression AND_BITWISE equality_expression .)
    RBRAC           reduce using rule 37 (and_expression -> and_expression AND_BITWISE equality_expression .)
    COMMA           reduce using rule 37 (and_expression -> and_expression AND_BITWISE equality_expression .)
    FUNTYPE         reduce using rule 37 (and_expression -> and_expression AND_BITWISE equality_expression .)
    KEYWORD_UNTIL   reduce using rule 37 (and_expression -> and_expression AND_BITWISE equality_expression .)
    KEYWORD_TO      reduce using rule 37 (and_expression -> and_expression AND_BITWISE equality_expression .)
    EQUAL           shift and go to state 148
    NEQUAL          shift and go to state 147


state 206

    (67) cast_expression -> LPAREN primitive_type RPAREN . unary_expression
    (56) unary_expression -> . PLUS unary_expression
    (57) unary_expression -> . MINUS unary_expression
    (58) unary_expression -> . unary_expression_not_plus_minus
    (59) unary_expression_not_plus_minus -> . base_variable_set
    (60) unary_expression_not_plus_minus -> . TILDA unary_expression
    (61) unary_expression_not_plus_minus -> . NOT unary_expression
    (62) unary_expression_not_plus_minus -> . cast_expression
    (63) base_variable_set -> . variable_literal
    (64) base_variable_set -> . LPAREN expression RPAREN
    (67) cast_expression -> . LPAREN primitive_type RPAREN unary_expression
    (65) variable_literal -> . valid_variable
    (66) variable_literal -> . primary
    (24) valid_variable -> . name
    (25) valid_variable -> . array_access
    (68) primary -> . literal
    (69) primary -> . method_invocation
    (115) name -> . simple_name
    (116) name -> . qualified_name
    (26) array_access -> . name LBRAC expression RBRAC
    (70) literal -> . int_float
    (71) literal -> . c_literal
    (79) method_invocation -> . name LPAREN argument_list_opt RPAREN
    (117) simple_name -> . IDENTIFIER
    (118) qualified_name -> . name INST simple_name
    (77) int_float -> . DOUBLE_NUMBER
    (78) int_float -> . INT_NUMBER
    (72) c_literal -> . CHAR
    (73) c_literal -> . STRING
    (74) c_literal -> . BOOL_CONSTT
    (75) c_literal -> . BOOL_CONSTF
    (76) c_literal -> . KEYWORD_NULL

    PLUS            shift and go to state 36
    MINUS           shift and go to state 29
    TILDA           shift and go to state 72
    NOT             shift and go to state 57
    LPAREN          shift and go to state 94
    IDENTIFIER      shift and go to state 77
    DOUBLE_NUMBER   shift and go to state 33
    INT_NUMBER      shift and go to state 44
    CHAR            shift and go to state 63
    STRING          shift and go to state 76
    BOOL_CONSTT     shift and go to state 35
    BOOL_CONSTF     shift and go to state 30
    KEYWORD_NULL    shift and go to state 65

    qualified_name                 shift and go to state 79
    int_float                      shift and go to state 40
    c_literal                      shift and go to state 93
    variable_literal               shift and go to state 55
    unary_expression               shift and go to state 235
    base_variable_set              shift and go to state 88
    valid_variable                 shift and go to state 110
    array_access                   shift and go to state 28
    primary                        shift and go to state 62
    unary_expression_not_plus_minus shift and go to state 46
    literal                        shift and go to state 71
    method_invocation              shift and go to state 111
    cast_expression                shift and go to state 80
    simple_name                    shift and go to state 67
    name                           shift and go to state 112

state 207

    (64) base_variable_set -> LPAREN expression RPAREN .

    TIMES           reduce using rule 64 (base_variable_set -> LPAREN expression RPAREN .)
    DIVIDE          reduce using rule 64 (base_variable_set -> LPAREN expression RPAREN .)
    REMAINDER       reduce using rule 64 (base_variable_set -> LPAREN expression RPAREN .)
    PLUS            reduce using rule 64 (base_variable_set -> LPAREN expression RPAREN .)
    MINUS           reduce using rule 64 (base_variable_set -> LPAREN expression RPAREN .)
    LSHIFT          reduce using rule 64 (base_variable_set -> LPAREN expression RPAREN .)
    RSHIFT          reduce using rule 64 (base_variable_set -> LPAREN expression RPAREN .)
    GREATER         reduce using rule 64 (base_variable_set -> LPAREN expression RPAREN .)
    LESS            reduce using rule 64 (base_variable_set -> LPAREN expression RPAREN .)
    GEQ             reduce using rule 64 (base_variable_set -> LPAREN expression RPAREN .)
    LEQ             reduce using rule 64 (base_variable_set -> LPAREN expression RPAREN .)
    EQUAL           reduce using rule 64 (base_variable_set -> LPAREN expression RPAREN .)
    NEQUAL          reduce using rule 64 (base_variable_set -> LPAREN expression RPAREN .)
    AND_BITWISE     reduce using rule 64 (base_variable_set -> LPAREN expression RPAREN .)
    XOR             reduce using rule 64 (base_variable_set -> LPAREN expression RPAREN .)
    OR_BITWISE      reduce using rule 64 (base_variable_set -> LPAREN expression RPAREN .)
    AND             reduce using rule 64 (base_variable_set -> LPAREN expression RPAREN .)
    OR              reduce using rule 64 (base_variable_set -> LPAREN expression RPAREN .)
    KEYWORD_MATCH   reduce using rule 64 (base_variable_set -> LPAREN expression RPAREN .)
    TERMINATOR      reduce using rule 64 (base_variable_set -> LPAREN expression RPAREN .)
    RPAREN          reduce using rule 64 (base_variable_set -> LPAREN expression RPAREN .)
    RBRAC           reduce using rule 64 (base_variable_set -> LPAREN expression RPAREN .)
    COMMA           reduce using rule 64 (base_variable_set -> LPAREN expression RPAREN .)
    FUNTYPE         reduce using rule 64 (base_variable_set -> LPAREN expression RPAREN .)
    KEYWORD_UNTIL   reduce using rule 64 (base_variable_set -> LPAREN expression RPAREN .)
    KEYWORD_TO      reduce using rule 64 (base_variable_set -> LPAREN expression RPAREN .)
    KEYWORD_BY      reduce using rule 64 (base_variable_set -> LPAREN expression RPAREN .)


state 208

    (91) local_variable_declaration -> modifier_opts declaration_keyword variable_declaration_body .

    TERMINATOR      reduce using rule 91 (local_variable_declaration -> modifier_opts declaration_keyword variable_declaration_body .)


state 209

    (97) variable_declaration_body -> variable_declarator . ASOP variable_declaration_initializer

    ASOP            shift and go to state 236


state 210

    (98) variable_declaration_body -> LPAREN . variable_declarators RPAREN ASOP LPAREN variable_arguement_list RPAREN
    (100) variable_declarators -> . variable_declarator
    (101) variable_declarators -> . variable_declarators COMMA variable_declarator
    (102) variable_declarator -> . variable_declarator_id
    (103) variable_declarator_id -> . IDENTIFIER COLON type

    IDENTIFIER      shift and go to state 175

    variable_declarators           shift and go to state 237
    variable_declarator_id         shift and go to state 172
    variable_declarator            shift and go to state 174

state 211

    (99) variable_declaration_body -> IDENTIFIER . ASOP LPAREN func_arguement_list_opt RPAREN FUNTYPE expression
    (103) variable_declarator_id -> IDENTIFIER . COLON type

    ASOP            shift and go to state 238
    COLON           shift and go to state 223


state 212

    (182) method_header_name -> modifier_opts KEYWORD_DEF IDENTIFIER .

    LPAREN          reduce using rule 182 (method_header_name -> modifier_opts KEYWORD_DEF IDENTIFIER .)


state 213

    (146) for_update -> for_loop . for_step_opts
    (150) for_step_opts -> . KEYWORD_BY expression
    (151) for_step_opts -> . empty
    (186) empty -> .

    KEYWORD_BY      shift and go to state 239
    TERMINATOR      reduce using rule 186 (empty -> .)
    RPAREN          reduce using rule 186 (empty -> .)

    for_step_opts                  shift and go to state 240
    empty                          shift and go to state 241

state 214

    (143) for_statement -> KEYWORD_FOR LPAREN for_logic . RPAREN statement

    RPAREN          shift and go to state 242


state 215

    (144) for_logic -> for_update .
    (145) for_logic -> for_update . TERMINATOR for_logic

    RPAREN          reduce using rule 144 (for_logic -> for_update .)
    TERMINATOR      shift and go to state 243


state 216

    (147) for_loop -> IDENTIFIER . CHOOSE expression for_untilTo expression

    CHOOSE          shift and go to state 244


state 217

    (142) do_while_statement -> KEYWORD_DO statement KEYWORD_WHILE . LPAREN expression RPAREN TERMINATOR

    LPAREN          shift and go to state 245


state 218

    (176) constructor_arguement_list_declarator -> declaration_keyword IDENTIFIER COLON . type
    (104) type -> . primitive_type
    (105) type -> . reference_type
    (106) primitive_type -> . TYPE_INT
    (107) primitive_type -> . TYPE_DOUBLE
    (108) primitive_type -> . TYPE_CHAR
    (109) primitive_type -> . TYPE_STRING
    (110) primitive_type -> . TYPE_BOOLEAN
    (111) reference_type -> . class_data_type
    (112) reference_type -> . array_data_type
    (113) class_data_type -> . name
    (114) array_data_type -> . KEYWORD_ARRAY LBRAC type RBRAC
    (115) name -> . simple_name
    (116) name -> . qualified_name
    (117) simple_name -> . IDENTIFIER
    (118) qualified_name -> . name INST simple_name

    TYPE_INT        shift and go to state 154
    TYPE_DOUBLE     shift and go to state 159
    TYPE_CHAR       shift and go to state 156
    TYPE_STRING     shift and go to state 155
    TYPE_BOOLEAN    shift and go to state 158
    KEYWORD_ARRAY   shift and go to state 248
    IDENTIFIER      shift and go to state 77

    name                           shift and go to state 246
    qualified_name                 shift and go to state 79
    reference_type                 shift and go to state 247
    primitive_type                 shift and go to state 249
    class_data_type                shift and go to state 250
    type                           shift and go to state 251
    array_data_type                shift and go to state 252
    simple_name                    shift and go to state 67

state 219

    (175) constructor_arguement_list -> constructor_arguement_list COMMA constructor_arguement_list_declarator .

    COMMA           reduce using rule 175 (constructor_arguement_list -> constructor_arguement_list COMMA constructor_arguement_list_declarator .)
    RPAREN          reduce using rule 175 (constructor_arguement_list -> constructor_arguement_list COMMA constructor_arguement_list_declarator .)


state 220

    (171) class_header_extends -> KEYWORD_EXTENDS name LPAREN func_arguement_list_opt . RPAREN

    RPAREN          shift and go to state 253


state 221

    (179) method_header -> method_header_name LPAREN func_arguement_list_opt RPAREN . COLON method_return_type ASOP

    COLON           shift and go to state 254


state 222

    (101) variable_declarators -> variable_declarators COMMA . variable_declarator
    (102) variable_declarator -> . variable_declarator_id
    (103) variable_declarator_id -> . IDENTIFIER COLON type

    IDENTIFIER      shift and go to state 175

    variable_declarator_id         shift and go to state 172
    variable_declarator            shift and go to state 255

state 223

    (103) variable_declarator_id -> IDENTIFIER COLON . type
    (104) type -> . primitive_type
    (105) type -> . reference_type
    (106) primitive_type -> . TYPE_INT
    (107) primitive_type -> . TYPE_DOUBLE
    (108) primitive_type -> . TYPE_CHAR
    (109) primitive_type -> . TYPE_STRING
    (110) primitive_type -> . TYPE_BOOLEAN
    (111) reference_type -> . class_data_type
    (112) reference_type -> . array_data_type
    (113) class_data_type -> . name
    (114) array_data_type -> . KEYWORD_ARRAY LBRAC type RBRAC
    (115) name -> . simple_name
    (116) name -> . qualified_name
    (117) simple_name -> . IDENTIFIER
    (118) qualified_name -> . name INST simple_name

    TYPE_INT        shift and go to state 154
    TYPE_DOUBLE     shift and go to state 159
    TYPE_CHAR       shift and go to state 156
    TYPE_STRING     shift and go to state 155
    TYPE_BOOLEAN    shift and go to state 158
    KEYWORD_ARRAY   shift and go to state 248
    IDENTIFIER      shift and go to state 77

    name                           shift and go to state 246
    qualified_name                 shift and go to state 79
    reference_type                 shift and go to state 247
    primitive_type                 shift and go to state 249
    class_data_type                shift and go to state 250
    type                           shift and go to state 256
    array_data_type                shift and go to state 252
    simple_name                    shift and go to state 67

state 224

    (26) array_access -> name LBRAC expression RBRAC .

    ASOP            reduce using rule 26 (array_access -> name LBRAC expression RBRAC .)
    TIMES           reduce using rule 26 (array_access -> name LBRAC expression RBRAC .)
    DIVIDE          reduce using rule 26 (array_access -> name LBRAC expression RBRAC .)
    REMAINDER       reduce using rule 26 (array_access -> name LBRAC expression RBRAC .)
    PLUS            reduce using rule 26 (array_access -> name LBRAC expression RBRAC .)
    MINUS           reduce using rule 26 (array_access -> name LBRAC expression RBRAC .)
    LSHIFT          reduce using rule 26 (array_access -> name LBRAC expression RBRAC .)
    RSHIFT          reduce using rule 26 (array_access -> name LBRAC expression RBRAC .)
    GREATER         reduce using rule 26 (array_access -> name LBRAC expression RBRAC .)
    LESS            reduce using rule 26 (array_access -> name LBRAC expression RBRAC .)
    GEQ             reduce using rule 26 (array_access -> name LBRAC expression RBRAC .)
    LEQ             reduce using rule 26 (array_access -> name LBRAC expression RBRAC .)
    EQUAL           reduce using rule 26 (array_access -> name LBRAC expression RBRAC .)
    NEQUAL          reduce using rule 26 (array_access -> name LBRAC expression RBRAC .)
    AND_BITWISE     reduce using rule 26 (array_access -> name LBRAC expression RBRAC .)
    XOR             reduce using rule 26 (array_access -> name LBRAC expression RBRAC .)
    OR_BITWISE      reduce using rule 26 (array_access -> name LBRAC expression RBRAC .)
    AND             reduce using rule 26 (array_access -> name LBRAC expression RBRAC .)
    OR              reduce using rule 26 (array_access -> name LBRAC expression RBRAC .)
    TERMINATOR      reduce using rule 26 (array_access -> name LBRAC expression RBRAC .)
    KEYWORD_MATCH   reduce using rule 26 (array_access -> name LBRAC expression RBRAC .)
    RPAREN          reduce using rule 26 (array_access -> name LBRAC expression RBRAC .)
    RBRAC           reduce using rule 26 (array_access -> name LBRAC expression RBRAC .)
    COMMA           reduce using rule 26 (array_access -> name LBRAC expression RBRAC .)
    FUNTYPE         reduce using rule 26 (array_access -> name LBRAC expression RBRAC .)
    KEYWORD_UNTIL   reduce using rule 26 (array_access -> name LBRAC expression RBRAC .)
    KEYWORD_TO      reduce using rule 26 (array_access -> name LBRAC expression RBRAC .)
    KEYWORD_BY      reduce using rule 26 (array_access -> name LBRAC expression RBRAC .)


state 225

    (83) argument_list -> argument_list COMMA . expression
    (18) expression -> . assignment_expression
    (21) assignment_expression -> . assignment
    (22) assignment_expression -> . conditional_or_expression
    (23) assignment -> . valid_variable assignment_operator assignment_expression
    (28) conditional_or_expression -> . conditional_and_expression
    (29) conditional_or_expression -> . conditional_or_expression OR conditional_and_expression
    (24) valid_variable -> . name
    (25) valid_variable -> . array_access
    (30) conditional_and_expression -> . inclusive_or_expression
    (31) conditional_and_expression -> . conditional_and_expression AND inclusive_or_expression
    (115) name -> . simple_name
    (116) name -> . qualified_name
    (26) array_access -> . name LBRAC expression RBRAC
    (32) inclusive_or_expression -> . exclusive_or_expression
    (33) inclusive_or_expression -> . inclusive_or_expression OR_BITWISE exclusive_or_expression
    (117) simple_name -> . IDENTIFIER
    (118) qualified_name -> . name INST simple_name
    (34) exclusive_or_expression -> . and_expression
    (35) exclusive_or_expression -> . exclusive_or_expression XOR and_expression
    (36) and_expression -> . equality_expression
    (37) and_expression -> . and_expression AND_BITWISE equality_expression
    (38) equality_expression -> . relational_expression
    (39) equality_expression -> . equality_expression EQUAL relational_expression
    (40) equality_expression -> . equality_expression NEQUAL relational_expression
    (41) relational_expression -> . shift_expression
    (42) relational_expression -> . relational_expression GREATER shift_expression
    (43) relational_expression -> . relational_expression LESS shift_expression
    (44) relational_expression -> . relational_expression GEQ shift_expression
    (45) relational_expression -> . relational_expression LEQ shift_expression
    (46) shift_expression -> . additive_expression
    (47) shift_expression -> . shift_expression LSHIFT additive_expression
    (48) shift_expression -> . shift_expression RSHIFT additive_expression
    (49) additive_expression -> . multiplicative_expression
    (50) additive_expression -> . additive_expression PLUS multiplicative_expression
    (51) additive_expression -> . additive_expression MINUS multiplicative_expression
    (52) multiplicative_expression -> . unary_expression
    (53) multiplicative_expression -> . multiplicative_expression TIMES unary_expression
    (54) multiplicative_expression -> . multiplicative_expression DIVIDE unary_expression
    (55) multiplicative_expression -> . multiplicative_expression REMAINDER unary_expression
    (56) unary_expression -> . PLUS unary_expression
    (57) unary_expression -> . MINUS unary_expression
    (58) unary_expression -> . unary_expression_not_plus_minus
    (59) unary_expression_not_plus_minus -> . base_variable_set
    (60) unary_expression_not_plus_minus -> . TILDA unary_expression
    (61) unary_expression_not_plus_minus -> . NOT unary_expression
    (62) unary_expression_not_plus_minus -> . cast_expression
    (63) base_variable_set -> . variable_literal
    (64) base_variable_set -> . LPAREN expression RPAREN
    (67) cast_expression -> . LPAREN primitive_type RPAREN unary_expression
    (65) variable_literal -> . valid_variable
    (66) variable_literal -> . primary
    (68) primary -> . literal
    (69) primary -> . method_invocation
    (70) literal -> . int_float
    (71) literal -> . c_literal
    (79) method_invocation -> . name LPAREN argument_list_opt RPAREN
    (77) int_float -> . DOUBLE_NUMBER
    (78) int_float -> . INT_NUMBER
    (72) c_literal -> . CHAR
    (73) c_literal -> . STRING
    (74) c_literal -> . BOOL_CONSTT
    (75) c_literal -> . BOOL_CONSTF
    (76) c_literal -> . KEYWORD_NULL

    IDENTIFIER      shift and go to state 77
    PLUS            shift and go to state 36
    MINUS           shift and go to state 29
    TILDA           shift and go to state 72
    NOT             shift and go to state 57
    LPAREN          shift and go to state 94
    DOUBLE_NUMBER   shift and go to state 33
    INT_NUMBER      shift and go to state 44
    CHAR            shift and go to state 63
    STRING          shift and go to state 76
    BOOL_CONSTT     shift and go to state 35
    BOOL_CONSTF     shift and go to state 30
    KEYWORD_NULL    shift and go to state 65

    unary_expression               shift and go to state 45
    exclusive_or_expression        shift and go to state 61
    primary                        shift and go to state 62
    unary_expression_not_plus_minus shift and go to state 46
    array_access                   shift and go to state 28
    additive_expression            shift and go to state 66
    simple_name                    shift and go to state 67
    c_literal                      shift and go to state 93
    base_variable_set              shift and go to state 88
    valid_variable                 shift and go to state 48
    inclusive_or_expression        shift and go to state 32
    literal                        shift and go to state 71
    and_expression                 shift and go to state 87
    relational_expression          shift and go to state 73
    cast_expression                shift and go to state 80
    conditional_or_expression      shift and go to state 49
    assignment_expression          shift and go to state 91
    qualified_name                 shift and go to state 79
    assignment                     shift and go to state 138
    multiplicative_expression      shift and go to state 52
    method_invocation              shift and go to state 111
    shift_expression               shift and go to state 54
    equality_expression            shift and go to state 82
    int_float                      shift and go to state 40
    variable_literal               shift and go to state 55
    name                           shift and go to state 139
    expression                     shift and go to state 257
    conditional_and_expression     shift and go to state 56

state 226

    (79) method_invocation -> name LPAREN argument_list_opt RPAREN .

    TERMINATOR      reduce using rule 79 (method_invocation -> name LPAREN argument_list_opt RPAREN .)
    TIMES           reduce using rule 79 (method_invocation -> name LPAREN argument_list_opt RPAREN .)
    DIVIDE          reduce using rule 79 (method_invocation -> name LPAREN argument_list_opt RPAREN .)
    REMAINDER       reduce using rule 79 (method_invocation -> name LPAREN argument_list_opt RPAREN .)
    PLUS            reduce using rule 79 (method_invocation -> name LPAREN argument_list_opt RPAREN .)
    MINUS           reduce using rule 79 (method_invocation -> name LPAREN argument_list_opt RPAREN .)
    LSHIFT          reduce using rule 79 (method_invocation -> name LPAREN argument_list_opt RPAREN .)
    RSHIFT          reduce using rule 79 (method_invocation -> name LPAREN argument_list_opt RPAREN .)
    GREATER         reduce using rule 79 (method_invocation -> name LPAREN argument_list_opt RPAREN .)
    LESS            reduce using rule 79 (method_invocation -> name LPAREN argument_list_opt RPAREN .)
    GEQ             reduce using rule 79 (method_invocation -> name LPAREN argument_list_opt RPAREN .)
    LEQ             reduce using rule 79 (method_invocation -> name LPAREN argument_list_opt RPAREN .)
    EQUAL           reduce using rule 79 (method_invocation -> name LPAREN argument_list_opt RPAREN .)
    NEQUAL          reduce using rule 79 (method_invocation -> name LPAREN argument_list_opt RPAREN .)
    AND_BITWISE     reduce using rule 79 (method_invocation -> name LPAREN argument_list_opt RPAREN .)
    XOR             reduce using rule 79 (method_invocation -> name LPAREN argument_list_opt RPAREN .)
    OR_BITWISE      reduce using rule 79 (method_invocation -> name LPAREN argument_list_opt RPAREN .)
    AND             reduce using rule 79 (method_invocation -> name LPAREN argument_list_opt RPAREN .)
    OR              reduce using rule 79 (method_invocation -> name LPAREN argument_list_opt RPAREN .)
    KEYWORD_MATCH   reduce using rule 79 (method_invocation -> name LPAREN argument_list_opt RPAREN .)
    RPAREN          reduce using rule 79 (method_invocation -> name LPAREN argument_list_opt RPAREN .)
    RBRAC           reduce using rule 79 (method_invocation -> name LPAREN argument_list_opt RPAREN .)
    COMMA           reduce using rule 79 (method_invocation -> name LPAREN argument_list_opt RPAREN .)
    FUNTYPE         reduce using rule 79 (method_invocation -> name LPAREN argument_list_opt RPAREN .)
    KEYWORD_UNTIL   reduce using rule 79 (method_invocation -> name LPAREN argument_list_opt RPAREN .)
    KEYWORD_TO      reduce using rule 79 (method_invocation -> name LPAREN argument_list_opt RPAREN .)
    KEYWORD_BY      reduce using rule 79 (method_invocation -> name LPAREN argument_list_opt RPAREN .)


state 227

    (141) while_statement -> KEYWORD_WHILE LPAREN expression RPAREN . statement
    (122) statement -> . normal_statement
    (123) statement -> . if_then_statement
    (124) statement -> . if_then_else_statement
    (125) statement -> . while_statement
    (126) statement -> . do_while_statement
    (127) statement -> . for_statement
    (128) normal_statement -> . block
    (129) normal_statement -> . expression_statement
    (130) normal_statement -> . empty_statement
    (131) normal_statement -> . return_statement
    (132) normal_statement -> . switch_statement
    (136) if_then_statement -> . KEYWORD_IF LPAREN expression RPAREN statement
    (137) if_then_else_statement -> . KEYWORD_IF LPAREN expression RPAREN if_then_else_intermediate KEYWORD_ELSE statement
    (141) while_statement -> . KEYWORD_WHILE LPAREN expression RPAREN statement
    (142) do_while_statement -> . KEYWORD_DO statement KEYWORD_WHILE LPAREN expression RPAREN TERMINATOR
    (143) for_statement -> . KEYWORD_FOR LPAREN for_logic RPAREN statement
    (8) block -> . BLOCKBEGIN block_statements_opt BLOCKEND
    (133) expression_statement -> . statement_expression TERMINATOR
    (163) empty_statement -> . TERMINATOR
    (164) return_statement -> . KEYWORD_RETURN expression_optional TERMINATOR
    (152) switch_statement -> . expression KEYWORD_MATCH switch_block
    (134) statement_expression -> . assignment
    (135) statement_expression -> . method_invocation
    (18) expression -> . assignment_expression
    (23) assignment -> . valid_variable assignment_operator assignment_expression
    (79) method_invocation -> . name LPAREN argument_list_opt RPAREN
    (21) assignment_expression -> . assignment
    (22) assignment_expression -> . conditional_or_expression
    (24) valid_variable -> . name
    (25) valid_variable -> . array_access
    (115) name -> . simple_name
    (116) name -> . qualified_name
    (28) conditional_or_expression -> . conditional_and_expression
    (29) conditional_or_expression -> . conditional_or_expression OR conditional_and_expression
    (26) array_access -> . name LBRAC expression RBRAC
    (117) simple_name -> . IDENTIFIER
    (118) qualified_name -> . name INST simple_name
    (30) conditional_and_expression -> . inclusive_or_expression
    (31) conditional_and_expression -> . conditional_and_expression AND inclusive_or_expression
    (32) inclusive_or_expression -> . exclusive_or_expression
    (33) inclusive_or_expression -> . inclusive_or_expression OR_BITWISE exclusive_or_expression
    (34) exclusive_or_expression -> . and_expression
    (35) exclusive_or_expression -> . exclusive_or_expression XOR and_expression
    (36) and_expression -> . equality_expression
    (37) and_expression -> . and_expression AND_BITWISE equality_expression
    (38) equality_expression -> . relational_expression
    (39) equality_expression -> . equality_expression EQUAL relational_expression
    (40) equality_expression -> . equality_expression NEQUAL relational_expression
    (41) relational_expression -> . shift_expression
    (42) relational_expression -> . relational_expression GREATER shift_expression
    (43) relational_expression -> . relational_expression LESS shift_expression
    (44) relational_expression -> . relational_expression GEQ shift_expression
    (45) relational_expression -> . relational_expression LEQ shift_expression
    (46) shift_expression -> . additive_expression
    (47) shift_expression -> . shift_expression LSHIFT additive_expression
    (48) shift_expression -> . shift_expression RSHIFT additive_expression
    (49) additive_expression -> . multiplicative_expression
    (50) additive_expression -> . additive_expression PLUS multiplicative_expression
    (51) additive_expression -> . additive_expression MINUS multiplicative_expression
    (52) multiplicative_expression -> . unary_expression
    (53) multiplicative_expression -> . multiplicative_expression TIMES unary_expression
    (54) multiplicative_expression -> . multiplicative_expression DIVIDE unary_expression
    (55) multiplicative_expression -> . multiplicative_expression REMAINDER unary_expression
    (56) unary_expression -> . PLUS unary_expression
    (57) unary_expression -> . MINUS unary_expression
    (58) unary_expression -> . unary_expression_not_plus_minus
    (59) unary_expression_not_plus_minus -> . base_variable_set
    (60) unary_expression_not_plus_minus -> . TILDA unary_expression
    (61) unary_expression_not_plus_minus -> . NOT unary_expression
    (62) unary_expression_not_plus_minus -> . cast_expression
    (63) base_variable_set -> . variable_literal
    (64) base_variable_set -> . LPAREN expression RPAREN
    (67) cast_expression -> . LPAREN primitive_type RPAREN unary_expression
    (65) variable_literal -> . valid_variable
    (66) variable_literal -> . primary
    (68) primary -> . literal
    (69) primary -> . method_invocation
    (70) literal -> . int_float
    (71) literal -> . c_literal
    (77) int_float -> . DOUBLE_NUMBER
    (78) int_float -> . INT_NUMBER
    (72) c_literal -> . CHAR
    (73) c_literal -> . STRING
    (74) c_literal -> . BOOL_CONSTT
    (75) c_literal -> . BOOL_CONSTF
    (76) c_literal -> . KEYWORD_NULL

    KEYWORD_IF      shift and go to state 81
    KEYWORD_WHILE   shift and go to state 50
    KEYWORD_DO      shift and go to state 98
    KEYWORD_FOR     shift and go to state 97
    BLOCKBEGIN      shift and go to state 15
    TERMINATOR      shift and go to state 53
    KEYWORD_RETURN  shift and go to state 68
    IDENTIFIER      shift and go to state 77
    PLUS            shift and go to state 36
    MINUS           shift and go to state 29
    TILDA           shift and go to state 72
    NOT             shift and go to state 57
    LPAREN          shift and go to state 94
    DOUBLE_NUMBER   shift and go to state 33
    INT_NUMBER      shift and go to state 44
    CHAR            shift and go to state 63
    STRING          shift and go to state 76
    BOOL_CONSTT     shift and go to state 35
    BOOL_CONSTF     shift and go to state 30
    KEYWORD_NULL    shift and go to state 65

    expression_statement           shift and go to state 27
    unary_expression               shift and go to state 45
    exclusive_or_expression        shift and go to state 61
    normal_statement               shift and go to state 86
    primary                        shift and go to state 62
    unary_expression_not_plus_minus shift and go to state 46
    if_then_statement              shift and go to state 64
    array_access                   shift and go to state 28
    switch_statement               shift and go to state 47
    assignment_expression          shift and go to state 91
    qualified_name                 shift and go to state 79
    base_variable_set              shift and go to state 88
    valid_variable                 shift and go to state 48
    inclusive_or_expression        shift and go to state 32
    literal                        shift and go to state 71
    return_statement               shift and go to state 89
    while_statement                shift and go to state 34
    and_expression                 shift and go to state 87
    statement                      shift and go to state 258
    statement_expression           shift and go to state 37
    method_invocation              shift and go to state 75
    simple_name                    shift and go to state 67
    conditional_or_expression      shift and go to state 49
    relational_expression          shift and go to state 73
    for_statement                  shift and go to state 38
    do_while_statement             shift and go to state 51
    assignment                     shift and go to state 92
    multiplicative_expression      shift and go to state 52
    c_literal                      shift and go to state 93
    additive_expression            shift and go to state 66
    cast_expression                shift and go to state 80
    shift_expression               shift and go to state 54
    equality_expression            shift and go to state 82
    int_float                      shift and go to state 40
    variable_literal               shift and go to state 55
    name                           shift and go to state 43
    empty_statement                shift and go to state 84
    expression                     shift and go to state 58
    conditional_and_expression     shift and go to state 56
    block                          shift and go to state 59
    if_then_else_statement         shift and go to state 60

state 228

    (155) switch_block -> BLOCKBEGIN switch_labels . BLOCKEND
    (161) switch_labels -> switch_labels . switch_label
    (159) switch_block_statement -> switch_labels . block_statements
    (162) switch_label -> . KEYWORD_CASE expression FUNTYPE
    (11) block_statements -> . block_statement
    (12) block_statements -> . block_statements block_statement
    (13) block_statement -> . local_variable_declaration_statement
    (14) block_statement -> . statement
    (15) block_statement -> . class_declaration
    (16) block_statement -> . SingletonObject
    (17) block_statement -> . method_declaration
    (90) local_variable_declaration_statement -> . local_variable_declaration TERMINATOR
    (122) statement -> . normal_statement
    (123) statement -> . if_then_statement
    (124) statement -> . if_then_else_statement
    (125) statement -> . while_statement
    (126) statement -> . do_while_statement
    (127) statement -> . for_statement
    (165) class_declaration -> . class_header class_body
    (5) SingletonObject -> . ObjectDeclare block
    (178) method_declaration -> . method_header method_body
    (91) local_variable_declaration -> . modifier_opts declaration_keyword variable_declaration_body
    (128) normal_statement -> . block
    (129) normal_statement -> . expression_statement
    (130) normal_statement -> . empty_statement
    (131) normal_statement -> . return_statement
    (132) normal_statement -> . switch_statement
    (136) if_then_statement -> . KEYWORD_IF LPAREN expression RPAREN statement
    (137) if_then_else_statement -> . KEYWORD_IF LPAREN expression RPAREN if_then_else_intermediate KEYWORD_ELSE statement
    (141) while_statement -> . KEYWORD_WHILE LPAREN expression RPAREN statement
    (142) do_while_statement -> . KEYWORD_DO statement KEYWORD_WHILE LPAREN expression RPAREN TERMINATOR
    (143) for_statement -> . KEYWORD_FOR LPAREN for_logic RPAREN statement
    (166) class_header -> . class_header_name class_header_extends_opt
    (6) ObjectDeclare -> . KEYWORD_OBJECT IDENTIFIER
    (7) ObjectDeclare -> . KEYWORD_OBJECT IDENTIFIER KEYWORD_EXTENDS IDENTIFIER
    (179) method_header -> . method_header_name LPAREN func_arguement_list_opt RPAREN COLON method_return_type ASOP
    (86) modifier_opts -> . modifier
    (87) modifier_opts -> . empty
    (8) block -> . BLOCKBEGIN block_statements_opt BLOCKEND
    (133) expression_statement -> . statement_expression TERMINATOR
    (163) empty_statement -> . TERMINATOR
    (164) return_statement -> . KEYWORD_RETURN expression_optional TERMINATOR
    (152) switch_statement -> . expression KEYWORD_MATCH switch_block
    (167) class_header_name -> . class_header_name1 LPAREN constructor_arguement_list_opt RPAREN
    (182) method_header_name -> . modifier_opts KEYWORD_DEF IDENTIFIER
    (84) modifier -> . KEYWORD_PROTECTED
    (85) modifier -> . KEYWORD_PRIVATE
    (186) empty -> .
    (134) statement_expression -> . assignment
    (135) statement_expression -> . method_invocation
    (18) expression -> . assignment_expression
    (168) class_header_name1 -> . modifier_opts KEYWORD_CLASS name
    (23) assignment -> . valid_variable assignment_operator assignment_expression
    (79) method_invocation -> . name LPAREN argument_list_opt RPAREN
    (21) assignment_expression -> . assignment
    (22) assignment_expression -> . conditional_or_expression
    (24) valid_variable -> . name
    (25) valid_variable -> . array_access
    (115) name -> . simple_name
    (116) name -> . qualified_name
    (28) conditional_or_expression -> . conditional_and_expression
    (29) conditional_or_expression -> . conditional_or_expression OR conditional_and_expression
    (26) array_access -> . name LBRAC expression RBRAC
    (117) simple_name -> . IDENTIFIER
    (118) qualified_name -> . name INST simple_name
    (30) conditional_and_expression -> . inclusive_or_expression
    (31) conditional_and_expression -> . conditional_and_expression AND inclusive_or_expression
    (32) inclusive_or_expression -> . exclusive_or_expression
    (33) inclusive_or_expression -> . inclusive_or_expression OR_BITWISE exclusive_or_expression
    (34) exclusive_or_expression -> . and_expression
    (35) exclusive_or_expression -> . exclusive_or_expression XOR and_expression
    (36) and_expression -> . equality_expression
    (37) and_expression -> . and_expression AND_BITWISE equality_expression
    (38) equality_expression -> . relational_expression
    (39) equality_expression -> . equality_expression EQUAL relational_expression
    (40) equality_expression -> . equality_expression NEQUAL relational_expression
    (41) relational_expression -> . shift_expression
    (42) relational_expression -> . relational_expression GREATER shift_expression
    (43) relational_expression -> . relational_expression LESS shift_expression
    (44) relational_expression -> . relational_expression GEQ shift_expression
    (45) relational_expression -> . relational_expression LEQ shift_expression
    (46) shift_expression -> . additive_expression
    (47) shift_expression -> . shift_expression LSHIFT additive_expression
    (48) shift_expression -> . shift_expression RSHIFT additive_expression
    (49) additive_expression -> . multiplicative_expression
    (50) additive_expression -> . additive_expression PLUS multiplicative_expression
    (51) additive_expression -> . additive_expression MINUS multiplicative_expression
    (52) multiplicative_expression -> . unary_expression
    (53) multiplicative_expression -> . multiplicative_expression TIMES unary_expression
    (54) multiplicative_expression -> . multiplicative_expression DIVIDE unary_expression
    (55) multiplicative_expression -> . multiplicative_expression REMAINDER unary_expression
    (56) unary_expression -> . PLUS unary_expression
    (57) unary_expression -> . MINUS unary_expression
    (58) unary_expression -> . unary_expression_not_plus_minus
    (59) unary_expression_not_plus_minus -> . base_variable_set
    (60) unary_expression_not_plus_minus -> . TILDA unary_expression
    (61) unary_expression_not_plus_minus -> . NOT unary_expression
    (62) unary_expression_not_plus_minus -> . cast_expression
    (63) base_variable_set -> . variable_literal
    (64) base_variable_set -> . LPAREN expression RPAREN
    (67) cast_expression -> . LPAREN primitive_type RPAREN unary_expression
    (65) variable_literal -> . valid_variable
    (66) variable_literal -> . primary
    (68) primary -> . literal
    (69) primary -> . method_invocation
    (70) literal -> . int_float
    (71) literal -> . c_literal
    (77) int_float -> . DOUBLE_NUMBER
    (78) int_float -> . INT_NUMBER
    (72) c_literal -> . CHAR
    (73) c_literal -> . STRING
    (74) c_literal -> . BOOL_CONSTT
    (75) c_literal -> . BOOL_CONSTF
    (76) c_literal -> . KEYWORD_NULL

    BLOCKEND        shift and go to state 259
    KEYWORD_CASE    shift and go to state 230
    KEYWORD_IF      shift and go to state 81
    KEYWORD_WHILE   shift and go to state 50
    KEYWORD_DO      shift and go to state 98
    KEYWORD_FOR     shift and go to state 97
    KEYWORD_OBJECT  shift and go to state 3
    BLOCKBEGIN      shift and go to state 15
    TERMINATOR      shift and go to state 53
    KEYWORD_RETURN  shift and go to state 68
    KEYWORD_PROTECTED shift and go to state 12
    KEYWORD_PRIVATE shift and go to state 9
    KEYWORD_DEF     reduce using rule 186 (empty -> .)
    KEYWORD_CLASS   reduce using rule 186 (empty -> .)
    KEYWORD_VAR     reduce using rule 186 (empty -> .)
    KEYWORD_VAL     reduce using rule 186 (empty -> .)
    IDENTIFIER      shift and go to state 77
    PLUS            shift and go to state 36
    MINUS           shift and go to state 29
    TILDA           shift and go to state 72
    NOT             shift and go to state 57
    LPAREN          shift and go to state 94
    DOUBLE_NUMBER   shift and go to state 33
    INT_NUMBER      shift and go to state 44
    CHAR            shift and go to state 63
    STRING          shift and go to state 76
    BOOL_CONSTT     shift and go to state 35
    BOOL_CONSTF     shift and go to state 30
    KEYWORD_NULL    shift and go to state 65

    expression_statement           shift and go to state 27
    unary_expression               shift and go to state 45
    exclusive_or_expression        shift and go to state 61
    normal_statement               shift and go to state 86
    ObjectDeclare                  shift and go to state 1
    class_header_name1             shift and go to state 2
    if_then_statement              shift and go to state 64
    array_access                   shift and go to state 28
    switch_statement               shift and go to state 47
    assignment_expression          shift and go to state 91
    qualified_name                 shift and go to state 79
    base_variable_set              shift and go to state 88
    valid_variable                 shift and go to state 48
    inclusive_or_expression        shift and go to state 32
    method_header_name             shift and go to state 42
    class_header_name              shift and go to state 5
    method_declaration             shift and go to state 69
    cast_expression                shift and go to state 80
    block_statement                shift and go to state 70
    return_statement               shift and go to state 89
    while_statement                shift and go to state 34
    and_expression                 shift and go to state 87
    statement                      shift and go to state 74
    literal                        shift and go to state 71
    statement_expression           shift and go to state 37
    method_invocation              shift and go to state 75
    simple_name                    shift and go to state 67
    conditional_or_expression      shift and go to state 49
    c_literal                      shift and go to state 93
    empty                          shift and go to state 6
    relational_expression          shift and go to state 73
    block_statements               shift and go to state 261
    for_statement                  shift and go to state 38
    local_variable_declaration_statement shift and go to state 39
    do_while_statement             shift and go to state 51
    int_float                      shift and go to state 40
    assignment                     shift and go to state 92
    multiplicative_expression      shift and go to state 52
    primary                        shift and go to state 62
    additive_expression            shift and go to state 66
    SingletonObject                shift and go to state 41
    switch_label                   shift and go to state 260
    class_header                   shift and go to state 10
    modifier_opts                  shift and go to state 95
    equality_expression            shift and go to state 82
    variable_literal               shift and go to state 55
    name                           shift and go to state 43
    unary_expression_not_plus_minus shift and go to state 46
    method_header                  shift and go to state 83
    empty_statement                shift and go to state 84
    class_declaration              shift and go to state 96
    shift_expression               shift and go to state 54
    local_variable_declaration     shift and go to state 85
    modifier                       shift and go to state 14
    expression                     shift and go to state 58
    conditional_and_expression     shift and go to state 56
    block                          shift and go to state 59
    if_then_else_statement         shift and go to state 60

state 229

    (160) switch_labels -> switch_label .

    BLOCKEND        reduce using rule 160 (switch_labels -> switch_label .)
    KEYWORD_CASE    reduce using rule 160 (switch_labels -> switch_label .)
    KEYWORD_IF      reduce using rule 160 (switch_labels -> switch_label .)
    KEYWORD_WHILE   reduce using rule 160 (switch_labels -> switch_label .)
    KEYWORD_DO      reduce using rule 160 (switch_labels -> switch_label .)
    KEYWORD_FOR     reduce using rule 160 (switch_labels -> switch_label .)
    KEYWORD_OBJECT  reduce using rule 160 (switch_labels -> switch_label .)
    BLOCKBEGIN      reduce using rule 160 (switch_labels -> switch_label .)
    TERMINATOR      reduce using rule 160 (switch_labels -> switch_label .)
    KEYWORD_RETURN  reduce using rule 160 (switch_labels -> switch_label .)
    KEYWORD_PROTECTED reduce using rule 160 (switch_labels -> switch_label .)
    KEYWORD_PRIVATE reduce using rule 160 (switch_labels -> switch_label .)
    IDENTIFIER      reduce using rule 160 (switch_labels -> switch_label .)
    PLUS            reduce using rule 160 (switch_labels -> switch_label .)
    MINUS           reduce using rule 160 (switch_labels -> switch_label .)
    TILDA           reduce using rule 160 (switch_labels -> switch_label .)
    NOT             reduce using rule 160 (switch_labels -> switch_label .)
    LPAREN          reduce using rule 160 (switch_labels -> switch_label .)
    DOUBLE_NUMBER   reduce using rule 160 (switch_labels -> switch_label .)
    INT_NUMBER      reduce using rule 160 (switch_labels -> switch_label .)
    CHAR            reduce using rule 160 (switch_labels -> switch_label .)
    STRING          reduce using rule 160 (switch_labels -> switch_label .)
    BOOL_CONSTT     reduce using rule 160 (switch_labels -> switch_label .)
    BOOL_CONSTF     reduce using rule 160 (switch_labels -> switch_label .)
    KEYWORD_NULL    reduce using rule 160 (switch_labels -> switch_label .)
    KEYWORD_DEF     reduce using rule 160 (switch_labels -> switch_label .)
    KEYWORD_CLASS   reduce using rule 160 (switch_labels -> switch_label .)
    KEYWORD_VAR     reduce using rule 160 (switch_labels -> switch_label .)
    KEYWORD_VAL     reduce using rule 160 (switch_labels -> switch_label .)


state 230

    (162) switch_label -> KEYWORD_CASE . expression FUNTYPE
    (18) expression -> . assignment_expression
    (21) assignment_expression -> . assignment
    (22) assignment_expression -> . conditional_or_expression
    (23) assignment -> . valid_variable assignment_operator assignment_expression
    (28) conditional_or_expression -> . conditional_and_expression
    (29) conditional_or_expression -> . conditional_or_expression OR conditional_and_expression
    (24) valid_variable -> . name
    (25) valid_variable -> . array_access
    (30) conditional_and_expression -> . inclusive_or_expression
    (31) conditional_and_expression -> . conditional_and_expression AND inclusive_or_expression
    (115) name -> . simple_name
    (116) name -> . qualified_name
    (26) array_access -> . name LBRAC expression RBRAC
    (32) inclusive_or_expression -> . exclusive_or_expression
    (33) inclusive_or_expression -> . inclusive_or_expression OR_BITWISE exclusive_or_expression
    (117) simple_name -> . IDENTIFIER
    (118) qualified_name -> . name INST simple_name
    (34) exclusive_or_expression -> . and_expression
    (35) exclusive_or_expression -> . exclusive_or_expression XOR and_expression
    (36) and_expression -> . equality_expression
    (37) and_expression -> . and_expression AND_BITWISE equality_expression
    (38) equality_expression -> . relational_expression
    (39) equality_expression -> . equality_expression EQUAL relational_expression
    (40) equality_expression -> . equality_expression NEQUAL relational_expression
    (41) relational_expression -> . shift_expression
    (42) relational_expression -> . relational_expression GREATER shift_expression
    (43) relational_expression -> . relational_expression LESS shift_expression
    (44) relational_expression -> . relational_expression GEQ shift_expression
    (45) relational_expression -> . relational_expression LEQ shift_expression
    (46) shift_expression -> . additive_expression
    (47) shift_expression -> . shift_expression LSHIFT additive_expression
    (48) shift_expression -> . shift_expression RSHIFT additive_expression
    (49) additive_expression -> . multiplicative_expression
    (50) additive_expression -> . additive_expression PLUS multiplicative_expression
    (51) additive_expression -> . additive_expression MINUS multiplicative_expression
    (52) multiplicative_expression -> . unary_expression
    (53) multiplicative_expression -> . multiplicative_expression TIMES unary_expression
    (54) multiplicative_expression -> . multiplicative_expression DIVIDE unary_expression
    (55) multiplicative_expression -> . multiplicative_expression REMAINDER unary_expression
    (56) unary_expression -> . PLUS unary_expression
    (57) unary_expression -> . MINUS unary_expression
    (58) unary_expression -> . unary_expression_not_plus_minus
    (59) unary_expression_not_plus_minus -> . base_variable_set
    (60) unary_expression_not_plus_minus -> . TILDA unary_expression
    (61) unary_expression_not_plus_minus -> . NOT unary_expression
    (62) unary_expression_not_plus_minus -> . cast_expression
    (63) base_variable_set -> . variable_literal
    (64) base_variable_set -> . LPAREN expression RPAREN
    (67) cast_expression -> . LPAREN primitive_type RPAREN unary_expression
    (65) variable_literal -> . valid_variable
    (66) variable_literal -> . primary
    (68) primary -> . literal
    (69) primary -> . method_invocation
    (70) literal -> . int_float
    (71) literal -> . c_literal
    (79) method_invocation -> . name LPAREN argument_list_opt RPAREN
    (77) int_float -> . DOUBLE_NUMBER
    (78) int_float -> . INT_NUMBER
    (72) c_literal -> . CHAR
    (73) c_literal -> . STRING
    (74) c_literal -> . BOOL_CONSTT
    (75) c_literal -> . BOOL_CONSTF
    (76) c_literal -> . KEYWORD_NULL

    IDENTIFIER      shift and go to state 77
    PLUS            shift and go to state 36
    MINUS           shift and go to state 29
    TILDA           shift and go to state 72
    NOT             shift and go to state 57
    LPAREN          shift and go to state 94
    DOUBLE_NUMBER   shift and go to state 33
    INT_NUMBER      shift and go to state 44
    CHAR            shift and go to state 63
    STRING          shift and go to state 76
    BOOL_CONSTT     shift and go to state 35
    BOOL_CONSTF     shift and go to state 30
    KEYWORD_NULL    shift and go to state 65

    unary_expression               shift and go to state 45
    exclusive_or_expression        shift and go to state 61
    primary                        shift and go to state 62
    unary_expression_not_plus_minus shift and go to state 46
    array_access                   shift and go to state 28
    additive_expression            shift and go to state 66
    simple_name                    shift and go to state 67
    c_literal                      shift and go to state 93
    base_variable_set              shift and go to state 88
    valid_variable                 shift and go to state 48
    inclusive_or_expression        shift and go to state 32
    literal                        shift and go to state 71
    and_expression                 shift and go to state 87
    relational_expression          shift and go to state 73
    cast_expression                shift and go to state 80
    conditional_or_expression      shift and go to state 49
    assignment_expression          shift and go to state 91
    qualified_name                 shift and go to state 79
    assignment                     shift and go to state 138
    multiplicative_expression      shift and go to state 52
    method_invocation              shift and go to state 111
    shift_expression               shift and go to state 54
    equality_expression            shift and go to state 82
    int_float                      shift and go to state 40
    variable_literal               shift and go to state 55
    name                           shift and go to state 139
    expression                     shift and go to state 262
    conditional_and_expression     shift and go to state 56

state 231

    (153) switch_block -> BLOCKBEGIN BLOCKEND .

    KEYWORD_IF      reduce using rule 153 (switch_block -> BLOCKBEGIN BLOCKEND .)
    KEYWORD_WHILE   reduce using rule 153 (switch_block -> BLOCKBEGIN BLOCKEND .)
    KEYWORD_DO      reduce using rule 153 (switch_block -> BLOCKBEGIN BLOCKEND .)
    KEYWORD_FOR     reduce using rule 153 (switch_block -> BLOCKBEGIN BLOCKEND .)
    KEYWORD_OBJECT  reduce using rule 153 (switch_block -> BLOCKBEGIN BLOCKEND .)
    BLOCKBEGIN      reduce using rule 153 (switch_block -> BLOCKBEGIN BLOCKEND .)
    TERMINATOR      reduce using rule 153 (switch_block -> BLOCKBEGIN BLOCKEND .)
    KEYWORD_RETURN  reduce using rule 153 (switch_block -> BLOCKBEGIN BLOCKEND .)
    KEYWORD_PROTECTED reduce using rule 153 (switch_block -> BLOCKBEGIN BLOCKEND .)
    KEYWORD_PRIVATE reduce using rule 153 (switch_block -> BLOCKBEGIN BLOCKEND .)
    IDENTIFIER      reduce using rule 153 (switch_block -> BLOCKBEGIN BLOCKEND .)
    PLUS            reduce using rule 153 (switch_block -> BLOCKBEGIN BLOCKEND .)
    MINUS           reduce using rule 153 (switch_block -> BLOCKBEGIN BLOCKEND .)
    TILDA           reduce using rule 153 (switch_block -> BLOCKBEGIN BLOCKEND .)
    NOT             reduce using rule 153 (switch_block -> BLOCKBEGIN BLOCKEND .)
    LPAREN          reduce using rule 153 (switch_block -> BLOCKBEGIN BLOCKEND .)
    DOUBLE_NUMBER   reduce using rule 153 (switch_block -> BLOCKBEGIN BLOCKEND .)
    INT_NUMBER      reduce using rule 153 (switch_block -> BLOCKBEGIN BLOCKEND .)
    CHAR            reduce using rule 153 (switch_block -> BLOCKBEGIN BLOCKEND .)
    STRING          reduce using rule 153 (switch_block -> BLOCKBEGIN BLOCKEND .)
    BOOL_CONSTT     reduce using rule 153 (switch_block -> BLOCKBEGIN BLOCKEND .)
    BOOL_CONSTF     reduce using rule 153 (switch_block -> BLOCKBEGIN BLOCKEND .)
    KEYWORD_NULL    reduce using rule 153 (switch_block -> BLOCKBEGIN BLOCKEND .)
    KEYWORD_DEF     reduce using rule 153 (switch_block -> BLOCKBEGIN BLOCKEND .)
    KEYWORD_CLASS   reduce using rule 153 (switch_block -> BLOCKBEGIN BLOCKEND .)
    KEYWORD_VAR     reduce using rule 153 (switch_block -> BLOCKBEGIN BLOCKEND .)
    KEYWORD_VAL     reduce using rule 153 (switch_block -> BLOCKBEGIN BLOCKEND .)
    BLOCKEND        reduce using rule 153 (switch_block -> BLOCKBEGIN BLOCKEND .)
    KEYWORD_CASE    reduce using rule 153 (switch_block -> BLOCKBEGIN BLOCKEND .)
    KEYWORD_ELSE    reduce using rule 153 (switch_block -> BLOCKBEGIN BLOCKEND .)


state 232

    (154) switch_block -> BLOCKBEGIN switch_block_statements . BLOCKEND
    (156) switch_block -> BLOCKBEGIN switch_block_statements . switch_labels BLOCKEND
    (158) switch_block_statements -> switch_block_statements . switch_block_statement
    (160) switch_labels -> . switch_label
    (161) switch_labels -> . switch_labels switch_label
    (159) switch_block_statement -> . switch_labels block_statements
    (162) switch_label -> . KEYWORD_CASE expression FUNTYPE

    BLOCKEND        shift and go to state 264
    KEYWORD_CASE    shift and go to state 230

    switch_labels                  shift and go to state 263
    switch_label                   shift and go to state 229
    switch_block_statement         shift and go to state 265

state 233

    (157) switch_block_statements -> switch_block_statement .

    BLOCKEND        reduce using rule 157 (switch_block_statements -> switch_block_statement .)
    KEYWORD_CASE    reduce using rule 157 (switch_block_statements -> switch_block_statement .)


state 234

    (136) if_then_statement -> KEYWORD_IF LPAREN expression RPAREN . statement
    (137) if_then_else_statement -> KEYWORD_IF LPAREN expression RPAREN . if_then_else_intermediate KEYWORD_ELSE statement
    (122) statement -> . normal_statement
    (123) statement -> . if_then_statement
    (124) statement -> . if_then_else_statement
    (125) statement -> . while_statement
    (126) statement -> . do_while_statement
    (127) statement -> . for_statement
    (139) if_then_else_intermediate -> . normal_statement
    (140) if_then_else_intermediate -> . if_then_else_statement_precedence
    (128) normal_statement -> . block
    (129) normal_statement -> . expression_statement
    (130) normal_statement -> . empty_statement
    (131) normal_statement -> . return_statement
    (132) normal_statement -> . switch_statement
    (136) if_then_statement -> . KEYWORD_IF LPAREN expression RPAREN statement
    (137) if_then_else_statement -> . KEYWORD_IF LPAREN expression RPAREN if_then_else_intermediate KEYWORD_ELSE statement
    (141) while_statement -> . KEYWORD_WHILE LPAREN expression RPAREN statement
    (142) do_while_statement -> . KEYWORD_DO statement KEYWORD_WHILE LPAREN expression RPAREN TERMINATOR
    (143) for_statement -> . KEYWORD_FOR LPAREN for_logic RPAREN statement
    (138) if_then_else_statement_precedence -> . KEYWORD_IF LPAREN expression RPAREN if_then_else_intermediate KEYWORD_ELSE if_then_else_intermediate
    (8) block -> . BLOCKBEGIN block_statements_opt BLOCKEND
    (133) expression_statement -> . statement_expression TERMINATOR
    (163) empty_statement -> . TERMINATOR
    (164) return_statement -> . KEYWORD_RETURN expression_optional TERMINATOR
    (152) switch_statement -> . expression KEYWORD_MATCH switch_block
    (134) statement_expression -> . assignment
    (135) statement_expression -> . method_invocation
    (18) expression -> . assignment_expression
    (23) assignment -> . valid_variable assignment_operator assignment_expression
    (79) method_invocation -> . name LPAREN argument_list_opt RPAREN
    (21) assignment_expression -> . assignment
    (22) assignment_expression -> . conditional_or_expression
    (24) valid_variable -> . name
    (25) valid_variable -> . array_access
    (115) name -> . simple_name
    (116) name -> . qualified_name
    (28) conditional_or_expression -> . conditional_and_expression
    (29) conditional_or_expression -> . conditional_or_expression OR conditional_and_expression
    (26) array_access -> . name LBRAC expression RBRAC
    (117) simple_name -> . IDENTIFIER
    (118) qualified_name -> . name INST simple_name
    (30) conditional_and_expression -> . inclusive_or_expression
    (31) conditional_and_expression -> . conditional_and_expression AND inclusive_or_expression
    (32) inclusive_or_expression -> . exclusive_or_expression
    (33) inclusive_or_expression -> . inclusive_or_expression OR_BITWISE exclusive_or_expression
    (34) exclusive_or_expression -> . and_expression
    (35) exclusive_or_expression -> . exclusive_or_expression XOR and_expression
    (36) and_expression -> . equality_expression
    (37) and_expression -> . and_expression AND_BITWISE equality_expression
    (38) equality_expression -> . relational_expression
    (39) equality_expression -> . equality_expression EQUAL relational_expression
    (40) equality_expression -> . equality_expression NEQUAL relational_expression
    (41) relational_expression -> . shift_expression
    (42) relational_expression -> . relational_expression GREATER shift_expression
    (43) relational_expression -> . relational_expression LESS shift_expression
    (44) relational_expression -> . relational_expression GEQ shift_expression
    (45) relational_expression -> . relational_expression LEQ shift_expression
    (46) shift_expression -> . additive_expression
    (47) shift_expression -> . shift_expression LSHIFT additive_expression
    (48) shift_expression -> . shift_expression RSHIFT additive_expression
    (49) additive_expression -> . multiplicative_expression
    (50) additive_expression -> . additive_expression PLUS multiplicative_expression
    (51) additive_expression -> . additive_expression MINUS multiplicative_expression
    (52) multiplicative_expression -> . unary_expression
    (53) multiplicative_expression -> . multiplicative_expression TIMES unary_expression
    (54) multiplicative_expression -> . multiplicative_expression DIVIDE unary_expression
    (55) multiplicative_expression -> . multiplicative_expression REMAINDER unary_expression
    (56) unary_expression -> . PLUS unary_expression
    (57) unary_expression -> . MINUS unary_expression
    (58) unary_expression -> . unary_expression_not_plus_minus
    (59) unary_expression_not_plus_minus -> . base_variable_set
    (60) unary_expression_not_plus_minus -> . TILDA unary_expression
    (61) unary_expression_not_plus_minus -> . NOT unary_expression
    (62) unary_expression_not_plus_minus -> . cast_expression
    (63) base_variable_set -> . variable_literal
    (64) base_variable_set -> . LPAREN expression RPAREN
    (67) cast_expression -> . LPAREN primitive_type RPAREN unary_expression
    (65) variable_literal -> . valid_variable
    (66) variable_literal -> . primary
    (68) primary -> . literal
    (69) primary -> . method_invocation
    (70) literal -> . int_float
    (71) literal -> . c_literal
    (77) int_float -> . DOUBLE_NUMBER
    (78) int_float -> . INT_NUMBER
    (72) c_literal -> . CHAR
    (73) c_literal -> . STRING
    (74) c_literal -> . BOOL_CONSTT
    (75) c_literal -> . BOOL_CONSTF
    (76) c_literal -> . KEYWORD_NULL

    KEYWORD_IF      shift and go to state 268
    KEYWORD_WHILE   shift and go to state 50
    KEYWORD_DO      shift and go to state 98
    KEYWORD_FOR     shift and go to state 97
    BLOCKBEGIN      shift and go to state 15
    TERMINATOR      shift and go to state 53
    KEYWORD_RETURN  shift and go to state 68
    IDENTIFIER      shift and go to state 77
    PLUS            shift and go to state 36
    MINUS           shift and go to state 29
    TILDA           shift and go to state 72
    NOT             shift and go to state 57
    LPAREN          shift and go to state 94
    DOUBLE_NUMBER   shift and go to state 33
    INT_NUMBER      shift and go to state 44
    CHAR            shift and go to state 63
    STRING          shift and go to state 76
    BOOL_CONSTT     shift and go to state 35
    BOOL_CONSTF     shift and go to state 30
    KEYWORD_NULL    shift and go to state 65

    expression_statement           shift and go to state 27
    if_then_else_statement_precedence shift and go to state 269
    unary_expression               shift and go to state 45
    exclusive_or_expression        shift and go to state 61
    normal_statement               shift and go to state 270
    primary                        shift and go to state 62
    unary_expression_not_plus_minus shift and go to state 46
    if_then_else_intermediate      shift and go to state 266
    if_then_statement              shift and go to state 64
    array_access                   shift and go to state 28
    switch_statement               shift and go to state 47
    assignment_expression          shift and go to state 91
    qualified_name                 shift and go to state 79
    base_variable_set              shift and go to state 88
    valid_variable                 shift and go to state 48
    inclusive_or_expression        shift and go to state 32
    literal                        shift and go to state 71
    return_statement               shift and go to state 89
    while_statement                shift and go to state 34
    and_expression                 shift and go to state 87
    statement                      shift and go to state 267
    statement_expression           shift and go to state 37
    method_invocation              shift and go to state 75
    simple_name                    shift and go to state 67
    conditional_or_expression      shift and go to state 49
    relational_expression          shift and go to state 73
    for_statement                  shift and go to state 38
    do_while_statement             shift and go to state 51
    assignment                     shift and go to state 92
    multiplicative_expression      shift and go to state 52
    c_literal                      shift and go to state 93
    additive_expression            shift and go to state 66
    cast_expression                shift and go to state 80
    shift_expression               shift and go to state 54
    equality_expression            shift and go to state 82
    int_float                      shift and go to state 40
    variable_literal               shift and go to state 55
    name                           shift and go to state 43
    empty_statement                shift and go to state 84
    expression                     shift and go to state 58
    conditional_and_expression     shift and go to state 56
    block                          shift and go to state 59
    if_then_else_statement         shift and go to state 60

state 235

    (67) cast_expression -> LPAREN primitive_type RPAREN unary_expression .

    TIMES           reduce using rule 67 (cast_expression -> LPAREN primitive_type RPAREN unary_expression .)
    DIVIDE          reduce using rule 67 (cast_expression -> LPAREN primitive_type RPAREN unary_expression .)
    REMAINDER       reduce using rule 67 (cast_expression -> LPAREN primitive_type RPAREN unary_expression .)
    PLUS            reduce using rule 67 (cast_expression -> LPAREN primitive_type RPAREN unary_expression .)
    MINUS           reduce using rule 67 (cast_expression -> LPAREN primitive_type RPAREN unary_expression .)
    LSHIFT          reduce using rule 67 (cast_expression -> LPAREN primitive_type RPAREN unary_expression .)
    RSHIFT          reduce using rule 67 (cast_expression -> LPAREN primitive_type RPAREN unary_expression .)
    GREATER         reduce using rule 67 (cast_expression -> LPAREN primitive_type RPAREN unary_expression .)
    LESS            reduce using rule 67 (cast_expression -> LPAREN primitive_type RPAREN unary_expression .)
    GEQ             reduce using rule 67 (cast_expression -> LPAREN primitive_type RPAREN unary_expression .)
    LEQ             reduce using rule 67 (cast_expression -> LPAREN primitive_type RPAREN unary_expression .)
    EQUAL           reduce using rule 67 (cast_expression -> LPAREN primitive_type RPAREN unary_expression .)
    NEQUAL          reduce using rule 67 (cast_expression -> LPAREN primitive_type RPAREN unary_expression .)
    AND_BITWISE     reduce using rule 67 (cast_expression -> LPAREN primitive_type RPAREN unary_expression .)
    XOR             reduce using rule 67 (cast_expression -> LPAREN primitive_type RPAREN unary_expression .)
    OR_BITWISE      reduce using rule 67 (cast_expression -> LPAREN primitive_type RPAREN unary_expression .)
    AND             reduce using rule 67 (cast_expression -> LPAREN primitive_type RPAREN unary_expression .)
    OR              reduce using rule 67 (cast_expression -> LPAREN primitive_type RPAREN unary_expression .)
    RPAREN          reduce using rule 67 (cast_expression -> LPAREN primitive_type RPAREN unary_expression .)
    KEYWORD_MATCH   reduce using rule 67 (cast_expression -> LPAREN primitive_type RPAREN unary_expression .)
    TERMINATOR      reduce using rule 67 (cast_expression -> LPAREN primitive_type RPAREN unary_expression .)
    RBRAC           reduce using rule 67 (cast_expression -> LPAREN primitive_type RPAREN unary_expression .)
    COMMA           reduce using rule 67 (cast_expression -> LPAREN primitive_type RPAREN unary_expression .)
    FUNTYPE         reduce using rule 67 (cast_expression -> LPAREN primitive_type RPAREN unary_expression .)
    KEYWORD_UNTIL   reduce using rule 67 (cast_expression -> LPAREN primitive_type RPAREN unary_expression .)
    KEYWORD_TO      reduce using rule 67 (cast_expression -> LPAREN primitive_type RPAREN unary_expression .)
    KEYWORD_BY      reduce using rule 67 (cast_expression -> LPAREN primitive_type RPAREN unary_expression .)


state 236

    (97) variable_declaration_body -> variable_declarator ASOP . variable_declaration_initializer
    (92) variable_declaration_initializer -> . expression
    (93) variable_declaration_initializer -> . array_initializer
    (94) variable_declaration_initializer -> . class_initializer
    (18) expression -> . assignment_expression
    (119) array_initializer -> . KEYWORD_NEW KEYWORD_ARRAY LBRAC type RBRAC LPAREN INT_NUMBER RPAREN
    (120) array_initializer -> . KEYWORD_ARRAY LPAREN argument_list_opt RPAREN
    (121) class_initializer -> . KEYWORD_NEW name LPAREN argument_list_opt RPAREN
    (21) assignment_expression -> . assignment
    (22) assignment_expression -> . conditional_or_expression
    (23) assignment -> . valid_variable assignment_operator assignment_expression
    (28) conditional_or_expression -> . conditional_and_expression
    (29) conditional_or_expression -> . conditional_or_expression OR conditional_and_expression
    (24) valid_variable -> . name
    (25) valid_variable -> . array_access
    (30) conditional_and_expression -> . inclusive_or_expression
    (31) conditional_and_expression -> . conditional_and_expression AND inclusive_or_expression
    (115) name -> . simple_name
    (116) name -> . qualified_name
    (26) array_access -> . name LBRAC expression RBRAC
    (32) inclusive_or_expression -> . exclusive_or_expression
    (33) inclusive_or_expression -> . inclusive_or_expression OR_BITWISE exclusive_or_expression
    (117) simple_name -> . IDENTIFIER
    (118) qualified_name -> . name INST simple_name
    (34) exclusive_or_expression -> . and_expression
    (35) exclusive_or_expression -> . exclusive_or_expression XOR and_expression
    (36) and_expression -> . equality_expression
    (37) and_expression -> . and_expression AND_BITWISE equality_expression
    (38) equality_expression -> . relational_expression
    (39) equality_expression -> . equality_expression EQUAL relational_expression
    (40) equality_expression -> . equality_expression NEQUAL relational_expression
    (41) relational_expression -> . shift_expression
    (42) relational_expression -> . relational_expression GREATER shift_expression
    (43) relational_expression -> . relational_expression LESS shift_expression
    (44) relational_expression -> . relational_expression GEQ shift_expression
    (45) relational_expression -> . relational_expression LEQ shift_expression
    (46) shift_expression -> . additive_expression
    (47) shift_expression -> . shift_expression LSHIFT additive_expression
    (48) shift_expression -> . shift_expression RSHIFT additive_expression
    (49) additive_expression -> . multiplicative_expression
    (50) additive_expression -> . additive_expression PLUS multiplicative_expression
    (51) additive_expression -> . additive_expression MINUS multiplicative_expression
    (52) multiplicative_expression -> . unary_expression
    (53) multiplicative_expression -> . multiplicative_expression TIMES unary_expression
    (54) multiplicative_expression -> . multiplicative_expression DIVIDE unary_expression
    (55) multiplicative_expression -> . multiplicative_expression REMAINDER unary_expression
    (56) unary_expression -> . PLUS unary_expression
    (57) unary_expression -> . MINUS unary_expression
    (58) unary_expression -> . unary_expression_not_plus_minus
    (59) unary_expression_not_plus_minus -> . base_variable_set
    (60) unary_expression_not_plus_minus -> . TILDA unary_expression
    (61) unary_expression_not_plus_minus -> . NOT unary_expression
    (62) unary_expression_not_plus_minus -> . cast_expression
    (63) base_variable_set -> . variable_literal
    (64) base_variable_set -> . LPAREN expression RPAREN
    (67) cast_expression -> . LPAREN primitive_type RPAREN unary_expression
    (65) variable_literal -> . valid_variable
    (66) variable_literal -> . primary
    (68) primary -> . literal
    (69) primary -> . method_invocation
    (70) literal -> . int_float
    (71) literal -> . c_literal
    (79) method_invocation -> . name LPAREN argument_list_opt RPAREN
    (77) int_float -> . DOUBLE_NUMBER
    (78) int_float -> . INT_NUMBER
    (72) c_literal -> . CHAR
    (73) c_literal -> . STRING
    (74) c_literal -> . BOOL_CONSTT
    (75) c_literal -> . BOOL_CONSTF
    (76) c_literal -> . KEYWORD_NULL

    KEYWORD_NEW     shift and go to state 273
    KEYWORD_ARRAY   shift and go to state 275
    IDENTIFIER      shift and go to state 77
    PLUS            shift and go to state 36
    MINUS           shift and go to state 29
    TILDA           shift and go to state 72
    NOT             shift and go to state 57
    LPAREN          shift and go to state 94
    DOUBLE_NUMBER   shift and go to state 33
    INT_NUMBER      shift and go to state 44
    CHAR            shift and go to state 63
    STRING          shift and go to state 76
    BOOL_CONSTT     shift and go to state 35
    BOOL_CONSTF     shift and go to state 30
    KEYWORD_NULL    shift and go to state 65

    variable_declaration_initializer shift and go to state 271
    unary_expression               shift and go to state 45
    exclusive_or_expression        shift and go to state 61
    primary                        shift and go to state 62
    unary_expression_not_plus_minus shift and go to state 46
    array_access                   shift and go to state 28
    and_expression                 shift and go to state 87
    simple_name                    shift and go to state 67
    c_literal                      shift and go to state 93
    base_variable_set              shift and go to state 88
    valid_variable                 shift and go to state 48
    inclusive_or_expression        shift and go to state 32
    literal                        shift and go to state 71
    relational_expression          shift and go to state 73
    cast_expression                shift and go to state 80
    conditional_or_expression      shift and go to state 49
    assignment_expression          shift and go to state 91
    qualified_name                 shift and go to state 79
    assignment                     shift and go to state 138
    multiplicative_expression      shift and go to state 52
    additive_expression            shift and go to state 66
    method_invocation              shift and go to state 111
    class_initializer              shift and go to state 274
    shift_expression               shift and go to state 54
    equality_expression            shift and go to state 82
    array_initializer              shift and go to state 272
    int_float                      shift and go to state 40
    variable_literal               shift and go to state 55
    name                           shift and go to state 139
    expression                     shift and go to state 276
    conditional_and_expression     shift and go to state 56

state 237

    (98) variable_declaration_body -> LPAREN variable_declarators . RPAREN ASOP LPAREN variable_arguement_list RPAREN
    (101) variable_declarators -> variable_declarators . COMMA variable_declarator

    RPAREN          shift and go to state 277
    COMMA           shift and go to state 222


state 238

    (99) variable_declaration_body -> IDENTIFIER ASOP . LPAREN func_arguement_list_opt RPAREN FUNTYPE expression

    LPAREN          shift and go to state 278


state 239

    (150) for_step_opts -> KEYWORD_BY . expression
    (18) expression -> . assignment_expression
    (21) assignment_expression -> . assignment
    (22) assignment_expression -> . conditional_or_expression
    (23) assignment -> . valid_variable assignment_operator assignment_expression
    (28) conditional_or_expression -> . conditional_and_expression
    (29) conditional_or_expression -> . conditional_or_expression OR conditional_and_expression
    (24) valid_variable -> . name
    (25) valid_variable -> . array_access
    (30) conditional_and_expression -> . inclusive_or_expression
    (31) conditional_and_expression -> . conditional_and_expression AND inclusive_or_expression
    (115) name -> . simple_name
    (116) name -> . qualified_name
    (26) array_access -> . name LBRAC expression RBRAC
    (32) inclusive_or_expression -> . exclusive_or_expression
    (33) inclusive_or_expression -> . inclusive_or_expression OR_BITWISE exclusive_or_expression
    (117) simple_name -> . IDENTIFIER
    (118) qualified_name -> . name INST simple_name
    (34) exclusive_or_expression -> . and_expression
    (35) exclusive_or_expression -> . exclusive_or_expression XOR and_expression
    (36) and_expression -> . equality_expression
    (37) and_expression -> . and_expression AND_BITWISE equality_expression
    (38) equality_expression -> . relational_expression
    (39) equality_expression -> . equality_expression EQUAL relational_expression
    (40) equality_expression -> . equality_expression NEQUAL relational_expression
    (41) relational_expression -> . shift_expression
    (42) relational_expression -> . relational_expression GREATER shift_expression
    (43) relational_expression -> . relational_expression LESS shift_expression
    (44) relational_expression -> . relational_expression GEQ shift_expression
    (45) relational_expression -> . relational_expression LEQ shift_expression
    (46) shift_expression -> . additive_expression
    (47) shift_expression -> . shift_expression LSHIFT additive_expression
    (48) shift_expression -> . shift_expression RSHIFT additive_expression
    (49) additive_expression -> . multiplicative_expression
    (50) additive_expression -> . additive_expression PLUS multiplicative_expression
    (51) additive_expression -> . additive_expression MINUS multiplicative_expression
    (52) multiplicative_expression -> . unary_expression
    (53) multiplicative_expression -> . multiplicative_expression TIMES unary_expression
    (54) multiplicative_expression -> . multiplicative_expression DIVIDE unary_expression
    (55) multiplicative_expression -> . multiplicative_expression REMAINDER unary_expression
    (56) unary_expression -> . PLUS unary_expression
    (57) unary_expression -> . MINUS unary_expression
    (58) unary_expression -> . unary_expression_not_plus_minus
    (59) unary_expression_not_plus_minus -> . base_variable_set
    (60) unary_expression_not_plus_minus -> . TILDA unary_expression
    (61) unary_expression_not_plus_minus -> . NOT unary_expression
    (62) unary_expression_not_plus_minus -> . cast_expression
    (63) base_variable_set -> . variable_literal
    (64) base_variable_set -> . LPAREN expression RPAREN
    (67) cast_expression -> . LPAREN primitive_type RPAREN unary_expression
    (65) variable_literal -> . valid_variable
    (66) variable_literal -> . primary
    (68) primary -> . literal
    (69) primary -> . method_invocation
    (70) literal -> . int_float
    (71) literal -> . c_literal
    (79) method_invocation -> . name LPAREN argument_list_opt RPAREN
    (77) int_float -> . DOUBLE_NUMBER
    (78) int_float -> . INT_NUMBER
    (72) c_literal -> . CHAR
    (73) c_literal -> . STRING
    (74) c_literal -> . BOOL_CONSTT
    (75) c_literal -> . BOOL_CONSTF
    (76) c_literal -> . KEYWORD_NULL

    IDENTIFIER      shift and go to state 77
    PLUS            shift and go to state 36
    MINUS           shift and go to state 29
    TILDA           shift and go to state 72
    NOT             shift and go to state 57
    LPAREN          shift and go to state 94
    DOUBLE_NUMBER   shift and go to state 33
    INT_NUMBER      shift and go to state 44
    CHAR            shift and go to state 63
    STRING          shift and go to state 76
    BOOL_CONSTT     shift and go to state 35
    BOOL_CONSTF     shift and go to state 30
    KEYWORD_NULL    shift and go to state 65

    unary_expression               shift and go to state 45
    exclusive_or_expression        shift and go to state 61
    primary                        shift and go to state 62
    unary_expression_not_plus_minus shift and go to state 46
    array_access                   shift and go to state 28
    additive_expression            shift and go to state 66
    simple_name                    shift and go to state 67
    c_literal                      shift and go to state 93
    base_variable_set              shift and go to state 88
    valid_variable                 shift and go to state 48
    inclusive_or_expression        shift and go to state 32
    literal                        shift and go to state 71
    and_expression                 shift and go to state 87
    relational_expression          shift and go to state 73
    cast_expression                shift and go to state 80
    conditional_or_expression      shift and go to state 49
    assignment_expression          shift and go to state 91
    qualified_name                 shift and go to state 79
    assignment                     shift and go to state 138
    multiplicative_expression      shift and go to state 52
    method_invocation              shift and go to state 111
    shift_expression               shift and go to state 54
    equality_expression            shift and go to state 82
    int_float                      shift and go to state 40
    variable_literal               shift and go to state 55
    name                           shift and go to state 139
    expression                     shift and go to state 279
    conditional_and_expression     shift and go to state 56

state 240

    (146) for_update -> for_loop for_step_opts .

    TERMINATOR      reduce using rule 146 (for_update -> for_loop for_step_opts .)
    RPAREN          reduce using rule 146 (for_update -> for_loop for_step_opts .)


state 241

    (151) for_step_opts -> empty .

    TERMINATOR      reduce using rule 151 (for_step_opts -> empty .)
    RPAREN          reduce using rule 151 (for_step_opts -> empty .)


state 242

    (143) for_statement -> KEYWORD_FOR LPAREN for_logic RPAREN . statement
    (122) statement -> . normal_statement
    (123) statement -> . if_then_statement
    (124) statement -> . if_then_else_statement
    (125) statement -> . while_statement
    (126) statement -> . do_while_statement
    (127) statement -> . for_statement
    (128) normal_statement -> . block
    (129) normal_statement -> . expression_statement
    (130) normal_statement -> . empty_statement
    (131) normal_statement -> . return_statement
    (132) normal_statement -> . switch_statement
    (136) if_then_statement -> . KEYWORD_IF LPAREN expression RPAREN statement
    (137) if_then_else_statement -> . KEYWORD_IF LPAREN expression RPAREN if_then_else_intermediate KEYWORD_ELSE statement
    (141) while_statement -> . KEYWORD_WHILE LPAREN expression RPAREN statement
    (142) do_while_statement -> . KEYWORD_DO statement KEYWORD_WHILE LPAREN expression RPAREN TERMINATOR
    (143) for_statement -> . KEYWORD_FOR LPAREN for_logic RPAREN statement
    (8) block -> . BLOCKBEGIN block_statements_opt BLOCKEND
    (133) expression_statement -> . statement_expression TERMINATOR
    (163) empty_statement -> . TERMINATOR
    (164) return_statement -> . KEYWORD_RETURN expression_optional TERMINATOR
    (152) switch_statement -> . expression KEYWORD_MATCH switch_block
    (134) statement_expression -> . assignment
    (135) statement_expression -> . method_invocation
    (18) expression -> . assignment_expression
    (23) assignment -> . valid_variable assignment_operator assignment_expression
    (79) method_invocation -> . name LPAREN argument_list_opt RPAREN
    (21) assignment_expression -> . assignment
    (22) assignment_expression -> . conditional_or_expression
    (24) valid_variable -> . name
    (25) valid_variable -> . array_access
    (115) name -> . simple_name
    (116) name -> . qualified_name
    (28) conditional_or_expression -> . conditional_and_expression
    (29) conditional_or_expression -> . conditional_or_expression OR conditional_and_expression
    (26) array_access -> . name LBRAC expression RBRAC
    (117) simple_name -> . IDENTIFIER
    (118) qualified_name -> . name INST simple_name
    (30) conditional_and_expression -> . inclusive_or_expression
    (31) conditional_and_expression -> . conditional_and_expression AND inclusive_or_expression
    (32) inclusive_or_expression -> . exclusive_or_expression
    (33) inclusive_or_expression -> . inclusive_or_expression OR_BITWISE exclusive_or_expression
    (34) exclusive_or_expression -> . and_expression
    (35) exclusive_or_expression -> . exclusive_or_expression XOR and_expression
    (36) and_expression -> . equality_expression
    (37) and_expression -> . and_expression AND_BITWISE equality_expression
    (38) equality_expression -> . relational_expression
    (39) equality_expression -> . equality_expression EQUAL relational_expression
    (40) equality_expression -> . equality_expression NEQUAL relational_expression
    (41) relational_expression -> . shift_expression
    (42) relational_expression -> . relational_expression GREATER shift_expression
    (43) relational_expression -> . relational_expression LESS shift_expression
    (44) relational_expression -> . relational_expression GEQ shift_expression
    (45) relational_expression -> . relational_expression LEQ shift_expression
    (46) shift_expression -> . additive_expression
    (47) shift_expression -> . shift_expression LSHIFT additive_expression
    (48) shift_expression -> . shift_expression RSHIFT additive_expression
    (49) additive_expression -> . multiplicative_expression
    (50) additive_expression -> . additive_expression PLUS multiplicative_expression
    (51) additive_expression -> . additive_expression MINUS multiplicative_expression
    (52) multiplicative_expression -> . unary_expression
    (53) multiplicative_expression -> . multiplicative_expression TIMES unary_expression
    (54) multiplicative_expression -> . multiplicative_expression DIVIDE unary_expression
    (55) multiplicative_expression -> . multiplicative_expression REMAINDER unary_expression
    (56) unary_expression -> . PLUS unary_expression
    (57) unary_expression -> . MINUS unary_expression
    (58) unary_expression -> . unary_expression_not_plus_minus
    (59) unary_expression_not_plus_minus -> . base_variable_set
    (60) unary_expression_not_plus_minus -> . TILDA unary_expression
    (61) unary_expression_not_plus_minus -> . NOT unary_expression
    (62) unary_expression_not_plus_minus -> . cast_expression
    (63) base_variable_set -> . variable_literal
    (64) base_variable_set -> . LPAREN expression RPAREN
    (67) cast_expression -> . LPAREN primitive_type RPAREN unary_expression
    (65) variable_literal -> . valid_variable
    (66) variable_literal -> . primary
    (68) primary -> . literal
    (69) primary -> . method_invocation
    (70) literal -> . int_float
    (71) literal -> . c_literal
    (77) int_float -> . DOUBLE_NUMBER
    (78) int_float -> . INT_NUMBER
    (72) c_literal -> . CHAR
    (73) c_literal -> . STRING
    (74) c_literal -> . BOOL_CONSTT
    (75) c_literal -> . BOOL_CONSTF
    (76) c_literal -> . KEYWORD_NULL

    KEYWORD_IF      shift and go to state 81
    KEYWORD_WHILE   shift and go to state 50
    KEYWORD_DO      shift and go to state 98
    KEYWORD_FOR     shift and go to state 97
    BLOCKBEGIN      shift and go to state 15
    TERMINATOR      shift and go to state 53
    KEYWORD_RETURN  shift and go to state 68
    IDENTIFIER      shift and go to state 77
    PLUS            shift and go to state 36
    MINUS           shift and go to state 29
    TILDA           shift and go to state 72
    NOT             shift and go to state 57
    LPAREN          shift and go to state 94
    DOUBLE_NUMBER   shift and go to state 33
    INT_NUMBER      shift and go to state 44
    CHAR            shift and go to state 63
    STRING          shift and go to state 76
    BOOL_CONSTT     shift and go to state 35
    BOOL_CONSTF     shift and go to state 30
    KEYWORD_NULL    shift and go to state 65

    expression_statement           shift and go to state 27
    unary_expression               shift and go to state 45
    exclusive_or_expression        shift and go to state 61
    normal_statement               shift and go to state 86
    primary                        shift and go to state 62
    unary_expression_not_plus_minus shift and go to state 46
    if_then_statement              shift and go to state 64
    array_access                   shift and go to state 28
    switch_statement               shift and go to state 47
    assignment_expression          shift and go to state 91
    qualified_name                 shift and go to state 79
    base_variable_set              shift and go to state 88
    valid_variable                 shift and go to state 48
    inclusive_or_expression        shift and go to state 32
    literal                        shift and go to state 71
    return_statement               shift and go to state 89
    while_statement                shift and go to state 34
    and_expression                 shift and go to state 87
    statement                      shift and go to state 280
    statement_expression           shift and go to state 37
    method_invocation              shift and go to state 75
    simple_name                    shift and go to state 67
    conditional_or_expression      shift and go to state 49
    relational_expression          shift and go to state 73
    for_statement                  shift and go to state 38
    do_while_statement             shift and go to state 51
    assignment                     shift and go to state 92
    multiplicative_expression      shift and go to state 52
    c_literal                      shift and go to state 93
    additive_expression            shift and go to state 66
    cast_expression                shift and go to state 80
    shift_expression               shift and go to state 54
    equality_expression            shift and go to state 82
    int_float                      shift and go to state 40
    variable_literal               shift and go to state 55
    name                           shift and go to state 43
    empty_statement                shift and go to state 84
    expression                     shift and go to state 58
    conditional_and_expression     shift and go to state 56
    block                          shift and go to state 59
    if_then_else_statement         shift and go to state 60

state 243

    (145) for_logic -> for_update TERMINATOR . for_logic
    (144) for_logic -> . for_update
    (145) for_logic -> . for_update TERMINATOR for_logic
    (146) for_update -> . for_loop for_step_opts
    (147) for_loop -> . IDENTIFIER CHOOSE expression for_untilTo expression

    IDENTIFIER      shift and go to state 216

    for_loop                       shift and go to state 213
    for_logic                      shift and go to state 281
    for_update                     shift and go to state 215

state 244

    (147) for_loop -> IDENTIFIER CHOOSE . expression for_untilTo expression
    (18) expression -> . assignment_expression
    (21) assignment_expression -> . assignment
    (22) assignment_expression -> . conditional_or_expression
    (23) assignment -> . valid_variable assignment_operator assignment_expression
    (28) conditional_or_expression -> . conditional_and_expression
    (29) conditional_or_expression -> . conditional_or_expression OR conditional_and_expression
    (24) valid_variable -> . name
    (25) valid_variable -> . array_access
    (30) conditional_and_expression -> . inclusive_or_expression
    (31) conditional_and_expression -> . conditional_and_expression AND inclusive_or_expression
    (115) name -> . simple_name
    (116) name -> . qualified_name
    (26) array_access -> . name LBRAC expression RBRAC
    (32) inclusive_or_expression -> . exclusive_or_expression
    (33) inclusive_or_expression -> . inclusive_or_expression OR_BITWISE exclusive_or_expression
    (117) simple_name -> . IDENTIFIER
    (118) qualified_name -> . name INST simple_name
    (34) exclusive_or_expression -> . and_expression
    (35) exclusive_or_expression -> . exclusive_or_expression XOR and_expression
    (36) and_expression -> . equality_expression
    (37) and_expression -> . and_expression AND_BITWISE equality_expression
    (38) equality_expression -> . relational_expression
    (39) equality_expression -> . equality_expression EQUAL relational_expression
    (40) equality_expression -> . equality_expression NEQUAL relational_expression
    (41) relational_expression -> . shift_expression
    (42) relational_expression -> . relational_expression GREATER shift_expression
    (43) relational_expression -> . relational_expression LESS shift_expression
    (44) relational_expression -> . relational_expression GEQ shift_expression
    (45) relational_expression -> . relational_expression LEQ shift_expression
    (46) shift_expression -> . additive_expression
    (47) shift_expression -> . shift_expression LSHIFT additive_expression
    (48) shift_expression -> . shift_expression RSHIFT additive_expression
    (49) additive_expression -> . multiplicative_expression
    (50) additive_expression -> . additive_expression PLUS multiplicative_expression
    (51) additive_expression -> . additive_expression MINUS multiplicative_expression
    (52) multiplicative_expression -> . unary_expression
    (53) multiplicative_expression -> . multiplicative_expression TIMES unary_expression
    (54) multiplicative_expression -> . multiplicative_expression DIVIDE unary_expression
    (55) multiplicative_expression -> . multiplicative_expression REMAINDER unary_expression
    (56) unary_expression -> . PLUS unary_expression
    (57) unary_expression -> . MINUS unary_expression
    (58) unary_expression -> . unary_expression_not_plus_minus
    (59) unary_expression_not_plus_minus -> . base_variable_set
    (60) unary_expression_not_plus_minus -> . TILDA unary_expression
    (61) unary_expression_not_plus_minus -> . NOT unary_expression
    (62) unary_expression_not_plus_minus -> . cast_expression
    (63) base_variable_set -> . variable_literal
    (64) base_variable_set -> . LPAREN expression RPAREN
    (67) cast_expression -> . LPAREN primitive_type RPAREN unary_expression
    (65) variable_literal -> . valid_variable
    (66) variable_literal -> . primary
    (68) primary -> . literal
    (69) primary -> . method_invocation
    (70) literal -> . int_float
    (71) literal -> . c_literal
    (79) method_invocation -> . name LPAREN argument_list_opt RPAREN
    (77) int_float -> . DOUBLE_NUMBER
    (78) int_float -> . INT_NUMBER
    (72) c_literal -> . CHAR
    (73) c_literal -> . STRING
    (74) c_literal -> . BOOL_CONSTT
    (75) c_literal -> . BOOL_CONSTF
    (76) c_literal -> . KEYWORD_NULL

    IDENTIFIER      shift and go to state 77
    PLUS            shift and go to state 36
    MINUS           shift and go to state 29
    TILDA           shift and go to state 72
    NOT             shift and go to state 57
    LPAREN          shift and go to state 94
    DOUBLE_NUMBER   shift and go to state 33
    INT_NUMBER      shift and go to state 44
    CHAR            shift and go to state 63
    STRING          shift and go to state 76
    BOOL_CONSTT     shift and go to state 35
    BOOL_CONSTF     shift and go to state 30
    KEYWORD_NULL    shift and go to state 65

    unary_expression               shift and go to state 45
    exclusive_or_expression        shift and go to state 61
    primary                        shift and go to state 62
    unary_expression_not_plus_minus shift and go to state 46
    array_access                   shift and go to state 28
    additive_expression            shift and go to state 66
    simple_name                    shift and go to state 67
    c_literal                      shift and go to state 93
    base_variable_set              shift and go to state 88
    valid_variable                 shift and go to state 48
    inclusive_or_expression        shift and go to state 32
    literal                        shift and go to state 71
    and_expression                 shift and go to state 87
    relational_expression          shift and go to state 73
    cast_expression                shift and go to state 80
    conditional_or_expression      shift and go to state 49
    assignment_expression          shift and go to state 91
    qualified_name                 shift and go to state 79
    assignment                     shift and go to state 138
    multiplicative_expression      shift and go to state 52
    method_invocation              shift and go to state 111
    shift_expression               shift and go to state 54
    equality_expression            shift and go to state 82
    int_float                      shift and go to state 40
    variable_literal               shift and go to state 55
    name                           shift and go to state 139
    expression                     shift and go to state 282
    conditional_and_expression     shift and go to state 56

state 245

    (142) do_while_statement -> KEYWORD_DO statement KEYWORD_WHILE LPAREN . expression RPAREN TERMINATOR
    (18) expression -> . assignment_expression
    (21) assignment_expression -> . assignment
    (22) assignment_expression -> . conditional_or_expression
    (23) assignment -> . valid_variable assignment_operator assignment_expression
    (28) conditional_or_expression -> . conditional_and_expression
    (29) conditional_or_expression -> . conditional_or_expression OR conditional_and_expression
    (24) valid_variable -> . name
    (25) valid_variable -> . array_access
    (30) conditional_and_expression -> . inclusive_or_expression
    (31) conditional_and_expression -> . conditional_and_expression AND inclusive_or_expression
    (115) name -> . simple_name
    (116) name -> . qualified_name
    (26) array_access -> . name LBRAC expression RBRAC
    (32) inclusive_or_expression -> . exclusive_or_expression
    (33) inclusive_or_expression -> . inclusive_or_expression OR_BITWISE exclusive_or_expression
    (117) simple_name -> . IDENTIFIER
    (118) qualified_name -> . name INST simple_name
    (34) exclusive_or_expression -> . and_expression
    (35) exclusive_or_expression -> . exclusive_or_expression XOR and_expression
    (36) and_expression -> . equality_expression
    (37) and_expression -> . and_expression AND_BITWISE equality_expression
    (38) equality_expression -> . relational_expression
    (39) equality_expression -> . equality_expression EQUAL relational_expression
    (40) equality_expression -> . equality_expression NEQUAL relational_expression
    (41) relational_expression -> . shift_expression
    (42) relational_expression -> . relational_expression GREATER shift_expression
    (43) relational_expression -> . relational_expression LESS shift_expression
    (44) relational_expression -> . relational_expression GEQ shift_expression
    (45) relational_expression -> . relational_expression LEQ shift_expression
    (46) shift_expression -> . additive_expression
    (47) shift_expression -> . shift_expression LSHIFT additive_expression
    (48) shift_expression -> . shift_expression RSHIFT additive_expression
    (49) additive_expression -> . multiplicative_expression
    (50) additive_expression -> . additive_expression PLUS multiplicative_expression
    (51) additive_expression -> . additive_expression MINUS multiplicative_expression
    (52) multiplicative_expression -> . unary_expression
    (53) multiplicative_expression -> . multiplicative_expression TIMES unary_expression
    (54) multiplicative_expression -> . multiplicative_expression DIVIDE unary_expression
    (55) multiplicative_expression -> . multiplicative_expression REMAINDER unary_expression
    (56) unary_expression -> . PLUS unary_expression
    (57) unary_expression -> . MINUS unary_expression
    (58) unary_expression -> . unary_expression_not_plus_minus
    (59) unary_expression_not_plus_minus -> . base_variable_set
    (60) unary_expression_not_plus_minus -> . TILDA unary_expression
    (61) unary_expression_not_plus_minus -> . NOT unary_expression
    (62) unary_expression_not_plus_minus -> . cast_expression
    (63) base_variable_set -> . variable_literal
    (64) base_variable_set -> . LPAREN expression RPAREN
    (67) cast_expression -> . LPAREN primitive_type RPAREN unary_expression
    (65) variable_literal -> . valid_variable
    (66) variable_literal -> . primary
    (68) primary -> . literal
    (69) primary -> . method_invocation
    (70) literal -> . int_float
    (71) literal -> . c_literal
    (79) method_invocation -> . name LPAREN argument_list_opt RPAREN
    (77) int_float -> . DOUBLE_NUMBER
    (78) int_float -> . INT_NUMBER
    (72) c_literal -> . CHAR
    (73) c_literal -> . STRING
    (74) c_literal -> . BOOL_CONSTT
    (75) c_literal -> . BOOL_CONSTF
    (76) c_literal -> . KEYWORD_NULL

    IDENTIFIER      shift and go to state 77
    PLUS            shift and go to state 36
    MINUS           shift and go to state 29
    TILDA           shift and go to state 72
    NOT             shift and go to state 57
    LPAREN          shift and go to state 94
    DOUBLE_NUMBER   shift and go to state 33
    INT_NUMBER      shift and go to state 44
    CHAR            shift and go to state 63
    STRING          shift and go to state 76
    BOOL_CONSTT     shift and go to state 35
    BOOL_CONSTF     shift and go to state 30
    KEYWORD_NULL    shift and go to state 65

    unary_expression               shift and go to state 45
    exclusive_or_expression        shift and go to state 61
    primary                        shift and go to state 62
    unary_expression_not_plus_minus shift and go to state 46
    array_access                   shift and go to state 28
    additive_expression            shift and go to state 66
    simple_name                    shift and go to state 67
    c_literal                      shift and go to state 93
    base_variable_set              shift and go to state 88
    valid_variable                 shift and go to state 48
    inclusive_or_expression        shift and go to state 32
    literal                        shift and go to state 71
    and_expression                 shift and go to state 87
    relational_expression          shift and go to state 73
    cast_expression                shift and go to state 80
    conditional_or_expression      shift and go to state 49
    assignment_expression          shift and go to state 91
    qualified_name                 shift and go to state 79
    assignment                     shift and go to state 138
    multiplicative_expression      shift and go to state 52
    method_invocation              shift and go to state 111
    shift_expression               shift and go to state 54
    equality_expression            shift and go to state 82
    int_float                      shift and go to state 40
    variable_literal               shift and go to state 55
    name                           shift and go to state 139
    expression                     shift and go to state 283
    conditional_and_expression     shift and go to state 56

state 246

    (113) class_data_type -> name .
    (118) qualified_name -> name . INST simple_name

    RBRAC           reduce using rule 113 (class_data_type -> name .)
    ASOP            reduce using rule 113 (class_data_type -> name .)
    COMMA           reduce using rule 113 (class_data_type -> name .)
    RPAREN          reduce using rule 113 (class_data_type -> name .)
    INST            shift and go to state 119


state 247

    (105) type -> reference_type .

    COMMA           reduce using rule 105 (type -> reference_type .)
    RPAREN          reduce using rule 105 (type -> reference_type .)
    ASOP            reduce using rule 105 (type -> reference_type .)
    RBRAC           reduce using rule 105 (type -> reference_type .)


state 248

    (114) array_data_type -> KEYWORD_ARRAY . LBRAC type RBRAC

    LBRAC           shift and go to state 284


state 249

    (104) type -> primitive_type .

    COMMA           reduce using rule 104 (type -> primitive_type .)
    RPAREN          reduce using rule 104 (type -> primitive_type .)
    ASOP            reduce using rule 104 (type -> primitive_type .)
    RBRAC           reduce using rule 104 (type -> primitive_type .)


state 250

    (111) reference_type -> class_data_type .

    ASOP            reduce using rule 111 (reference_type -> class_data_type .)
    COMMA           reduce using rule 111 (reference_type -> class_data_type .)
    RPAREN          reduce using rule 111 (reference_type -> class_data_type .)
    RBRAC           reduce using rule 111 (reference_type -> class_data_type .)


state 251

    (176) constructor_arguement_list_declarator -> declaration_keyword IDENTIFIER COLON type .

    COMMA           reduce using rule 176 (constructor_arguement_list_declarator -> declaration_keyword IDENTIFIER COLON type .)
    RPAREN          reduce using rule 176 (constructor_arguement_list_declarator -> declaration_keyword IDENTIFIER COLON type .)


state 252

    (112) reference_type -> array_data_type .

    ASOP            reduce using rule 112 (reference_type -> array_data_type .)
    COMMA           reduce using rule 112 (reference_type -> array_data_type .)
    RPAREN          reduce using rule 112 (reference_type -> array_data_type .)
    RBRAC           reduce using rule 112 (reference_type -> array_data_type .)


state 253

    (171) class_header_extends -> KEYWORD_EXTENDS name LPAREN func_arguement_list_opt RPAREN .

    BLOCKBEGIN      reduce using rule 171 (class_header_extends -> KEYWORD_EXTENDS name LPAREN func_arguement_list_opt RPAREN .)


state 254

    (179) method_header -> method_header_name LPAREN func_arguement_list_opt RPAREN COLON . method_return_type ASOP
    (180) method_return_type -> . type
    (181) method_return_type -> . TYPE_VOID
    (104) type -> . primitive_type
    (105) type -> . reference_type
    (106) primitive_type -> . TYPE_INT
    (107) primitive_type -> . TYPE_DOUBLE
    (108) primitive_type -> . TYPE_CHAR
    (109) primitive_type -> . TYPE_STRING
    (110) primitive_type -> . TYPE_BOOLEAN
    (111) reference_type -> . class_data_type
    (112) reference_type -> . array_data_type
    (113) class_data_type -> . name
    (114) array_data_type -> . KEYWORD_ARRAY LBRAC type RBRAC
    (115) name -> . simple_name
    (116) name -> . qualified_name
    (117) simple_name -> . IDENTIFIER
    (118) qualified_name -> . name INST simple_name

    TYPE_VOID       shift and go to state 285
    TYPE_INT        shift and go to state 154
    TYPE_DOUBLE     shift and go to state 159
    TYPE_CHAR       shift and go to state 156
    TYPE_STRING     shift and go to state 155
    TYPE_BOOLEAN    shift and go to state 158
    KEYWORD_ARRAY   shift and go to state 248
    IDENTIFIER      shift and go to state 77

    name                           shift and go to state 246
    qualified_name                 shift and go to state 79
    method_return_type             shift and go to state 287
    reference_type                 shift and go to state 247
    primitive_type                 shift and go to state 249
    class_data_type                shift and go to state 250
    type                           shift and go to state 286
    array_data_type                shift and go to state 252
    simple_name                    shift and go to state 67

state 255

    (101) variable_declarators -> variable_declarators COMMA variable_declarator .

    COMMA           reduce using rule 101 (variable_declarators -> variable_declarators COMMA variable_declarator .)
    RPAREN          reduce using rule 101 (variable_declarators -> variable_declarators COMMA variable_declarator .)


state 256

    (103) variable_declarator_id -> IDENTIFIER COLON type .

    COMMA           reduce using rule 103 (variable_declarator_id -> IDENTIFIER COLON type .)
    RPAREN          reduce using rule 103 (variable_declarator_id -> IDENTIFIER COLON type .)
    ASOP            reduce using rule 103 (variable_declarator_id -> IDENTIFIER COLON type .)


state 257

    (83) argument_list -> argument_list COMMA expression .

    COMMA           reduce using rule 83 (argument_list -> argument_list COMMA expression .)
    RPAREN          reduce using rule 83 (argument_list -> argument_list COMMA expression .)


state 258

    (141) while_statement -> KEYWORD_WHILE LPAREN expression RPAREN statement .

    KEYWORD_IF      reduce using rule 141 (while_statement -> KEYWORD_WHILE LPAREN expression RPAREN statement .)
    KEYWORD_WHILE   reduce using rule 141 (while_statement -> KEYWORD_WHILE LPAREN expression RPAREN statement .)
    KEYWORD_DO      reduce using rule 141 (while_statement -> KEYWORD_WHILE LPAREN expression RPAREN statement .)
    KEYWORD_FOR     reduce using rule 141 (while_statement -> KEYWORD_WHILE LPAREN expression RPAREN statement .)
    KEYWORD_OBJECT  reduce using rule 141 (while_statement -> KEYWORD_WHILE LPAREN expression RPAREN statement .)
    BLOCKBEGIN      reduce using rule 141 (while_statement -> KEYWORD_WHILE LPAREN expression RPAREN statement .)
    TERMINATOR      reduce using rule 141 (while_statement -> KEYWORD_WHILE LPAREN expression RPAREN statement .)
    KEYWORD_RETURN  reduce using rule 141 (while_statement -> KEYWORD_WHILE LPAREN expression RPAREN statement .)
    KEYWORD_PROTECTED reduce using rule 141 (while_statement -> KEYWORD_WHILE LPAREN expression RPAREN statement .)
    KEYWORD_PRIVATE reduce using rule 141 (while_statement -> KEYWORD_WHILE LPAREN expression RPAREN statement .)
    IDENTIFIER      reduce using rule 141 (while_statement -> KEYWORD_WHILE LPAREN expression RPAREN statement .)
    PLUS            reduce using rule 141 (while_statement -> KEYWORD_WHILE LPAREN expression RPAREN statement .)
    MINUS           reduce using rule 141 (while_statement -> KEYWORD_WHILE LPAREN expression RPAREN statement .)
    TILDA           reduce using rule 141 (while_statement -> KEYWORD_WHILE LPAREN expression RPAREN statement .)
    NOT             reduce using rule 141 (while_statement -> KEYWORD_WHILE LPAREN expression RPAREN statement .)
    LPAREN          reduce using rule 141 (while_statement -> KEYWORD_WHILE LPAREN expression RPAREN statement .)
    DOUBLE_NUMBER   reduce using rule 141 (while_statement -> KEYWORD_WHILE LPAREN expression RPAREN statement .)
    INT_NUMBER      reduce using rule 141 (while_statement -> KEYWORD_WHILE LPAREN expression RPAREN statement .)
    CHAR            reduce using rule 141 (while_statement -> KEYWORD_WHILE LPAREN expression RPAREN statement .)
    STRING          reduce using rule 141 (while_statement -> KEYWORD_WHILE LPAREN expression RPAREN statement .)
    BOOL_CONSTT     reduce using rule 141 (while_statement -> KEYWORD_WHILE LPAREN expression RPAREN statement .)
    BOOL_CONSTF     reduce using rule 141 (while_statement -> KEYWORD_WHILE LPAREN expression RPAREN statement .)
    KEYWORD_NULL    reduce using rule 141 (while_statement -> KEYWORD_WHILE LPAREN expression RPAREN statement .)
    KEYWORD_DEF     reduce using rule 141 (while_statement -> KEYWORD_WHILE LPAREN expression RPAREN statement .)
    KEYWORD_CLASS   reduce using rule 141 (while_statement -> KEYWORD_WHILE LPAREN expression RPAREN statement .)
    KEYWORD_VAR     reduce using rule 141 (while_statement -> KEYWORD_WHILE LPAREN expression RPAREN statement .)
    KEYWORD_VAL     reduce using rule 141 (while_statement -> KEYWORD_WHILE LPAREN expression RPAREN statement .)
    BLOCKEND        reduce using rule 141 (while_statement -> KEYWORD_WHILE LPAREN expression RPAREN statement .)
    KEYWORD_CASE    reduce using rule 141 (while_statement -> KEYWORD_WHILE LPAREN expression RPAREN statement .)


state 259

    (155) switch_block -> BLOCKBEGIN switch_labels BLOCKEND .

    KEYWORD_IF      reduce using rule 155 (switch_block -> BLOCKBEGIN switch_labels BLOCKEND .)
    KEYWORD_WHILE   reduce using rule 155 (switch_block -> BLOCKBEGIN switch_labels BLOCKEND .)
    KEYWORD_DO      reduce using rule 155 (switch_block -> BLOCKBEGIN switch_labels BLOCKEND .)
    KEYWORD_FOR     reduce using rule 155 (switch_block -> BLOCKBEGIN switch_labels BLOCKEND .)
    KEYWORD_OBJECT  reduce using rule 155 (switch_block -> BLOCKBEGIN switch_labels BLOCKEND .)
    BLOCKBEGIN      reduce using rule 155 (switch_block -> BLOCKBEGIN switch_labels BLOCKEND .)
    TERMINATOR      reduce using rule 155 (switch_block -> BLOCKBEGIN switch_labels BLOCKEND .)
    KEYWORD_RETURN  reduce using rule 155 (switch_block -> BLOCKBEGIN switch_labels BLOCKEND .)
    KEYWORD_PROTECTED reduce using rule 155 (switch_block -> BLOCKBEGIN switch_labels BLOCKEND .)
    KEYWORD_PRIVATE reduce using rule 155 (switch_block -> BLOCKBEGIN switch_labels BLOCKEND .)
    IDENTIFIER      reduce using rule 155 (switch_block -> BLOCKBEGIN switch_labels BLOCKEND .)
    PLUS            reduce using rule 155 (switch_block -> BLOCKBEGIN switch_labels BLOCKEND .)
    MINUS           reduce using rule 155 (switch_block -> BLOCKBEGIN switch_labels BLOCKEND .)
    TILDA           reduce using rule 155 (switch_block -> BLOCKBEGIN switch_labels BLOCKEND .)
    NOT             reduce using rule 155 (switch_block -> BLOCKBEGIN switch_labels BLOCKEND .)
    LPAREN          reduce using rule 155 (switch_block -> BLOCKBEGIN switch_labels BLOCKEND .)
    DOUBLE_NUMBER   reduce using rule 155 (switch_block -> BLOCKBEGIN switch_labels BLOCKEND .)
    INT_NUMBER      reduce using rule 155 (switch_block -> BLOCKBEGIN switch_labels BLOCKEND .)
    CHAR            reduce using rule 155 (switch_block -> BLOCKBEGIN switch_labels BLOCKEND .)
    STRING          reduce using rule 155 (switch_block -> BLOCKBEGIN switch_labels BLOCKEND .)
    BOOL_CONSTT     reduce using rule 155 (switch_block -> BLOCKBEGIN switch_labels BLOCKEND .)
    BOOL_CONSTF     reduce using rule 155 (switch_block -> BLOCKBEGIN switch_labels BLOCKEND .)
    KEYWORD_NULL    reduce using rule 155 (switch_block -> BLOCKBEGIN switch_labels BLOCKEND .)
    KEYWORD_DEF     reduce using rule 155 (switch_block -> BLOCKBEGIN switch_labels BLOCKEND .)
    KEYWORD_CLASS   reduce using rule 155 (switch_block -> BLOCKBEGIN switch_labels BLOCKEND .)
    KEYWORD_VAR     reduce using rule 155 (switch_block -> BLOCKBEGIN switch_labels BLOCKEND .)
    KEYWORD_VAL     reduce using rule 155 (switch_block -> BLOCKBEGIN switch_labels BLOCKEND .)
    BLOCKEND        reduce using rule 155 (switch_block -> BLOCKBEGIN switch_labels BLOCKEND .)
    KEYWORD_CASE    reduce using rule 155 (switch_block -> BLOCKBEGIN switch_labels BLOCKEND .)
    KEYWORD_ELSE    reduce using rule 155 (switch_block -> BLOCKBEGIN switch_labels BLOCKEND .)


state 260

    (161) switch_labels -> switch_labels switch_label .

    BLOCKEND        reduce using rule 161 (switch_labels -> switch_labels switch_label .)
    KEYWORD_CASE    reduce using rule 161 (switch_labels -> switch_labels switch_label .)
    KEYWORD_IF      reduce using rule 161 (switch_labels -> switch_labels switch_label .)
    KEYWORD_WHILE   reduce using rule 161 (switch_labels -> switch_labels switch_label .)
    KEYWORD_DO      reduce using rule 161 (switch_labels -> switch_labels switch_label .)
    KEYWORD_FOR     reduce using rule 161 (switch_labels -> switch_labels switch_label .)
    KEYWORD_OBJECT  reduce using rule 161 (switch_labels -> switch_labels switch_label .)
    BLOCKBEGIN      reduce using rule 161 (switch_labels -> switch_labels switch_label .)
    TERMINATOR      reduce using rule 161 (switch_labels -> switch_labels switch_label .)
    KEYWORD_RETURN  reduce using rule 161 (switch_labels -> switch_labels switch_label .)
    KEYWORD_PROTECTED reduce using rule 161 (switch_labels -> switch_labels switch_label .)
    KEYWORD_PRIVATE reduce using rule 161 (switch_labels -> switch_labels switch_label .)
    IDENTIFIER      reduce using rule 161 (switch_labels -> switch_labels switch_label .)
    PLUS            reduce using rule 161 (switch_labels -> switch_labels switch_label .)
    MINUS           reduce using rule 161 (switch_labels -> switch_labels switch_label .)
    TILDA           reduce using rule 161 (switch_labels -> switch_labels switch_label .)
    NOT             reduce using rule 161 (switch_labels -> switch_labels switch_label .)
    LPAREN          reduce using rule 161 (switch_labels -> switch_labels switch_label .)
    DOUBLE_NUMBER   reduce using rule 161 (switch_labels -> switch_labels switch_label .)
    INT_NUMBER      reduce using rule 161 (switch_labels -> switch_labels switch_label .)
    CHAR            reduce using rule 161 (switch_labels -> switch_labels switch_label .)
    STRING          reduce using rule 161 (switch_labels -> switch_labels switch_label .)
    BOOL_CONSTT     reduce using rule 161 (switch_labels -> switch_labels switch_label .)
    BOOL_CONSTF     reduce using rule 161 (switch_labels -> switch_labels switch_label .)
    KEYWORD_NULL    reduce using rule 161 (switch_labels -> switch_labels switch_label .)
    KEYWORD_DEF     reduce using rule 161 (switch_labels -> switch_labels switch_label .)
    KEYWORD_CLASS   reduce using rule 161 (switch_labels -> switch_labels switch_label .)
    KEYWORD_VAR     reduce using rule 161 (switch_labels -> switch_labels switch_label .)
    KEYWORD_VAL     reduce using rule 161 (switch_labels -> switch_labels switch_label .)


state 261

    (159) switch_block_statement -> switch_labels block_statements .
    (12) block_statements -> block_statements . block_statement
    (13) block_statement -> . local_variable_declaration_statement
    (14) block_statement -> . statement
    (15) block_statement -> . class_declaration
    (16) block_statement -> . SingletonObject
    (17) block_statement -> . method_declaration
    (90) local_variable_declaration_statement -> . local_variable_declaration TERMINATOR
    (122) statement -> . normal_statement
    (123) statement -> . if_then_statement
    (124) statement -> . if_then_else_statement
    (125) statement -> . while_statement
    (126) statement -> . do_while_statement
    (127) statement -> . for_statement
    (165) class_declaration -> . class_header class_body
    (5) SingletonObject -> . ObjectDeclare block
    (178) method_declaration -> . method_header method_body
    (91) local_variable_declaration -> . modifier_opts declaration_keyword variable_declaration_body
    (128) normal_statement -> . block
    (129) normal_statement -> . expression_statement
    (130) normal_statement -> . empty_statement
    (131) normal_statement -> . return_statement
    (132) normal_statement -> . switch_statement
    (136) if_then_statement -> . KEYWORD_IF LPAREN expression RPAREN statement
    (137) if_then_else_statement -> . KEYWORD_IF LPAREN expression RPAREN if_then_else_intermediate KEYWORD_ELSE statement
    (141) while_statement -> . KEYWORD_WHILE LPAREN expression RPAREN statement
    (142) do_while_statement -> . KEYWORD_DO statement KEYWORD_WHILE LPAREN expression RPAREN TERMINATOR
    (143) for_statement -> . KEYWORD_FOR LPAREN for_logic RPAREN statement
    (166) class_header -> . class_header_name class_header_extends_opt
    (6) ObjectDeclare -> . KEYWORD_OBJECT IDENTIFIER
    (7) ObjectDeclare -> . KEYWORD_OBJECT IDENTIFIER KEYWORD_EXTENDS IDENTIFIER
    (179) method_header -> . method_header_name LPAREN func_arguement_list_opt RPAREN COLON method_return_type ASOP
    (86) modifier_opts -> . modifier
    (87) modifier_opts -> . empty
    (8) block -> . BLOCKBEGIN block_statements_opt BLOCKEND
    (133) expression_statement -> . statement_expression TERMINATOR
    (163) empty_statement -> . TERMINATOR
    (164) return_statement -> . KEYWORD_RETURN expression_optional TERMINATOR
    (152) switch_statement -> . expression KEYWORD_MATCH switch_block
    (167) class_header_name -> . class_header_name1 LPAREN constructor_arguement_list_opt RPAREN
    (182) method_header_name -> . modifier_opts KEYWORD_DEF IDENTIFIER
    (84) modifier -> . KEYWORD_PROTECTED
    (85) modifier -> . KEYWORD_PRIVATE
    (186) empty -> .
    (134) statement_expression -> . assignment
    (135) statement_expression -> . method_invocation
    (18) expression -> . assignment_expression
    (168) class_header_name1 -> . modifier_opts KEYWORD_CLASS name
    (23) assignment -> . valid_variable assignment_operator assignment_expression
    (79) method_invocation -> . name LPAREN argument_list_opt RPAREN
    (21) assignment_expression -> . assignment
    (22) assignment_expression -> . conditional_or_expression
    (24) valid_variable -> . name
    (25) valid_variable -> . array_access
    (115) name -> . simple_name
    (116) name -> . qualified_name
    (28) conditional_or_expression -> . conditional_and_expression
    (29) conditional_or_expression -> . conditional_or_expression OR conditional_and_expression
    (26) array_access -> . name LBRAC expression RBRAC
    (117) simple_name -> . IDENTIFIER
    (118) qualified_name -> . name INST simple_name
    (30) conditional_and_expression -> . inclusive_or_expression
    (31) conditional_and_expression -> . conditional_and_expression AND inclusive_or_expression
    (32) inclusive_or_expression -> . exclusive_or_expression
    (33) inclusive_or_expression -> . inclusive_or_expression OR_BITWISE exclusive_or_expression
    (34) exclusive_or_expression -> . and_expression
    (35) exclusive_or_expression -> . exclusive_or_expression XOR and_expression
    (36) and_expression -> . equality_expression
    (37) and_expression -> . and_expression AND_BITWISE equality_expression
    (38) equality_expression -> . relational_expression
    (39) equality_expression -> . equality_expression EQUAL relational_expression
    (40) equality_expression -> . equality_expression NEQUAL relational_expression
    (41) relational_expression -> . shift_expression
    (42) relational_expression -> . relational_expression GREATER shift_expression
    (43) relational_expression -> . relational_expression LESS shift_expression
    (44) relational_expression -> . relational_expression GEQ shift_expression
    (45) relational_expression -> . relational_expression LEQ shift_expression
    (46) shift_expression -> . additive_expression
    (47) shift_expression -> . shift_expression LSHIFT additive_expression
    (48) shift_expression -> . shift_expression RSHIFT additive_expression
    (49) additive_expression -> . multiplicative_expression
    (50) additive_expression -> . additive_expression PLUS multiplicative_expression
    (51) additive_expression -> . additive_expression MINUS multiplicative_expression
    (52) multiplicative_expression -> . unary_expression
    (53) multiplicative_expression -> . multiplicative_expression TIMES unary_expression
    (54) multiplicative_expression -> . multiplicative_expression DIVIDE unary_expression
    (55) multiplicative_expression -> . multiplicative_expression REMAINDER unary_expression
    (56) unary_expression -> . PLUS unary_expression
    (57) unary_expression -> . MINUS unary_expression
    (58) unary_expression -> . unary_expression_not_plus_minus
    (59) unary_expression_not_plus_minus -> . base_variable_set
    (60) unary_expression_not_plus_minus -> . TILDA unary_expression
    (61) unary_expression_not_plus_minus -> . NOT unary_expression
    (62) unary_expression_not_plus_minus -> . cast_expression
    (63) base_variable_set -> . variable_literal
    (64) base_variable_set -> . LPAREN expression RPAREN
    (67) cast_expression -> . LPAREN primitive_type RPAREN unary_expression
    (65) variable_literal -> . valid_variable
    (66) variable_literal -> . primary
    (68) primary -> . literal
    (69) primary -> . method_invocation
    (70) literal -> . int_float
    (71) literal -> . c_literal
    (77) int_float -> . DOUBLE_NUMBER
    (78) int_float -> . INT_NUMBER
    (72) c_literal -> . CHAR
    (73) c_literal -> . STRING
    (74) c_literal -> . BOOL_CONSTT
    (75) c_literal -> . BOOL_CONSTF
    (76) c_literal -> . KEYWORD_NULL

    BLOCKEND        reduce using rule 159 (switch_block_statement -> switch_labels block_statements .)
    KEYWORD_CASE    reduce using rule 159 (switch_block_statement -> switch_labels block_statements .)
    KEYWORD_IF      shift and go to state 81
    KEYWORD_WHILE   shift and go to state 50
    KEYWORD_DO      shift and go to state 98
    KEYWORD_FOR     shift and go to state 97
    KEYWORD_OBJECT  shift and go to state 3
    BLOCKBEGIN      shift and go to state 15
    TERMINATOR      shift and go to state 53
    KEYWORD_RETURN  shift and go to state 68
    KEYWORD_PROTECTED shift and go to state 12
    KEYWORD_PRIVATE shift and go to state 9
    KEYWORD_DEF     reduce using rule 186 (empty -> .)
    KEYWORD_CLASS   reduce using rule 186 (empty -> .)
    KEYWORD_VAR     reduce using rule 186 (empty -> .)
    KEYWORD_VAL     reduce using rule 186 (empty -> .)
    IDENTIFIER      shift and go to state 77
    PLUS            shift and go to state 36
    MINUS           shift and go to state 29
    TILDA           shift and go to state 72
    NOT             shift and go to state 57
    LPAREN          shift and go to state 94
    DOUBLE_NUMBER   shift and go to state 33
    INT_NUMBER      shift and go to state 44
    CHAR            shift and go to state 63
    STRING          shift and go to state 76
    BOOL_CONSTT     shift and go to state 35
    BOOL_CONSTF     shift and go to state 30
    KEYWORD_NULL    shift and go to state 65

    expression_statement           shift and go to state 27
    unary_expression               shift and go to state 45
    exclusive_or_expression        shift and go to state 61
    normal_statement               shift and go to state 86
    ObjectDeclare                  shift and go to state 1
    class_header_name1             shift and go to state 2
    if_then_statement              shift and go to state 64
    array_access                   shift and go to state 28
    switch_statement               shift and go to state 47
    assignment_expression          shift and go to state 91
    qualified_name                 shift and go to state 79
    base_variable_set              shift and go to state 88
    valid_variable                 shift and go to state 48
    inclusive_or_expression        shift and go to state 32
    class_header_name              shift and go to state 5
    method_declaration             shift and go to state 69
    cast_expression                shift and go to state 80
    block_statement                shift and go to state 153
    return_statement               shift and go to state 89
    while_statement                shift and go to state 34
    and_expression                 shift and go to state 87
    statement                      shift and go to state 74
    literal                        shift and go to state 71
    statement_expression           shift and go to state 37
    method_invocation              shift and go to state 75
    simple_name                    shift and go to state 67
    conditional_or_expression      shift and go to state 49
    c_literal                      shift and go to state 93
    empty                          shift and go to state 6
    relational_expression          shift and go to state 73
    for_statement                  shift and go to state 38
    local_variable_declaration_statement shift and go to state 39
    do_while_statement             shift and go to state 51
    int_float                      shift and go to state 40
    assignment                     shift and go to state 92
    multiplicative_expression      shift and go to state 52
    primary                        shift and go to state 62
    additive_expression            shift and go to state 66
    SingletonObject                shift and go to state 41
    method_header_name             shift and go to state 42
    class_header                   shift and go to state 10
    modifier_opts                  shift and go to state 95
    equality_expression            shift and go to state 82
    variable_literal               shift and go to state 55
    name                           shift and go to state 43
    unary_expression_not_plus_minus shift and go to state 46
    method_header                  shift and go to state 83
    empty_statement                shift and go to state 84
    class_declaration              shift and go to state 96
    shift_expression               shift and go to state 54
    local_variable_declaration     shift and go to state 85
    modifier                       shift and go to state 14
    expression                     shift and go to state 58
    conditional_and_expression     shift and go to state 56
    block                          shift and go to state 59
    if_then_else_statement         shift and go to state 60

state 262

    (162) switch_label -> KEYWORD_CASE expression . FUNTYPE

    FUNTYPE         shift and go to state 288


state 263

    (156) switch_block -> BLOCKBEGIN switch_block_statements switch_labels . BLOCKEND
    (161) switch_labels -> switch_labels . switch_label
    (159) switch_block_statement -> switch_labels . block_statements
    (162) switch_label -> . KEYWORD_CASE expression FUNTYPE
    (11) block_statements -> . block_statement
    (12) block_statements -> . block_statements block_statement
    (13) block_statement -> . local_variable_declaration_statement
    (14) block_statement -> . statement
    (15) block_statement -> . class_declaration
    (16) block_statement -> . SingletonObject
    (17) block_statement -> . method_declaration
    (90) local_variable_declaration_statement -> . local_variable_declaration TERMINATOR
    (122) statement -> . normal_statement
    (123) statement -> . if_then_statement
    (124) statement -> . if_then_else_statement
    (125) statement -> . while_statement
    (126) statement -> . do_while_statement
    (127) statement -> . for_statement
    (165) class_declaration -> . class_header class_body
    (5) SingletonObject -> . ObjectDeclare block
    (178) method_declaration -> . method_header method_body
    (91) local_variable_declaration -> . modifier_opts declaration_keyword variable_declaration_body
    (128) normal_statement -> . block
    (129) normal_statement -> . expression_statement
    (130) normal_statement -> . empty_statement
    (131) normal_statement -> . return_statement
    (132) normal_statement -> . switch_statement
    (136) if_then_statement -> . KEYWORD_IF LPAREN expression RPAREN statement
    (137) if_then_else_statement -> . KEYWORD_IF LPAREN expression RPAREN if_then_else_intermediate KEYWORD_ELSE statement
    (141) while_statement -> . KEYWORD_WHILE LPAREN expression RPAREN statement
    (142) do_while_statement -> . KEYWORD_DO statement KEYWORD_WHILE LPAREN expression RPAREN TERMINATOR
    (143) for_statement -> . KEYWORD_FOR LPAREN for_logic RPAREN statement
    (166) class_header -> . class_header_name class_header_extends_opt
    (6) ObjectDeclare -> . KEYWORD_OBJECT IDENTIFIER
    (7) ObjectDeclare -> . KEYWORD_OBJECT IDENTIFIER KEYWORD_EXTENDS IDENTIFIER
    (179) method_header -> . method_header_name LPAREN func_arguement_list_opt RPAREN COLON method_return_type ASOP
    (86) modifier_opts -> . modifier
    (87) modifier_opts -> . empty
    (8) block -> . BLOCKBEGIN block_statements_opt BLOCKEND
    (133) expression_statement -> . statement_expression TERMINATOR
    (163) empty_statement -> . TERMINATOR
    (164) return_statement -> . KEYWORD_RETURN expression_optional TERMINATOR
    (152) switch_statement -> . expression KEYWORD_MATCH switch_block
    (167) class_header_name -> . class_header_name1 LPAREN constructor_arguement_list_opt RPAREN
    (182) method_header_name -> . modifier_opts KEYWORD_DEF IDENTIFIER
    (84) modifier -> . KEYWORD_PROTECTED
    (85) modifier -> . KEYWORD_PRIVATE
    (186) empty -> .
    (134) statement_expression -> . assignment
    (135) statement_expression -> . method_invocation
    (18) expression -> . assignment_expression
    (168) class_header_name1 -> . modifier_opts KEYWORD_CLASS name
    (23) assignment -> . valid_variable assignment_operator assignment_expression
    (79) method_invocation -> . name LPAREN argument_list_opt RPAREN
    (21) assignment_expression -> . assignment
    (22) assignment_expression -> . conditional_or_expression
    (24) valid_variable -> . name
    (25) valid_variable -> . array_access
    (115) name -> . simple_name
    (116) name -> . qualified_name
    (28) conditional_or_expression -> . conditional_and_expression
    (29) conditional_or_expression -> . conditional_or_expression OR conditional_and_expression
    (26) array_access -> . name LBRAC expression RBRAC
    (117) simple_name -> . IDENTIFIER
    (118) qualified_name -> . name INST simple_name
    (30) conditional_and_expression -> . inclusive_or_expression
    (31) conditional_and_expression -> . conditional_and_expression AND inclusive_or_expression
    (32) inclusive_or_expression -> . exclusive_or_expression
    (33) inclusive_or_expression -> . inclusive_or_expression OR_BITWISE exclusive_or_expression
    (34) exclusive_or_expression -> . and_expression
    (35) exclusive_or_expression -> . exclusive_or_expression XOR and_expression
    (36) and_expression -> . equality_expression
    (37) and_expression -> . and_expression AND_BITWISE equality_expression
    (38) equality_expression -> . relational_expression
    (39) equality_expression -> . equality_expression EQUAL relational_expression
    (40) equality_expression -> . equality_expression NEQUAL relational_expression
    (41) relational_expression -> . shift_expression
    (42) relational_expression -> . relational_expression GREATER shift_expression
    (43) relational_expression -> . relational_expression LESS shift_expression
    (44) relational_expression -> . relational_expression GEQ shift_expression
    (45) relational_expression -> . relational_expression LEQ shift_expression
    (46) shift_expression -> . additive_expression
    (47) shift_expression -> . shift_expression LSHIFT additive_expression
    (48) shift_expression -> . shift_expression RSHIFT additive_expression
    (49) additive_expression -> . multiplicative_expression
    (50) additive_expression -> . additive_expression PLUS multiplicative_expression
    (51) additive_expression -> . additive_expression MINUS multiplicative_expression
    (52) multiplicative_expression -> . unary_expression
    (53) multiplicative_expression -> . multiplicative_expression TIMES unary_expression
    (54) multiplicative_expression -> . multiplicative_expression DIVIDE unary_expression
    (55) multiplicative_expression -> . multiplicative_expression REMAINDER unary_expression
    (56) unary_expression -> . PLUS unary_expression
    (57) unary_expression -> . MINUS unary_expression
    (58) unary_expression -> . unary_expression_not_plus_minus
    (59) unary_expression_not_plus_minus -> . base_variable_set
    (60) unary_expression_not_plus_minus -> . TILDA unary_expression
    (61) unary_expression_not_plus_minus -> . NOT unary_expression
    (62) unary_expression_not_plus_minus -> . cast_expression
    (63) base_variable_set -> . variable_literal
    (64) base_variable_set -> . LPAREN expression RPAREN
    (67) cast_expression -> . LPAREN primitive_type RPAREN unary_expression
    (65) variable_literal -> . valid_variable
    (66) variable_literal -> . primary
    (68) primary -> . literal
    (69) primary -> . method_invocation
    (70) literal -> . int_float
    (71) literal -> . c_literal
    (77) int_float -> . DOUBLE_NUMBER
    (78) int_float -> . INT_NUMBER
    (72) c_literal -> . CHAR
    (73) c_literal -> . STRING
    (74) c_literal -> . BOOL_CONSTT
    (75) c_literal -> . BOOL_CONSTF
    (76) c_literal -> . KEYWORD_NULL

    BLOCKEND        shift and go to state 289
    KEYWORD_CASE    shift and go to state 230
    KEYWORD_IF      shift and go to state 81
    KEYWORD_WHILE   shift and go to state 50
    KEYWORD_DO      shift and go to state 98
    KEYWORD_FOR     shift and go to state 97
    KEYWORD_OBJECT  shift and go to state 3
    BLOCKBEGIN      shift and go to state 15
    TERMINATOR      shift and go to state 53
    KEYWORD_RETURN  shift and go to state 68
    KEYWORD_PROTECTED shift and go to state 12
    KEYWORD_PRIVATE shift and go to state 9
    KEYWORD_DEF     reduce using rule 186 (empty -> .)
    KEYWORD_CLASS   reduce using rule 186 (empty -> .)
    KEYWORD_VAR     reduce using rule 186 (empty -> .)
    KEYWORD_VAL     reduce using rule 186 (empty -> .)
    IDENTIFIER      shift and go to state 77
    PLUS            shift and go to state 36
    MINUS           shift and go to state 29
    TILDA           shift and go to state 72
    NOT             shift and go to state 57
    LPAREN          shift and go to state 94
    DOUBLE_NUMBER   shift and go to state 33
    INT_NUMBER      shift and go to state 44
    CHAR            shift and go to state 63
    STRING          shift and go to state 76
    BOOL_CONSTT     shift and go to state 35
    BOOL_CONSTF     shift and go to state 30
    KEYWORD_NULL    shift and go to state 65

    expression_statement           shift and go to state 27
    unary_expression               shift and go to state 45
    exclusive_or_expression        shift and go to state 61
    normal_statement               shift and go to state 86
    ObjectDeclare                  shift and go to state 1
    class_header_name1             shift and go to state 2
    if_then_statement              shift and go to state 64
    array_access                   shift and go to state 28
    switch_statement               shift and go to state 47
    assignment_expression          shift and go to state 91
    qualified_name                 shift and go to state 79
    base_variable_set              shift and go to state 88
    valid_variable                 shift and go to state 48
    inclusive_or_expression        shift and go to state 32
    method_header_name             shift and go to state 42
    class_header_name              shift and go to state 5
    method_declaration             shift and go to state 69
    cast_expression                shift and go to state 80
    block_statement                shift and go to state 70
    return_statement               shift and go to state 89
    while_statement                shift and go to state 34
    and_expression                 shift and go to state 87
    statement                      shift and go to state 74
    literal                        shift and go to state 71
    statement_expression           shift and go to state 37
    method_invocation              shift and go to state 75
    simple_name                    shift and go to state 67
    conditional_or_expression      shift and go to state 49
    c_literal                      shift and go to state 93
    empty                          shift and go to state 6
    relational_expression          shift and go to state 73
    block_statements               shift and go to state 261
    for_statement                  shift and go to state 38
    local_variable_declaration_statement shift and go to state 39
    do_while_statement             shift and go to state 51
    int_float                      shift and go to state 40
    assignment                     shift and go to state 92
    multiplicative_expression      shift and go to state 52
    primary                        shift and go to state 62
    additive_expression            shift and go to state 66
    SingletonObject                shift and go to state 41
    switch_label                   shift and go to state 260
    class_header                   shift and go to state 10
    modifier_opts                  shift and go to state 95
    equality_expression            shift and go to state 82
    variable_literal               shift and go to state 55
    name                           shift and go to state 43
    unary_expression_not_plus_minus shift and go to state 46
    expression                     shift and go to state 58
    method_header                  shift and go to state 83
    empty_statement                shift and go to state 84
    class_declaration              shift and go to state 96
    shift_expression               shift and go to state 54
    local_variable_declaration     shift and go to state 85
    modifier                       shift and go to state 14
    conditional_and_expression     shift and go to state 56
    block                          shift and go to state 59
    if_then_else_statement         shift and go to state 60

state 264

    (154) switch_block -> BLOCKBEGIN switch_block_statements BLOCKEND .

    KEYWORD_IF      reduce using rule 154 (switch_block -> BLOCKBEGIN switch_block_statements BLOCKEND .)
    KEYWORD_WHILE   reduce using rule 154 (switch_block -> BLOCKBEGIN switch_block_statements BLOCKEND .)
    KEYWORD_DO      reduce using rule 154 (switch_block -> BLOCKBEGIN switch_block_statements BLOCKEND .)
    KEYWORD_FOR     reduce using rule 154 (switch_block -> BLOCKBEGIN switch_block_statements BLOCKEND .)
    KEYWORD_OBJECT  reduce using rule 154 (switch_block -> BLOCKBEGIN switch_block_statements BLOCKEND .)
    BLOCKBEGIN      reduce using rule 154 (switch_block -> BLOCKBEGIN switch_block_statements BLOCKEND .)
    TERMINATOR      reduce using rule 154 (switch_block -> BLOCKBEGIN switch_block_statements BLOCKEND .)
    KEYWORD_RETURN  reduce using rule 154 (switch_block -> BLOCKBEGIN switch_block_statements BLOCKEND .)
    KEYWORD_PROTECTED reduce using rule 154 (switch_block -> BLOCKBEGIN switch_block_statements BLOCKEND .)
    KEYWORD_PRIVATE reduce using rule 154 (switch_block -> BLOCKBEGIN switch_block_statements BLOCKEND .)
    IDENTIFIER      reduce using rule 154 (switch_block -> BLOCKBEGIN switch_block_statements BLOCKEND .)
    PLUS            reduce using rule 154 (switch_block -> BLOCKBEGIN switch_block_statements BLOCKEND .)
    MINUS           reduce using rule 154 (switch_block -> BLOCKBEGIN switch_block_statements BLOCKEND .)
    TILDA           reduce using rule 154 (switch_block -> BLOCKBEGIN switch_block_statements BLOCKEND .)
    NOT             reduce using rule 154 (switch_block -> BLOCKBEGIN switch_block_statements BLOCKEND .)
    LPAREN          reduce using rule 154 (switch_block -> BLOCKBEGIN switch_block_statements BLOCKEND .)
    DOUBLE_NUMBER   reduce using rule 154 (switch_block -> BLOCKBEGIN switch_block_statements BLOCKEND .)
    INT_NUMBER      reduce using rule 154 (switch_block -> BLOCKBEGIN switch_block_statements BLOCKEND .)
    CHAR            reduce using rule 154 (switch_block -> BLOCKBEGIN switch_block_statements BLOCKEND .)
    STRING          reduce using rule 154 (switch_block -> BLOCKBEGIN switch_block_statements BLOCKEND .)
    BOOL_CONSTT     reduce using rule 154 (switch_block -> BLOCKBEGIN switch_block_statements BLOCKEND .)
    BOOL_CONSTF     reduce using rule 154 (switch_block -> BLOCKBEGIN switch_block_statements BLOCKEND .)
    KEYWORD_NULL    reduce using rule 154 (switch_block -> BLOCKBEGIN switch_block_statements BLOCKEND .)
    KEYWORD_DEF     reduce using rule 154 (switch_block -> BLOCKBEGIN switch_block_statements BLOCKEND .)
    KEYWORD_CLASS   reduce using rule 154 (switch_block -> BLOCKBEGIN switch_block_statements BLOCKEND .)
    KEYWORD_VAR     reduce using rule 154 (switch_block -> BLOCKBEGIN switch_block_statements BLOCKEND .)
    KEYWORD_VAL     reduce using rule 154 (switch_block -> BLOCKBEGIN switch_block_statements BLOCKEND .)
    BLOCKEND        reduce using rule 154 (switch_block -> BLOCKBEGIN switch_block_statements BLOCKEND .)
    KEYWORD_CASE    reduce using rule 154 (switch_block -> BLOCKBEGIN switch_block_statements BLOCKEND .)
    KEYWORD_ELSE    reduce using rule 154 (switch_block -> BLOCKBEGIN switch_block_statements BLOCKEND .)


state 265

    (158) switch_block_statements -> switch_block_statements switch_block_statement .

    BLOCKEND        reduce using rule 158 (switch_block_statements -> switch_block_statements switch_block_statement .)
    KEYWORD_CASE    reduce using rule 158 (switch_block_statements -> switch_block_statements switch_block_statement .)


state 266

    (137) if_then_else_statement -> KEYWORD_IF LPAREN expression RPAREN if_then_else_intermediate . KEYWORD_ELSE statement

    KEYWORD_ELSE    shift and go to state 290


state 267

    (136) if_then_statement -> KEYWORD_IF LPAREN expression RPAREN statement .

    KEYWORD_IF      reduce using rule 136 (if_then_statement -> KEYWORD_IF LPAREN expression RPAREN statement .)
    KEYWORD_WHILE   reduce using rule 136 (if_then_statement -> KEYWORD_IF LPAREN expression RPAREN statement .)
    KEYWORD_DO      reduce using rule 136 (if_then_statement -> KEYWORD_IF LPAREN expression RPAREN statement .)
    KEYWORD_FOR     reduce using rule 136 (if_then_statement -> KEYWORD_IF LPAREN expression RPAREN statement .)
    KEYWORD_OBJECT  reduce using rule 136 (if_then_statement -> KEYWORD_IF LPAREN expression RPAREN statement .)
    BLOCKBEGIN      reduce using rule 136 (if_then_statement -> KEYWORD_IF LPAREN expression RPAREN statement .)
    TERMINATOR      reduce using rule 136 (if_then_statement -> KEYWORD_IF LPAREN expression RPAREN statement .)
    KEYWORD_RETURN  reduce using rule 136 (if_then_statement -> KEYWORD_IF LPAREN expression RPAREN statement .)
    KEYWORD_PROTECTED reduce using rule 136 (if_then_statement -> KEYWORD_IF LPAREN expression RPAREN statement .)
    KEYWORD_PRIVATE reduce using rule 136 (if_then_statement -> KEYWORD_IF LPAREN expression RPAREN statement .)
    IDENTIFIER      reduce using rule 136 (if_then_statement -> KEYWORD_IF LPAREN expression RPAREN statement .)
    PLUS            reduce using rule 136 (if_then_statement -> KEYWORD_IF LPAREN expression RPAREN statement .)
    MINUS           reduce using rule 136 (if_then_statement -> KEYWORD_IF LPAREN expression RPAREN statement .)
    TILDA           reduce using rule 136 (if_then_statement -> KEYWORD_IF LPAREN expression RPAREN statement .)
    NOT             reduce using rule 136 (if_then_statement -> KEYWORD_IF LPAREN expression RPAREN statement .)
    LPAREN          reduce using rule 136 (if_then_statement -> KEYWORD_IF LPAREN expression RPAREN statement .)
    DOUBLE_NUMBER   reduce using rule 136 (if_then_statement -> KEYWORD_IF LPAREN expression RPAREN statement .)
    INT_NUMBER      reduce using rule 136 (if_then_statement -> KEYWORD_IF LPAREN expression RPAREN statement .)
    CHAR            reduce using rule 136 (if_then_statement -> KEYWORD_IF LPAREN expression RPAREN statement .)
    STRING          reduce using rule 136 (if_then_statement -> KEYWORD_IF LPAREN expression RPAREN statement .)
    BOOL_CONSTT     reduce using rule 136 (if_then_statement -> KEYWORD_IF LPAREN expression RPAREN statement .)
    BOOL_CONSTF     reduce using rule 136 (if_then_statement -> KEYWORD_IF LPAREN expression RPAREN statement .)
    KEYWORD_NULL    reduce using rule 136 (if_then_statement -> KEYWORD_IF LPAREN expression RPAREN statement .)
    KEYWORD_DEF     reduce using rule 136 (if_then_statement -> KEYWORD_IF LPAREN expression RPAREN statement .)
    KEYWORD_CLASS   reduce using rule 136 (if_then_statement -> KEYWORD_IF LPAREN expression RPAREN statement .)
    KEYWORD_VAR     reduce using rule 136 (if_then_statement -> KEYWORD_IF LPAREN expression RPAREN statement .)
    KEYWORD_VAL     reduce using rule 136 (if_then_statement -> KEYWORD_IF LPAREN expression RPAREN statement .)
    BLOCKEND        reduce using rule 136 (if_then_statement -> KEYWORD_IF LPAREN expression RPAREN statement .)
    KEYWORD_CASE    reduce using rule 136 (if_then_statement -> KEYWORD_IF LPAREN expression RPAREN statement .)


state 268

    (136) if_then_statement -> KEYWORD_IF . LPAREN expression RPAREN statement
    (137) if_then_else_statement -> KEYWORD_IF . LPAREN expression RPAREN if_then_else_intermediate KEYWORD_ELSE statement
    (138) if_then_else_statement_precedence -> KEYWORD_IF . LPAREN expression RPAREN if_then_else_intermediate KEYWORD_ELSE if_then_else_intermediate

    LPAREN          shift and go to state 291


state 269

    (140) if_then_else_intermediate -> if_then_else_statement_precedence .

    KEYWORD_ELSE    reduce using rule 140 (if_then_else_intermediate -> if_then_else_statement_precedence .)


state 270

    (122) statement -> normal_statement .
    (139) if_then_else_intermediate -> normal_statement .

    KEYWORD_IF      reduce using rule 122 (statement -> normal_statement .)
    KEYWORD_WHILE   reduce using rule 122 (statement -> normal_statement .)
    KEYWORD_DO      reduce using rule 122 (statement -> normal_statement .)
    KEYWORD_FOR     reduce using rule 122 (statement -> normal_statement .)
    KEYWORD_OBJECT  reduce using rule 122 (statement -> normal_statement .)
    BLOCKBEGIN      reduce using rule 122 (statement -> normal_statement .)
    TERMINATOR      reduce using rule 122 (statement -> normal_statement .)
    KEYWORD_RETURN  reduce using rule 122 (statement -> normal_statement .)
    KEYWORD_PROTECTED reduce using rule 122 (statement -> normal_statement .)
    KEYWORD_PRIVATE reduce using rule 122 (statement -> normal_statement .)
    IDENTIFIER      reduce using rule 122 (statement -> normal_statement .)
    PLUS            reduce using rule 122 (statement -> normal_statement .)
    MINUS           reduce using rule 122 (statement -> normal_statement .)
    TILDA           reduce using rule 122 (statement -> normal_statement .)
    NOT             reduce using rule 122 (statement -> normal_statement .)
    LPAREN          reduce using rule 122 (statement -> normal_statement .)
    DOUBLE_NUMBER   reduce using rule 122 (statement -> normal_statement .)
    INT_NUMBER      reduce using rule 122 (statement -> normal_statement .)
    CHAR            reduce using rule 122 (statement -> normal_statement .)
    STRING          reduce using rule 122 (statement -> normal_statement .)
    BOOL_CONSTT     reduce using rule 122 (statement -> normal_statement .)
    BOOL_CONSTF     reduce using rule 122 (statement -> normal_statement .)
    KEYWORD_NULL    reduce using rule 122 (statement -> normal_statement .)
    KEYWORD_DEF     reduce using rule 122 (statement -> normal_statement .)
    KEYWORD_CLASS   reduce using rule 122 (statement -> normal_statement .)
    KEYWORD_VAR     reduce using rule 122 (statement -> normal_statement .)
    KEYWORD_VAL     reduce using rule 122 (statement -> normal_statement .)
    BLOCKEND        reduce using rule 122 (statement -> normal_statement .)
    KEYWORD_CASE    reduce using rule 122 (statement -> normal_statement .)
    KEYWORD_ELSE    reduce using rule 139 (if_then_else_intermediate -> normal_statement .)


state 271

    (97) variable_declaration_body -> variable_declarator ASOP variable_declaration_initializer .

    TERMINATOR      reduce using rule 97 (variable_declaration_body -> variable_declarator ASOP variable_declaration_initializer .)


state 272

    (93) variable_declaration_initializer -> array_initializer .

    RPAREN          reduce using rule 93 (variable_declaration_initializer -> array_initializer .)
    COMMA           reduce using rule 93 (variable_declaration_initializer -> array_initializer .)
    TERMINATOR      reduce using rule 93 (variable_declaration_initializer -> array_initializer .)


state 273

    (119) array_initializer -> KEYWORD_NEW . KEYWORD_ARRAY LBRAC type RBRAC LPAREN INT_NUMBER RPAREN
    (121) class_initializer -> KEYWORD_NEW . name LPAREN argument_list_opt RPAREN
    (115) name -> . simple_name
    (116) name -> . qualified_name
    (117) simple_name -> . IDENTIFIER
    (118) qualified_name -> . name INST simple_name

    KEYWORD_ARRAY   shift and go to state 292
    IDENTIFIER      shift and go to state 77

    simple_name                    shift and go to state 67
    name                           shift and go to state 293
    qualified_name                 shift and go to state 79

state 274

    (94) variable_declaration_initializer -> class_initializer .

    RPAREN          reduce using rule 94 (variable_declaration_initializer -> class_initializer .)
    COMMA           reduce using rule 94 (variable_declaration_initializer -> class_initializer .)
    TERMINATOR      reduce using rule 94 (variable_declaration_initializer -> class_initializer .)


state 275

    (120) array_initializer -> KEYWORD_ARRAY . LPAREN argument_list_opt RPAREN

    LPAREN          shift and go to state 294


state 276

    (92) variable_declaration_initializer -> expression .

    RPAREN          reduce using rule 92 (variable_declaration_initializer -> expression .)
    COMMA           reduce using rule 92 (variable_declaration_initializer -> expression .)
    TERMINATOR      reduce using rule 92 (variable_declaration_initializer -> expression .)


state 277

    (98) variable_declaration_body -> LPAREN variable_declarators RPAREN . ASOP LPAREN variable_arguement_list RPAREN

    ASOP            shift and go to state 295


state 278

    (99) variable_declaration_body -> IDENTIFIER ASOP LPAREN . func_arguement_list_opt RPAREN FUNTYPE expression
    (183) func_arguement_list_opt -> . variable_declarators
    (184) func_arguement_list_opt -> . empty
    (100) variable_declarators -> . variable_declarator
    (101) variable_declarators -> . variable_declarators COMMA variable_declarator
    (186) empty -> .
    (102) variable_declarator -> . variable_declarator_id
    (103) variable_declarator_id -> . IDENTIFIER COLON type

    RPAREN          reduce using rule 186 (empty -> .)
    IDENTIFIER      shift and go to state 175

    func_arguement_list_opt        shift and go to state 296
    variable_declarators           shift and go to state 173
    variable_declarator            shift and go to state 174
    variable_declarator_id         shift and go to state 172
    empty                          shift and go to state 176

state 279

    (150) for_step_opts -> KEYWORD_BY expression .

    TERMINATOR      reduce using rule 150 (for_step_opts -> KEYWORD_BY expression .)
    RPAREN          reduce using rule 150 (for_step_opts -> KEYWORD_BY expression .)


state 280

    (143) for_statement -> KEYWORD_FOR LPAREN for_logic RPAREN statement .

    KEYWORD_WHILE   reduce using rule 143 (for_statement -> KEYWORD_FOR LPAREN for_logic RPAREN statement .)
    KEYWORD_IF      reduce using rule 143 (for_statement -> KEYWORD_FOR LPAREN for_logic RPAREN statement .)
    KEYWORD_DO      reduce using rule 143 (for_statement -> KEYWORD_FOR LPAREN for_logic RPAREN statement .)
    KEYWORD_FOR     reduce using rule 143 (for_statement -> KEYWORD_FOR LPAREN for_logic RPAREN statement .)
    KEYWORD_OBJECT  reduce using rule 143 (for_statement -> KEYWORD_FOR LPAREN for_logic RPAREN statement .)
    BLOCKBEGIN      reduce using rule 143 (for_statement -> KEYWORD_FOR LPAREN for_logic RPAREN statement .)
    TERMINATOR      reduce using rule 143 (for_statement -> KEYWORD_FOR LPAREN for_logic RPAREN statement .)
    KEYWORD_RETURN  reduce using rule 143 (for_statement -> KEYWORD_FOR LPAREN for_logic RPAREN statement .)
    KEYWORD_PROTECTED reduce using rule 143 (for_statement -> KEYWORD_FOR LPAREN for_logic RPAREN statement .)
    KEYWORD_PRIVATE reduce using rule 143 (for_statement -> KEYWORD_FOR LPAREN for_logic RPAREN statement .)
    IDENTIFIER      reduce using rule 143 (for_statement -> KEYWORD_FOR LPAREN for_logic RPAREN statement .)
    PLUS            reduce using rule 143 (for_statement -> KEYWORD_FOR LPAREN for_logic RPAREN statement .)
    MINUS           reduce using rule 143 (for_statement -> KEYWORD_FOR LPAREN for_logic RPAREN statement .)
    TILDA           reduce using rule 143 (for_statement -> KEYWORD_FOR LPAREN for_logic RPAREN statement .)
    NOT             reduce using rule 143 (for_statement -> KEYWORD_FOR LPAREN for_logic RPAREN statement .)
    LPAREN          reduce using rule 143 (for_statement -> KEYWORD_FOR LPAREN for_logic RPAREN statement .)
    DOUBLE_NUMBER   reduce using rule 143 (for_statement -> KEYWORD_FOR LPAREN for_logic RPAREN statement .)
    INT_NUMBER      reduce using rule 143 (for_statement -> KEYWORD_FOR LPAREN for_logic RPAREN statement .)
    CHAR            reduce using rule 143 (for_statement -> KEYWORD_FOR LPAREN for_logic RPAREN statement .)
    STRING          reduce using rule 143 (for_statement -> KEYWORD_FOR LPAREN for_logic RPAREN statement .)
    BOOL_CONSTT     reduce using rule 143 (for_statement -> KEYWORD_FOR LPAREN for_logic RPAREN statement .)
    BOOL_CONSTF     reduce using rule 143 (for_statement -> KEYWORD_FOR LPAREN for_logic RPAREN statement .)
    KEYWORD_NULL    reduce using rule 143 (for_statement -> KEYWORD_FOR LPAREN for_logic RPAREN statement .)
    KEYWORD_DEF     reduce using rule 143 (for_statement -> KEYWORD_FOR LPAREN for_logic RPAREN statement .)
    KEYWORD_CLASS   reduce using rule 143 (for_statement -> KEYWORD_FOR LPAREN for_logic RPAREN statement .)
    KEYWORD_VAR     reduce using rule 143 (for_statement -> KEYWORD_FOR LPAREN for_logic RPAREN statement .)
    KEYWORD_VAL     reduce using rule 143 (for_statement -> KEYWORD_FOR LPAREN for_logic RPAREN statement .)
    BLOCKEND        reduce using rule 143 (for_statement -> KEYWORD_FOR LPAREN for_logic RPAREN statement .)
    KEYWORD_CASE    reduce using rule 143 (for_statement -> KEYWORD_FOR LPAREN for_logic RPAREN statement .)


state 281

    (145) for_logic -> for_update TERMINATOR for_logic .

    RPAREN          reduce using rule 145 (for_logic -> for_update TERMINATOR for_logic .)


state 282

    (147) for_loop -> IDENTIFIER CHOOSE expression . for_untilTo expression
    (148) for_untilTo -> . KEYWORD_UNTIL
    (149) for_untilTo -> . KEYWORD_TO

    KEYWORD_UNTIL   shift and go to state 299
    KEYWORD_TO      shift and go to state 298

    for_untilTo                    shift and go to state 297

state 283

    (142) do_while_statement -> KEYWORD_DO statement KEYWORD_WHILE LPAREN expression . RPAREN TERMINATOR

    RPAREN          shift and go to state 300


state 284

    (114) array_data_type -> KEYWORD_ARRAY LBRAC . type RBRAC
    (104) type -> . primitive_type
    (105) type -> . reference_type
    (106) primitive_type -> . TYPE_INT
    (107) primitive_type -> . TYPE_DOUBLE
    (108) primitive_type -> . TYPE_CHAR
    (109) primitive_type -> . TYPE_STRING
    (110) primitive_type -> . TYPE_BOOLEAN
    (111) reference_type -> . class_data_type
    (112) reference_type -> . array_data_type
    (113) class_data_type -> . name
    (114) array_data_type -> . KEYWORD_ARRAY LBRAC type RBRAC
    (115) name -> . simple_name
    (116) name -> . qualified_name
    (117) simple_name -> . IDENTIFIER
    (118) qualified_name -> . name INST simple_name

    TYPE_INT        shift and go to state 154
    TYPE_DOUBLE     shift and go to state 159
    TYPE_CHAR       shift and go to state 156
    TYPE_STRING     shift and go to state 155
    TYPE_BOOLEAN    shift and go to state 158
    KEYWORD_ARRAY   shift and go to state 248
    IDENTIFIER      shift and go to state 77

    name                           shift and go to state 246
    qualified_name                 shift and go to state 79
    reference_type                 shift and go to state 247
    primitive_type                 shift and go to state 249
    class_data_type                shift and go to state 250
    type                           shift and go to state 301
    array_data_type                shift and go to state 252
    simple_name                    shift and go to state 67

state 285

    (181) method_return_type -> TYPE_VOID .

    ASOP            reduce using rule 181 (method_return_type -> TYPE_VOID .)


state 286

    (180) method_return_type -> type .

    ASOP            reduce using rule 180 (method_return_type -> type .)


state 287

    (179) method_header -> method_header_name LPAREN func_arguement_list_opt RPAREN COLON method_return_type . ASOP

    ASOP            shift and go to state 302


state 288

    (162) switch_label -> KEYWORD_CASE expression FUNTYPE .

    BLOCKEND        reduce using rule 162 (switch_label -> KEYWORD_CASE expression FUNTYPE .)
    KEYWORD_CASE    reduce using rule 162 (switch_label -> KEYWORD_CASE expression FUNTYPE .)
    KEYWORD_IF      reduce using rule 162 (switch_label -> KEYWORD_CASE expression FUNTYPE .)
    KEYWORD_WHILE   reduce using rule 162 (switch_label -> KEYWORD_CASE expression FUNTYPE .)
    KEYWORD_DO      reduce using rule 162 (switch_label -> KEYWORD_CASE expression FUNTYPE .)
    KEYWORD_FOR     reduce using rule 162 (switch_label -> KEYWORD_CASE expression FUNTYPE .)
    KEYWORD_OBJECT  reduce using rule 162 (switch_label -> KEYWORD_CASE expression FUNTYPE .)
    BLOCKBEGIN      reduce using rule 162 (switch_label -> KEYWORD_CASE expression FUNTYPE .)
    TERMINATOR      reduce using rule 162 (switch_label -> KEYWORD_CASE expression FUNTYPE .)
    KEYWORD_RETURN  reduce using rule 162 (switch_label -> KEYWORD_CASE expression FUNTYPE .)
    KEYWORD_PROTECTED reduce using rule 162 (switch_label -> KEYWORD_CASE expression FUNTYPE .)
    KEYWORD_PRIVATE reduce using rule 162 (switch_label -> KEYWORD_CASE expression FUNTYPE .)
    IDENTIFIER      reduce using rule 162 (switch_label -> KEYWORD_CASE expression FUNTYPE .)
    PLUS            reduce using rule 162 (switch_label -> KEYWORD_CASE expression FUNTYPE .)
    MINUS           reduce using rule 162 (switch_label -> KEYWORD_CASE expression FUNTYPE .)
    TILDA           reduce using rule 162 (switch_label -> KEYWORD_CASE expression FUNTYPE .)
    NOT             reduce using rule 162 (switch_label -> KEYWORD_CASE expression FUNTYPE .)
    LPAREN          reduce using rule 162 (switch_label -> KEYWORD_CASE expression FUNTYPE .)
    DOUBLE_NUMBER   reduce using rule 162 (switch_label -> KEYWORD_CASE expression FUNTYPE .)
    INT_NUMBER      reduce using rule 162 (switch_label -> KEYWORD_CASE expression FUNTYPE .)
    CHAR            reduce using rule 162 (switch_label -> KEYWORD_CASE expression FUNTYPE .)
    STRING          reduce using rule 162 (switch_label -> KEYWORD_CASE expression FUNTYPE .)
    BOOL_CONSTT     reduce using rule 162 (switch_label -> KEYWORD_CASE expression FUNTYPE .)
    BOOL_CONSTF     reduce using rule 162 (switch_label -> KEYWORD_CASE expression FUNTYPE .)
    KEYWORD_NULL    reduce using rule 162 (switch_label -> KEYWORD_CASE expression FUNTYPE .)
    KEYWORD_DEF     reduce using rule 162 (switch_label -> KEYWORD_CASE expression FUNTYPE .)
    KEYWORD_CLASS   reduce using rule 162 (switch_label -> KEYWORD_CASE expression FUNTYPE .)
    KEYWORD_VAR     reduce using rule 162 (switch_label -> KEYWORD_CASE expression FUNTYPE .)
    KEYWORD_VAL     reduce using rule 162 (switch_label -> KEYWORD_CASE expression FUNTYPE .)


state 289

    (156) switch_block -> BLOCKBEGIN switch_block_statements switch_labels BLOCKEND .

    KEYWORD_IF      reduce using rule 156 (switch_block -> BLOCKBEGIN switch_block_statements switch_labels BLOCKEND .)
    KEYWORD_WHILE   reduce using rule 156 (switch_block -> BLOCKBEGIN switch_block_statements switch_labels BLOCKEND .)
    KEYWORD_DO      reduce using rule 156 (switch_block -> BLOCKBEGIN switch_block_statements switch_labels BLOCKEND .)
    KEYWORD_FOR     reduce using rule 156 (switch_block -> BLOCKBEGIN switch_block_statements switch_labels BLOCKEND .)
    KEYWORD_OBJECT  reduce using rule 156 (switch_block -> BLOCKBEGIN switch_block_statements switch_labels BLOCKEND .)
    BLOCKBEGIN      reduce using rule 156 (switch_block -> BLOCKBEGIN switch_block_statements switch_labels BLOCKEND .)
    TERMINATOR      reduce using rule 156 (switch_block -> BLOCKBEGIN switch_block_statements switch_labels BLOCKEND .)
    KEYWORD_RETURN  reduce using rule 156 (switch_block -> BLOCKBEGIN switch_block_statements switch_labels BLOCKEND .)
    KEYWORD_PROTECTED reduce using rule 156 (switch_block -> BLOCKBEGIN switch_block_statements switch_labels BLOCKEND .)
    KEYWORD_PRIVATE reduce using rule 156 (switch_block -> BLOCKBEGIN switch_block_statements switch_labels BLOCKEND .)
    IDENTIFIER      reduce using rule 156 (switch_block -> BLOCKBEGIN switch_block_statements switch_labels BLOCKEND .)
    PLUS            reduce using rule 156 (switch_block -> BLOCKBEGIN switch_block_statements switch_labels BLOCKEND .)
    MINUS           reduce using rule 156 (switch_block -> BLOCKBEGIN switch_block_statements switch_labels BLOCKEND .)
    TILDA           reduce using rule 156 (switch_block -> BLOCKBEGIN switch_block_statements switch_labels BLOCKEND .)
    NOT             reduce using rule 156 (switch_block -> BLOCKBEGIN switch_block_statements switch_labels BLOCKEND .)
    LPAREN          reduce using rule 156 (switch_block -> BLOCKBEGIN switch_block_statements switch_labels BLOCKEND .)
    DOUBLE_NUMBER   reduce using rule 156 (switch_block -> BLOCKBEGIN switch_block_statements switch_labels BLOCKEND .)
    INT_NUMBER      reduce using rule 156 (switch_block -> BLOCKBEGIN switch_block_statements switch_labels BLOCKEND .)
    CHAR            reduce using rule 156 (switch_block -> BLOCKBEGIN switch_block_statements switch_labels BLOCKEND .)
    STRING          reduce using rule 156 (switch_block -> BLOCKBEGIN switch_block_statements switch_labels BLOCKEND .)
    BOOL_CONSTT     reduce using rule 156 (switch_block -> BLOCKBEGIN switch_block_statements switch_labels BLOCKEND .)
    BOOL_CONSTF     reduce using rule 156 (switch_block -> BLOCKBEGIN switch_block_statements switch_labels BLOCKEND .)
    KEYWORD_NULL    reduce using rule 156 (switch_block -> BLOCKBEGIN switch_block_statements switch_labels BLOCKEND .)
    KEYWORD_DEF     reduce using rule 156 (switch_block -> BLOCKBEGIN switch_block_statements switch_labels BLOCKEND .)
    KEYWORD_CLASS   reduce using rule 156 (switch_block -> BLOCKBEGIN switch_block_statements switch_labels BLOCKEND .)
    KEYWORD_VAR     reduce using rule 156 (switch_block -> BLOCKBEGIN switch_block_statements switch_labels BLOCKEND .)
    KEYWORD_VAL     reduce using rule 156 (switch_block -> BLOCKBEGIN switch_block_statements switch_labels BLOCKEND .)
    BLOCKEND        reduce using rule 156 (switch_block -> BLOCKBEGIN switch_block_statements switch_labels BLOCKEND .)
    KEYWORD_CASE    reduce using rule 156 (switch_block -> BLOCKBEGIN switch_block_statements switch_labels BLOCKEND .)
    KEYWORD_ELSE    reduce using rule 156 (switch_block -> BLOCKBEGIN switch_block_statements switch_labels BLOCKEND .)


state 290

    (137) if_then_else_statement -> KEYWORD_IF LPAREN expression RPAREN if_then_else_intermediate KEYWORD_ELSE . statement
    (122) statement -> . normal_statement
    (123) statement -> . if_then_statement
    (124) statement -> . if_then_else_statement
    (125) statement -> . while_statement
    (126) statement -> . do_while_statement
    (127) statement -> . for_statement
    (128) normal_statement -> . block
    (129) normal_statement -> . expression_statement
    (130) normal_statement -> . empty_statement
    (131) normal_statement -> . return_statement
    (132) normal_statement -> . switch_statement
    (136) if_then_statement -> . KEYWORD_IF LPAREN expression RPAREN statement
    (137) if_then_else_statement -> . KEYWORD_IF LPAREN expression RPAREN if_then_else_intermediate KEYWORD_ELSE statement
    (141) while_statement -> . KEYWORD_WHILE LPAREN expression RPAREN statement
    (142) do_while_statement -> . KEYWORD_DO statement KEYWORD_WHILE LPAREN expression RPAREN TERMINATOR
    (143) for_statement -> . KEYWORD_FOR LPAREN for_logic RPAREN statement
    (8) block -> . BLOCKBEGIN block_statements_opt BLOCKEND
    (133) expression_statement -> . statement_expression TERMINATOR
    (163) empty_statement -> . TERMINATOR
    (164) return_statement -> . KEYWORD_RETURN expression_optional TERMINATOR
    (152) switch_statement -> . expression KEYWORD_MATCH switch_block
    (134) statement_expression -> . assignment
    (135) statement_expression -> . method_invocation
    (18) expression -> . assignment_expression
    (23) assignment -> . valid_variable assignment_operator assignment_expression
    (79) method_invocation -> . name LPAREN argument_list_opt RPAREN
    (21) assignment_expression -> . assignment
    (22) assignment_expression -> . conditional_or_expression
    (24) valid_variable -> . name
    (25) valid_variable -> . array_access
    (115) name -> . simple_name
    (116) name -> . qualified_name
    (28) conditional_or_expression -> . conditional_and_expression
    (29) conditional_or_expression -> . conditional_or_expression OR conditional_and_expression
    (26) array_access -> . name LBRAC expression RBRAC
    (117) simple_name -> . IDENTIFIER
    (118) qualified_name -> . name INST simple_name
    (30) conditional_and_expression -> . inclusive_or_expression
    (31) conditional_and_expression -> . conditional_and_expression AND inclusive_or_expression
    (32) inclusive_or_expression -> . exclusive_or_expression
    (33) inclusive_or_expression -> . inclusive_or_expression OR_BITWISE exclusive_or_expression
    (34) exclusive_or_expression -> . and_expression
    (35) exclusive_or_expression -> . exclusive_or_expression XOR and_expression
    (36) and_expression -> . equality_expression
    (37) and_expression -> . and_expression AND_BITWISE equality_expression
    (38) equality_expression -> . relational_expression
    (39) equality_expression -> . equality_expression EQUAL relational_expression
    (40) equality_expression -> . equality_expression NEQUAL relational_expression
    (41) relational_expression -> . shift_expression
    (42) relational_expression -> . relational_expression GREATER shift_expression
    (43) relational_expression -> . relational_expression LESS shift_expression
    (44) relational_expression -> . relational_expression GEQ shift_expression
    (45) relational_expression -> . relational_expression LEQ shift_expression
    (46) shift_expression -> . additive_expression
    (47) shift_expression -> . shift_expression LSHIFT additive_expression
    (48) shift_expression -> . shift_expression RSHIFT additive_expression
    (49) additive_expression -> . multiplicative_expression
    (50) additive_expression -> . additive_expression PLUS multiplicative_expression
    (51) additive_expression -> . additive_expression MINUS multiplicative_expression
    (52) multiplicative_expression -> . unary_expression
    (53) multiplicative_expression -> . multiplicative_expression TIMES unary_expression
    (54) multiplicative_expression -> . multiplicative_expression DIVIDE unary_expression
    (55) multiplicative_expression -> . multiplicative_expression REMAINDER unary_expression
    (56) unary_expression -> . PLUS unary_expression
    (57) unary_expression -> . MINUS unary_expression
    (58) unary_expression -> . unary_expression_not_plus_minus
    (59) unary_expression_not_plus_minus -> . base_variable_set
    (60) unary_expression_not_plus_minus -> . TILDA unary_expression
    (61) unary_expression_not_plus_minus -> . NOT unary_expression
    (62) unary_expression_not_plus_minus -> . cast_expression
    (63) base_variable_set -> . variable_literal
    (64) base_variable_set -> . LPAREN expression RPAREN
    (67) cast_expression -> . LPAREN primitive_type RPAREN unary_expression
    (65) variable_literal -> . valid_variable
    (66) variable_literal -> . primary
    (68) primary -> . literal
    (69) primary -> . method_invocation
    (70) literal -> . int_float
    (71) literal -> . c_literal
    (77) int_float -> . DOUBLE_NUMBER
    (78) int_float -> . INT_NUMBER
    (72) c_literal -> . CHAR
    (73) c_literal -> . STRING
    (74) c_literal -> . BOOL_CONSTT
    (75) c_literal -> . BOOL_CONSTF
    (76) c_literal -> . KEYWORD_NULL

    KEYWORD_IF      shift and go to state 81
    KEYWORD_WHILE   shift and go to state 50
    KEYWORD_DO      shift and go to state 98
    KEYWORD_FOR     shift and go to state 97
    BLOCKBEGIN      shift and go to state 15
    TERMINATOR      shift and go to state 53
    KEYWORD_RETURN  shift and go to state 68
    IDENTIFIER      shift and go to state 77
    PLUS            shift and go to state 36
    MINUS           shift and go to state 29
    TILDA           shift and go to state 72
    NOT             shift and go to state 57
    LPAREN          shift and go to state 94
    DOUBLE_NUMBER   shift and go to state 33
    INT_NUMBER      shift and go to state 44
    CHAR            shift and go to state 63
    STRING          shift and go to state 76
    BOOL_CONSTT     shift and go to state 35
    BOOL_CONSTF     shift and go to state 30
    KEYWORD_NULL    shift and go to state 65

    expression_statement           shift and go to state 27
    unary_expression               shift and go to state 45
    exclusive_or_expression        shift and go to state 61
    normal_statement               shift and go to state 86
    primary                        shift and go to state 62
    unary_expression_not_plus_minus shift and go to state 46
    if_then_statement              shift and go to state 64
    array_access                   shift and go to state 28
    switch_statement               shift and go to state 47
    assignment_expression          shift and go to state 91
    qualified_name                 shift and go to state 79
    base_variable_set              shift and go to state 88
    valid_variable                 shift and go to state 48
    inclusive_or_expression        shift and go to state 32
    literal                        shift and go to state 71
    return_statement               shift and go to state 89
    while_statement                shift and go to state 34
    and_expression                 shift and go to state 87
    statement                      shift and go to state 303
    statement_expression           shift and go to state 37
    method_invocation              shift and go to state 75
    simple_name                    shift and go to state 67
    conditional_or_expression      shift and go to state 49
    relational_expression          shift and go to state 73
    for_statement                  shift and go to state 38
    do_while_statement             shift and go to state 51
    assignment                     shift and go to state 92
    multiplicative_expression      shift and go to state 52
    c_literal                      shift and go to state 93
    additive_expression            shift and go to state 66
    cast_expression                shift and go to state 80
    shift_expression               shift and go to state 54
    equality_expression            shift and go to state 82
    int_float                      shift and go to state 40
    variable_literal               shift and go to state 55
    name                           shift and go to state 43
    empty_statement                shift and go to state 84
    expression                     shift and go to state 58
    conditional_and_expression     shift and go to state 56
    block                          shift and go to state 59
    if_then_else_statement         shift and go to state 60

state 291

    (136) if_then_statement -> KEYWORD_IF LPAREN . expression RPAREN statement
    (137) if_then_else_statement -> KEYWORD_IF LPAREN . expression RPAREN if_then_else_intermediate KEYWORD_ELSE statement
    (138) if_then_else_statement_precedence -> KEYWORD_IF LPAREN . expression RPAREN if_then_else_intermediate KEYWORD_ELSE if_then_else_intermediate
    (18) expression -> . assignment_expression
    (21) assignment_expression -> . assignment
    (22) assignment_expression -> . conditional_or_expression
    (23) assignment -> . valid_variable assignment_operator assignment_expression
    (28) conditional_or_expression -> . conditional_and_expression
    (29) conditional_or_expression -> . conditional_or_expression OR conditional_and_expression
    (24) valid_variable -> . name
    (25) valid_variable -> . array_access
    (30) conditional_and_expression -> . inclusive_or_expression
    (31) conditional_and_expression -> . conditional_and_expression AND inclusive_or_expression
    (115) name -> . simple_name
    (116) name -> . qualified_name
    (26) array_access -> . name LBRAC expression RBRAC
    (32) inclusive_or_expression -> . exclusive_or_expression
    (33) inclusive_or_expression -> . inclusive_or_expression OR_BITWISE exclusive_or_expression
    (117) simple_name -> . IDENTIFIER
    (118) qualified_name -> . name INST simple_name
    (34) exclusive_or_expression -> . and_expression
    (35) exclusive_or_expression -> . exclusive_or_expression XOR and_expression
    (36) and_expression -> . equality_expression
    (37) and_expression -> . and_expression AND_BITWISE equality_expression
    (38) equality_expression -> . relational_expression
    (39) equality_expression -> . equality_expression EQUAL relational_expression
    (40) equality_expression -> . equality_expression NEQUAL relational_expression
    (41) relational_expression -> . shift_expression
    (42) relational_expression -> . relational_expression GREATER shift_expression
    (43) relational_expression -> . relational_expression LESS shift_expression
    (44) relational_expression -> . relational_expression GEQ shift_expression
    (45) relational_expression -> . relational_expression LEQ shift_expression
    (46) shift_expression -> . additive_expression
    (47) shift_expression -> . shift_expression LSHIFT additive_expression
    (48) shift_expression -> . shift_expression RSHIFT additive_expression
    (49) additive_expression -> . multiplicative_expression
    (50) additive_expression -> . additive_expression PLUS multiplicative_expression
    (51) additive_expression -> . additive_expression MINUS multiplicative_expression
    (52) multiplicative_expression -> . unary_expression
    (53) multiplicative_expression -> . multiplicative_expression TIMES unary_expression
    (54) multiplicative_expression -> . multiplicative_expression DIVIDE unary_expression
    (55) multiplicative_expression -> . multiplicative_expression REMAINDER unary_expression
    (56) unary_expression -> . PLUS unary_expression
    (57) unary_expression -> . MINUS unary_expression
    (58) unary_expression -> . unary_expression_not_plus_minus
    (59) unary_expression_not_plus_minus -> . base_variable_set
    (60) unary_expression_not_plus_minus -> . TILDA unary_expression
    (61) unary_expression_not_plus_minus -> . NOT unary_expression
    (62) unary_expression_not_plus_minus -> . cast_expression
    (63) base_variable_set -> . variable_literal
    (64) base_variable_set -> . LPAREN expression RPAREN
    (67) cast_expression -> . LPAREN primitive_type RPAREN unary_expression
    (65) variable_literal -> . valid_variable
    (66) variable_literal -> . primary
    (68) primary -> . literal
    (69) primary -> . method_invocation
    (70) literal -> . int_float
    (71) literal -> . c_literal
    (79) method_invocation -> . name LPAREN argument_list_opt RPAREN
    (77) int_float -> . DOUBLE_NUMBER
    (78) int_float -> . INT_NUMBER
    (72) c_literal -> . CHAR
    (73) c_literal -> . STRING
    (74) c_literal -> . BOOL_CONSTT
    (75) c_literal -> . BOOL_CONSTF
    (76) c_literal -> . KEYWORD_NULL

    IDENTIFIER      shift and go to state 77
    PLUS            shift and go to state 36
    MINUS           shift and go to state 29
    TILDA           shift and go to state 72
    NOT             shift and go to state 57
    LPAREN          shift and go to state 94
    DOUBLE_NUMBER   shift and go to state 33
    INT_NUMBER      shift and go to state 44
    CHAR            shift and go to state 63
    STRING          shift and go to state 76
    BOOL_CONSTT     shift and go to state 35
    BOOL_CONSTF     shift and go to state 30
    KEYWORD_NULL    shift and go to state 65

    unary_expression               shift and go to state 45
    exclusive_or_expression        shift and go to state 61
    primary                        shift and go to state 62
    unary_expression_not_plus_minus shift and go to state 46
    array_access                   shift and go to state 28
    additive_expression            shift and go to state 66
    simple_name                    shift and go to state 67
    c_literal                      shift and go to state 93
    base_variable_set              shift and go to state 88
    valid_variable                 shift and go to state 48
    inclusive_or_expression        shift and go to state 32
    literal                        shift and go to state 71
    and_expression                 shift and go to state 87
    relational_expression          shift and go to state 73
    cast_expression                shift and go to state 80
    conditional_or_expression      shift and go to state 49
    assignment_expression          shift and go to state 91
    qualified_name                 shift and go to state 79
    assignment                     shift and go to state 138
    multiplicative_expression      shift and go to state 52
    method_invocation              shift and go to state 111
    shift_expression               shift and go to state 54
    equality_expression            shift and go to state 82
    int_float                      shift and go to state 40
    variable_literal               shift and go to state 55
    name                           shift and go to state 139
    expression                     shift and go to state 304
    conditional_and_expression     shift and go to state 56

state 292

    (119) array_initializer -> KEYWORD_NEW KEYWORD_ARRAY . LBRAC type RBRAC LPAREN INT_NUMBER RPAREN

    LBRAC           shift and go to state 305


state 293

    (121) class_initializer -> KEYWORD_NEW name . LPAREN argument_list_opt RPAREN
    (118) qualified_name -> name . INST simple_name

    LPAREN          shift and go to state 306
    INST            shift and go to state 119


state 294

    (120) array_initializer -> KEYWORD_ARRAY LPAREN . argument_list_opt RPAREN
    (80) argument_list_opt -> . argument_list
    (81) argument_list_opt -> . empty
    (82) argument_list -> . expression
    (83) argument_list -> . argument_list COMMA expression
    (186) empty -> .
    (18) expression -> . assignment_expression
    (21) assignment_expression -> . assignment
    (22) assignment_expression -> . conditional_or_expression
    (23) assignment -> . valid_variable assignment_operator assignment_expression
    (28) conditional_or_expression -> . conditional_and_expression
    (29) conditional_or_expression -> . conditional_or_expression OR conditional_and_expression
    (24) valid_variable -> . name
    (25) valid_variable -> . array_access
    (30) conditional_and_expression -> . inclusive_or_expression
    (31) conditional_and_expression -> . conditional_and_expression AND inclusive_or_expression
    (115) name -> . simple_name
    (116) name -> . qualified_name
    (26) array_access -> . name LBRAC expression RBRAC
    (32) inclusive_or_expression -> . exclusive_or_expression
    (33) inclusive_or_expression -> . inclusive_or_expression OR_BITWISE exclusive_or_expression
    (117) simple_name -> . IDENTIFIER
    (118) qualified_name -> . name INST simple_name
    (34) exclusive_or_expression -> . and_expression
    (35) exclusive_or_expression -> . exclusive_or_expression XOR and_expression
    (36) and_expression -> . equality_expression
    (37) and_expression -> . and_expression AND_BITWISE equality_expression
    (38) equality_expression -> . relational_expression
    (39) equality_expression -> . equality_expression EQUAL relational_expression
    (40) equality_expression -> . equality_expression NEQUAL relational_expression
    (41) relational_expression -> . shift_expression
    (42) relational_expression -> . relational_expression GREATER shift_expression
    (43) relational_expression -> . relational_expression LESS shift_expression
    (44) relational_expression -> . relational_expression GEQ shift_expression
    (45) relational_expression -> . relational_expression LEQ shift_expression
    (46) shift_expression -> . additive_expression
    (47) shift_expression -> . shift_expression LSHIFT additive_expression
    (48) shift_expression -> . shift_expression RSHIFT additive_expression
    (49) additive_expression -> . multiplicative_expression
    (50) additive_expression -> . additive_expression PLUS multiplicative_expression
    (51) additive_expression -> . additive_expression MINUS multiplicative_expression
    (52) multiplicative_expression -> . unary_expression
    (53) multiplicative_expression -> . multiplicative_expression TIMES unary_expression
    (54) multiplicative_expression -> . multiplicative_expression DIVIDE unary_expression
    (55) multiplicative_expression -> . multiplicative_expression REMAINDER unary_expression
    (56) unary_expression -> . PLUS unary_expression
    (57) unary_expression -> . MINUS unary_expression
    (58) unary_expression -> . unary_expression_not_plus_minus
    (59) unary_expression_not_plus_minus -> . base_variable_set
    (60) unary_expression_not_plus_minus -> . TILDA unary_expression
    (61) unary_expression_not_plus_minus -> . NOT unary_expression
    (62) unary_expression_not_plus_minus -> . cast_expression
    (63) base_variable_set -> . variable_literal
    (64) base_variable_set -> . LPAREN expression RPAREN
    (67) cast_expression -> . LPAREN primitive_type RPAREN unary_expression
    (65) variable_literal -> . valid_variable
    (66) variable_literal -> . primary
    (68) primary -> . literal
    (69) primary -> . method_invocation
    (70) literal -> . int_float
    (71) literal -> . c_literal
    (79) method_invocation -> . name LPAREN argument_list_opt RPAREN
    (77) int_float -> . DOUBLE_NUMBER
    (78) int_float -> . INT_NUMBER
    (72) c_literal -> . CHAR
    (73) c_literal -> . STRING
    (74) c_literal -> . BOOL_CONSTT
    (75) c_literal -> . BOOL_CONSTF
    (76) c_literal -> . KEYWORD_NULL

    RPAREN          reduce using rule 186 (empty -> .)
    IDENTIFIER      shift and go to state 77
    PLUS            shift and go to state 36
    MINUS           shift and go to state 29
    TILDA           shift and go to state 72
    NOT             shift and go to state 57
    LPAREN          shift and go to state 94
    DOUBLE_NUMBER   shift and go to state 33
    INT_NUMBER      shift and go to state 44
    CHAR            shift and go to state 63
    STRING          shift and go to state 76
    BOOL_CONSTT     shift and go to state 35
    BOOL_CONSTF     shift and go to state 30
    KEYWORD_NULL    shift and go to state 65

    and_expression                 shift and go to state 87
    exclusive_or_expression        shift and go to state 61
    primary                        shift and go to state 62
    unary_expression_not_plus_minus shift and go to state 46
    array_access                   shift and go to state 28
    additive_expression            shift and go to state 66
    simple_name                    shift and go to state 67
    c_literal                      shift and go to state 93
    unary_expression               shift and go to state 45
    base_variable_set              shift and go to state 88
    valid_variable                 shift and go to state 48
    inclusive_or_expression        shift and go to state 32
    literal                        shift and go to state 71
    relational_expression          shift and go to state 73
    cast_expression                shift and go to state 80
    conditional_or_expression      shift and go to state 49
    empty                          shift and go to state 180
    argument_list                  shift and go to state 179
    assignment_expression          shift and go to state 91
    qualified_name                 shift and go to state 79
    assignment                     shift and go to state 138
    multiplicative_expression      shift and go to state 52
    method_invocation              shift and go to state 111
    shift_expression               shift and go to state 54
    equality_expression            shift and go to state 82
    int_float                      shift and go to state 40
    variable_literal               shift and go to state 55
    name                           shift and go to state 139
    argument_list_opt              shift and go to state 307
    expression                     shift and go to state 182
    conditional_and_expression     shift and go to state 56

state 295

    (98) variable_declaration_body -> LPAREN variable_declarators RPAREN ASOP . LPAREN variable_arguement_list RPAREN

    LPAREN          shift and go to state 308


state 296

    (99) variable_declaration_body -> IDENTIFIER ASOP LPAREN func_arguement_list_opt . RPAREN FUNTYPE expression

    RPAREN          shift and go to state 309


state 297

    (147) for_loop -> IDENTIFIER CHOOSE expression for_untilTo . expression
    (18) expression -> . assignment_expression
    (21) assignment_expression -> . assignment
    (22) assignment_expression -> . conditional_or_expression
    (23) assignment -> . valid_variable assignment_operator assignment_expression
    (28) conditional_or_expression -> . conditional_and_expression
    (29) conditional_or_expression -> . conditional_or_expression OR conditional_and_expression
    (24) valid_variable -> . name
    (25) valid_variable -> . array_access
    (30) conditional_and_expression -> . inclusive_or_expression
    (31) conditional_and_expression -> . conditional_and_expression AND inclusive_or_expression
    (115) name -> . simple_name
    (116) name -> . qualified_name
    (26) array_access -> . name LBRAC expression RBRAC
    (32) inclusive_or_expression -> . exclusive_or_expression
    (33) inclusive_or_expression -> . inclusive_or_expression OR_BITWISE exclusive_or_expression
    (117) simple_name -> . IDENTIFIER
    (118) qualified_name -> . name INST simple_name
    (34) exclusive_or_expression -> . and_expression
    (35) exclusive_or_expression -> . exclusive_or_expression XOR and_expression
    (36) and_expression -> . equality_expression
    (37) and_expression -> . and_expression AND_BITWISE equality_expression
    (38) equality_expression -> . relational_expression
    (39) equality_expression -> . equality_expression EQUAL relational_expression
    (40) equality_expression -> . equality_expression NEQUAL relational_expression
    (41) relational_expression -> . shift_expression
    (42) relational_expression -> . relational_expression GREATER shift_expression
    (43) relational_expression -> . relational_expression LESS shift_expression
    (44) relational_expression -> . relational_expression GEQ shift_expression
    (45) relational_expression -> . relational_expression LEQ shift_expression
    (46) shift_expression -> . additive_expression
    (47) shift_expression -> . shift_expression LSHIFT additive_expression
    (48) shift_expression -> . shift_expression RSHIFT additive_expression
    (49) additive_expression -> . multiplicative_expression
    (50) additive_expression -> . additive_expression PLUS multiplicative_expression
    (51) additive_expression -> . additive_expression MINUS multiplicative_expression
    (52) multiplicative_expression -> . unary_expression
    (53) multiplicative_expression -> . multiplicative_expression TIMES unary_expression
    (54) multiplicative_expression -> . multiplicative_expression DIVIDE unary_expression
    (55) multiplicative_expression -> . multiplicative_expression REMAINDER unary_expression
    (56) unary_expression -> . PLUS unary_expression
    (57) unary_expression -> . MINUS unary_expression
    (58) unary_expression -> . unary_expression_not_plus_minus
    (59) unary_expression_not_plus_minus -> . base_variable_set
    (60) unary_expression_not_plus_minus -> . TILDA unary_expression
    (61) unary_expression_not_plus_minus -> . NOT unary_expression
    (62) unary_expression_not_plus_minus -> . cast_expression
    (63) base_variable_set -> . variable_literal
    (64) base_variable_set -> . LPAREN expression RPAREN
    (67) cast_expression -> . LPAREN primitive_type RPAREN unary_expression
    (65) variable_literal -> . valid_variable
    (66) variable_literal -> . primary
    (68) primary -> . literal
    (69) primary -> . method_invocation
    (70) literal -> . int_float
    (71) literal -> . c_literal
    (79) method_invocation -> . name LPAREN argument_list_opt RPAREN
    (77) int_float -> . DOUBLE_NUMBER
    (78) int_float -> . INT_NUMBER
    (72) c_literal -> . CHAR
    (73) c_literal -> . STRING
    (74) c_literal -> . BOOL_CONSTT
    (75) c_literal -> . BOOL_CONSTF
    (76) c_literal -> . KEYWORD_NULL

    IDENTIFIER      shift and go to state 77
    PLUS            shift and go to state 36
    MINUS           shift and go to state 29
    TILDA           shift and go to state 72
    NOT             shift and go to state 57
    LPAREN          shift and go to state 94
    DOUBLE_NUMBER   shift and go to state 33
    INT_NUMBER      shift and go to state 44
    CHAR            shift and go to state 63
    STRING          shift and go to state 76
    BOOL_CONSTT     shift and go to state 35
    BOOL_CONSTF     shift and go to state 30
    KEYWORD_NULL    shift and go to state 65

    unary_expression               shift and go to state 45
    exclusive_or_expression        shift and go to state 61
    primary                        shift and go to state 62
    unary_expression_not_plus_minus shift and go to state 46
    array_access                   shift and go to state 28
    additive_expression            shift and go to state 66
    simple_name                    shift and go to state 67
    c_literal                      shift and go to state 93
    base_variable_set              shift and go to state 88
    valid_variable                 shift and go to state 48
    inclusive_or_expression        shift and go to state 32
    literal                        shift and go to state 71
    and_expression                 shift and go to state 87
    relational_expression          shift and go to state 73
    cast_expression                shift and go to state 80
    conditional_or_expression      shift and go to state 49
    assignment_expression          shift and go to state 91
    qualified_name                 shift and go to state 79
    assignment                     shift and go to state 138
    multiplicative_expression      shift and go to state 52
    method_invocation              shift and go to state 111
    shift_expression               shift and go to state 54
    equality_expression            shift and go to state 82
    int_float                      shift and go to state 40
    variable_literal               shift and go to state 55
    name                           shift and go to state 139
    expression                     shift and go to state 310
    conditional_and_expression     shift and go to state 56

state 298

    (149) for_untilTo -> KEYWORD_TO .

    IDENTIFIER      reduce using rule 149 (for_untilTo -> KEYWORD_TO .)
    PLUS            reduce using rule 149 (for_untilTo -> KEYWORD_TO .)
    MINUS           reduce using rule 149 (for_untilTo -> KEYWORD_TO .)
    TILDA           reduce using rule 149 (for_untilTo -> KEYWORD_TO .)
    NOT             reduce using rule 149 (for_untilTo -> KEYWORD_TO .)
    LPAREN          reduce using rule 149 (for_untilTo -> KEYWORD_TO .)
    DOUBLE_NUMBER   reduce using rule 149 (for_untilTo -> KEYWORD_TO .)
    INT_NUMBER      reduce using rule 149 (for_untilTo -> KEYWORD_TO .)
    CHAR            reduce using rule 149 (for_untilTo -> KEYWORD_TO .)
    STRING          reduce using rule 149 (for_untilTo -> KEYWORD_TO .)
    BOOL_CONSTT     reduce using rule 149 (for_untilTo -> KEYWORD_TO .)
    BOOL_CONSTF     reduce using rule 149 (for_untilTo -> KEYWORD_TO .)
    KEYWORD_NULL    reduce using rule 149 (for_untilTo -> KEYWORD_TO .)


state 299

    (148) for_untilTo -> KEYWORD_UNTIL .

    IDENTIFIER      reduce using rule 148 (for_untilTo -> KEYWORD_UNTIL .)
    PLUS            reduce using rule 148 (for_untilTo -> KEYWORD_UNTIL .)
    MINUS           reduce using rule 148 (for_untilTo -> KEYWORD_UNTIL .)
    TILDA           reduce using rule 148 (for_untilTo -> KEYWORD_UNTIL .)
    NOT             reduce using rule 148 (for_untilTo -> KEYWORD_UNTIL .)
    LPAREN          reduce using rule 148 (for_untilTo -> KEYWORD_UNTIL .)
    DOUBLE_NUMBER   reduce using rule 148 (for_untilTo -> KEYWORD_UNTIL .)
    INT_NUMBER      reduce using rule 148 (for_untilTo -> KEYWORD_UNTIL .)
    CHAR            reduce using rule 148 (for_untilTo -> KEYWORD_UNTIL .)
    STRING          reduce using rule 148 (for_untilTo -> KEYWORD_UNTIL .)
    BOOL_CONSTT     reduce using rule 148 (for_untilTo -> KEYWORD_UNTIL .)
    BOOL_CONSTF     reduce using rule 148 (for_untilTo -> KEYWORD_UNTIL .)
    KEYWORD_NULL    reduce using rule 148 (for_untilTo -> KEYWORD_UNTIL .)


state 300

    (142) do_while_statement -> KEYWORD_DO statement KEYWORD_WHILE LPAREN expression RPAREN . TERMINATOR

    TERMINATOR      shift and go to state 311


state 301

    (114) array_data_type -> KEYWORD_ARRAY LBRAC type . RBRAC

    RBRAC           shift and go to state 312


state 302

    (179) method_header -> method_header_name LPAREN func_arguement_list_opt RPAREN COLON method_return_type ASOP .

    BLOCKBEGIN      reduce using rule 179 (method_header -> method_header_name LPAREN func_arguement_list_opt RPAREN COLON method_return_type ASOP .)


state 303

    (137) if_then_else_statement -> KEYWORD_IF LPAREN expression RPAREN if_then_else_intermediate KEYWORD_ELSE statement .

    KEYWORD_IF      reduce using rule 137 (if_then_else_statement -> KEYWORD_IF LPAREN expression RPAREN if_then_else_intermediate KEYWORD_ELSE statement .)
    KEYWORD_WHILE   reduce using rule 137 (if_then_else_statement -> KEYWORD_IF LPAREN expression RPAREN if_then_else_intermediate KEYWORD_ELSE statement .)
    KEYWORD_DO      reduce using rule 137 (if_then_else_statement -> KEYWORD_IF LPAREN expression RPAREN if_then_else_intermediate KEYWORD_ELSE statement .)
    KEYWORD_FOR     reduce using rule 137 (if_then_else_statement -> KEYWORD_IF LPAREN expression RPAREN if_then_else_intermediate KEYWORD_ELSE statement .)
    KEYWORD_OBJECT  reduce using rule 137 (if_then_else_statement -> KEYWORD_IF LPAREN expression RPAREN if_then_else_intermediate KEYWORD_ELSE statement .)
    BLOCKBEGIN      reduce using rule 137 (if_then_else_statement -> KEYWORD_IF LPAREN expression RPAREN if_then_else_intermediate KEYWORD_ELSE statement .)
    TERMINATOR      reduce using rule 137 (if_then_else_statement -> KEYWORD_IF LPAREN expression RPAREN if_then_else_intermediate KEYWORD_ELSE statement .)
    KEYWORD_RETURN  reduce using rule 137 (if_then_else_statement -> KEYWORD_IF LPAREN expression RPAREN if_then_else_intermediate KEYWORD_ELSE statement .)
    KEYWORD_PROTECTED reduce using rule 137 (if_then_else_statement -> KEYWORD_IF LPAREN expression RPAREN if_then_else_intermediate KEYWORD_ELSE statement .)
    KEYWORD_PRIVATE reduce using rule 137 (if_then_else_statement -> KEYWORD_IF LPAREN expression RPAREN if_then_else_intermediate KEYWORD_ELSE statement .)
    IDENTIFIER      reduce using rule 137 (if_then_else_statement -> KEYWORD_IF LPAREN expression RPAREN if_then_else_intermediate KEYWORD_ELSE statement .)
    PLUS            reduce using rule 137 (if_then_else_statement -> KEYWORD_IF LPAREN expression RPAREN if_then_else_intermediate KEYWORD_ELSE statement .)
    MINUS           reduce using rule 137 (if_then_else_statement -> KEYWORD_IF LPAREN expression RPAREN if_then_else_intermediate KEYWORD_ELSE statement .)
    TILDA           reduce using rule 137 (if_then_else_statement -> KEYWORD_IF LPAREN expression RPAREN if_then_else_intermediate KEYWORD_ELSE statement .)
    NOT             reduce using rule 137 (if_then_else_statement -> KEYWORD_IF LPAREN expression RPAREN if_then_else_intermediate KEYWORD_ELSE statement .)
    LPAREN          reduce using rule 137 (if_then_else_statement -> KEYWORD_IF LPAREN expression RPAREN if_then_else_intermediate KEYWORD_ELSE statement .)
    DOUBLE_NUMBER   reduce using rule 137 (if_then_else_statement -> KEYWORD_IF LPAREN expression RPAREN if_then_else_intermediate KEYWORD_ELSE statement .)
    INT_NUMBER      reduce using rule 137 (if_then_else_statement -> KEYWORD_IF LPAREN expression RPAREN if_then_else_intermediate KEYWORD_ELSE statement .)
    CHAR            reduce using rule 137 (if_then_else_statement -> KEYWORD_IF LPAREN expression RPAREN if_then_else_intermediate KEYWORD_ELSE statement .)
    STRING          reduce using rule 137 (if_then_else_statement -> KEYWORD_IF LPAREN expression RPAREN if_then_else_intermediate KEYWORD_ELSE statement .)
    BOOL_CONSTT     reduce using rule 137 (if_then_else_statement -> KEYWORD_IF LPAREN expression RPAREN if_then_else_intermediate KEYWORD_ELSE statement .)
    BOOL_CONSTF     reduce using rule 137 (if_then_else_statement -> KEYWORD_IF LPAREN expression RPAREN if_then_else_intermediate KEYWORD_ELSE statement .)
    KEYWORD_NULL    reduce using rule 137 (if_then_else_statement -> KEYWORD_IF LPAREN expression RPAREN if_then_else_intermediate KEYWORD_ELSE statement .)
    KEYWORD_DEF     reduce using rule 137 (if_then_else_statement -> KEYWORD_IF LPAREN expression RPAREN if_then_else_intermediate KEYWORD_ELSE statement .)
    KEYWORD_CLASS   reduce using rule 137 (if_then_else_statement -> KEYWORD_IF LPAREN expression RPAREN if_then_else_intermediate KEYWORD_ELSE statement .)
    KEYWORD_VAR     reduce using rule 137 (if_then_else_statement -> KEYWORD_IF LPAREN expression RPAREN if_then_else_intermediate KEYWORD_ELSE statement .)
    KEYWORD_VAL     reduce using rule 137 (if_then_else_statement -> KEYWORD_IF LPAREN expression RPAREN if_then_else_intermediate KEYWORD_ELSE statement .)
    BLOCKEND        reduce using rule 137 (if_then_else_statement -> KEYWORD_IF LPAREN expression RPAREN if_then_else_intermediate KEYWORD_ELSE statement .)
    KEYWORD_CASE    reduce using rule 137 (if_then_else_statement -> KEYWORD_IF LPAREN expression RPAREN if_then_else_intermediate KEYWORD_ELSE statement .)


state 304

    (136) if_then_statement -> KEYWORD_IF LPAREN expression . RPAREN statement
    (137) if_then_else_statement -> KEYWORD_IF LPAREN expression . RPAREN if_then_else_intermediate KEYWORD_ELSE statement
    (138) if_then_else_statement_precedence -> KEYWORD_IF LPAREN expression . RPAREN if_then_else_intermediate KEYWORD_ELSE if_then_else_intermediate

    RPAREN          shift and go to state 313


state 305

    (119) array_initializer -> KEYWORD_NEW KEYWORD_ARRAY LBRAC . type RBRAC LPAREN INT_NUMBER RPAREN
    (104) type -> . primitive_type
    (105) type -> . reference_type
    (106) primitive_type -> . TYPE_INT
    (107) primitive_type -> . TYPE_DOUBLE
    (108) primitive_type -> . TYPE_CHAR
    (109) primitive_type -> . TYPE_STRING
    (110) primitive_type -> . TYPE_BOOLEAN
    (111) reference_type -> . class_data_type
    (112) reference_type -> . array_data_type
    (113) class_data_type -> . name
    (114) array_data_type -> . KEYWORD_ARRAY LBRAC type RBRAC
    (115) name -> . simple_name
    (116) name -> . qualified_name
    (117) simple_name -> . IDENTIFIER
    (118) qualified_name -> . name INST simple_name

    TYPE_INT        shift and go to state 154
    TYPE_DOUBLE     shift and go to state 159
    TYPE_CHAR       shift and go to state 156
    TYPE_STRING     shift and go to state 155
    TYPE_BOOLEAN    shift and go to state 158
    KEYWORD_ARRAY   shift and go to state 248
    IDENTIFIER      shift and go to state 77

    name                           shift and go to state 246
    qualified_name                 shift and go to state 79
    reference_type                 shift and go to state 247
    primitive_type                 shift and go to state 249
    class_data_type                shift and go to state 250
    type                           shift and go to state 314
    array_data_type                shift and go to state 252
    simple_name                    shift and go to state 67

state 306

    (121) class_initializer -> KEYWORD_NEW name LPAREN . argument_list_opt RPAREN
    (80) argument_list_opt -> . argument_list
    (81) argument_list_opt -> . empty
    (82) argument_list -> . expression
    (83) argument_list -> . argument_list COMMA expression
    (186) empty -> .
    (18) expression -> . assignment_expression
    (21) assignment_expression -> . assignment
    (22) assignment_expression -> . conditional_or_expression
    (23) assignment -> . valid_variable assignment_operator assignment_expression
    (28) conditional_or_expression -> . conditional_and_expression
    (29) conditional_or_expression -> . conditional_or_expression OR conditional_and_expression
    (24) valid_variable -> . name
    (25) valid_variable -> . array_access
    (30) conditional_and_expression -> . inclusive_or_expression
    (31) conditional_and_expression -> . conditional_and_expression AND inclusive_or_expression
    (115) name -> . simple_name
    (116) name -> . qualified_name
    (26) array_access -> . name LBRAC expression RBRAC
    (32) inclusive_or_expression -> . exclusive_or_expression
    (33) inclusive_or_expression -> . inclusive_or_expression OR_BITWISE exclusive_or_expression
    (117) simple_name -> . IDENTIFIER
    (118) qualified_name -> . name INST simple_name
    (34) exclusive_or_expression -> . and_expression
    (35) exclusive_or_expression -> . exclusive_or_expression XOR and_expression
    (36) and_expression -> . equality_expression
    (37) and_expression -> . and_expression AND_BITWISE equality_expression
    (38) equality_expression -> . relational_expression
    (39) equality_expression -> . equality_expression EQUAL relational_expression
    (40) equality_expression -> . equality_expression NEQUAL relational_expression
    (41) relational_expression -> . shift_expression
    (42) relational_expression -> . relational_expression GREATER shift_expression
    (43) relational_expression -> . relational_expression LESS shift_expression
    (44) relational_expression -> . relational_expression GEQ shift_expression
    (45) relational_expression -> . relational_expression LEQ shift_expression
    (46) shift_expression -> . additive_expression
    (47) shift_expression -> . shift_expression LSHIFT additive_expression
    (48) shift_expression -> . shift_expression RSHIFT additive_expression
    (49) additive_expression -> . multiplicative_expression
    (50) additive_expression -> . additive_expression PLUS multiplicative_expression
    (51) additive_expression -> . additive_expression MINUS multiplicative_expression
    (52) multiplicative_expression -> . unary_expression
    (53) multiplicative_expression -> . multiplicative_expression TIMES unary_expression
    (54) multiplicative_expression -> . multiplicative_expression DIVIDE unary_expression
    (55) multiplicative_expression -> . multiplicative_expression REMAINDER unary_expression
    (56) unary_expression -> . PLUS unary_expression
    (57) unary_expression -> . MINUS unary_expression
    (58) unary_expression -> . unary_expression_not_plus_minus
    (59) unary_expression_not_plus_minus -> . base_variable_set
    (60) unary_expression_not_plus_minus -> . TILDA unary_expression
    (61) unary_expression_not_plus_minus -> . NOT unary_expression
    (62) unary_expression_not_plus_minus -> . cast_expression
    (63) base_variable_set -> . variable_literal
    (64) base_variable_set -> . LPAREN expression RPAREN
    (67) cast_expression -> . LPAREN primitive_type RPAREN unary_expression
    (65) variable_literal -> . valid_variable
    (66) variable_literal -> . primary
    (68) primary -> . literal
    (69) primary -> . method_invocation
    (70) literal -> . int_float
    (71) literal -> . c_literal
    (79) method_invocation -> . name LPAREN argument_list_opt RPAREN
    (77) int_float -> . DOUBLE_NUMBER
    (78) int_float -> . INT_NUMBER
    (72) c_literal -> . CHAR
    (73) c_literal -> . STRING
    (74) c_literal -> . BOOL_CONSTT
    (75) c_literal -> . BOOL_CONSTF
    (76) c_literal -> . KEYWORD_NULL

    RPAREN          reduce using rule 186 (empty -> .)
    IDENTIFIER      shift and go to state 77
    PLUS            shift and go to state 36
    MINUS           shift and go to state 29
    TILDA           shift and go to state 72
    NOT             shift and go to state 57
    LPAREN          shift and go to state 94
    DOUBLE_NUMBER   shift and go to state 33
    INT_NUMBER      shift and go to state 44
    CHAR            shift and go to state 63
    STRING          shift and go to state 76
    BOOL_CONSTT     shift and go to state 35
    BOOL_CONSTF     shift and go to state 30
    KEYWORD_NULL    shift and go to state 65

    and_expression                 shift and go to state 87
    exclusive_or_expression        shift and go to state 61
    primary                        shift and go to state 62
    unary_expression_not_plus_minus shift and go to state 46
    array_access                   shift and go to state 28
    additive_expression            shift and go to state 66
    simple_name                    shift and go to state 67
    c_literal                      shift and go to state 93
    unary_expression               shift and go to state 45
    base_variable_set              shift and go to state 88
    valid_variable                 shift and go to state 48
    inclusive_or_expression        shift and go to state 32
    literal                        shift and go to state 71
    relational_expression          shift and go to state 73
    cast_expression                shift and go to state 80
    conditional_or_expression      shift and go to state 49
    empty                          shift and go to state 180
    argument_list                  shift and go to state 179
    assignment_expression          shift and go to state 91
    qualified_name                 shift and go to state 79
    assignment                     shift and go to state 138
    multiplicative_expression      shift and go to state 52
    method_invocation              shift and go to state 111
    shift_expression               shift and go to state 54
    equality_expression            shift and go to state 82
    int_float                      shift and go to state 40
    variable_literal               shift and go to state 55
    name                           shift and go to state 139
    argument_list_opt              shift and go to state 315
    expression                     shift and go to state 182
    conditional_and_expression     shift and go to state 56

state 307

    (120) array_initializer -> KEYWORD_ARRAY LPAREN argument_list_opt . RPAREN

    RPAREN          shift and go to state 316


state 308

    (98) variable_declaration_body -> LPAREN variable_declarators RPAREN ASOP LPAREN . variable_arguement_list RPAREN
    (95) variable_arguement_list -> . variable_declaration_initializer
    (96) variable_arguement_list -> . variable_arguement_list COMMA variable_declaration_initializer
    (92) variable_declaration_initializer -> . expression
    (93) variable_declaration_initializer -> . array_initializer
    (94) variable_declaration_initializer -> . class_initializer
    (18) expression -> . assignment_expression
    (119) array_initializer -> . KEYWORD_NEW KEYWORD_ARRAY LBRAC type RBRAC LPAREN INT_NUMBER RPAREN
    (120) array_initializer -> . KEYWORD_ARRAY LPAREN argument_list_opt RPAREN
    (121) class_initializer -> . KEYWORD_NEW name LPAREN argument_list_opt RPAREN
    (21) assignment_expression -> . assignment
    (22) assignment_expression -> . conditional_or_expression
    (23) assignment -> . valid_variable assignment_operator assignment_expression
    (28) conditional_or_expression -> . conditional_and_expression
    (29) conditional_or_expression -> . conditional_or_expression OR conditional_and_expression
    (24) valid_variable -> . name
    (25) valid_variable -> . array_access
    (30) conditional_and_expression -> . inclusive_or_expression
    (31) conditional_and_expression -> . conditional_and_expression AND inclusive_or_expression
    (115) name -> . simple_name
    (116) name -> . qualified_name
    (26) array_access -> . name LBRAC expression RBRAC
    (32) inclusive_or_expression -> . exclusive_or_expression
    (33) inclusive_or_expression -> . inclusive_or_expression OR_BITWISE exclusive_or_expression
    (117) simple_name -> . IDENTIFIER
    (118) qualified_name -> . name INST simple_name
    (34) exclusive_or_expression -> . and_expression
    (35) exclusive_or_expression -> . exclusive_or_expression XOR and_expression
    (36) and_expression -> . equality_expression
    (37) and_expression -> . and_expression AND_BITWISE equality_expression
    (38) equality_expression -> . relational_expression
    (39) equality_expression -> . equality_expression EQUAL relational_expression
    (40) equality_expression -> . equality_expression NEQUAL relational_expression
    (41) relational_expression -> . shift_expression
    (42) relational_expression -> . relational_expression GREATER shift_expression
    (43) relational_expression -> . relational_expression LESS shift_expression
    (44) relational_expression -> . relational_expression GEQ shift_expression
    (45) relational_expression -> . relational_expression LEQ shift_expression
    (46) shift_expression -> . additive_expression
    (47) shift_expression -> . shift_expression LSHIFT additive_expression
    (48) shift_expression -> . shift_expression RSHIFT additive_expression
    (49) additive_expression -> . multiplicative_expression
    (50) additive_expression -> . additive_expression PLUS multiplicative_expression
    (51) additive_expression -> . additive_expression MINUS multiplicative_expression
    (52) multiplicative_expression -> . unary_expression
    (53) multiplicative_expression -> . multiplicative_expression TIMES unary_expression
    (54) multiplicative_expression -> . multiplicative_expression DIVIDE unary_expression
    (55) multiplicative_expression -> . multiplicative_expression REMAINDER unary_expression
    (56) unary_expression -> . PLUS unary_expression
    (57) unary_expression -> . MINUS unary_expression
    (58) unary_expression -> . unary_expression_not_plus_minus
    (59) unary_expression_not_plus_minus -> . base_variable_set
    (60) unary_expression_not_plus_minus -> . TILDA unary_expression
    (61) unary_expression_not_plus_minus -> . NOT unary_expression
    (62) unary_expression_not_plus_minus -> . cast_expression
    (63) base_variable_set -> . variable_literal
    (64) base_variable_set -> . LPAREN expression RPAREN
    (67) cast_expression -> . LPAREN primitive_type RPAREN unary_expression
    (65) variable_literal -> . valid_variable
    (66) variable_literal -> . primary
    (68) primary -> . literal
    (69) primary -> . method_invocation
    (70) literal -> . int_float
    (71) literal -> . c_literal
    (79) method_invocation -> . name LPAREN argument_list_opt RPAREN
    (77) int_float -> . DOUBLE_NUMBER
    (78) int_float -> . INT_NUMBER
    (72) c_literal -> . CHAR
    (73) c_literal -> . STRING
    (74) c_literal -> . BOOL_CONSTT
    (75) c_literal -> . BOOL_CONSTF
    (76) c_literal -> . KEYWORD_NULL

    KEYWORD_NEW     shift and go to state 273
    KEYWORD_ARRAY   shift and go to state 275
    IDENTIFIER      shift and go to state 77
    PLUS            shift and go to state 36
    MINUS           shift and go to state 29
    TILDA           shift and go to state 72
    NOT             shift and go to state 57
    LPAREN          shift and go to state 94
    DOUBLE_NUMBER   shift and go to state 33
    INT_NUMBER      shift and go to state 44
    CHAR            shift and go to state 63
    STRING          shift and go to state 76
    BOOL_CONSTT     shift and go to state 35
    BOOL_CONSTF     shift and go to state 30
    KEYWORD_NULL    shift and go to state 65

    variable_declaration_initializer shift and go to state 317
    unary_expression               shift and go to state 45
    exclusive_or_expression        shift and go to state 61
    primary                        shift and go to state 62
    unary_expression_not_plus_minus shift and go to state 46
    variable_arguement_list        shift and go to state 318
    array_access                   shift and go to state 28
    and_expression                 shift and go to state 87
    simple_name                    shift and go to state 67
    c_literal                      shift and go to state 93
    base_variable_set              shift and go to state 88
    valid_variable                 shift and go to state 48
    inclusive_or_expression        shift and go to state 32
    literal                        shift and go to state 71
    relational_expression          shift and go to state 73
    cast_expression                shift and go to state 80
    conditional_or_expression      shift and go to state 49
    assignment_expression          shift and go to state 91
    qualified_name                 shift and go to state 79
    assignment                     shift and go to state 138
    multiplicative_expression      shift and go to state 52
    additive_expression            shift and go to state 66
    method_invocation              shift and go to state 111
    class_initializer              shift and go to state 274
    shift_expression               shift and go to state 54
    equality_expression            shift and go to state 82
    array_initializer              shift and go to state 272
    int_float                      shift and go to state 40
    variable_literal               shift and go to state 55
    name                           shift and go to state 139
    expression                     shift and go to state 276
    conditional_and_expression     shift and go to state 56

state 309

    (99) variable_declaration_body -> IDENTIFIER ASOP LPAREN func_arguement_list_opt RPAREN . FUNTYPE expression

    FUNTYPE         shift and go to state 319


state 310

    (147) for_loop -> IDENTIFIER CHOOSE expression for_untilTo expression .

    KEYWORD_BY      reduce using rule 147 (for_loop -> IDENTIFIER CHOOSE expression for_untilTo expression .)
    TERMINATOR      reduce using rule 147 (for_loop -> IDENTIFIER CHOOSE expression for_untilTo expression .)
    RPAREN          reduce using rule 147 (for_loop -> IDENTIFIER CHOOSE expression for_untilTo expression .)


state 311

    (142) do_while_statement -> KEYWORD_DO statement KEYWORD_WHILE LPAREN expression RPAREN TERMINATOR .

    KEYWORD_IF      reduce using rule 142 (do_while_statement -> KEYWORD_DO statement KEYWORD_WHILE LPAREN expression RPAREN TERMINATOR .)
    KEYWORD_WHILE   reduce using rule 142 (do_while_statement -> KEYWORD_DO statement KEYWORD_WHILE LPAREN expression RPAREN TERMINATOR .)
    KEYWORD_DO      reduce using rule 142 (do_while_statement -> KEYWORD_DO statement KEYWORD_WHILE LPAREN expression RPAREN TERMINATOR .)
    KEYWORD_FOR     reduce using rule 142 (do_while_statement -> KEYWORD_DO statement KEYWORD_WHILE LPAREN expression RPAREN TERMINATOR .)
    KEYWORD_OBJECT  reduce using rule 142 (do_while_statement -> KEYWORD_DO statement KEYWORD_WHILE LPAREN expression RPAREN TERMINATOR .)
    BLOCKBEGIN      reduce using rule 142 (do_while_statement -> KEYWORD_DO statement KEYWORD_WHILE LPAREN expression RPAREN TERMINATOR .)
    TERMINATOR      reduce using rule 142 (do_while_statement -> KEYWORD_DO statement KEYWORD_WHILE LPAREN expression RPAREN TERMINATOR .)
    KEYWORD_RETURN  reduce using rule 142 (do_while_statement -> KEYWORD_DO statement KEYWORD_WHILE LPAREN expression RPAREN TERMINATOR .)
    KEYWORD_PROTECTED reduce using rule 142 (do_while_statement -> KEYWORD_DO statement KEYWORD_WHILE LPAREN expression RPAREN TERMINATOR .)
    KEYWORD_PRIVATE reduce using rule 142 (do_while_statement -> KEYWORD_DO statement KEYWORD_WHILE LPAREN expression RPAREN TERMINATOR .)
    IDENTIFIER      reduce using rule 142 (do_while_statement -> KEYWORD_DO statement KEYWORD_WHILE LPAREN expression RPAREN TERMINATOR .)
    PLUS            reduce using rule 142 (do_while_statement -> KEYWORD_DO statement KEYWORD_WHILE LPAREN expression RPAREN TERMINATOR .)
    MINUS           reduce using rule 142 (do_while_statement -> KEYWORD_DO statement KEYWORD_WHILE LPAREN expression RPAREN TERMINATOR .)
    TILDA           reduce using rule 142 (do_while_statement -> KEYWORD_DO statement KEYWORD_WHILE LPAREN expression RPAREN TERMINATOR .)
    NOT             reduce using rule 142 (do_while_statement -> KEYWORD_DO statement KEYWORD_WHILE LPAREN expression RPAREN TERMINATOR .)
    LPAREN          reduce using rule 142 (do_while_statement -> KEYWORD_DO statement KEYWORD_WHILE LPAREN expression RPAREN TERMINATOR .)
    DOUBLE_NUMBER   reduce using rule 142 (do_while_statement -> KEYWORD_DO statement KEYWORD_WHILE LPAREN expression RPAREN TERMINATOR .)
    INT_NUMBER      reduce using rule 142 (do_while_statement -> KEYWORD_DO statement KEYWORD_WHILE LPAREN expression RPAREN TERMINATOR .)
    CHAR            reduce using rule 142 (do_while_statement -> KEYWORD_DO statement KEYWORD_WHILE LPAREN expression RPAREN TERMINATOR .)
    STRING          reduce using rule 142 (do_while_statement -> KEYWORD_DO statement KEYWORD_WHILE LPAREN expression RPAREN TERMINATOR .)
    BOOL_CONSTT     reduce using rule 142 (do_while_statement -> KEYWORD_DO statement KEYWORD_WHILE LPAREN expression RPAREN TERMINATOR .)
    BOOL_CONSTF     reduce using rule 142 (do_while_statement -> KEYWORD_DO statement KEYWORD_WHILE LPAREN expression RPAREN TERMINATOR .)
    KEYWORD_NULL    reduce using rule 142 (do_while_statement -> KEYWORD_DO statement KEYWORD_WHILE LPAREN expression RPAREN TERMINATOR .)
    KEYWORD_DEF     reduce using rule 142 (do_while_statement -> KEYWORD_DO statement KEYWORD_WHILE LPAREN expression RPAREN TERMINATOR .)
    KEYWORD_CLASS   reduce using rule 142 (do_while_statement -> KEYWORD_DO statement KEYWORD_WHILE LPAREN expression RPAREN TERMINATOR .)
    KEYWORD_VAR     reduce using rule 142 (do_while_statement -> KEYWORD_DO statement KEYWORD_WHILE LPAREN expression RPAREN TERMINATOR .)
    KEYWORD_VAL     reduce using rule 142 (do_while_statement -> KEYWORD_DO statement KEYWORD_WHILE LPAREN expression RPAREN TERMINATOR .)
    BLOCKEND        reduce using rule 142 (do_while_statement -> KEYWORD_DO statement KEYWORD_WHILE LPAREN expression RPAREN TERMINATOR .)
    KEYWORD_CASE    reduce using rule 142 (do_while_statement -> KEYWORD_DO statement KEYWORD_WHILE LPAREN expression RPAREN TERMINATOR .)


state 312

    (114) array_data_type -> KEYWORD_ARRAY LBRAC type RBRAC .

    RBRAC           reduce using rule 114 (array_data_type -> KEYWORD_ARRAY LBRAC type RBRAC .)
    COMMA           reduce using rule 114 (array_data_type -> KEYWORD_ARRAY LBRAC type RBRAC .)
    RPAREN          reduce using rule 114 (array_data_type -> KEYWORD_ARRAY LBRAC type RBRAC .)
    ASOP            reduce using rule 114 (array_data_type -> KEYWORD_ARRAY LBRAC type RBRAC .)


state 313

    (136) if_then_statement -> KEYWORD_IF LPAREN expression RPAREN . statement
    (137) if_then_else_statement -> KEYWORD_IF LPAREN expression RPAREN . if_then_else_intermediate KEYWORD_ELSE statement
    (138) if_then_else_statement_precedence -> KEYWORD_IF LPAREN expression RPAREN . if_then_else_intermediate KEYWORD_ELSE if_then_else_intermediate
    (122) statement -> . normal_statement
    (123) statement -> . if_then_statement
    (124) statement -> . if_then_else_statement
    (125) statement -> . while_statement
    (126) statement -> . do_while_statement
    (127) statement -> . for_statement
    (139) if_then_else_intermediate -> . normal_statement
    (140) if_then_else_intermediate -> . if_then_else_statement_precedence
    (128) normal_statement -> . block
    (129) normal_statement -> . expression_statement
    (130) normal_statement -> . empty_statement
    (131) normal_statement -> . return_statement
    (132) normal_statement -> . switch_statement
    (136) if_then_statement -> . KEYWORD_IF LPAREN expression RPAREN statement
    (137) if_then_else_statement -> . KEYWORD_IF LPAREN expression RPAREN if_then_else_intermediate KEYWORD_ELSE statement
    (141) while_statement -> . KEYWORD_WHILE LPAREN expression RPAREN statement
    (142) do_while_statement -> . KEYWORD_DO statement KEYWORD_WHILE LPAREN expression RPAREN TERMINATOR
    (143) for_statement -> . KEYWORD_FOR LPAREN for_logic RPAREN statement
    (138) if_then_else_statement_precedence -> . KEYWORD_IF LPAREN expression RPAREN if_then_else_intermediate KEYWORD_ELSE if_then_else_intermediate
    (8) block -> . BLOCKBEGIN block_statements_opt BLOCKEND
    (133) expression_statement -> . statement_expression TERMINATOR
    (163) empty_statement -> . TERMINATOR
    (164) return_statement -> . KEYWORD_RETURN expression_optional TERMINATOR
    (152) switch_statement -> . expression KEYWORD_MATCH switch_block
    (134) statement_expression -> . assignment
    (135) statement_expression -> . method_invocation
    (18) expression -> . assignment_expression
    (23) assignment -> . valid_variable assignment_operator assignment_expression
    (79) method_invocation -> . name LPAREN argument_list_opt RPAREN
    (21) assignment_expression -> . assignment
    (22) assignment_expression -> . conditional_or_expression
    (24) valid_variable -> . name
    (25) valid_variable -> . array_access
    (115) name -> . simple_name
    (116) name -> . qualified_name
    (28) conditional_or_expression -> . conditional_and_expression
    (29) conditional_or_expression -> . conditional_or_expression OR conditional_and_expression
    (26) array_access -> . name LBRAC expression RBRAC
    (117) simple_name -> . IDENTIFIER
    (118) qualified_name -> . name INST simple_name
    (30) conditional_and_expression -> . inclusive_or_expression
    (31) conditional_and_expression -> . conditional_and_expression AND inclusive_or_expression
    (32) inclusive_or_expression -> . exclusive_or_expression
    (33) inclusive_or_expression -> . inclusive_or_expression OR_BITWISE exclusive_or_expression
    (34) exclusive_or_expression -> . and_expression
    (35) exclusive_or_expression -> . exclusive_or_expression XOR and_expression
    (36) and_expression -> . equality_expression
    (37) and_expression -> . and_expression AND_BITWISE equality_expression
    (38) equality_expression -> . relational_expression
    (39) equality_expression -> . equality_expression EQUAL relational_expression
    (40) equality_expression -> . equality_expression NEQUAL relational_expression
    (41) relational_expression -> . shift_expression
    (42) relational_expression -> . relational_expression GREATER shift_expression
    (43) relational_expression -> . relational_expression LESS shift_expression
    (44) relational_expression -> . relational_expression GEQ shift_expression
    (45) relational_expression -> . relational_expression LEQ shift_expression
    (46) shift_expression -> . additive_expression
    (47) shift_expression -> . shift_expression LSHIFT additive_expression
    (48) shift_expression -> . shift_expression RSHIFT additive_expression
    (49) additive_expression -> . multiplicative_expression
    (50) additive_expression -> . additive_expression PLUS multiplicative_expression
    (51) additive_expression -> . additive_expression MINUS multiplicative_expression
    (52) multiplicative_expression -> . unary_expression
    (53) multiplicative_expression -> . multiplicative_expression TIMES unary_expression
    (54) multiplicative_expression -> . multiplicative_expression DIVIDE unary_expression
    (55) multiplicative_expression -> . multiplicative_expression REMAINDER unary_expression
    (56) unary_expression -> . PLUS unary_expression
    (57) unary_expression -> . MINUS unary_expression
    (58) unary_expression -> . unary_expression_not_plus_minus
    (59) unary_expression_not_plus_minus -> . base_variable_set
    (60) unary_expression_not_plus_minus -> . TILDA unary_expression
    (61) unary_expression_not_plus_minus -> . NOT unary_expression
    (62) unary_expression_not_plus_minus -> . cast_expression
    (63) base_variable_set -> . variable_literal
    (64) base_variable_set -> . LPAREN expression RPAREN
    (67) cast_expression -> . LPAREN primitive_type RPAREN unary_expression
    (65) variable_literal -> . valid_variable
    (66) variable_literal -> . primary
    (68) primary -> . literal
    (69) primary -> . method_invocation
    (70) literal -> . int_float
    (71) literal -> . c_literal
    (77) int_float -> . DOUBLE_NUMBER
    (78) int_float -> . INT_NUMBER
    (72) c_literal -> . CHAR
    (73) c_literal -> . STRING
    (74) c_literal -> . BOOL_CONSTT
    (75) c_literal -> . BOOL_CONSTF
    (76) c_literal -> . KEYWORD_NULL

    KEYWORD_IF      shift and go to state 268
    KEYWORD_WHILE   shift and go to state 50
    KEYWORD_DO      shift and go to state 98
    KEYWORD_FOR     shift and go to state 97
    BLOCKBEGIN      shift and go to state 15
    TERMINATOR      shift and go to state 53
    KEYWORD_RETURN  shift and go to state 68
    IDENTIFIER      shift and go to state 77
    PLUS            shift and go to state 36
    MINUS           shift and go to state 29
    TILDA           shift and go to state 72
    NOT             shift and go to state 57
    LPAREN          shift and go to state 94
    DOUBLE_NUMBER   shift and go to state 33
    INT_NUMBER      shift and go to state 44
    CHAR            shift and go to state 63
    STRING          shift and go to state 76
    BOOL_CONSTT     shift and go to state 35
    BOOL_CONSTF     shift and go to state 30
    KEYWORD_NULL    shift and go to state 65

    expression_statement           shift and go to state 27
    if_then_else_statement_precedence shift and go to state 269
    unary_expression               shift and go to state 45
    exclusive_or_expression        shift and go to state 61
    normal_statement               shift and go to state 270
    primary                        shift and go to state 62
    unary_expression_not_plus_minus shift and go to state 46
    if_then_else_intermediate      shift and go to state 320
    if_then_statement              shift and go to state 64
    array_access                   shift and go to state 28
    switch_statement               shift and go to state 47
    assignment_expression          shift and go to state 91
    qualified_name                 shift and go to state 79
    base_variable_set              shift and go to state 88
    valid_variable                 shift and go to state 48
    inclusive_or_expression        shift and go to state 32
    literal                        shift and go to state 71
    return_statement               shift and go to state 89
    while_statement                shift and go to state 34
    and_expression                 shift and go to state 87
    statement                      shift and go to state 267
    statement_expression           shift and go to state 37
    method_invocation              shift and go to state 75
    simple_name                    shift and go to state 67
    conditional_or_expression      shift and go to state 49
    relational_expression          shift and go to state 73
    for_statement                  shift and go to state 38
    do_while_statement             shift and go to state 51
    assignment                     shift and go to state 92
    multiplicative_expression      shift and go to state 52
    c_literal                      shift and go to state 93
    additive_expression            shift and go to state 66
    cast_expression                shift and go to state 80
    shift_expression               shift and go to state 54
    equality_expression            shift and go to state 82
    int_float                      shift and go to state 40
    variable_literal               shift and go to state 55
    name                           shift and go to state 43
    empty_statement                shift and go to state 84
    expression                     shift and go to state 58
    conditional_and_expression     shift and go to state 56
    block                          shift and go to state 59
    if_then_else_statement         shift and go to state 60

state 314

    (119) array_initializer -> KEYWORD_NEW KEYWORD_ARRAY LBRAC type . RBRAC LPAREN INT_NUMBER RPAREN

    RBRAC           shift and go to state 321


state 315

    (121) class_initializer -> KEYWORD_NEW name LPAREN argument_list_opt . RPAREN

    RPAREN          shift and go to state 322


state 316

    (120) array_initializer -> KEYWORD_ARRAY LPAREN argument_list_opt RPAREN .

    RPAREN          reduce using rule 120 (array_initializer -> KEYWORD_ARRAY LPAREN argument_list_opt RPAREN .)
    COMMA           reduce using rule 120 (array_initializer -> KEYWORD_ARRAY LPAREN argument_list_opt RPAREN .)
    TERMINATOR      reduce using rule 120 (array_initializer -> KEYWORD_ARRAY LPAREN argument_list_opt RPAREN .)


state 317

    (95) variable_arguement_list -> variable_declaration_initializer .

    RPAREN          reduce using rule 95 (variable_arguement_list -> variable_declaration_initializer .)
    COMMA           reduce using rule 95 (variable_arguement_list -> variable_declaration_initializer .)


state 318

    (98) variable_declaration_body -> LPAREN variable_declarators RPAREN ASOP LPAREN variable_arguement_list . RPAREN
    (96) variable_arguement_list -> variable_arguement_list . COMMA variable_declaration_initializer

    RPAREN          shift and go to state 323
    COMMA           shift and go to state 324


state 319

    (99) variable_declaration_body -> IDENTIFIER ASOP LPAREN func_arguement_list_opt RPAREN FUNTYPE . expression
    (18) expression -> . assignment_expression
    (21) assignment_expression -> . assignment
    (22) assignment_expression -> . conditional_or_expression
    (23) assignment -> . valid_variable assignment_operator assignment_expression
    (28) conditional_or_expression -> . conditional_and_expression
    (29) conditional_or_expression -> . conditional_or_expression OR conditional_and_expression
    (24) valid_variable -> . name
    (25) valid_variable -> . array_access
    (30) conditional_and_expression -> . inclusive_or_expression
    (31) conditional_and_expression -> . conditional_and_expression AND inclusive_or_expression
    (115) name -> . simple_name
    (116) name -> . qualified_name
    (26) array_access -> . name LBRAC expression RBRAC
    (32) inclusive_or_expression -> . exclusive_or_expression
    (33) inclusive_or_expression -> . inclusive_or_expression OR_BITWISE exclusive_or_expression
    (117) simple_name -> . IDENTIFIER
    (118) qualified_name -> . name INST simple_name
    (34) exclusive_or_expression -> . and_expression
    (35) exclusive_or_expression -> . exclusive_or_expression XOR and_expression
    (36) and_expression -> . equality_expression
    (37) and_expression -> . and_expression AND_BITWISE equality_expression
    (38) equality_expression -> . relational_expression
    (39) equality_expression -> . equality_expression EQUAL relational_expression
    (40) equality_expression -> . equality_expression NEQUAL relational_expression
    (41) relational_expression -> . shift_expression
    (42) relational_expression -> . relational_expression GREATER shift_expression
    (43) relational_expression -> . relational_expression LESS shift_expression
    (44) relational_expression -> . relational_expression GEQ shift_expression
    (45) relational_expression -> . relational_expression LEQ shift_expression
    (46) shift_expression -> . additive_expression
    (47) shift_expression -> . shift_expression LSHIFT additive_expression
    (48) shift_expression -> . shift_expression RSHIFT additive_expression
    (49) additive_expression -> . multiplicative_expression
    (50) additive_expression -> . additive_expression PLUS multiplicative_expression
    (51) additive_expression -> . additive_expression MINUS multiplicative_expression
    (52) multiplicative_expression -> . unary_expression
    (53) multiplicative_expression -> . multiplicative_expression TIMES unary_expression
    (54) multiplicative_expression -> . multiplicative_expression DIVIDE unary_expression
    (55) multiplicative_expression -> . multiplicative_expression REMAINDER unary_expression
    (56) unary_expression -> . PLUS unary_expression
    (57) unary_expression -> . MINUS unary_expression
    (58) unary_expression -> . unary_expression_not_plus_minus
    (59) unary_expression_not_plus_minus -> . base_variable_set
    (60) unary_expression_not_plus_minus -> . TILDA unary_expression
    (61) unary_expression_not_plus_minus -> . NOT unary_expression
    (62) unary_expression_not_plus_minus -> . cast_expression
    (63) base_variable_set -> . variable_literal
    (64) base_variable_set -> . LPAREN expression RPAREN
    (67) cast_expression -> . LPAREN primitive_type RPAREN unary_expression
    (65) variable_literal -> . valid_variable
    (66) variable_literal -> . primary
    (68) primary -> . literal
    (69) primary -> . method_invocation
    (70) literal -> . int_float
    (71) literal -> . c_literal
    (79) method_invocation -> . name LPAREN argument_list_opt RPAREN
    (77) int_float -> . DOUBLE_NUMBER
    (78) int_float -> . INT_NUMBER
    (72) c_literal -> . CHAR
    (73) c_literal -> . STRING
    (74) c_literal -> . BOOL_CONSTT
    (75) c_literal -> . BOOL_CONSTF
    (76) c_literal -> . KEYWORD_NULL

    IDENTIFIER      shift and go to state 77
    PLUS            shift and go to state 36
    MINUS           shift and go to state 29
    TILDA           shift and go to state 72
    NOT             shift and go to state 57
    LPAREN          shift and go to state 94
    DOUBLE_NUMBER   shift and go to state 33
    INT_NUMBER      shift and go to state 44
    CHAR            shift and go to state 63
    STRING          shift and go to state 76
    BOOL_CONSTT     shift and go to state 35
    BOOL_CONSTF     shift and go to state 30
    KEYWORD_NULL    shift and go to state 65

    unary_expression               shift and go to state 45
    exclusive_or_expression        shift and go to state 61
    primary                        shift and go to state 62
    unary_expression_not_plus_minus shift and go to state 46
    array_access                   shift and go to state 28
    additive_expression            shift and go to state 66
    simple_name                    shift and go to state 67
    c_literal                      shift and go to state 93
    base_variable_set              shift and go to state 88
    valid_variable                 shift and go to state 48
    inclusive_or_expression        shift and go to state 32
    literal                        shift and go to state 71
    and_expression                 shift and go to state 87
    relational_expression          shift and go to state 73
    cast_expression                shift and go to state 80
    conditional_or_expression      shift and go to state 49
    assignment_expression          shift and go to state 91
    qualified_name                 shift and go to state 79
    assignment                     shift and go to state 138
    multiplicative_expression      shift and go to state 52
    method_invocation              shift and go to state 111
    shift_expression               shift and go to state 54
    equality_expression            shift and go to state 82
    int_float                      shift and go to state 40
    variable_literal               shift and go to state 55
    name                           shift and go to state 139
    expression                     shift and go to state 325
    conditional_and_expression     shift and go to state 56

state 320

    (137) if_then_else_statement -> KEYWORD_IF LPAREN expression RPAREN if_then_else_intermediate . KEYWORD_ELSE statement
    (138) if_then_else_statement_precedence -> KEYWORD_IF LPAREN expression RPAREN if_then_else_intermediate . KEYWORD_ELSE if_then_else_intermediate

    KEYWORD_ELSE    shift and go to state 326


state 321

    (119) array_initializer -> KEYWORD_NEW KEYWORD_ARRAY LBRAC type RBRAC . LPAREN INT_NUMBER RPAREN

    LPAREN          shift and go to state 327


state 322

    (121) class_initializer -> KEYWORD_NEW name LPAREN argument_list_opt RPAREN .

    TERMINATOR      reduce using rule 121 (class_initializer -> KEYWORD_NEW name LPAREN argument_list_opt RPAREN .)
    RPAREN          reduce using rule 121 (class_initializer -> KEYWORD_NEW name LPAREN argument_list_opt RPAREN .)
    COMMA           reduce using rule 121 (class_initializer -> KEYWORD_NEW name LPAREN argument_list_opt RPAREN .)


state 323

    (98) variable_declaration_body -> LPAREN variable_declarators RPAREN ASOP LPAREN variable_arguement_list RPAREN .

    TERMINATOR      reduce using rule 98 (variable_declaration_body -> LPAREN variable_declarators RPAREN ASOP LPAREN variable_arguement_list RPAREN .)


state 324

    (96) variable_arguement_list -> variable_arguement_list COMMA . variable_declaration_initializer
    (92) variable_declaration_initializer -> . expression
    (93) variable_declaration_initializer -> . array_initializer
    (94) variable_declaration_initializer -> . class_initializer
    (18) expression -> . assignment_expression
    (119) array_initializer -> . KEYWORD_NEW KEYWORD_ARRAY LBRAC type RBRAC LPAREN INT_NUMBER RPAREN
    (120) array_initializer -> . KEYWORD_ARRAY LPAREN argument_list_opt RPAREN
    (121) class_initializer -> . KEYWORD_NEW name LPAREN argument_list_opt RPAREN
    (21) assignment_expression -> . assignment
    (22) assignment_expression -> . conditional_or_expression
    (23) assignment -> . valid_variable assignment_operator assignment_expression
    (28) conditional_or_expression -> . conditional_and_expression
    (29) conditional_or_expression -> . conditional_or_expression OR conditional_and_expression
    (24) valid_variable -> . name
    (25) valid_variable -> . array_access
    (30) conditional_and_expression -> . inclusive_or_expression
    (31) conditional_and_expression -> . conditional_and_expression AND inclusive_or_expression
    (115) name -> . simple_name
    (116) name -> . qualified_name
    (26) array_access -> . name LBRAC expression RBRAC
    (32) inclusive_or_expression -> . exclusive_or_expression
    (33) inclusive_or_expression -> . inclusive_or_expression OR_BITWISE exclusive_or_expression
    (117) simple_name -> . IDENTIFIER
    (118) qualified_name -> . name INST simple_name
    (34) exclusive_or_expression -> . and_expression
    (35) exclusive_or_expression -> . exclusive_or_expression XOR and_expression
    (36) and_expression -> . equality_expression
    (37) and_expression -> . and_expression AND_BITWISE equality_expression
    (38) equality_expression -> . relational_expression
    (39) equality_expression -> . equality_expression EQUAL relational_expression
    (40) equality_expression -> . equality_expression NEQUAL relational_expression
    (41) relational_expression -> . shift_expression
    (42) relational_expression -> . relational_expression GREATER shift_expression
    (43) relational_expression -> . relational_expression LESS shift_expression
    (44) relational_expression -> . relational_expression GEQ shift_expression
    (45) relational_expression -> . relational_expression LEQ shift_expression
    (46) shift_expression -> . additive_expression
    (47) shift_expression -> . shift_expression LSHIFT additive_expression
    (48) shift_expression -> . shift_expression RSHIFT additive_expression
    (49) additive_expression -> . multiplicative_expression
    (50) additive_expression -> . additive_expression PLUS multiplicative_expression
    (51) additive_expression -> . additive_expression MINUS multiplicative_expression
    (52) multiplicative_expression -> . unary_expression
    (53) multiplicative_expression -> . multiplicative_expression TIMES unary_expression
    (54) multiplicative_expression -> . multiplicative_expression DIVIDE unary_expression
    (55) multiplicative_expression -> . multiplicative_expression REMAINDER unary_expression
    (56) unary_expression -> . PLUS unary_expression
    (57) unary_expression -> . MINUS unary_expression
    (58) unary_expression -> . unary_expression_not_plus_minus
    (59) unary_expression_not_plus_minus -> . base_variable_set
    (60) unary_expression_not_plus_minus -> . TILDA unary_expression
    (61) unary_expression_not_plus_minus -> . NOT unary_expression
    (62) unary_expression_not_plus_minus -> . cast_expression
    (63) base_variable_set -> . variable_literal
    (64) base_variable_set -> . LPAREN expression RPAREN
    (67) cast_expression -> . LPAREN primitive_type RPAREN unary_expression
    (65) variable_literal -> . valid_variable
    (66) variable_literal -> . primary
    (68) primary -> . literal
    (69) primary -> . method_invocation
    (70) literal -> . int_float
    (71) literal -> . c_literal
    (79) method_invocation -> . name LPAREN argument_list_opt RPAREN
    (77) int_float -> . DOUBLE_NUMBER
    (78) int_float -> . INT_NUMBER
    (72) c_literal -> . CHAR
    (73) c_literal -> . STRING
    (74) c_literal -> . BOOL_CONSTT
    (75) c_literal -> . BOOL_CONSTF
    (76) c_literal -> . KEYWORD_NULL

    KEYWORD_NEW     shift and go to state 273
    KEYWORD_ARRAY   shift and go to state 275
    IDENTIFIER      shift and go to state 77
    PLUS            shift and go to state 36
    MINUS           shift and go to state 29
    TILDA           shift and go to state 72
    NOT             shift and go to state 57
    LPAREN          shift and go to state 94
    DOUBLE_NUMBER   shift and go to state 33
    INT_NUMBER      shift and go to state 44
    CHAR            shift and go to state 63
    STRING          shift and go to state 76
    BOOL_CONSTT     shift and go to state 35
    BOOL_CONSTF     shift and go to state 30
    KEYWORD_NULL    shift and go to state 65

    variable_declaration_initializer shift and go to state 328
    unary_expression               shift and go to state 45
    exclusive_or_expression        shift and go to state 61
    primary                        shift and go to state 62
    unary_expression_not_plus_minus shift and go to state 46
    array_access                   shift and go to state 28
    and_expression                 shift and go to state 87
    simple_name                    shift and go to state 67
    c_literal                      shift and go to state 93
    base_variable_set              shift and go to state 88
    valid_variable                 shift and go to state 48
    inclusive_or_expression        shift and go to state 32
    literal                        shift and go to state 71
    relational_expression          shift and go to state 73
    cast_expression                shift and go to state 80
    conditional_or_expression      shift and go to state 49
    assignment_expression          shift and go to state 91
    qualified_name                 shift and go to state 79
    assignment                     shift and go to state 138
    multiplicative_expression      shift and go to state 52
    additive_expression            shift and go to state 66
    method_invocation              shift and go to state 111
    class_initializer              shift and go to state 274
    shift_expression               shift and go to state 54
    equality_expression            shift and go to state 82
    array_initializer              shift and go to state 272
    int_float                      shift and go to state 40
    variable_literal               shift and go to state 55
    name                           shift and go to state 139
    expression                     shift and go to state 276
    conditional_and_expression     shift and go to state 56

state 325

    (99) variable_declaration_body -> IDENTIFIER ASOP LPAREN func_arguement_list_opt RPAREN FUNTYPE expression .

    TERMINATOR      reduce using rule 99 (variable_declaration_body -> IDENTIFIER ASOP LPAREN func_arguement_list_opt RPAREN FUNTYPE expression .)


state 326

    (137) if_then_else_statement -> KEYWORD_IF LPAREN expression RPAREN if_then_else_intermediate KEYWORD_ELSE . statement
    (138) if_then_else_statement_precedence -> KEYWORD_IF LPAREN expression RPAREN if_then_else_intermediate KEYWORD_ELSE . if_then_else_intermediate
    (122) statement -> . normal_statement
    (123) statement -> . if_then_statement
    (124) statement -> . if_then_else_statement
    (125) statement -> . while_statement
    (126) statement -> . do_while_statement
    (127) statement -> . for_statement
    (139) if_then_else_intermediate -> . normal_statement
    (140) if_then_else_intermediate -> . if_then_else_statement_precedence
    (128) normal_statement -> . block
    (129) normal_statement -> . expression_statement
    (130) normal_statement -> . empty_statement
    (131) normal_statement -> . return_statement
    (132) normal_statement -> . switch_statement
    (136) if_then_statement -> . KEYWORD_IF LPAREN expression RPAREN statement
    (137) if_then_else_statement -> . KEYWORD_IF LPAREN expression RPAREN if_then_else_intermediate KEYWORD_ELSE statement
    (141) while_statement -> . KEYWORD_WHILE LPAREN expression RPAREN statement
    (142) do_while_statement -> . KEYWORD_DO statement KEYWORD_WHILE LPAREN expression RPAREN TERMINATOR
    (143) for_statement -> . KEYWORD_FOR LPAREN for_logic RPAREN statement
    (138) if_then_else_statement_precedence -> . KEYWORD_IF LPAREN expression RPAREN if_then_else_intermediate KEYWORD_ELSE if_then_else_intermediate
    (8) block -> . BLOCKBEGIN block_statements_opt BLOCKEND
    (133) expression_statement -> . statement_expression TERMINATOR
    (163) empty_statement -> . TERMINATOR
    (164) return_statement -> . KEYWORD_RETURN expression_optional TERMINATOR
    (152) switch_statement -> . expression KEYWORD_MATCH switch_block
    (134) statement_expression -> . assignment
    (135) statement_expression -> . method_invocation
    (18) expression -> . assignment_expression
    (23) assignment -> . valid_variable assignment_operator assignment_expression
    (79) method_invocation -> . name LPAREN argument_list_opt RPAREN
    (21) assignment_expression -> . assignment
    (22) assignment_expression -> . conditional_or_expression
    (24) valid_variable -> . name
    (25) valid_variable -> . array_access
    (115) name -> . simple_name
    (116) name -> . qualified_name
    (28) conditional_or_expression -> . conditional_and_expression
    (29) conditional_or_expression -> . conditional_or_expression OR conditional_and_expression
    (26) array_access -> . name LBRAC expression RBRAC
    (117) simple_name -> . IDENTIFIER
    (118) qualified_name -> . name INST simple_name
    (30) conditional_and_expression -> . inclusive_or_expression
    (31) conditional_and_expression -> . conditional_and_expression AND inclusive_or_expression
    (32) inclusive_or_expression -> . exclusive_or_expression
    (33) inclusive_or_expression -> . inclusive_or_expression OR_BITWISE exclusive_or_expression
    (34) exclusive_or_expression -> . and_expression
    (35) exclusive_or_expression -> . exclusive_or_expression XOR and_expression
    (36) and_expression -> . equality_expression
    (37) and_expression -> . and_expression AND_BITWISE equality_expression
    (38) equality_expression -> . relational_expression
    (39) equality_expression -> . equality_expression EQUAL relational_expression
    (40) equality_expression -> . equality_expression NEQUAL relational_expression
    (41) relational_expression -> . shift_expression
    (42) relational_expression -> . relational_expression GREATER shift_expression
    (43) relational_expression -> . relational_expression LESS shift_expression
    (44) relational_expression -> . relational_expression GEQ shift_expression
    (45) relational_expression -> . relational_expression LEQ shift_expression
    (46) shift_expression -> . additive_expression
    (47) shift_expression -> . shift_expression LSHIFT additive_expression
    (48) shift_expression -> . shift_expression RSHIFT additive_expression
    (49) additive_expression -> . multiplicative_expression
    (50) additive_expression -> . additive_expression PLUS multiplicative_expression
    (51) additive_expression -> . additive_expression MINUS multiplicative_expression
    (52) multiplicative_expression -> . unary_expression
    (53) multiplicative_expression -> . multiplicative_expression TIMES unary_expression
    (54) multiplicative_expression -> . multiplicative_expression DIVIDE unary_expression
    (55) multiplicative_expression -> . multiplicative_expression REMAINDER unary_expression
    (56) unary_expression -> . PLUS unary_expression
    (57) unary_expression -> . MINUS unary_expression
    (58) unary_expression -> . unary_expression_not_plus_minus
    (59) unary_expression_not_plus_minus -> . base_variable_set
    (60) unary_expression_not_plus_minus -> . TILDA unary_expression
    (61) unary_expression_not_plus_minus -> . NOT unary_expression
    (62) unary_expression_not_plus_minus -> . cast_expression
    (63) base_variable_set -> . variable_literal
    (64) base_variable_set -> . LPAREN expression RPAREN
    (67) cast_expression -> . LPAREN primitive_type RPAREN unary_expression
    (65) variable_literal -> . valid_variable
    (66) variable_literal -> . primary
    (68) primary -> . literal
    (69) primary -> . method_invocation
    (70) literal -> . int_float
    (71) literal -> . c_literal
    (77) int_float -> . DOUBLE_NUMBER
    (78) int_float -> . INT_NUMBER
    (72) c_literal -> . CHAR
    (73) c_literal -> . STRING
    (74) c_literal -> . BOOL_CONSTT
    (75) c_literal -> . BOOL_CONSTF
    (76) c_literal -> . KEYWORD_NULL

    KEYWORD_IF      shift and go to state 268
    KEYWORD_WHILE   shift and go to state 50
    KEYWORD_DO      shift and go to state 98
    KEYWORD_FOR     shift and go to state 97
    BLOCKBEGIN      shift and go to state 15
    TERMINATOR      shift and go to state 53
    KEYWORD_RETURN  shift and go to state 68
    IDENTIFIER      shift and go to state 77
    PLUS            shift and go to state 36
    MINUS           shift and go to state 29
    TILDA           shift and go to state 72
    NOT             shift and go to state 57
    LPAREN          shift and go to state 94
    DOUBLE_NUMBER   shift and go to state 33
    INT_NUMBER      shift and go to state 44
    CHAR            shift and go to state 63
    STRING          shift and go to state 76
    BOOL_CONSTT     shift and go to state 35
    BOOL_CONSTF     shift and go to state 30
    KEYWORD_NULL    shift and go to state 65

    expression_statement           shift and go to state 27
    if_then_else_statement_precedence shift and go to state 269
    unary_expression               shift and go to state 45
    exclusive_or_expression        shift and go to state 61
    normal_statement               shift and go to state 270
    primary                        shift and go to state 62
    unary_expression_not_plus_minus shift and go to state 46
    if_then_else_intermediate      shift and go to state 329
    if_then_statement              shift and go to state 64
    array_access                   shift and go to state 28
    switch_statement               shift and go to state 47
    assignment_expression          shift and go to state 91
    qualified_name                 shift and go to state 79
    base_variable_set              shift and go to state 88
    valid_variable                 shift and go to state 48
    inclusive_or_expression        shift and go to state 32
    literal                        shift and go to state 71
    return_statement               shift and go to state 89
    while_statement                shift and go to state 34
    and_expression                 shift and go to state 87
    statement                      shift and go to state 303
    statement_expression           shift and go to state 37
    method_invocation              shift and go to state 75
    simple_name                    shift and go to state 67
    conditional_or_expression      shift and go to state 49
    relational_expression          shift and go to state 73
    for_statement                  shift and go to state 38
    do_while_statement             shift and go to state 51
    assignment                     shift and go to state 92
    multiplicative_expression      shift and go to state 52
    c_literal                      shift and go to state 93
    additive_expression            shift and go to state 66
    cast_expression                shift and go to state 80
    shift_expression               shift and go to state 54
    equality_expression            shift and go to state 82
    int_float                      shift and go to state 40
    variable_literal               shift and go to state 55
    name                           shift and go to state 43
    empty_statement                shift and go to state 84
    expression                     shift and go to state 58
    conditional_and_expression     shift and go to state 56
    block                          shift and go to state 59
    if_then_else_statement         shift and go to state 60

state 327

    (119) array_initializer -> KEYWORD_NEW KEYWORD_ARRAY LBRAC type RBRAC LPAREN . INT_NUMBER RPAREN

    INT_NUMBER      shift and go to state 330


state 328

    (96) variable_arguement_list -> variable_arguement_list COMMA variable_declaration_initializer .

    RPAREN          reduce using rule 96 (variable_arguement_list -> variable_arguement_list COMMA variable_declaration_initializer .)
    COMMA           reduce using rule 96 (variable_arguement_list -> variable_arguement_list COMMA variable_declaration_initializer .)


state 329

    (138) if_then_else_statement_precedence -> KEYWORD_IF LPAREN expression RPAREN if_then_else_intermediate KEYWORD_ELSE if_then_else_intermediate .

    KEYWORD_ELSE    reduce using rule 138 (if_then_else_statement_precedence -> KEYWORD_IF LPAREN expression RPAREN if_then_else_intermediate KEYWORD_ELSE if_then_else_intermediate .)


state 330

    (119) array_initializer -> KEYWORD_NEW KEYWORD_ARRAY LBRAC type RBRAC LPAREN INT_NUMBER . RPAREN

    RPAREN          shift and go to state 331


state 331

    (119) array_initializer -> KEYWORD_NEW KEYWORD_ARRAY LBRAC type RBRAC LPAREN INT_NUMBER RPAREN .

    RPAREN          reduce using rule 119 (array_initializer -> KEYWORD_NEW KEYWORD_ARRAY LBRAC type RBRAC LPAREN INT_NUMBER RPAREN .)
    COMMA           reduce using rule 119 (array_initializer -> KEYWORD_NEW KEYWORD_ARRAY LBRAC type RBRAC LPAREN INT_NUMBER RPAREN .)
    TERMINATOR      reduce using rule 119 (array_initializer -> KEYWORD_NEW KEYWORD_ARRAY LBRAC type RBRAC LPAREN INT_NUMBER RPAREN .)

