Created by PLY version 3.8 (http://www.dabeaz.com/ply)

Unused terminals:

    KEYWORD_DEFINE
    KEYWORD_PACKAGE
    COMMENT
    KEYWORD_BREAK
    KEYWORD_YIELD
    KEYWORD_PRIVATE
    KEYWORD_IMPORT
    KEYWORD_OFDIM
    KEYWORD_EXTENDS
    COMMENT_END
    CHAR
    KEYWORD_NULL
    COMMENT_BEGIN
    KEYWORD_THIS
    DOUBLE_NUMBER
    KEYWORD_WITH
    STRING
    KEYWORD_TYPE
    KEYWORD_PROTECTED
    KEYWORD_OVERRIDE

Grammar

Rule 0     S' -> ProgramStructure
Rule 1     ProgramStructure -> ProgramStructure class_and_objects
Rule 2     ProgramStructure -> class_and_objects
Rule 3     class_and_objects -> SingletonObject
Rule 4     class_and_objects -> class_declaration
Rule 5     SingletonObject -> ObjectDeclare block
Rule 6     ObjectDeclare -> KEYWORD_OBJECT IDENTIFIER
Rule 7     block -> start_scope block_statements_opt end_scope
Rule 8     start_scope -> BLOCKBEGIN
Rule 9     end_scope -> BLOCKEND
Rule 10    block_statements_opt -> block_statements
Rule 11    block_statements_opt -> empty
Rule 12    block_statements -> block_statement
Rule 13    block_statements -> block_statements marker block_statement
Rule 14    block_statement -> local_variable_declaration_statement
Rule 15    block_statement -> statement
Rule 16    block_statement -> class_declaration
Rule 17    block_statement -> SingletonObject
Rule 18    block_statement -> method_declaration
Rule 19    expression -> assignment_expression
Rule 20    expression_optional -> expression
Rule 21    expression_optional -> empty
Rule 22    assignment_expression -> assignment
Rule 23    assignment_expression -> conditional_or_expression
Rule 24    assignment_expression -> method_invocation
Rule 25    assignment -> valid_variable assignment_operator assignment_expression
Rule 26    valid_variable -> name
Rule 27    valid_variable -> array_access
Rule 28    array_access -> name dimension
Rule 29    dimension -> LBRAC expression RBRAC
Rule 30    assignment_operator -> ASOP
Rule 31    assignment_operator -> TIMES_ASSIGN
Rule 32    assignment_operator -> DIVIDE_ASSIGN
Rule 33    assignment_operator -> REMAINDER_ASSIGN
Rule 34    assignment_operator -> PLUS_ASSIGN
Rule 35    assignment_operator -> MINUS_ASSIGN
Rule 36    assignment_operator -> LSHIFT_ASSIGN
Rule 37    assignment_operator -> RSHIFT_ASSIGN
Rule 38    assignment_operator -> AND_ASSIGN
Rule 39    assignment_operator -> OR_ASSIGN
Rule 40    assignment_operator -> XOR_ASSIGN
Rule 41    marker -> empty
Rule 42    narker -> empty
Rule 43    conditional_or_expression -> conditional_and_expression
Rule 44    conditional_or_expression -> conditional_or_expression OR marker conditional_and_expression
Rule 45    conditional_and_expression -> inclusive_or_expression
Rule 46    conditional_and_expression -> conditional_and_expression AND marker inclusive_or_expression
Rule 47    inclusive_or_expression -> exclusive_or_expression
Rule 48    inclusive_or_expression -> inclusive_or_expression OR_BITWISE exclusive_or_expression
Rule 49    exclusive_or_expression -> and_expression
Rule 50    exclusive_or_expression -> exclusive_or_expression XOR and_expression
Rule 51    and_expression -> equality_expression
Rule 52    and_expression -> and_expression AND_BITWISE equality_expression
Rule 53    equality_expression -> relational_expression
Rule 54    equality_expression -> equality_expression EQUAL relational_expression
Rule 55    equality_expression -> equality_expression NEQUAL relational_expression
Rule 56    relational_expression -> shift_expression
Rule 57    relational_expression -> relational_expression GREATER shift_expression
Rule 58    relational_expression -> relational_expression LESS shift_expression
Rule 59    relational_expression -> relational_expression GEQ shift_expression
Rule 60    relational_expression -> relational_expression LEQ shift_expression
Rule 61    shift_expression -> additive_expression
Rule 62    shift_expression -> shift_expression LSHIFT additive_expression
Rule 63    shift_expression -> shift_expression RSHIFT additive_expression
Rule 64    additive_expression -> multiplicative_expression
Rule 65    additive_expression -> additive_expression PLUS multiplicative_expression
Rule 66    additive_expression -> additive_expression MINUS multiplicative_expression
Rule 67    multiplicative_expression -> unary_expression
Rule 68    multiplicative_expression -> multiplicative_expression TIMES unary_expression
Rule 69    multiplicative_expression -> multiplicative_expression DIVIDE unary_expression
Rule 70    multiplicative_expression -> multiplicative_expression REMAINDER unary_expression
Rule 71    unary_expression -> PLUS unary_expression
Rule 72    unary_expression -> MINUS unary_expression
Rule 73    unary_expression -> unary_expression_not_plus_minus
Rule 74    unary_expression_not_plus_minus -> base_variable_set
Rule 75    unary_expression_not_plus_minus -> TILDA unary_expression
Rule 76    unary_expression_not_plus_minus -> NOT unary_expression
Rule 77    base_variable_set -> variable_literal
Rule 78    base_variable_set -> LPAREN expression RPAREN
Rule 79    variable_literal -> valid_variable
Rule 80    variable_literal -> primary
Rule 81    primary -> literal
Rule 82    primary -> method_invocation
Rule 83    literal -> int_float
Rule 84    literal -> c_literal
Rule 85    c_literal -> BOOL_CONSTT
Rule 86    c_literal -> BOOL_CONSTF
Rule 87    int_float -> INT_NUMBER
Rule 88    method_invocation -> name LPAREN argument_list_opt RPAREN
Rule 89    argument_list_opt -> argument_list
Rule 90    argument_list_opt -> empty
Rule 91    argument_list -> expression
Rule 92    argument_list -> argument_list COMMA expression
Rule 93    declaration_keyword -> KEYWORD_VAR
Rule 94    declaration_keyword -> KEYWORD_VAL
Rule 95    local_variable_declaration_statement -> local_variable_declaration TERMINATOR
Rule 96    local_variable_declaration -> declaration_keyword variable_declaration_body
Rule 97    variable_declaration_initializer -> expression
Rule 98    variable_declaration_initializer -> array_initializer
Rule 99    variable_declaration_initializer -> class_initializer
Rule 100   variable_argument_list -> variable_declaration_initializer
Rule 101   variable_argument_list -> variable_argument_list COMMA variable_declaration_initializer
Rule 102   variable_declaration_body -> identifiers COLON type ASOP variable_declaration_initializer
Rule 103   identifiers -> identifiers COMMA IDENTIFIER
Rule 104   identifiers -> IDENTIFIER
Rule 105   variable_list -> variable_declarator_id
Rule 106   variable_list -> variable_list COMMA variable_declarator_id
Rule 107   variable_declarator_id -> IDENTIFIER COLON type
Rule 108   fun_variable_declarator_id -> IDENTIFIER COLON type
Rule 109   type -> primitive_type
Rule 110   type -> reference_type
Rule 111   primitive_type -> TYPE_INT
Rule 112   primitive_type -> TYPE_DOUBLE
Rule 113   primitive_type -> TYPE_CHAR
Rule 114   primitive_type -> TYPE_STRING
Rule 115   primitive_type -> TYPE_BOOLEAN
Rule 116   primitive_type -> TYPE_VOID
Rule 117   reference_type -> class_data_type
Rule 118   reference_type -> array_data_type
Rule 119   class_data_type -> name
Rule 120   array_data_type -> KEYWORD_ARRAY LBRAC TYPE_INT RBRAC
Rule 121   name -> simple_name
Rule 122   name -> qualified_name
Rule 123   simple_name -> IDENTIFIER
Rule 124   qualified_name -> name INST simple_name
Rule 125   array_initializer -> KEYWORD_NEW KEYWORD_ARRAY LBRAC type RBRAC LPAREN conditional_or_expression RPAREN
Rule 126   array_initializer -> KEYWORD_ARRAY LBRAC type RBRAC LPAREN argument_list RPAREN
Rule 127   class_initializer -> KEYWORD_NEW name LPAREN argument_list_opt RPAREN
Rule 128   statement -> normal_statement marker
Rule 129   statement -> if_then_statement marker
Rule 130   statement -> if_then_else_statement marker
Rule 131   statement -> while_statement marker
Rule 132   statement -> do_while_statement marker
Rule 133   statement -> for_statement marker
Rule 134   normal_statement -> block marker
Rule 135   normal_statement -> expression_statement marker
Rule 136   normal_statement -> empty_statement marker
Rule 137   normal_statement -> return_statement marker
Rule 138   normal_statement -> switch_statement marker
Rule 139   expression_statement -> statement_expression TERMINATOR
Rule 140   statement_expression -> assignment
Rule 141   statement_expression -> method_invocation
Rule 142   if_then_statement -> KEYWORD_IF LPAREN expression RPAREN marker block
Rule 143   if_then_else_statement -> KEYWORD_IF LPAREN expression RPAREN marker if_then_else_intermediate narker KEYWORD_ELSE marker block
Rule 144   if_then_else_statement_precedence -> KEYWORD_IF LPAREN expression RPAREN marker if_then_else_intermediate narker KEYWORD_ELSE marker if_then_else_intermediate
Rule 145   if_then_else_intermediate -> normal_statement
Rule 146   if_then_else_intermediate -> if_then_else_statement_precedence
Rule 147   while_statement -> KEYWORD_WHILE LPAREN marker expression RPAREN marker block
Rule 148   do_while_statement -> KEYWORD_DO marker block KEYWORD_WHILE LPAREN marker expression RPAREN TERMINATOR
Rule 149   for_statement -> KEYWORD_FOR LPAREN for_update RPAREN marker block
Rule 150   for_update -> for_loop marker for_step_opts
Rule 151   for_loop -> IDENTIFIER CHOOSE expression for_untilTo marker expression
Rule 152   for_untilTo -> KEYWORD_UNTIL
Rule 153   for_untilTo -> KEYWORD_TO
Rule 154   for_step_opts -> KEYWORD_BY expression
Rule 155   for_step_opts -> empty
Rule 156   switch_statement -> expression KEYWORD_MATCH switch_block marker
Rule 157   switch_block -> BLOCKBEGIN BLOCKEND
Rule 158   switch_block -> BLOCKBEGIN switch_block_statements BLOCKEND
Rule 159   switch_block_statements -> switch_block_statement marker
Rule 160   switch_block_statements -> switch_block_statements switch_block_statement marker
Rule 161   switch_block_statement -> switch_label narker marker block narker
Rule 162   switch_label -> KEYWORD_CASE expression FUNTYPE
Rule 163   empty_statement -> TERMINATOR
Rule 164   return_statement -> KEYWORD_RETURN expression_optional TERMINATOR
Rule 165   method_declaration -> method_header method_body
Rule 166   method_header -> method_header_name func_arg_start fun_params_opt RPAREN COLON method_return_type ASOP
Rule 167   func_arg_start -> LPAREN
Rule 168   fun_params_opt -> fun_params
Rule 169   fun_params_opt -> empty
Rule 170   fun_params -> fun_variable_declarator_id
Rule 171   fun_params -> fun_params COMMA fun_variable_declarator_id
Rule 172   method_return_type -> type
Rule 173   method_return_type -> TYPE_VOID
Rule 174   method_header_name -> KEYWORD_DEF IDENTIFIER
Rule 175   method_body -> method_start_scope block_statements_opt end_scope
Rule 176   method_start_scope -> BLOCKBEGIN
Rule 177   class_declaration -> class_header class_body
Rule 178   class_header -> KEYWORD_CLASS simple_name class_param_clause
Rule 179   class_param_clause -> func_arg_start class_params_opt RPAREN
Rule 180   class_params_opt -> class_params
Rule 181   class_params_opt -> empty
Rule 182   class_params -> class_param
Rule 183   class_params -> class_params COMMA class_param
Rule 184   class_param -> class_declaration_keyword_opt variable_declarator_id
Rule 185   class_declaration_keyword_opt -> declaration_keyword
Rule 186   class_declaration_keyword_opt -> empty
Rule 187   type_opt -> COLON type
Rule 188   type_opt -> empty
Rule 189   class_body -> class_body_start block_statements_opt end_scope
Rule 190   class_body_start -> BLOCKBEGIN
Rule 191   empty -> <empty>

Terminals, with rules where they appear

AND                  : 46
AND_ASSIGN           : 38
AND_BITWISE          : 52
ASOP                 : 30 102 166
BLOCKBEGIN           : 8 157 158 176 190
BLOCKEND             : 9 157 158
BOOL_CONSTF          : 86
BOOL_CONSTT          : 85
CHAR                 : 
CHOOSE               : 151
COLON                : 102 107 108 166 187
COMMA                : 92 101 103 106 171 183
COMMENT              : 
COMMENT_BEGIN        : 
COMMENT_END          : 
DIVIDE               : 69
DIVIDE_ASSIGN        : 32
DOUBLE_NUMBER        : 
EQUAL                : 54
FUNTYPE              : 162
GEQ                  : 59
GREATER              : 57
IDENTIFIER           : 6 103 104 107 108 123 151 174
INST                 : 124
INT_NUMBER           : 87
KEYWORD_ARRAY        : 120 125 126
KEYWORD_BREAK        : 
KEYWORD_BY           : 154
KEYWORD_CASE         : 162
KEYWORD_CLASS        : 178
KEYWORD_DEF          : 174
KEYWORD_DEFINE       : 
KEYWORD_DO           : 148
KEYWORD_ELSE         : 143 144
KEYWORD_EXTENDS      : 
KEYWORD_FOR          : 149
KEYWORD_IF           : 142 143 144
KEYWORD_IMPORT       : 
KEYWORD_MATCH        : 156
KEYWORD_NEW          : 125 127
KEYWORD_NULL         : 
KEYWORD_OBJECT       : 6
KEYWORD_OFDIM        : 
KEYWORD_OVERRIDE     : 
KEYWORD_PACKAGE      : 
KEYWORD_PRIVATE      : 
KEYWORD_PROTECTED    : 
KEYWORD_RETURN       : 164
KEYWORD_THIS         : 
KEYWORD_TO           : 153
KEYWORD_TYPE         : 
KEYWORD_UNTIL        : 152
KEYWORD_VAL          : 94
KEYWORD_VAR          : 93
KEYWORD_WHILE        : 147 148
KEYWORD_WITH         : 
KEYWORD_YIELD        : 
LBRAC                : 29 120 125 126
LEQ                  : 60
LESS                 : 58
LPAREN               : 78 88 125 126 127 142 143 144 147 148 149 167
LSHIFT               : 62
LSHIFT_ASSIGN        : 36
MINUS                : 66 72
MINUS_ASSIGN         : 35
NEQUAL               : 55
NOT                  : 76
OR                   : 44
OR_ASSIGN            : 39
OR_BITWISE           : 48
PLUS                 : 65 71
PLUS_ASSIGN          : 34
RBRAC                : 29 120 125 126
REMAINDER            : 70
REMAINDER_ASSIGN     : 33
RPAREN               : 78 88 125 126 127 142 143 144 147 148 149 166 179
RSHIFT               : 63
RSHIFT_ASSIGN        : 37
STRING               : 
TERMINATOR           : 95 139 148 163 164
TILDA                : 75
TIMES                : 68
TIMES_ASSIGN         : 31
TYPE_BOOLEAN         : 115
TYPE_CHAR            : 113
TYPE_DOUBLE          : 112
TYPE_INT             : 111 120
TYPE_STRING          : 114
TYPE_VOID            : 116 173
XOR                  : 50
XOR_ASSIGN           : 40
error                : 

Nonterminals, with rules where they appear

ObjectDeclare        : 5
ProgramStructure     : 1 0
SingletonObject      : 3 17
additive_expression  : 61 62 63 65 66
and_expression       : 49 50 52
argument_list        : 89 92 126
argument_list_opt    : 88 127
array_access         : 27
array_data_type      : 118
array_initializer    : 98
assignment           : 22 140
assignment_expression : 19 25
assignment_operator  : 25
base_variable_set    : 74
block                : 5 134 142 143 147 148 149 161
block_statement      : 12 13
block_statements     : 10 13
block_statements_opt : 7 175 189
c_literal            : 84
class_and_objects    : 1 2
class_body           : 177
class_body_start     : 189
class_data_type      : 117
class_declaration    : 4 16
class_declaration_keyword_opt : 184
class_header         : 177
class_initializer    : 99
class_param          : 182 183
class_param_clause   : 178
class_params         : 180 183
class_params_opt     : 179
conditional_and_expression : 43 44 46
conditional_or_expression : 23 44 125
declaration_keyword  : 96 185
dimension            : 28
do_while_statement   : 132
empty                : 11 21 41 42 90 155 169 181 186 188
empty_statement      : 136
end_scope            : 7 175 189
equality_expression  : 51 52 54 55
exclusive_or_expression : 47 48 50
expression           : 20 29 78 91 92 97 142 143 144 147 148 151 151 154 156 162
expression_optional  : 164
expression_statement : 135
for_loop             : 150
for_statement        : 133
for_step_opts        : 150
for_untilTo          : 151
for_update           : 149
fun_params           : 168 171
fun_params_opt       : 166
fun_variable_declarator_id : 170 171
func_arg_start       : 166 179
identifiers          : 102 103
if_then_else_intermediate : 143 144 144
if_then_else_statement : 130
if_then_else_statement_precedence : 146
if_then_statement    : 129
inclusive_or_expression : 45 46 48
int_float            : 83
literal              : 81
local_variable_declaration : 95
local_variable_declaration_statement : 14
marker               : 13 44 46 128 129 130 131 132 133 134 135 136 137 138 142 143 143 144 144 147 147 148 148 149 150 151 156 159 160 161
method_body          : 165
method_declaration   : 18
method_header        : 165
method_header_name   : 166
method_invocation    : 24 82 141
method_return_type   : 166
method_start_scope   : 175
multiplicative_expression : 64 65 66 68 69 70
name                 : 26 28 88 119 124 127
narker               : 143 144 161 161
normal_statement     : 128 145
primary              : 80
primitive_type       : 109
qualified_name       : 122
reference_type       : 110
relational_expression : 53 54 55 57 58 59 60
return_statement     : 137
shift_expression     : 56 57 58 59 60 62 63
simple_name          : 121 124 178
start_scope          : 7
statement            : 15
statement_expression : 139
switch_block         : 156
switch_block_statement : 159 160
switch_block_statements : 158 160
switch_label         : 161
switch_statement     : 138
type                 : 102 107 108 125 126 172 187
type_opt             : 
unary_expression     : 67 68 69 70 71 72 75 76
unary_expression_not_plus_minus : 73
valid_variable       : 25 79
variable_argument_list : 101
variable_declaration_body : 96
variable_declaration_initializer : 100 101 102
variable_declarator_id : 105 106 184
variable_list        : 106
variable_literal     : 77
while_statement      : 131

Parsing method: LALR

state 0

    (0) S' -> . ProgramStructure
    (1) ProgramStructure -> . ProgramStructure class_and_objects
    (2) ProgramStructure -> . class_and_objects
    (3) class_and_objects -> . SingletonObject
    (4) class_and_objects -> . class_declaration
    (5) SingletonObject -> . ObjectDeclare block
    (177) class_declaration -> . class_header class_body
    (6) ObjectDeclare -> . KEYWORD_OBJECT IDENTIFIER
    (178) class_header -> . KEYWORD_CLASS simple_name class_param_clause

    KEYWORD_OBJECT  shift and go to state 8
    KEYWORD_CLASS   shift and go to state 1

    ProgramStructure               shift and go to state 2
    ObjectDeclare                  shift and go to state 3
    class_declaration              shift and go to state 4
    class_and_objects              shift and go to state 5
    SingletonObject                shift and go to state 6
    class_header                   shift and go to state 7

state 1

    (178) class_header -> KEYWORD_CLASS . simple_name class_param_clause
    (123) simple_name -> . IDENTIFIER

    IDENTIFIER      shift and go to state 9

    simple_name                    shift and go to state 10

state 2

    (0) S' -> ProgramStructure .
    (1) ProgramStructure -> ProgramStructure . class_and_objects
    (3) class_and_objects -> . SingletonObject
    (4) class_and_objects -> . class_declaration
    (5) SingletonObject -> . ObjectDeclare block
    (177) class_declaration -> . class_header class_body
    (6) ObjectDeclare -> . KEYWORD_OBJECT IDENTIFIER
    (178) class_header -> . KEYWORD_CLASS simple_name class_param_clause

    KEYWORD_OBJECT  shift and go to state 8
    KEYWORD_CLASS   shift and go to state 1

    ObjectDeclare                  shift and go to state 3
    class_declaration              shift and go to state 4
    class_and_objects              shift and go to state 11
    SingletonObject                shift and go to state 6
    class_header                   shift and go to state 7

state 3

    (5) SingletonObject -> ObjectDeclare . block
    (7) block -> . start_scope block_statements_opt end_scope
    (8) start_scope -> . BLOCKBEGIN

    BLOCKBEGIN      shift and go to state 12

    start_scope                    shift and go to state 13
    block                          shift and go to state 14

state 4

    (4) class_and_objects -> class_declaration .

    KEYWORD_OBJECT  reduce using rule 4 (class_and_objects -> class_declaration .)
    KEYWORD_CLASS   reduce using rule 4 (class_and_objects -> class_declaration .)
    $end            reduce using rule 4 (class_and_objects -> class_declaration .)


state 5

    (2) ProgramStructure -> class_and_objects .

    KEYWORD_OBJECT  reduce using rule 2 (ProgramStructure -> class_and_objects .)
    KEYWORD_CLASS   reduce using rule 2 (ProgramStructure -> class_and_objects .)
    $end            reduce using rule 2 (ProgramStructure -> class_and_objects .)


state 6

    (3) class_and_objects -> SingletonObject .

    KEYWORD_OBJECT  reduce using rule 3 (class_and_objects -> SingletonObject .)
    KEYWORD_CLASS   reduce using rule 3 (class_and_objects -> SingletonObject .)
    $end            reduce using rule 3 (class_and_objects -> SingletonObject .)


state 7

    (177) class_declaration -> class_header . class_body
    (189) class_body -> . class_body_start block_statements_opt end_scope
    (190) class_body_start -> . BLOCKBEGIN

    BLOCKBEGIN      shift and go to state 17

    class_body_start               shift and go to state 15
    class_body                     shift and go to state 16

state 8

    (6) ObjectDeclare -> KEYWORD_OBJECT . IDENTIFIER

    IDENTIFIER      shift and go to state 18


state 9

    (123) simple_name -> IDENTIFIER .

    LPAREN          reduce using rule 123 (simple_name -> IDENTIFIER .)
    INST            reduce using rule 123 (simple_name -> IDENTIFIER .)
    LBRAC           reduce using rule 123 (simple_name -> IDENTIFIER .)
    TIMES           reduce using rule 123 (simple_name -> IDENTIFIER .)
    DIVIDE          reduce using rule 123 (simple_name -> IDENTIFIER .)
    REMAINDER       reduce using rule 123 (simple_name -> IDENTIFIER .)
    PLUS            reduce using rule 123 (simple_name -> IDENTIFIER .)
    MINUS           reduce using rule 123 (simple_name -> IDENTIFIER .)
    LSHIFT          reduce using rule 123 (simple_name -> IDENTIFIER .)
    RSHIFT          reduce using rule 123 (simple_name -> IDENTIFIER .)
    GREATER         reduce using rule 123 (simple_name -> IDENTIFIER .)
    LESS            reduce using rule 123 (simple_name -> IDENTIFIER .)
    GEQ             reduce using rule 123 (simple_name -> IDENTIFIER .)
    LEQ             reduce using rule 123 (simple_name -> IDENTIFIER .)
    EQUAL           reduce using rule 123 (simple_name -> IDENTIFIER .)
    NEQUAL          reduce using rule 123 (simple_name -> IDENTIFIER .)
    AND_BITWISE     reduce using rule 123 (simple_name -> IDENTIFIER .)
    XOR             reduce using rule 123 (simple_name -> IDENTIFIER .)
    OR_BITWISE      reduce using rule 123 (simple_name -> IDENTIFIER .)
    AND             reduce using rule 123 (simple_name -> IDENTIFIER .)
    OR              reduce using rule 123 (simple_name -> IDENTIFIER .)
    KEYWORD_MATCH   reduce using rule 123 (simple_name -> IDENTIFIER .)
    TERMINATOR      reduce using rule 123 (simple_name -> IDENTIFIER .)
    RPAREN          reduce using rule 123 (simple_name -> IDENTIFIER .)
    RBRAC           reduce using rule 123 (simple_name -> IDENTIFIER .)
    COMMA           reduce using rule 123 (simple_name -> IDENTIFIER .)
    FUNTYPE         reduce using rule 123 (simple_name -> IDENTIFIER .)
    KEYWORD_UNTIL   reduce using rule 123 (simple_name -> IDENTIFIER .)
    KEYWORD_TO      reduce using rule 123 (simple_name -> IDENTIFIER .)
    KEYWORD_BY      reduce using rule 123 (simple_name -> IDENTIFIER .)
    ASOP            reduce using rule 123 (simple_name -> IDENTIFIER .)
    TIMES_ASSIGN    reduce using rule 123 (simple_name -> IDENTIFIER .)
    DIVIDE_ASSIGN   reduce using rule 123 (simple_name -> IDENTIFIER .)
    REMAINDER_ASSIGN reduce using rule 123 (simple_name -> IDENTIFIER .)
    PLUS_ASSIGN     reduce using rule 123 (simple_name -> IDENTIFIER .)
    MINUS_ASSIGN    reduce using rule 123 (simple_name -> IDENTIFIER .)
    LSHIFT_ASSIGN   reduce using rule 123 (simple_name -> IDENTIFIER .)
    RSHIFT_ASSIGN   reduce using rule 123 (simple_name -> IDENTIFIER .)
    AND_ASSIGN      reduce using rule 123 (simple_name -> IDENTIFIER .)
    OR_ASSIGN       reduce using rule 123 (simple_name -> IDENTIFIER .)
    XOR_ASSIGN      reduce using rule 123 (simple_name -> IDENTIFIER .)


state 10

    (178) class_header -> KEYWORD_CLASS simple_name . class_param_clause
    (179) class_param_clause -> . func_arg_start class_params_opt RPAREN
    (167) func_arg_start -> . LPAREN

    LPAREN          shift and go to state 21

    func_arg_start                 shift and go to state 19
    class_param_clause             shift and go to state 20

state 11

    (1) ProgramStructure -> ProgramStructure class_and_objects .

    KEYWORD_OBJECT  reduce using rule 1 (ProgramStructure -> ProgramStructure class_and_objects .)
    KEYWORD_CLASS   reduce using rule 1 (ProgramStructure -> ProgramStructure class_and_objects .)
    $end            reduce using rule 1 (ProgramStructure -> ProgramStructure class_and_objects .)


state 12

    (8) start_scope -> BLOCKBEGIN .

    KEYWORD_IF      reduce using rule 8 (start_scope -> BLOCKBEGIN .)
    KEYWORD_WHILE   reduce using rule 8 (start_scope -> BLOCKBEGIN .)
    KEYWORD_DO      reduce using rule 8 (start_scope -> BLOCKBEGIN .)
    KEYWORD_FOR     reduce using rule 8 (start_scope -> BLOCKBEGIN .)
    KEYWORD_CLASS   reduce using rule 8 (start_scope -> BLOCKBEGIN .)
    KEYWORD_OBJECT  reduce using rule 8 (start_scope -> BLOCKBEGIN .)
    KEYWORD_VAR     reduce using rule 8 (start_scope -> BLOCKBEGIN .)
    KEYWORD_VAL     reduce using rule 8 (start_scope -> BLOCKBEGIN .)
    TERMINATOR      reduce using rule 8 (start_scope -> BLOCKBEGIN .)
    KEYWORD_RETURN  reduce using rule 8 (start_scope -> BLOCKBEGIN .)
    KEYWORD_DEF     reduce using rule 8 (start_scope -> BLOCKBEGIN .)
    BLOCKBEGIN      reduce using rule 8 (start_scope -> BLOCKBEGIN .)
    IDENTIFIER      reduce using rule 8 (start_scope -> BLOCKBEGIN .)
    PLUS            reduce using rule 8 (start_scope -> BLOCKBEGIN .)
    MINUS           reduce using rule 8 (start_scope -> BLOCKBEGIN .)
    TILDA           reduce using rule 8 (start_scope -> BLOCKBEGIN .)
    NOT             reduce using rule 8 (start_scope -> BLOCKBEGIN .)
    LPAREN          reduce using rule 8 (start_scope -> BLOCKBEGIN .)
    INT_NUMBER      reduce using rule 8 (start_scope -> BLOCKBEGIN .)
    BOOL_CONSTT     reduce using rule 8 (start_scope -> BLOCKBEGIN .)
    BOOL_CONSTF     reduce using rule 8 (start_scope -> BLOCKBEGIN .)
    BLOCKEND        reduce using rule 8 (start_scope -> BLOCKBEGIN .)


state 13

    (7) block -> start_scope . block_statements_opt end_scope
    (10) block_statements_opt -> . block_statements
    (11) block_statements_opt -> . empty
    (12) block_statements -> . block_statement
    (13) block_statements -> . block_statements marker block_statement
    (191) empty -> .
    (14) block_statement -> . local_variable_declaration_statement
    (15) block_statement -> . statement
    (16) block_statement -> . class_declaration
    (17) block_statement -> . SingletonObject
    (18) block_statement -> . method_declaration
    (95) local_variable_declaration_statement -> . local_variable_declaration TERMINATOR
    (128) statement -> . normal_statement marker
    (129) statement -> . if_then_statement marker
    (130) statement -> . if_then_else_statement marker
    (131) statement -> . while_statement marker
    (132) statement -> . do_while_statement marker
    (133) statement -> . for_statement marker
    (177) class_declaration -> . class_header class_body
    (5) SingletonObject -> . ObjectDeclare block
    (165) method_declaration -> . method_header method_body
    (96) local_variable_declaration -> . declaration_keyword variable_declaration_body
    (134) normal_statement -> . block marker
    (135) normal_statement -> . expression_statement marker
    (136) normal_statement -> . empty_statement marker
    (137) normal_statement -> . return_statement marker
    (138) normal_statement -> . switch_statement marker
    (142) if_then_statement -> . KEYWORD_IF LPAREN expression RPAREN marker block
    (143) if_then_else_statement -> . KEYWORD_IF LPAREN expression RPAREN marker if_then_else_intermediate narker KEYWORD_ELSE marker block
    (147) while_statement -> . KEYWORD_WHILE LPAREN marker expression RPAREN marker block
    (148) do_while_statement -> . KEYWORD_DO marker block KEYWORD_WHILE LPAREN marker expression RPAREN TERMINATOR
    (149) for_statement -> . KEYWORD_FOR LPAREN for_update RPAREN marker block
    (178) class_header -> . KEYWORD_CLASS simple_name class_param_clause
    (6) ObjectDeclare -> . KEYWORD_OBJECT IDENTIFIER
    (166) method_header -> . method_header_name func_arg_start fun_params_opt RPAREN COLON method_return_type ASOP
    (93) declaration_keyword -> . KEYWORD_VAR
    (94) declaration_keyword -> . KEYWORD_VAL
    (7) block -> . start_scope block_statements_opt end_scope
    (139) expression_statement -> . statement_expression TERMINATOR
    (163) empty_statement -> . TERMINATOR
    (164) return_statement -> . KEYWORD_RETURN expression_optional TERMINATOR
    (156) switch_statement -> . expression KEYWORD_MATCH switch_block marker
    (174) method_header_name -> . KEYWORD_DEF IDENTIFIER
    (8) start_scope -> . BLOCKBEGIN
    (140) statement_expression -> . assignment
    (141) statement_expression -> . method_invocation
    (19) expression -> . assignment_expression
    (25) assignment -> . valid_variable assignment_operator assignment_expression
    (88) method_invocation -> . name LPAREN argument_list_opt RPAREN
    (22) assignment_expression -> . assignment
    (23) assignment_expression -> . conditional_or_expression
    (24) assignment_expression -> . method_invocation
    (26) valid_variable -> . name
    (27) valid_variable -> . array_access
    (121) name -> . simple_name
    (122) name -> . qualified_name
    (43) conditional_or_expression -> . conditional_and_expression
    (44) conditional_or_expression -> . conditional_or_expression OR marker conditional_and_expression
    (28) array_access -> . name dimension
    (123) simple_name -> . IDENTIFIER
    (124) qualified_name -> . name INST simple_name
    (45) conditional_and_expression -> . inclusive_or_expression
    (46) conditional_and_expression -> . conditional_and_expression AND marker inclusive_or_expression
    (47) inclusive_or_expression -> . exclusive_or_expression
    (48) inclusive_or_expression -> . inclusive_or_expression OR_BITWISE exclusive_or_expression
    (49) exclusive_or_expression -> . and_expression
    (50) exclusive_or_expression -> . exclusive_or_expression XOR and_expression
    (51) and_expression -> . equality_expression
    (52) and_expression -> . and_expression AND_BITWISE equality_expression
    (53) equality_expression -> . relational_expression
    (54) equality_expression -> . equality_expression EQUAL relational_expression
    (55) equality_expression -> . equality_expression NEQUAL relational_expression
    (56) relational_expression -> . shift_expression
    (57) relational_expression -> . relational_expression GREATER shift_expression
    (58) relational_expression -> . relational_expression LESS shift_expression
    (59) relational_expression -> . relational_expression GEQ shift_expression
    (60) relational_expression -> . relational_expression LEQ shift_expression
    (61) shift_expression -> . additive_expression
    (62) shift_expression -> . shift_expression LSHIFT additive_expression
    (63) shift_expression -> . shift_expression RSHIFT additive_expression
    (64) additive_expression -> . multiplicative_expression
    (65) additive_expression -> . additive_expression PLUS multiplicative_expression
    (66) additive_expression -> . additive_expression MINUS multiplicative_expression
    (67) multiplicative_expression -> . unary_expression
    (68) multiplicative_expression -> . multiplicative_expression TIMES unary_expression
    (69) multiplicative_expression -> . multiplicative_expression DIVIDE unary_expression
    (70) multiplicative_expression -> . multiplicative_expression REMAINDER unary_expression
    (71) unary_expression -> . PLUS unary_expression
    (72) unary_expression -> . MINUS unary_expression
    (73) unary_expression -> . unary_expression_not_plus_minus
    (74) unary_expression_not_plus_minus -> . base_variable_set
    (75) unary_expression_not_plus_minus -> . TILDA unary_expression
    (76) unary_expression_not_plus_minus -> . NOT unary_expression
    (77) base_variable_set -> . variable_literal
    (78) base_variable_set -> . LPAREN expression RPAREN
    (79) variable_literal -> . valid_variable
    (80) variable_literal -> . primary
    (81) primary -> . literal
    (82) primary -> . method_invocation
    (83) literal -> . int_float
    (84) literal -> . c_literal
    (87) int_float -> . INT_NUMBER
    (85) c_literal -> . BOOL_CONSTT
    (86) c_literal -> . BOOL_CONSTF

    BLOCKEND        reduce using rule 191 (empty -> .)
    KEYWORD_IF      shift and go to state 73
    KEYWORD_WHILE   shift and go to state 43
    KEYWORD_DO      shift and go to state 90
    KEYWORD_FOR     shift and go to state 89
    KEYWORD_CLASS   shift and go to state 1
    KEYWORD_OBJECT  shift and go to state 8
    KEYWORD_VAR     shift and go to state 46
    KEYWORD_VAL     shift and go to state 47
    TERMINATOR      shift and go to state 48
    KEYWORD_RETURN  shift and go to state 61
    KEYWORD_DEF     shift and go to state 72
    BLOCKBEGIN      shift and go to state 12
    IDENTIFIER      shift and go to state 9
    PLUS            shift and go to state 30
    MINUS           shift and go to state 24
    TILDA           shift and go to state 65
    NOT             shift and go to state 52
    LPAREN          shift and go to state 86
    INT_NUMBER      shift and go to state 38
    BOOL_CONSTT     shift and go to state 29
    BOOL_CONSTF     shift and go to state 25

    expression_statement           shift and go to state 22
    unary_expression               shift and go to state 39
    exclusive_or_expression        shift and go to state 56
    normal_statement               shift and go to state 78
    ObjectDeclare                  shift and go to state 3
    primary                        shift and go to state 57
    declaration_keyword            shift and go to state 70
    if_then_statement              shift and go to state 58
    array_access                   shift and go to state 23
    switch_statement               shift and go to state 41
    simple_name                    shift and go to state 60
    block_statements_opt           shift and go to state 26
    qualified_name                 shift and go to state 71
    base_variable_set              shift and go to state 80
    inclusive_or_expression        shift and go to state 27
    method_declaration             shift and go to state 62
    literal                        shift and go to state 64
    block_statement                shift and go to state 63
    return_statement               shift and go to state 81
    while_statement                shift and go to state 28
    unary_expression_not_plus_minus shift and go to state 40
    and_expression                 shift and go to state 79
    statement                      shift and go to state 67
    c_literal                      shift and go to state 85
    statement_expression           shift and go to state 31
    method_invocation              shift and go to state 68
    conditional_or_expression      shift and go to state 42
    empty                          shift and go to state 69
    relational_expression          shift and go to state 66
    block_statements               shift and go to state 82
    for_statement                  shift and go to state 32
    local_variable_declaration_statement shift and go to state 33
    do_while_statement             shift and go to state 44
    int_float                      shift and go to state 34
    assignment                     shift and go to state 84
    multiplicative_expression      shift and go to state 45
    additive_expression            shift and go to state 59
    SingletonObject                shift and go to state 35
    start_scope                    shift and go to state 13
    method_header_name             shift and go to state 36
    class_header                   shift and go to state 7
    shift_expression               shift and go to state 49
    equality_expression            shift and go to state 74
    variable_literal               shift and go to state 50
    name                           shift and go to state 37
    assignment_expression          shift and go to state 83
    valid_variable                 shift and go to state 87
    method_header                  shift and go to state 75
    empty_statement                shift and go to state 76
    class_declaration              shift and go to state 88
    local_variable_declaration     shift and go to state 77
    expression                     shift and go to state 53
    conditional_and_expression     shift and go to state 51
    block                          shift and go to state 54
    if_then_else_statement         shift and go to state 55

state 14

    (5) SingletonObject -> ObjectDeclare block .

    KEYWORD_IF      reduce using rule 5 (SingletonObject -> ObjectDeclare block .)
    KEYWORD_WHILE   reduce using rule 5 (SingletonObject -> ObjectDeclare block .)
    KEYWORD_DO      reduce using rule 5 (SingletonObject -> ObjectDeclare block .)
    KEYWORD_FOR     reduce using rule 5 (SingletonObject -> ObjectDeclare block .)
    KEYWORD_CLASS   reduce using rule 5 (SingletonObject -> ObjectDeclare block .)
    KEYWORD_OBJECT  reduce using rule 5 (SingletonObject -> ObjectDeclare block .)
    KEYWORD_VAR     reduce using rule 5 (SingletonObject -> ObjectDeclare block .)
    KEYWORD_VAL     reduce using rule 5 (SingletonObject -> ObjectDeclare block .)
    TERMINATOR      reduce using rule 5 (SingletonObject -> ObjectDeclare block .)
    KEYWORD_RETURN  reduce using rule 5 (SingletonObject -> ObjectDeclare block .)
    KEYWORD_DEF     reduce using rule 5 (SingletonObject -> ObjectDeclare block .)
    BLOCKBEGIN      reduce using rule 5 (SingletonObject -> ObjectDeclare block .)
    IDENTIFIER      reduce using rule 5 (SingletonObject -> ObjectDeclare block .)
    PLUS            reduce using rule 5 (SingletonObject -> ObjectDeclare block .)
    MINUS           reduce using rule 5 (SingletonObject -> ObjectDeclare block .)
    TILDA           reduce using rule 5 (SingletonObject -> ObjectDeclare block .)
    NOT             reduce using rule 5 (SingletonObject -> ObjectDeclare block .)
    LPAREN          reduce using rule 5 (SingletonObject -> ObjectDeclare block .)
    INT_NUMBER      reduce using rule 5 (SingletonObject -> ObjectDeclare block .)
    BOOL_CONSTT     reduce using rule 5 (SingletonObject -> ObjectDeclare block .)
    BOOL_CONSTF     reduce using rule 5 (SingletonObject -> ObjectDeclare block .)
    BLOCKEND        reduce using rule 5 (SingletonObject -> ObjectDeclare block .)
    $end            reduce using rule 5 (SingletonObject -> ObjectDeclare block .)


state 15

    (189) class_body -> class_body_start . block_statements_opt end_scope
    (10) block_statements_opt -> . block_statements
    (11) block_statements_opt -> . empty
    (12) block_statements -> . block_statement
    (13) block_statements -> . block_statements marker block_statement
    (191) empty -> .
    (14) block_statement -> . local_variable_declaration_statement
    (15) block_statement -> . statement
    (16) block_statement -> . class_declaration
    (17) block_statement -> . SingletonObject
    (18) block_statement -> . method_declaration
    (95) local_variable_declaration_statement -> . local_variable_declaration TERMINATOR
    (128) statement -> . normal_statement marker
    (129) statement -> . if_then_statement marker
    (130) statement -> . if_then_else_statement marker
    (131) statement -> . while_statement marker
    (132) statement -> . do_while_statement marker
    (133) statement -> . for_statement marker
    (177) class_declaration -> . class_header class_body
    (5) SingletonObject -> . ObjectDeclare block
    (165) method_declaration -> . method_header method_body
    (96) local_variable_declaration -> . declaration_keyword variable_declaration_body
    (134) normal_statement -> . block marker
    (135) normal_statement -> . expression_statement marker
    (136) normal_statement -> . empty_statement marker
    (137) normal_statement -> . return_statement marker
    (138) normal_statement -> . switch_statement marker
    (142) if_then_statement -> . KEYWORD_IF LPAREN expression RPAREN marker block
    (143) if_then_else_statement -> . KEYWORD_IF LPAREN expression RPAREN marker if_then_else_intermediate narker KEYWORD_ELSE marker block
    (147) while_statement -> . KEYWORD_WHILE LPAREN marker expression RPAREN marker block
    (148) do_while_statement -> . KEYWORD_DO marker block KEYWORD_WHILE LPAREN marker expression RPAREN TERMINATOR
    (149) for_statement -> . KEYWORD_FOR LPAREN for_update RPAREN marker block
    (178) class_header -> . KEYWORD_CLASS simple_name class_param_clause
    (6) ObjectDeclare -> . KEYWORD_OBJECT IDENTIFIER
    (166) method_header -> . method_header_name func_arg_start fun_params_opt RPAREN COLON method_return_type ASOP
    (93) declaration_keyword -> . KEYWORD_VAR
    (94) declaration_keyword -> . KEYWORD_VAL
    (7) block -> . start_scope block_statements_opt end_scope
    (139) expression_statement -> . statement_expression TERMINATOR
    (163) empty_statement -> . TERMINATOR
    (164) return_statement -> . KEYWORD_RETURN expression_optional TERMINATOR
    (156) switch_statement -> . expression KEYWORD_MATCH switch_block marker
    (174) method_header_name -> . KEYWORD_DEF IDENTIFIER
    (8) start_scope -> . BLOCKBEGIN
    (140) statement_expression -> . assignment
    (141) statement_expression -> . method_invocation
    (19) expression -> . assignment_expression
    (25) assignment -> . valid_variable assignment_operator assignment_expression
    (88) method_invocation -> . name LPAREN argument_list_opt RPAREN
    (22) assignment_expression -> . assignment
    (23) assignment_expression -> . conditional_or_expression
    (24) assignment_expression -> . method_invocation
    (26) valid_variable -> . name
    (27) valid_variable -> . array_access
    (121) name -> . simple_name
    (122) name -> . qualified_name
    (43) conditional_or_expression -> . conditional_and_expression
    (44) conditional_or_expression -> . conditional_or_expression OR marker conditional_and_expression
    (28) array_access -> . name dimension
    (123) simple_name -> . IDENTIFIER
    (124) qualified_name -> . name INST simple_name
    (45) conditional_and_expression -> . inclusive_or_expression
    (46) conditional_and_expression -> . conditional_and_expression AND marker inclusive_or_expression
    (47) inclusive_or_expression -> . exclusive_or_expression
    (48) inclusive_or_expression -> . inclusive_or_expression OR_BITWISE exclusive_or_expression
    (49) exclusive_or_expression -> . and_expression
    (50) exclusive_or_expression -> . exclusive_or_expression XOR and_expression
    (51) and_expression -> . equality_expression
    (52) and_expression -> . and_expression AND_BITWISE equality_expression
    (53) equality_expression -> . relational_expression
    (54) equality_expression -> . equality_expression EQUAL relational_expression
    (55) equality_expression -> . equality_expression NEQUAL relational_expression
    (56) relational_expression -> . shift_expression
    (57) relational_expression -> . relational_expression GREATER shift_expression
    (58) relational_expression -> . relational_expression LESS shift_expression
    (59) relational_expression -> . relational_expression GEQ shift_expression
    (60) relational_expression -> . relational_expression LEQ shift_expression
    (61) shift_expression -> . additive_expression
    (62) shift_expression -> . shift_expression LSHIFT additive_expression
    (63) shift_expression -> . shift_expression RSHIFT additive_expression
    (64) additive_expression -> . multiplicative_expression
    (65) additive_expression -> . additive_expression PLUS multiplicative_expression
    (66) additive_expression -> . additive_expression MINUS multiplicative_expression
    (67) multiplicative_expression -> . unary_expression
    (68) multiplicative_expression -> . multiplicative_expression TIMES unary_expression
    (69) multiplicative_expression -> . multiplicative_expression DIVIDE unary_expression
    (70) multiplicative_expression -> . multiplicative_expression REMAINDER unary_expression
    (71) unary_expression -> . PLUS unary_expression
    (72) unary_expression -> . MINUS unary_expression
    (73) unary_expression -> . unary_expression_not_plus_minus
    (74) unary_expression_not_plus_minus -> . base_variable_set
    (75) unary_expression_not_plus_minus -> . TILDA unary_expression
    (76) unary_expression_not_plus_minus -> . NOT unary_expression
    (77) base_variable_set -> . variable_literal
    (78) base_variable_set -> . LPAREN expression RPAREN
    (79) variable_literal -> . valid_variable
    (80) variable_literal -> . primary
    (81) primary -> . literal
    (82) primary -> . method_invocation
    (83) literal -> . int_float
    (84) literal -> . c_literal
    (87) int_float -> . INT_NUMBER
    (85) c_literal -> . BOOL_CONSTT
    (86) c_literal -> . BOOL_CONSTF

    BLOCKEND        reduce using rule 191 (empty -> .)
    KEYWORD_IF      shift and go to state 73
    KEYWORD_WHILE   shift and go to state 43
    KEYWORD_DO      shift and go to state 90
    KEYWORD_FOR     shift and go to state 89
    KEYWORD_CLASS   shift and go to state 1
    KEYWORD_OBJECT  shift and go to state 8
    KEYWORD_VAR     shift and go to state 46
    KEYWORD_VAL     shift and go to state 47
    TERMINATOR      shift and go to state 48
    KEYWORD_RETURN  shift and go to state 61
    KEYWORD_DEF     shift and go to state 72
    BLOCKBEGIN      shift and go to state 12
    IDENTIFIER      shift and go to state 9
    PLUS            shift and go to state 30
    MINUS           shift and go to state 24
    TILDA           shift and go to state 65
    NOT             shift and go to state 52
    LPAREN          shift and go to state 86
    INT_NUMBER      shift and go to state 38
    BOOL_CONSTT     shift and go to state 29
    BOOL_CONSTF     shift and go to state 25

    expression_statement           shift and go to state 22
    unary_expression               shift and go to state 39
    exclusive_or_expression        shift and go to state 56
    normal_statement               shift and go to state 78
    ObjectDeclare                  shift and go to state 3
    primary                        shift and go to state 57
    declaration_keyword            shift and go to state 70
    if_then_statement              shift and go to state 58
    array_access                   shift and go to state 23
    switch_statement               shift and go to state 41
    simple_name                    shift and go to state 60
    block_statements_opt           shift and go to state 91
    conditional_and_expression     shift and go to state 51
    qualified_name                 shift and go to state 71
    base_variable_set              shift and go to state 80
    inclusive_or_expression        shift and go to state 27
    method_declaration             shift and go to state 62
    literal                        shift and go to state 64
    block_statement                shift and go to state 63
    return_statement               shift and go to state 81
    while_statement                shift and go to state 28
    unary_expression_not_plus_minus shift and go to state 40
    and_expression                 shift and go to state 79
    statement                      shift and go to state 67
    c_literal                      shift and go to state 85
    statement_expression           shift and go to state 31
    method_invocation              shift and go to state 68
    conditional_or_expression      shift and go to state 42
    empty                          shift and go to state 69
    relational_expression          shift and go to state 66
    block_statements               shift and go to state 82
    for_statement                  shift and go to state 32
    local_variable_declaration_statement shift and go to state 33
    do_while_statement             shift and go to state 44
    int_float                      shift and go to state 34
    assignment                     shift and go to state 84
    multiplicative_expression      shift and go to state 45
    additive_expression            shift and go to state 59
    SingletonObject                shift and go to state 35
    start_scope                    shift and go to state 13
    method_header_name             shift and go to state 36
    class_header                   shift and go to state 7
    shift_expression               shift and go to state 49
    equality_expression            shift and go to state 74
    variable_literal               shift and go to state 50
    name                           shift and go to state 37
    valid_variable                 shift and go to state 87
    method_header                  shift and go to state 75
    empty_statement                shift and go to state 76
    class_declaration              shift and go to state 88
    local_variable_declaration     shift and go to state 77
    expression                     shift and go to state 53
    assignment_expression          shift and go to state 83
    block                          shift and go to state 54
    if_then_else_statement         shift and go to state 55

state 16

    (177) class_declaration -> class_header class_body .

    KEYWORD_OBJECT  reduce using rule 177 (class_declaration -> class_header class_body .)
    KEYWORD_CLASS   reduce using rule 177 (class_declaration -> class_header class_body .)
    $end            reduce using rule 177 (class_declaration -> class_header class_body .)
    KEYWORD_IF      reduce using rule 177 (class_declaration -> class_header class_body .)
    KEYWORD_WHILE   reduce using rule 177 (class_declaration -> class_header class_body .)
    KEYWORD_DO      reduce using rule 177 (class_declaration -> class_header class_body .)
    KEYWORD_FOR     reduce using rule 177 (class_declaration -> class_header class_body .)
    KEYWORD_VAR     reduce using rule 177 (class_declaration -> class_header class_body .)
    KEYWORD_VAL     reduce using rule 177 (class_declaration -> class_header class_body .)
    TERMINATOR      reduce using rule 177 (class_declaration -> class_header class_body .)
    KEYWORD_RETURN  reduce using rule 177 (class_declaration -> class_header class_body .)
    KEYWORD_DEF     reduce using rule 177 (class_declaration -> class_header class_body .)
    BLOCKBEGIN      reduce using rule 177 (class_declaration -> class_header class_body .)
    IDENTIFIER      reduce using rule 177 (class_declaration -> class_header class_body .)
    PLUS            reduce using rule 177 (class_declaration -> class_header class_body .)
    MINUS           reduce using rule 177 (class_declaration -> class_header class_body .)
    TILDA           reduce using rule 177 (class_declaration -> class_header class_body .)
    NOT             reduce using rule 177 (class_declaration -> class_header class_body .)
    LPAREN          reduce using rule 177 (class_declaration -> class_header class_body .)
    INT_NUMBER      reduce using rule 177 (class_declaration -> class_header class_body .)
    BOOL_CONSTT     reduce using rule 177 (class_declaration -> class_header class_body .)
    BOOL_CONSTF     reduce using rule 177 (class_declaration -> class_header class_body .)
    BLOCKEND        reduce using rule 177 (class_declaration -> class_header class_body .)


state 17

    (190) class_body_start -> BLOCKBEGIN .

    KEYWORD_IF      reduce using rule 190 (class_body_start -> BLOCKBEGIN .)
    KEYWORD_WHILE   reduce using rule 190 (class_body_start -> BLOCKBEGIN .)
    KEYWORD_DO      reduce using rule 190 (class_body_start -> BLOCKBEGIN .)
    KEYWORD_FOR     reduce using rule 190 (class_body_start -> BLOCKBEGIN .)
    KEYWORD_CLASS   reduce using rule 190 (class_body_start -> BLOCKBEGIN .)
    KEYWORD_OBJECT  reduce using rule 190 (class_body_start -> BLOCKBEGIN .)
    KEYWORD_VAR     reduce using rule 190 (class_body_start -> BLOCKBEGIN .)
    KEYWORD_VAL     reduce using rule 190 (class_body_start -> BLOCKBEGIN .)
    TERMINATOR      reduce using rule 190 (class_body_start -> BLOCKBEGIN .)
    KEYWORD_RETURN  reduce using rule 190 (class_body_start -> BLOCKBEGIN .)
    KEYWORD_DEF     reduce using rule 190 (class_body_start -> BLOCKBEGIN .)
    BLOCKBEGIN      reduce using rule 190 (class_body_start -> BLOCKBEGIN .)
    IDENTIFIER      reduce using rule 190 (class_body_start -> BLOCKBEGIN .)
    PLUS            reduce using rule 190 (class_body_start -> BLOCKBEGIN .)
    MINUS           reduce using rule 190 (class_body_start -> BLOCKBEGIN .)
    TILDA           reduce using rule 190 (class_body_start -> BLOCKBEGIN .)
    NOT             reduce using rule 190 (class_body_start -> BLOCKBEGIN .)
    LPAREN          reduce using rule 190 (class_body_start -> BLOCKBEGIN .)
    INT_NUMBER      reduce using rule 190 (class_body_start -> BLOCKBEGIN .)
    BOOL_CONSTT     reduce using rule 190 (class_body_start -> BLOCKBEGIN .)
    BOOL_CONSTF     reduce using rule 190 (class_body_start -> BLOCKBEGIN .)
    BLOCKEND        reduce using rule 190 (class_body_start -> BLOCKBEGIN .)


state 18

    (6) ObjectDeclare -> KEYWORD_OBJECT IDENTIFIER .

    BLOCKBEGIN      reduce using rule 6 (ObjectDeclare -> KEYWORD_OBJECT IDENTIFIER .)


state 19

    (179) class_param_clause -> func_arg_start . class_params_opt RPAREN
    (180) class_params_opt -> . class_params
    (181) class_params_opt -> . empty
    (182) class_params -> . class_param
    (183) class_params -> . class_params COMMA class_param
    (191) empty -> .
    (184) class_param -> . class_declaration_keyword_opt variable_declarator_id
    (185) class_declaration_keyword_opt -> . declaration_keyword
    (186) class_declaration_keyword_opt -> . empty
    (93) declaration_keyword -> . KEYWORD_VAR
    (94) declaration_keyword -> . KEYWORD_VAL

    RPAREN          reduce using rule 191 (empty -> .)
    IDENTIFIER      reduce using rule 191 (empty -> .)
    KEYWORD_VAR     shift and go to state 46
    KEYWORD_VAL     shift and go to state 47

    class_params_opt               shift and go to state 92
    declaration_keyword            shift and go to state 93
    class_param                    shift and go to state 94
    class_params                   shift and go to state 95
    empty                          shift and go to state 97
    class_declaration_keyword_opt  shift and go to state 96

state 20

    (178) class_header -> KEYWORD_CLASS simple_name class_param_clause .

    BLOCKBEGIN      reduce using rule 178 (class_header -> KEYWORD_CLASS simple_name class_param_clause .)


state 21

    (167) func_arg_start -> LPAREN .

    IDENTIFIER      reduce using rule 167 (func_arg_start -> LPAREN .)
    RPAREN          reduce using rule 167 (func_arg_start -> LPAREN .)
    KEYWORD_VAR     reduce using rule 167 (func_arg_start -> LPAREN .)
    KEYWORD_VAL     reduce using rule 167 (func_arg_start -> LPAREN .)


state 22

    (135) normal_statement -> expression_statement . marker
    (41) marker -> . empty
    (191) empty -> .

    KEYWORD_IF      reduce using rule 191 (empty -> .)
    KEYWORD_WHILE   reduce using rule 191 (empty -> .)
    KEYWORD_DO      reduce using rule 191 (empty -> .)
    KEYWORD_FOR     reduce using rule 191 (empty -> .)
    KEYWORD_CLASS   reduce using rule 191 (empty -> .)
    KEYWORD_OBJECT  reduce using rule 191 (empty -> .)
    KEYWORD_VAR     reduce using rule 191 (empty -> .)
    KEYWORD_VAL     reduce using rule 191 (empty -> .)
    TERMINATOR      reduce using rule 191 (empty -> .)
    KEYWORD_RETURN  reduce using rule 191 (empty -> .)
    KEYWORD_DEF     reduce using rule 191 (empty -> .)
    BLOCKBEGIN      reduce using rule 191 (empty -> .)
    IDENTIFIER      reduce using rule 191 (empty -> .)
    PLUS            reduce using rule 191 (empty -> .)
    MINUS           reduce using rule 191 (empty -> .)
    TILDA           reduce using rule 191 (empty -> .)
    NOT             reduce using rule 191 (empty -> .)
    LPAREN          reduce using rule 191 (empty -> .)
    INT_NUMBER      reduce using rule 191 (empty -> .)
    BOOL_CONSTT     reduce using rule 191 (empty -> .)
    BOOL_CONSTF     reduce using rule 191 (empty -> .)
    BLOCKEND        reduce using rule 191 (empty -> .)
    KEYWORD_ELSE    reduce using rule 191 (empty -> .)

    marker                         shift and go to state 98
    empty                          shift and go to state 99

state 23

    (27) valid_variable -> array_access .

    TIMES           reduce using rule 27 (valid_variable -> array_access .)
    DIVIDE          reduce using rule 27 (valid_variable -> array_access .)
    REMAINDER       reduce using rule 27 (valid_variable -> array_access .)
    PLUS            reduce using rule 27 (valid_variable -> array_access .)
    MINUS           reduce using rule 27 (valid_variable -> array_access .)
    LSHIFT          reduce using rule 27 (valid_variable -> array_access .)
    RSHIFT          reduce using rule 27 (valid_variable -> array_access .)
    GREATER         reduce using rule 27 (valid_variable -> array_access .)
    LESS            reduce using rule 27 (valid_variable -> array_access .)
    GEQ             reduce using rule 27 (valid_variable -> array_access .)
    LEQ             reduce using rule 27 (valid_variable -> array_access .)
    EQUAL           reduce using rule 27 (valid_variable -> array_access .)
    NEQUAL          reduce using rule 27 (valid_variable -> array_access .)
    AND_BITWISE     reduce using rule 27 (valid_variable -> array_access .)
    XOR             reduce using rule 27 (valid_variable -> array_access .)
    OR_BITWISE      reduce using rule 27 (valid_variable -> array_access .)
    AND             reduce using rule 27 (valid_variable -> array_access .)
    OR              reduce using rule 27 (valid_variable -> array_access .)
    KEYWORD_MATCH   reduce using rule 27 (valid_variable -> array_access .)
    TERMINATOR      reduce using rule 27 (valid_variable -> array_access .)
    RPAREN          reduce using rule 27 (valid_variable -> array_access .)
    RBRAC           reduce using rule 27 (valid_variable -> array_access .)
    COMMA           reduce using rule 27 (valid_variable -> array_access .)
    FUNTYPE         reduce using rule 27 (valid_variable -> array_access .)
    KEYWORD_UNTIL   reduce using rule 27 (valid_variable -> array_access .)
    KEYWORD_TO      reduce using rule 27 (valid_variable -> array_access .)
    KEYWORD_BY      reduce using rule 27 (valid_variable -> array_access .)
    ASOP            reduce using rule 27 (valid_variable -> array_access .)
    TIMES_ASSIGN    reduce using rule 27 (valid_variable -> array_access .)
    DIVIDE_ASSIGN   reduce using rule 27 (valid_variable -> array_access .)
    REMAINDER_ASSIGN reduce using rule 27 (valid_variable -> array_access .)
    PLUS_ASSIGN     reduce using rule 27 (valid_variable -> array_access .)
    MINUS_ASSIGN    reduce using rule 27 (valid_variable -> array_access .)
    LSHIFT_ASSIGN   reduce using rule 27 (valid_variable -> array_access .)
    RSHIFT_ASSIGN   reduce using rule 27 (valid_variable -> array_access .)
    AND_ASSIGN      reduce using rule 27 (valid_variable -> array_access .)
    OR_ASSIGN       reduce using rule 27 (valid_variable -> array_access .)
    XOR_ASSIGN      reduce using rule 27 (valid_variable -> array_access .)


state 24

    (72) unary_expression -> MINUS . unary_expression
    (71) unary_expression -> . PLUS unary_expression
    (72) unary_expression -> . MINUS unary_expression
    (73) unary_expression -> . unary_expression_not_plus_minus
    (74) unary_expression_not_plus_minus -> . base_variable_set
    (75) unary_expression_not_plus_minus -> . TILDA unary_expression
    (76) unary_expression_not_plus_minus -> . NOT unary_expression
    (77) base_variable_set -> . variable_literal
    (78) base_variable_set -> . LPAREN expression RPAREN
    (79) variable_literal -> . valid_variable
    (80) variable_literal -> . primary
    (26) valid_variable -> . name
    (27) valid_variable -> . array_access
    (81) primary -> . literal
    (82) primary -> . method_invocation
    (121) name -> . simple_name
    (122) name -> . qualified_name
    (28) array_access -> . name dimension
    (83) literal -> . int_float
    (84) literal -> . c_literal
    (88) method_invocation -> . name LPAREN argument_list_opt RPAREN
    (123) simple_name -> . IDENTIFIER
    (124) qualified_name -> . name INST simple_name
    (87) int_float -> . INT_NUMBER
    (85) c_literal -> . BOOL_CONSTT
    (86) c_literal -> . BOOL_CONSTF

    PLUS            shift and go to state 30
    MINUS           shift and go to state 24
    TILDA           shift and go to state 65
    NOT             shift and go to state 52
    LPAREN          shift and go to state 86
    IDENTIFIER      shift and go to state 9
    INT_NUMBER      shift and go to state 38
    BOOL_CONSTT     shift and go to state 29
    BOOL_CONSTF     shift and go to state 25

    qualified_name                 shift and go to state 71
    int_float                      shift and go to state 34
    c_literal                      shift and go to state 85
    variable_literal               shift and go to state 50
    unary_expression               shift and go to state 100
    base_variable_set              shift and go to state 80
    valid_variable                 shift and go to state 101
    array_access                   shift and go to state 23
    primary                        shift and go to state 57
    unary_expression_not_plus_minus shift and go to state 40
    literal                        shift and go to state 64
    method_invocation              shift and go to state 102
    simple_name                    shift and go to state 60
    name                           shift and go to state 103

state 25

    (86) c_literal -> BOOL_CONSTF .

    TIMES           reduce using rule 86 (c_literal -> BOOL_CONSTF .)
    DIVIDE          reduce using rule 86 (c_literal -> BOOL_CONSTF .)
    REMAINDER       reduce using rule 86 (c_literal -> BOOL_CONSTF .)
    PLUS            reduce using rule 86 (c_literal -> BOOL_CONSTF .)
    MINUS           reduce using rule 86 (c_literal -> BOOL_CONSTF .)
    LSHIFT          reduce using rule 86 (c_literal -> BOOL_CONSTF .)
    RSHIFT          reduce using rule 86 (c_literal -> BOOL_CONSTF .)
    GREATER         reduce using rule 86 (c_literal -> BOOL_CONSTF .)
    LESS            reduce using rule 86 (c_literal -> BOOL_CONSTF .)
    GEQ             reduce using rule 86 (c_literal -> BOOL_CONSTF .)
    LEQ             reduce using rule 86 (c_literal -> BOOL_CONSTF .)
    EQUAL           reduce using rule 86 (c_literal -> BOOL_CONSTF .)
    NEQUAL          reduce using rule 86 (c_literal -> BOOL_CONSTF .)
    AND_BITWISE     reduce using rule 86 (c_literal -> BOOL_CONSTF .)
    XOR             reduce using rule 86 (c_literal -> BOOL_CONSTF .)
    OR_BITWISE      reduce using rule 86 (c_literal -> BOOL_CONSTF .)
    AND             reduce using rule 86 (c_literal -> BOOL_CONSTF .)
    OR              reduce using rule 86 (c_literal -> BOOL_CONSTF .)
    RPAREN          reduce using rule 86 (c_literal -> BOOL_CONSTF .)
    KEYWORD_MATCH   reduce using rule 86 (c_literal -> BOOL_CONSTF .)
    TERMINATOR      reduce using rule 86 (c_literal -> BOOL_CONSTF .)
    RBRAC           reduce using rule 86 (c_literal -> BOOL_CONSTF .)
    COMMA           reduce using rule 86 (c_literal -> BOOL_CONSTF .)
    FUNTYPE         reduce using rule 86 (c_literal -> BOOL_CONSTF .)
    KEYWORD_UNTIL   reduce using rule 86 (c_literal -> BOOL_CONSTF .)
    KEYWORD_TO      reduce using rule 86 (c_literal -> BOOL_CONSTF .)
    KEYWORD_BY      reduce using rule 86 (c_literal -> BOOL_CONSTF .)


state 26

    (7) block -> start_scope block_statements_opt . end_scope
    (9) end_scope -> . BLOCKEND

    BLOCKEND        shift and go to state 104

    end_scope                      shift and go to state 105

state 27

    (45) conditional_and_expression -> inclusive_or_expression .
    (48) inclusive_or_expression -> inclusive_or_expression . OR_BITWISE exclusive_or_expression

    AND             reduce using rule 45 (conditional_and_expression -> inclusive_or_expression .)
    OR              reduce using rule 45 (conditional_and_expression -> inclusive_or_expression .)
    KEYWORD_UNTIL   reduce using rule 45 (conditional_and_expression -> inclusive_or_expression .)
    KEYWORD_TO      reduce using rule 45 (conditional_and_expression -> inclusive_or_expression .)
    RPAREN          reduce using rule 45 (conditional_and_expression -> inclusive_or_expression .)
    KEYWORD_MATCH   reduce using rule 45 (conditional_and_expression -> inclusive_or_expression .)
    COMMA           reduce using rule 45 (conditional_and_expression -> inclusive_or_expression .)
    TERMINATOR      reduce using rule 45 (conditional_and_expression -> inclusive_or_expression .)
    KEYWORD_BY      reduce using rule 45 (conditional_and_expression -> inclusive_or_expression .)
    FUNTYPE         reduce using rule 45 (conditional_and_expression -> inclusive_or_expression .)
    RBRAC           reduce using rule 45 (conditional_and_expression -> inclusive_or_expression .)
    OR_BITWISE      shift and go to state 106


state 28

    (131) statement -> while_statement . marker
    (41) marker -> . empty
    (191) empty -> .

    KEYWORD_IF      reduce using rule 191 (empty -> .)
    KEYWORD_WHILE   reduce using rule 191 (empty -> .)
    KEYWORD_DO      reduce using rule 191 (empty -> .)
    KEYWORD_FOR     reduce using rule 191 (empty -> .)
    KEYWORD_CLASS   reduce using rule 191 (empty -> .)
    KEYWORD_OBJECT  reduce using rule 191 (empty -> .)
    KEYWORD_VAR     reduce using rule 191 (empty -> .)
    KEYWORD_VAL     reduce using rule 191 (empty -> .)
    TERMINATOR      reduce using rule 191 (empty -> .)
    KEYWORD_RETURN  reduce using rule 191 (empty -> .)
    KEYWORD_DEF     reduce using rule 191 (empty -> .)
    BLOCKBEGIN      reduce using rule 191 (empty -> .)
    IDENTIFIER      reduce using rule 191 (empty -> .)
    PLUS            reduce using rule 191 (empty -> .)
    MINUS           reduce using rule 191 (empty -> .)
    TILDA           reduce using rule 191 (empty -> .)
    NOT             reduce using rule 191 (empty -> .)
    LPAREN          reduce using rule 191 (empty -> .)
    INT_NUMBER      reduce using rule 191 (empty -> .)
    BOOL_CONSTT     reduce using rule 191 (empty -> .)
    BOOL_CONSTF     reduce using rule 191 (empty -> .)
    BLOCKEND        reduce using rule 191 (empty -> .)

    marker                         shift and go to state 107
    empty                          shift and go to state 99

state 29

    (85) c_literal -> BOOL_CONSTT .

    TIMES           reduce using rule 85 (c_literal -> BOOL_CONSTT .)
    DIVIDE          reduce using rule 85 (c_literal -> BOOL_CONSTT .)
    REMAINDER       reduce using rule 85 (c_literal -> BOOL_CONSTT .)
    PLUS            reduce using rule 85 (c_literal -> BOOL_CONSTT .)
    MINUS           reduce using rule 85 (c_literal -> BOOL_CONSTT .)
    LSHIFT          reduce using rule 85 (c_literal -> BOOL_CONSTT .)
    RSHIFT          reduce using rule 85 (c_literal -> BOOL_CONSTT .)
    GREATER         reduce using rule 85 (c_literal -> BOOL_CONSTT .)
    LESS            reduce using rule 85 (c_literal -> BOOL_CONSTT .)
    GEQ             reduce using rule 85 (c_literal -> BOOL_CONSTT .)
    LEQ             reduce using rule 85 (c_literal -> BOOL_CONSTT .)
    EQUAL           reduce using rule 85 (c_literal -> BOOL_CONSTT .)
    NEQUAL          reduce using rule 85 (c_literal -> BOOL_CONSTT .)
    AND_BITWISE     reduce using rule 85 (c_literal -> BOOL_CONSTT .)
    XOR             reduce using rule 85 (c_literal -> BOOL_CONSTT .)
    OR_BITWISE      reduce using rule 85 (c_literal -> BOOL_CONSTT .)
    AND             reduce using rule 85 (c_literal -> BOOL_CONSTT .)
    OR              reduce using rule 85 (c_literal -> BOOL_CONSTT .)
    RPAREN          reduce using rule 85 (c_literal -> BOOL_CONSTT .)
    KEYWORD_MATCH   reduce using rule 85 (c_literal -> BOOL_CONSTT .)
    TERMINATOR      reduce using rule 85 (c_literal -> BOOL_CONSTT .)
    RBRAC           reduce using rule 85 (c_literal -> BOOL_CONSTT .)
    COMMA           reduce using rule 85 (c_literal -> BOOL_CONSTT .)
    FUNTYPE         reduce using rule 85 (c_literal -> BOOL_CONSTT .)
    KEYWORD_UNTIL   reduce using rule 85 (c_literal -> BOOL_CONSTT .)
    KEYWORD_TO      reduce using rule 85 (c_literal -> BOOL_CONSTT .)
    KEYWORD_BY      reduce using rule 85 (c_literal -> BOOL_CONSTT .)


state 30

    (71) unary_expression -> PLUS . unary_expression
    (71) unary_expression -> . PLUS unary_expression
    (72) unary_expression -> . MINUS unary_expression
    (73) unary_expression -> . unary_expression_not_plus_minus
    (74) unary_expression_not_plus_minus -> . base_variable_set
    (75) unary_expression_not_plus_minus -> . TILDA unary_expression
    (76) unary_expression_not_plus_minus -> . NOT unary_expression
    (77) base_variable_set -> . variable_literal
    (78) base_variable_set -> . LPAREN expression RPAREN
    (79) variable_literal -> . valid_variable
    (80) variable_literal -> . primary
    (26) valid_variable -> . name
    (27) valid_variable -> . array_access
    (81) primary -> . literal
    (82) primary -> . method_invocation
    (121) name -> . simple_name
    (122) name -> . qualified_name
    (28) array_access -> . name dimension
    (83) literal -> . int_float
    (84) literal -> . c_literal
    (88) method_invocation -> . name LPAREN argument_list_opt RPAREN
    (123) simple_name -> . IDENTIFIER
    (124) qualified_name -> . name INST simple_name
    (87) int_float -> . INT_NUMBER
    (85) c_literal -> . BOOL_CONSTT
    (86) c_literal -> . BOOL_CONSTF

    PLUS            shift and go to state 30
    MINUS           shift and go to state 24
    TILDA           shift and go to state 65
    NOT             shift and go to state 52
    LPAREN          shift and go to state 86
    IDENTIFIER      shift and go to state 9
    INT_NUMBER      shift and go to state 38
    BOOL_CONSTT     shift and go to state 29
    BOOL_CONSTF     shift and go to state 25

    qualified_name                 shift and go to state 71
    int_float                      shift and go to state 34
    c_literal                      shift and go to state 85
    variable_literal               shift and go to state 50
    unary_expression               shift and go to state 108
    base_variable_set              shift and go to state 80
    valid_variable                 shift and go to state 101
    array_access                   shift and go to state 23
    primary                        shift and go to state 57
    unary_expression_not_plus_minus shift and go to state 40
    literal                        shift and go to state 64
    method_invocation              shift and go to state 102
    simple_name                    shift and go to state 60
    name                           shift and go to state 103

state 31

    (139) expression_statement -> statement_expression . TERMINATOR

    TERMINATOR      shift and go to state 109


state 32

    (133) statement -> for_statement . marker
    (41) marker -> . empty
    (191) empty -> .

    KEYWORD_IF      reduce using rule 191 (empty -> .)
    KEYWORD_WHILE   reduce using rule 191 (empty -> .)
    KEYWORD_DO      reduce using rule 191 (empty -> .)
    KEYWORD_FOR     reduce using rule 191 (empty -> .)
    KEYWORD_CLASS   reduce using rule 191 (empty -> .)
    KEYWORD_OBJECT  reduce using rule 191 (empty -> .)
    KEYWORD_VAR     reduce using rule 191 (empty -> .)
    KEYWORD_VAL     reduce using rule 191 (empty -> .)
    TERMINATOR      reduce using rule 191 (empty -> .)
    KEYWORD_RETURN  reduce using rule 191 (empty -> .)
    KEYWORD_DEF     reduce using rule 191 (empty -> .)
    BLOCKBEGIN      reduce using rule 191 (empty -> .)
    IDENTIFIER      reduce using rule 191 (empty -> .)
    PLUS            reduce using rule 191 (empty -> .)
    MINUS           reduce using rule 191 (empty -> .)
    TILDA           reduce using rule 191 (empty -> .)
    NOT             reduce using rule 191 (empty -> .)
    LPAREN          reduce using rule 191 (empty -> .)
    INT_NUMBER      reduce using rule 191 (empty -> .)
    BOOL_CONSTT     reduce using rule 191 (empty -> .)
    BOOL_CONSTF     reduce using rule 191 (empty -> .)
    BLOCKEND        reduce using rule 191 (empty -> .)

    marker                         shift and go to state 110
    empty                          shift and go to state 99

state 33

    (14) block_statement -> local_variable_declaration_statement .

    KEYWORD_IF      reduce using rule 14 (block_statement -> local_variable_declaration_statement .)
    KEYWORD_WHILE   reduce using rule 14 (block_statement -> local_variable_declaration_statement .)
    KEYWORD_DO      reduce using rule 14 (block_statement -> local_variable_declaration_statement .)
    KEYWORD_FOR     reduce using rule 14 (block_statement -> local_variable_declaration_statement .)
    KEYWORD_CLASS   reduce using rule 14 (block_statement -> local_variable_declaration_statement .)
    KEYWORD_OBJECT  reduce using rule 14 (block_statement -> local_variable_declaration_statement .)
    KEYWORD_VAR     reduce using rule 14 (block_statement -> local_variable_declaration_statement .)
    KEYWORD_VAL     reduce using rule 14 (block_statement -> local_variable_declaration_statement .)
    TERMINATOR      reduce using rule 14 (block_statement -> local_variable_declaration_statement .)
    KEYWORD_RETURN  reduce using rule 14 (block_statement -> local_variable_declaration_statement .)
    KEYWORD_DEF     reduce using rule 14 (block_statement -> local_variable_declaration_statement .)
    BLOCKBEGIN      reduce using rule 14 (block_statement -> local_variable_declaration_statement .)
    IDENTIFIER      reduce using rule 14 (block_statement -> local_variable_declaration_statement .)
    PLUS            reduce using rule 14 (block_statement -> local_variable_declaration_statement .)
    MINUS           reduce using rule 14 (block_statement -> local_variable_declaration_statement .)
    TILDA           reduce using rule 14 (block_statement -> local_variable_declaration_statement .)
    NOT             reduce using rule 14 (block_statement -> local_variable_declaration_statement .)
    LPAREN          reduce using rule 14 (block_statement -> local_variable_declaration_statement .)
    INT_NUMBER      reduce using rule 14 (block_statement -> local_variable_declaration_statement .)
    BOOL_CONSTT     reduce using rule 14 (block_statement -> local_variable_declaration_statement .)
    BOOL_CONSTF     reduce using rule 14 (block_statement -> local_variable_declaration_statement .)
    BLOCKEND        reduce using rule 14 (block_statement -> local_variable_declaration_statement .)


state 34

    (83) literal -> int_float .

    TIMES           reduce using rule 83 (literal -> int_float .)
    DIVIDE          reduce using rule 83 (literal -> int_float .)
    REMAINDER       reduce using rule 83 (literal -> int_float .)
    PLUS            reduce using rule 83 (literal -> int_float .)
    MINUS           reduce using rule 83 (literal -> int_float .)
    LSHIFT          reduce using rule 83 (literal -> int_float .)
    RSHIFT          reduce using rule 83 (literal -> int_float .)
    GREATER         reduce using rule 83 (literal -> int_float .)
    LESS            reduce using rule 83 (literal -> int_float .)
    GEQ             reduce using rule 83 (literal -> int_float .)
    LEQ             reduce using rule 83 (literal -> int_float .)
    EQUAL           reduce using rule 83 (literal -> int_float .)
    NEQUAL          reduce using rule 83 (literal -> int_float .)
    AND_BITWISE     reduce using rule 83 (literal -> int_float .)
    XOR             reduce using rule 83 (literal -> int_float .)
    OR_BITWISE      reduce using rule 83 (literal -> int_float .)
    AND             reduce using rule 83 (literal -> int_float .)
    OR              reduce using rule 83 (literal -> int_float .)
    KEYWORD_MATCH   reduce using rule 83 (literal -> int_float .)
    FUNTYPE         reduce using rule 83 (literal -> int_float .)
    TERMINATOR      reduce using rule 83 (literal -> int_float .)
    RPAREN          reduce using rule 83 (literal -> int_float .)
    RBRAC           reduce using rule 83 (literal -> int_float .)
    COMMA           reduce using rule 83 (literal -> int_float .)
    KEYWORD_UNTIL   reduce using rule 83 (literal -> int_float .)
    KEYWORD_TO      reduce using rule 83 (literal -> int_float .)
    KEYWORD_BY      reduce using rule 83 (literal -> int_float .)


state 35

    (17) block_statement -> SingletonObject .

    KEYWORD_IF      reduce using rule 17 (block_statement -> SingletonObject .)
    KEYWORD_WHILE   reduce using rule 17 (block_statement -> SingletonObject .)
    KEYWORD_DO      reduce using rule 17 (block_statement -> SingletonObject .)
    KEYWORD_FOR     reduce using rule 17 (block_statement -> SingletonObject .)
    KEYWORD_CLASS   reduce using rule 17 (block_statement -> SingletonObject .)
    KEYWORD_OBJECT  reduce using rule 17 (block_statement -> SingletonObject .)
    KEYWORD_VAR     reduce using rule 17 (block_statement -> SingletonObject .)
    KEYWORD_VAL     reduce using rule 17 (block_statement -> SingletonObject .)
    TERMINATOR      reduce using rule 17 (block_statement -> SingletonObject .)
    KEYWORD_RETURN  reduce using rule 17 (block_statement -> SingletonObject .)
    KEYWORD_DEF     reduce using rule 17 (block_statement -> SingletonObject .)
    BLOCKBEGIN      reduce using rule 17 (block_statement -> SingletonObject .)
    IDENTIFIER      reduce using rule 17 (block_statement -> SingletonObject .)
    PLUS            reduce using rule 17 (block_statement -> SingletonObject .)
    MINUS           reduce using rule 17 (block_statement -> SingletonObject .)
    TILDA           reduce using rule 17 (block_statement -> SingletonObject .)
    NOT             reduce using rule 17 (block_statement -> SingletonObject .)
    LPAREN          reduce using rule 17 (block_statement -> SingletonObject .)
    INT_NUMBER      reduce using rule 17 (block_statement -> SingletonObject .)
    BOOL_CONSTT     reduce using rule 17 (block_statement -> SingletonObject .)
    BOOL_CONSTF     reduce using rule 17 (block_statement -> SingletonObject .)
    BLOCKEND        reduce using rule 17 (block_statement -> SingletonObject .)


state 36

    (166) method_header -> method_header_name . func_arg_start fun_params_opt RPAREN COLON method_return_type ASOP
    (167) func_arg_start -> . LPAREN

    LPAREN          shift and go to state 21

    func_arg_start                 shift and go to state 111

state 37

    (88) method_invocation -> name . LPAREN argument_list_opt RPAREN
    (26) valid_variable -> name .
    (28) array_access -> name . dimension
    (124) qualified_name -> name . INST simple_name
    (29) dimension -> . LBRAC expression RBRAC

    LPAREN          shift and go to state 114
    ASOP            reduce using rule 26 (valid_variable -> name .)
    TIMES_ASSIGN    reduce using rule 26 (valid_variable -> name .)
    DIVIDE_ASSIGN   reduce using rule 26 (valid_variable -> name .)
    REMAINDER_ASSIGN reduce using rule 26 (valid_variable -> name .)
    PLUS_ASSIGN     reduce using rule 26 (valid_variable -> name .)
    MINUS_ASSIGN    reduce using rule 26 (valid_variable -> name .)
    LSHIFT_ASSIGN   reduce using rule 26 (valid_variable -> name .)
    RSHIFT_ASSIGN   reduce using rule 26 (valid_variable -> name .)
    AND_ASSIGN      reduce using rule 26 (valid_variable -> name .)
    OR_ASSIGN       reduce using rule 26 (valid_variable -> name .)
    XOR_ASSIGN      reduce using rule 26 (valid_variable -> name .)
    TIMES           reduce using rule 26 (valid_variable -> name .)
    DIVIDE          reduce using rule 26 (valid_variable -> name .)
    REMAINDER       reduce using rule 26 (valid_variable -> name .)
    PLUS            reduce using rule 26 (valid_variable -> name .)
    MINUS           reduce using rule 26 (valid_variable -> name .)
    LSHIFT          reduce using rule 26 (valid_variable -> name .)
    RSHIFT          reduce using rule 26 (valid_variable -> name .)
    GREATER         reduce using rule 26 (valid_variable -> name .)
    LESS            reduce using rule 26 (valid_variable -> name .)
    GEQ             reduce using rule 26 (valid_variable -> name .)
    LEQ             reduce using rule 26 (valid_variable -> name .)
    EQUAL           reduce using rule 26 (valid_variable -> name .)
    NEQUAL          reduce using rule 26 (valid_variable -> name .)
    AND_BITWISE     reduce using rule 26 (valid_variable -> name .)
    XOR             reduce using rule 26 (valid_variable -> name .)
    OR_BITWISE      reduce using rule 26 (valid_variable -> name .)
    AND             reduce using rule 26 (valid_variable -> name .)
    OR              reduce using rule 26 (valid_variable -> name .)
    COMMA           reduce using rule 26 (valid_variable -> name .)
    RPAREN          reduce using rule 26 (valid_variable -> name .)
    KEYWORD_MATCH   reduce using rule 26 (valid_variable -> name .)
    FUNTYPE         reduce using rule 26 (valid_variable -> name .)
    RBRAC           reduce using rule 26 (valid_variable -> name .)
    KEYWORD_UNTIL   reduce using rule 26 (valid_variable -> name .)
    KEYWORD_TO      reduce using rule 26 (valid_variable -> name .)
    TERMINATOR      reduce using rule 26 (valid_variable -> name .)
    KEYWORD_BY      reduce using rule 26 (valid_variable -> name .)
    INST            shift and go to state 113
    LBRAC           shift and go to state 112

    dimension                      shift and go to state 115

state 38

    (87) int_float -> INT_NUMBER .

    TIMES           reduce using rule 87 (int_float -> INT_NUMBER .)
    DIVIDE          reduce using rule 87 (int_float -> INT_NUMBER .)
    REMAINDER       reduce using rule 87 (int_float -> INT_NUMBER .)
    PLUS            reduce using rule 87 (int_float -> INT_NUMBER .)
    MINUS           reduce using rule 87 (int_float -> INT_NUMBER .)
    LSHIFT          reduce using rule 87 (int_float -> INT_NUMBER .)
    RSHIFT          reduce using rule 87 (int_float -> INT_NUMBER .)
    GREATER         reduce using rule 87 (int_float -> INT_NUMBER .)
    LESS            reduce using rule 87 (int_float -> INT_NUMBER .)
    GEQ             reduce using rule 87 (int_float -> INT_NUMBER .)
    LEQ             reduce using rule 87 (int_float -> INT_NUMBER .)
    EQUAL           reduce using rule 87 (int_float -> INT_NUMBER .)
    NEQUAL          reduce using rule 87 (int_float -> INT_NUMBER .)
    AND_BITWISE     reduce using rule 87 (int_float -> INT_NUMBER .)
    XOR             reduce using rule 87 (int_float -> INT_NUMBER .)
    OR_BITWISE      reduce using rule 87 (int_float -> INT_NUMBER .)
    AND             reduce using rule 87 (int_float -> INT_NUMBER .)
    OR              reduce using rule 87 (int_float -> INT_NUMBER .)
    KEYWORD_MATCH   reduce using rule 87 (int_float -> INT_NUMBER .)
    TERMINATOR      reduce using rule 87 (int_float -> INT_NUMBER .)
    RPAREN          reduce using rule 87 (int_float -> INT_NUMBER .)
    RBRAC           reduce using rule 87 (int_float -> INT_NUMBER .)
    COMMA           reduce using rule 87 (int_float -> INT_NUMBER .)
    FUNTYPE         reduce using rule 87 (int_float -> INT_NUMBER .)
    KEYWORD_UNTIL   reduce using rule 87 (int_float -> INT_NUMBER .)
    KEYWORD_TO      reduce using rule 87 (int_float -> INT_NUMBER .)
    KEYWORD_BY      reduce using rule 87 (int_float -> INT_NUMBER .)


state 39

    (67) multiplicative_expression -> unary_expression .

    TIMES           reduce using rule 67 (multiplicative_expression -> unary_expression .)
    DIVIDE          reduce using rule 67 (multiplicative_expression -> unary_expression .)
    REMAINDER       reduce using rule 67 (multiplicative_expression -> unary_expression .)
    PLUS            reduce using rule 67 (multiplicative_expression -> unary_expression .)
    MINUS           reduce using rule 67 (multiplicative_expression -> unary_expression .)
    LSHIFT          reduce using rule 67 (multiplicative_expression -> unary_expression .)
    RSHIFT          reduce using rule 67 (multiplicative_expression -> unary_expression .)
    GREATER         reduce using rule 67 (multiplicative_expression -> unary_expression .)
    LESS            reduce using rule 67 (multiplicative_expression -> unary_expression .)
    GEQ             reduce using rule 67 (multiplicative_expression -> unary_expression .)
    LEQ             reduce using rule 67 (multiplicative_expression -> unary_expression .)
    EQUAL           reduce using rule 67 (multiplicative_expression -> unary_expression .)
    NEQUAL          reduce using rule 67 (multiplicative_expression -> unary_expression .)
    AND_BITWISE     reduce using rule 67 (multiplicative_expression -> unary_expression .)
    XOR             reduce using rule 67 (multiplicative_expression -> unary_expression .)
    OR_BITWISE      reduce using rule 67 (multiplicative_expression -> unary_expression .)
    AND             reduce using rule 67 (multiplicative_expression -> unary_expression .)
    OR              reduce using rule 67 (multiplicative_expression -> unary_expression .)
    KEYWORD_MATCH   reduce using rule 67 (multiplicative_expression -> unary_expression .)
    TERMINATOR      reduce using rule 67 (multiplicative_expression -> unary_expression .)
    RPAREN          reduce using rule 67 (multiplicative_expression -> unary_expression .)
    RBRAC           reduce using rule 67 (multiplicative_expression -> unary_expression .)
    COMMA           reduce using rule 67 (multiplicative_expression -> unary_expression .)
    FUNTYPE         reduce using rule 67 (multiplicative_expression -> unary_expression .)
    KEYWORD_UNTIL   reduce using rule 67 (multiplicative_expression -> unary_expression .)
    KEYWORD_TO      reduce using rule 67 (multiplicative_expression -> unary_expression .)
    KEYWORD_BY      reduce using rule 67 (multiplicative_expression -> unary_expression .)


state 40

    (73) unary_expression -> unary_expression_not_plus_minus .

    TIMES           reduce using rule 73 (unary_expression -> unary_expression_not_plus_minus .)
    DIVIDE          reduce using rule 73 (unary_expression -> unary_expression_not_plus_minus .)
    REMAINDER       reduce using rule 73 (unary_expression -> unary_expression_not_plus_minus .)
    PLUS            reduce using rule 73 (unary_expression -> unary_expression_not_plus_minus .)
    MINUS           reduce using rule 73 (unary_expression -> unary_expression_not_plus_minus .)
    LSHIFT          reduce using rule 73 (unary_expression -> unary_expression_not_plus_minus .)
    RSHIFT          reduce using rule 73 (unary_expression -> unary_expression_not_plus_minus .)
    GREATER         reduce using rule 73 (unary_expression -> unary_expression_not_plus_minus .)
    LESS            reduce using rule 73 (unary_expression -> unary_expression_not_plus_minus .)
    GEQ             reduce using rule 73 (unary_expression -> unary_expression_not_plus_minus .)
    LEQ             reduce using rule 73 (unary_expression -> unary_expression_not_plus_minus .)
    EQUAL           reduce using rule 73 (unary_expression -> unary_expression_not_plus_minus .)
    NEQUAL          reduce using rule 73 (unary_expression -> unary_expression_not_plus_minus .)
    AND_BITWISE     reduce using rule 73 (unary_expression -> unary_expression_not_plus_minus .)
    XOR             reduce using rule 73 (unary_expression -> unary_expression_not_plus_minus .)
    OR_BITWISE      reduce using rule 73 (unary_expression -> unary_expression_not_plus_minus .)
    AND             reduce using rule 73 (unary_expression -> unary_expression_not_plus_minus .)
    OR              reduce using rule 73 (unary_expression -> unary_expression_not_plus_minus .)
    COMMA           reduce using rule 73 (unary_expression -> unary_expression_not_plus_minus .)
    RPAREN          reduce using rule 73 (unary_expression -> unary_expression_not_plus_minus .)
    KEYWORD_MATCH   reduce using rule 73 (unary_expression -> unary_expression_not_plus_minus .)
    TERMINATOR      reduce using rule 73 (unary_expression -> unary_expression_not_plus_minus .)
    RBRAC           reduce using rule 73 (unary_expression -> unary_expression_not_plus_minus .)
    FUNTYPE         reduce using rule 73 (unary_expression -> unary_expression_not_plus_minus .)
    KEYWORD_UNTIL   reduce using rule 73 (unary_expression -> unary_expression_not_plus_minus .)
    KEYWORD_TO      reduce using rule 73 (unary_expression -> unary_expression_not_plus_minus .)
    KEYWORD_BY      reduce using rule 73 (unary_expression -> unary_expression_not_plus_minus .)


state 41

    (138) normal_statement -> switch_statement . marker
    (41) marker -> . empty
    (191) empty -> .

    KEYWORD_IF      reduce using rule 191 (empty -> .)
    KEYWORD_WHILE   reduce using rule 191 (empty -> .)
    KEYWORD_DO      reduce using rule 191 (empty -> .)
    KEYWORD_FOR     reduce using rule 191 (empty -> .)
    KEYWORD_CLASS   reduce using rule 191 (empty -> .)
    KEYWORD_OBJECT  reduce using rule 191 (empty -> .)
    KEYWORD_VAR     reduce using rule 191 (empty -> .)
    KEYWORD_VAL     reduce using rule 191 (empty -> .)
    TERMINATOR      reduce using rule 191 (empty -> .)
    KEYWORD_RETURN  reduce using rule 191 (empty -> .)
    KEYWORD_DEF     reduce using rule 191 (empty -> .)
    BLOCKBEGIN      reduce using rule 191 (empty -> .)
    IDENTIFIER      reduce using rule 191 (empty -> .)
    PLUS            reduce using rule 191 (empty -> .)
    MINUS           reduce using rule 191 (empty -> .)
    TILDA           reduce using rule 191 (empty -> .)
    NOT             reduce using rule 191 (empty -> .)
    LPAREN          reduce using rule 191 (empty -> .)
    INT_NUMBER      reduce using rule 191 (empty -> .)
    BOOL_CONSTT     reduce using rule 191 (empty -> .)
    BOOL_CONSTF     reduce using rule 191 (empty -> .)
    BLOCKEND        reduce using rule 191 (empty -> .)
    KEYWORD_ELSE    reduce using rule 191 (empty -> .)

    marker                         shift and go to state 116
    empty                          shift and go to state 99

state 42

    (23) assignment_expression -> conditional_or_expression .
    (44) conditional_or_expression -> conditional_or_expression . OR marker conditional_and_expression

    KEYWORD_MATCH   reduce using rule 23 (assignment_expression -> conditional_or_expression .)
    RBRAC           reduce using rule 23 (assignment_expression -> conditional_or_expression .)
    RPAREN          reduce using rule 23 (assignment_expression -> conditional_or_expression .)
    COMMA           reduce using rule 23 (assignment_expression -> conditional_or_expression .)
    KEYWORD_BY      reduce using rule 23 (assignment_expression -> conditional_or_expression .)
    KEYWORD_UNTIL   reduce using rule 23 (assignment_expression -> conditional_or_expression .)
    KEYWORD_TO      reduce using rule 23 (assignment_expression -> conditional_or_expression .)
    FUNTYPE         reduce using rule 23 (assignment_expression -> conditional_or_expression .)
    TERMINATOR      reduce using rule 23 (assignment_expression -> conditional_or_expression .)
    OR              shift and go to state 117


state 43

    (147) while_statement -> KEYWORD_WHILE . LPAREN marker expression RPAREN marker block

    LPAREN          shift and go to state 118


state 44

    (132) statement -> do_while_statement . marker
    (41) marker -> . empty
    (191) empty -> .

    KEYWORD_IF      reduce using rule 191 (empty -> .)
    KEYWORD_WHILE   reduce using rule 191 (empty -> .)
    KEYWORD_DO      reduce using rule 191 (empty -> .)
    KEYWORD_FOR     reduce using rule 191 (empty -> .)
    KEYWORD_CLASS   reduce using rule 191 (empty -> .)
    KEYWORD_OBJECT  reduce using rule 191 (empty -> .)
    KEYWORD_VAR     reduce using rule 191 (empty -> .)
    KEYWORD_VAL     reduce using rule 191 (empty -> .)
    TERMINATOR      reduce using rule 191 (empty -> .)
    KEYWORD_RETURN  reduce using rule 191 (empty -> .)
    KEYWORD_DEF     reduce using rule 191 (empty -> .)
    BLOCKBEGIN      reduce using rule 191 (empty -> .)
    IDENTIFIER      reduce using rule 191 (empty -> .)
    PLUS            reduce using rule 191 (empty -> .)
    MINUS           reduce using rule 191 (empty -> .)
    TILDA           reduce using rule 191 (empty -> .)
    NOT             reduce using rule 191 (empty -> .)
    LPAREN          reduce using rule 191 (empty -> .)
    INT_NUMBER      reduce using rule 191 (empty -> .)
    BOOL_CONSTT     reduce using rule 191 (empty -> .)
    BOOL_CONSTF     reduce using rule 191 (empty -> .)
    BLOCKEND        reduce using rule 191 (empty -> .)

    marker                         shift and go to state 119
    empty                          shift and go to state 99

state 45

    (64) additive_expression -> multiplicative_expression .
    (68) multiplicative_expression -> multiplicative_expression . TIMES unary_expression
    (69) multiplicative_expression -> multiplicative_expression . DIVIDE unary_expression
    (70) multiplicative_expression -> multiplicative_expression . REMAINDER unary_expression

    PLUS            reduce using rule 64 (additive_expression -> multiplicative_expression .)
    MINUS           reduce using rule 64 (additive_expression -> multiplicative_expression .)
    LSHIFT          reduce using rule 64 (additive_expression -> multiplicative_expression .)
    RSHIFT          reduce using rule 64 (additive_expression -> multiplicative_expression .)
    GREATER         reduce using rule 64 (additive_expression -> multiplicative_expression .)
    LESS            reduce using rule 64 (additive_expression -> multiplicative_expression .)
    GEQ             reduce using rule 64 (additive_expression -> multiplicative_expression .)
    LEQ             reduce using rule 64 (additive_expression -> multiplicative_expression .)
    EQUAL           reduce using rule 64 (additive_expression -> multiplicative_expression .)
    NEQUAL          reduce using rule 64 (additive_expression -> multiplicative_expression .)
    AND_BITWISE     reduce using rule 64 (additive_expression -> multiplicative_expression .)
    XOR             reduce using rule 64 (additive_expression -> multiplicative_expression .)
    OR_BITWISE      reduce using rule 64 (additive_expression -> multiplicative_expression .)
    AND             reduce using rule 64 (additive_expression -> multiplicative_expression .)
    OR              reduce using rule 64 (additive_expression -> multiplicative_expression .)
    KEYWORD_MATCH   reduce using rule 64 (additive_expression -> multiplicative_expression .)
    TERMINATOR      reduce using rule 64 (additive_expression -> multiplicative_expression .)
    RPAREN          reduce using rule 64 (additive_expression -> multiplicative_expression .)
    RBRAC           reduce using rule 64 (additive_expression -> multiplicative_expression .)
    COMMA           reduce using rule 64 (additive_expression -> multiplicative_expression .)
    FUNTYPE         reduce using rule 64 (additive_expression -> multiplicative_expression .)
    KEYWORD_UNTIL   reduce using rule 64 (additive_expression -> multiplicative_expression .)
    KEYWORD_TO      reduce using rule 64 (additive_expression -> multiplicative_expression .)
    KEYWORD_BY      reduce using rule 64 (additive_expression -> multiplicative_expression .)
    TIMES           shift and go to state 122
    DIVIDE          shift and go to state 121
    REMAINDER       shift and go to state 120


state 46

    (93) declaration_keyword -> KEYWORD_VAR .

    IDENTIFIER      reduce using rule 93 (declaration_keyword -> KEYWORD_VAR .)


state 47

    (94) declaration_keyword -> KEYWORD_VAL .

    IDENTIFIER      reduce using rule 94 (declaration_keyword -> KEYWORD_VAL .)


state 48

    (163) empty_statement -> TERMINATOR .

    KEYWORD_ELSE    reduce using rule 163 (empty_statement -> TERMINATOR .)
    KEYWORD_IF      reduce using rule 163 (empty_statement -> TERMINATOR .)
    KEYWORD_WHILE   reduce using rule 163 (empty_statement -> TERMINATOR .)
    KEYWORD_DO      reduce using rule 163 (empty_statement -> TERMINATOR .)
    KEYWORD_FOR     reduce using rule 163 (empty_statement -> TERMINATOR .)
    KEYWORD_CLASS   reduce using rule 163 (empty_statement -> TERMINATOR .)
    KEYWORD_OBJECT  reduce using rule 163 (empty_statement -> TERMINATOR .)
    KEYWORD_VAR     reduce using rule 163 (empty_statement -> TERMINATOR .)
    KEYWORD_VAL     reduce using rule 163 (empty_statement -> TERMINATOR .)
    TERMINATOR      reduce using rule 163 (empty_statement -> TERMINATOR .)
    KEYWORD_RETURN  reduce using rule 163 (empty_statement -> TERMINATOR .)
    KEYWORD_DEF     reduce using rule 163 (empty_statement -> TERMINATOR .)
    BLOCKBEGIN      reduce using rule 163 (empty_statement -> TERMINATOR .)
    IDENTIFIER      reduce using rule 163 (empty_statement -> TERMINATOR .)
    PLUS            reduce using rule 163 (empty_statement -> TERMINATOR .)
    MINUS           reduce using rule 163 (empty_statement -> TERMINATOR .)
    TILDA           reduce using rule 163 (empty_statement -> TERMINATOR .)
    NOT             reduce using rule 163 (empty_statement -> TERMINATOR .)
    LPAREN          reduce using rule 163 (empty_statement -> TERMINATOR .)
    INT_NUMBER      reduce using rule 163 (empty_statement -> TERMINATOR .)
    BOOL_CONSTT     reduce using rule 163 (empty_statement -> TERMINATOR .)
    BOOL_CONSTF     reduce using rule 163 (empty_statement -> TERMINATOR .)
    BLOCKEND        reduce using rule 163 (empty_statement -> TERMINATOR .)


state 49

    (56) relational_expression -> shift_expression .
    (62) shift_expression -> shift_expression . LSHIFT additive_expression
    (63) shift_expression -> shift_expression . RSHIFT additive_expression

    GREATER         reduce using rule 56 (relational_expression -> shift_expression .)
    LESS            reduce using rule 56 (relational_expression -> shift_expression .)
    GEQ             reduce using rule 56 (relational_expression -> shift_expression .)
    LEQ             reduce using rule 56 (relational_expression -> shift_expression .)
    EQUAL           reduce using rule 56 (relational_expression -> shift_expression .)
    NEQUAL          reduce using rule 56 (relational_expression -> shift_expression .)
    AND_BITWISE     reduce using rule 56 (relational_expression -> shift_expression .)
    XOR             reduce using rule 56 (relational_expression -> shift_expression .)
    OR_BITWISE      reduce using rule 56 (relational_expression -> shift_expression .)
    AND             reduce using rule 56 (relational_expression -> shift_expression .)
    OR              reduce using rule 56 (relational_expression -> shift_expression .)
    RPAREN          reduce using rule 56 (relational_expression -> shift_expression .)
    COMMA           reduce using rule 56 (relational_expression -> shift_expression .)
    KEYWORD_MATCH   reduce using rule 56 (relational_expression -> shift_expression .)
    TERMINATOR      reduce using rule 56 (relational_expression -> shift_expression .)
    RBRAC           reduce using rule 56 (relational_expression -> shift_expression .)
    FUNTYPE         reduce using rule 56 (relational_expression -> shift_expression .)
    KEYWORD_UNTIL   reduce using rule 56 (relational_expression -> shift_expression .)
    KEYWORD_TO      reduce using rule 56 (relational_expression -> shift_expression .)
    KEYWORD_BY      reduce using rule 56 (relational_expression -> shift_expression .)
    LSHIFT          shift and go to state 124
    RSHIFT          shift and go to state 123


state 50

    (77) base_variable_set -> variable_literal .

    TIMES           reduce using rule 77 (base_variable_set -> variable_literal .)
    DIVIDE          reduce using rule 77 (base_variable_set -> variable_literal .)
    REMAINDER       reduce using rule 77 (base_variable_set -> variable_literal .)
    PLUS            reduce using rule 77 (base_variable_set -> variable_literal .)
    MINUS           reduce using rule 77 (base_variable_set -> variable_literal .)
    LSHIFT          reduce using rule 77 (base_variable_set -> variable_literal .)
    RSHIFT          reduce using rule 77 (base_variable_set -> variable_literal .)
    GREATER         reduce using rule 77 (base_variable_set -> variable_literal .)
    LESS            reduce using rule 77 (base_variable_set -> variable_literal .)
    GEQ             reduce using rule 77 (base_variable_set -> variable_literal .)
    LEQ             reduce using rule 77 (base_variable_set -> variable_literal .)
    EQUAL           reduce using rule 77 (base_variable_set -> variable_literal .)
    NEQUAL          reduce using rule 77 (base_variable_set -> variable_literal .)
    AND_BITWISE     reduce using rule 77 (base_variable_set -> variable_literal .)
    XOR             reduce using rule 77 (base_variable_set -> variable_literal .)
    OR_BITWISE      reduce using rule 77 (base_variable_set -> variable_literal .)
    AND             reduce using rule 77 (base_variable_set -> variable_literal .)
    OR              reduce using rule 77 (base_variable_set -> variable_literal .)
    RPAREN          reduce using rule 77 (base_variable_set -> variable_literal .)
    COMMA           reduce using rule 77 (base_variable_set -> variable_literal .)
    KEYWORD_MATCH   reduce using rule 77 (base_variable_set -> variable_literal .)
    TERMINATOR      reduce using rule 77 (base_variable_set -> variable_literal .)
    RBRAC           reduce using rule 77 (base_variable_set -> variable_literal .)
    FUNTYPE         reduce using rule 77 (base_variable_set -> variable_literal .)
    KEYWORD_UNTIL   reduce using rule 77 (base_variable_set -> variable_literal .)
    KEYWORD_TO      reduce using rule 77 (base_variable_set -> variable_literal .)
    KEYWORD_BY      reduce using rule 77 (base_variable_set -> variable_literal .)


state 51

    (43) conditional_or_expression -> conditional_and_expression .
    (46) conditional_and_expression -> conditional_and_expression . AND marker inclusive_or_expression

    OR              reduce using rule 43 (conditional_or_expression -> conditional_and_expression .)
    TERMINATOR      reduce using rule 43 (conditional_or_expression -> conditional_and_expression .)
    RPAREN          reduce using rule 43 (conditional_or_expression -> conditional_and_expression .)
    COMMA           reduce using rule 43 (conditional_or_expression -> conditional_and_expression .)
    FUNTYPE         reduce using rule 43 (conditional_or_expression -> conditional_and_expression .)
    KEYWORD_MATCH   reduce using rule 43 (conditional_or_expression -> conditional_and_expression .)
    RBRAC           reduce using rule 43 (conditional_or_expression -> conditional_and_expression .)
    KEYWORD_BY      reduce using rule 43 (conditional_or_expression -> conditional_and_expression .)
    KEYWORD_UNTIL   reduce using rule 43 (conditional_or_expression -> conditional_and_expression .)
    KEYWORD_TO      reduce using rule 43 (conditional_or_expression -> conditional_and_expression .)
    AND             shift and go to state 125


state 52

    (76) unary_expression_not_plus_minus -> NOT . unary_expression
    (71) unary_expression -> . PLUS unary_expression
    (72) unary_expression -> . MINUS unary_expression
    (73) unary_expression -> . unary_expression_not_plus_minus
    (74) unary_expression_not_plus_minus -> . base_variable_set
    (75) unary_expression_not_plus_minus -> . TILDA unary_expression
    (76) unary_expression_not_plus_minus -> . NOT unary_expression
    (77) base_variable_set -> . variable_literal
    (78) base_variable_set -> . LPAREN expression RPAREN
    (79) variable_literal -> . valid_variable
    (80) variable_literal -> . primary
    (26) valid_variable -> . name
    (27) valid_variable -> . array_access
    (81) primary -> . literal
    (82) primary -> . method_invocation
    (121) name -> . simple_name
    (122) name -> . qualified_name
    (28) array_access -> . name dimension
    (83) literal -> . int_float
    (84) literal -> . c_literal
    (88) method_invocation -> . name LPAREN argument_list_opt RPAREN
    (123) simple_name -> . IDENTIFIER
    (124) qualified_name -> . name INST simple_name
    (87) int_float -> . INT_NUMBER
    (85) c_literal -> . BOOL_CONSTT
    (86) c_literal -> . BOOL_CONSTF

    PLUS            shift and go to state 30
    MINUS           shift and go to state 24
    TILDA           shift and go to state 65
    NOT             shift and go to state 52
    LPAREN          shift and go to state 86
    IDENTIFIER      shift and go to state 9
    INT_NUMBER      shift and go to state 38
    BOOL_CONSTT     shift and go to state 29
    BOOL_CONSTF     shift and go to state 25

    qualified_name                 shift and go to state 71
    int_float                      shift and go to state 34
    c_literal                      shift and go to state 85
    variable_literal               shift and go to state 50
    unary_expression               shift and go to state 126
    base_variable_set              shift and go to state 80
    valid_variable                 shift and go to state 101
    array_access                   shift and go to state 23
    primary                        shift and go to state 57
    unary_expression_not_plus_minus shift and go to state 40
    literal                        shift and go to state 64
    method_invocation              shift and go to state 102
    simple_name                    shift and go to state 60
    name                           shift and go to state 103

state 53

    (156) switch_statement -> expression . KEYWORD_MATCH switch_block marker

    KEYWORD_MATCH   shift and go to state 127


state 54

    (134) normal_statement -> block . marker
    (41) marker -> . empty
    (191) empty -> .

    KEYWORD_IF      reduce using rule 191 (empty -> .)
    KEYWORD_WHILE   reduce using rule 191 (empty -> .)
    KEYWORD_DO      reduce using rule 191 (empty -> .)
    KEYWORD_FOR     reduce using rule 191 (empty -> .)
    KEYWORD_CLASS   reduce using rule 191 (empty -> .)
    KEYWORD_OBJECT  reduce using rule 191 (empty -> .)
    KEYWORD_VAR     reduce using rule 191 (empty -> .)
    KEYWORD_VAL     reduce using rule 191 (empty -> .)
    TERMINATOR      reduce using rule 191 (empty -> .)
    KEYWORD_RETURN  reduce using rule 191 (empty -> .)
    KEYWORD_DEF     reduce using rule 191 (empty -> .)
    BLOCKBEGIN      reduce using rule 191 (empty -> .)
    IDENTIFIER      reduce using rule 191 (empty -> .)
    PLUS            reduce using rule 191 (empty -> .)
    MINUS           reduce using rule 191 (empty -> .)
    TILDA           reduce using rule 191 (empty -> .)
    NOT             reduce using rule 191 (empty -> .)
    LPAREN          reduce using rule 191 (empty -> .)
    INT_NUMBER      reduce using rule 191 (empty -> .)
    BOOL_CONSTT     reduce using rule 191 (empty -> .)
    BOOL_CONSTF     reduce using rule 191 (empty -> .)
    BLOCKEND        reduce using rule 191 (empty -> .)
    KEYWORD_ELSE    reduce using rule 191 (empty -> .)

    marker                         shift and go to state 128
    empty                          shift and go to state 99

state 55

    (130) statement -> if_then_else_statement . marker
    (41) marker -> . empty
    (191) empty -> .

    KEYWORD_IF      reduce using rule 191 (empty -> .)
    KEYWORD_WHILE   reduce using rule 191 (empty -> .)
    KEYWORD_DO      reduce using rule 191 (empty -> .)
    KEYWORD_FOR     reduce using rule 191 (empty -> .)
    KEYWORD_CLASS   reduce using rule 191 (empty -> .)
    KEYWORD_OBJECT  reduce using rule 191 (empty -> .)
    KEYWORD_VAR     reduce using rule 191 (empty -> .)
    KEYWORD_VAL     reduce using rule 191 (empty -> .)
    TERMINATOR      reduce using rule 191 (empty -> .)
    KEYWORD_RETURN  reduce using rule 191 (empty -> .)
    KEYWORD_DEF     reduce using rule 191 (empty -> .)
    BLOCKBEGIN      reduce using rule 191 (empty -> .)
    IDENTIFIER      reduce using rule 191 (empty -> .)
    PLUS            reduce using rule 191 (empty -> .)
    MINUS           reduce using rule 191 (empty -> .)
    TILDA           reduce using rule 191 (empty -> .)
    NOT             reduce using rule 191 (empty -> .)
    LPAREN          reduce using rule 191 (empty -> .)
    INT_NUMBER      reduce using rule 191 (empty -> .)
    BOOL_CONSTT     reduce using rule 191 (empty -> .)
    BOOL_CONSTF     reduce using rule 191 (empty -> .)
    BLOCKEND        reduce using rule 191 (empty -> .)

    marker                         shift and go to state 129
    empty                          shift and go to state 99

state 56

    (47) inclusive_or_expression -> exclusive_or_expression .
    (50) exclusive_or_expression -> exclusive_or_expression . XOR and_expression

    OR_BITWISE      reduce using rule 47 (inclusive_or_expression -> exclusive_or_expression .)
    AND             reduce using rule 47 (inclusive_or_expression -> exclusive_or_expression .)
    OR              reduce using rule 47 (inclusive_or_expression -> exclusive_or_expression .)
    FUNTYPE         reduce using rule 47 (inclusive_or_expression -> exclusive_or_expression .)
    RBRAC           reduce using rule 47 (inclusive_or_expression -> exclusive_or_expression .)
    KEYWORD_MATCH   reduce using rule 47 (inclusive_or_expression -> exclusive_or_expression .)
    TERMINATOR      reduce using rule 47 (inclusive_or_expression -> exclusive_or_expression .)
    RPAREN          reduce using rule 47 (inclusive_or_expression -> exclusive_or_expression .)
    COMMA           reduce using rule 47 (inclusive_or_expression -> exclusive_or_expression .)
    KEYWORD_UNTIL   reduce using rule 47 (inclusive_or_expression -> exclusive_or_expression .)
    KEYWORD_TO      reduce using rule 47 (inclusive_or_expression -> exclusive_or_expression .)
    KEYWORD_BY      reduce using rule 47 (inclusive_or_expression -> exclusive_or_expression .)
    XOR             shift and go to state 130


state 57

    (80) variable_literal -> primary .

    TIMES           reduce using rule 80 (variable_literal -> primary .)
    DIVIDE          reduce using rule 80 (variable_literal -> primary .)
    REMAINDER       reduce using rule 80 (variable_literal -> primary .)
    PLUS            reduce using rule 80 (variable_literal -> primary .)
    MINUS           reduce using rule 80 (variable_literal -> primary .)
    LSHIFT          reduce using rule 80 (variable_literal -> primary .)
    RSHIFT          reduce using rule 80 (variable_literal -> primary .)
    GREATER         reduce using rule 80 (variable_literal -> primary .)
    LESS            reduce using rule 80 (variable_literal -> primary .)
    GEQ             reduce using rule 80 (variable_literal -> primary .)
    LEQ             reduce using rule 80 (variable_literal -> primary .)
    EQUAL           reduce using rule 80 (variable_literal -> primary .)
    NEQUAL          reduce using rule 80 (variable_literal -> primary .)
    AND_BITWISE     reduce using rule 80 (variable_literal -> primary .)
    XOR             reduce using rule 80 (variable_literal -> primary .)
    OR_BITWISE      reduce using rule 80 (variable_literal -> primary .)
    AND             reduce using rule 80 (variable_literal -> primary .)
    OR              reduce using rule 80 (variable_literal -> primary .)
    KEYWORD_MATCH   reduce using rule 80 (variable_literal -> primary .)
    TERMINATOR      reduce using rule 80 (variable_literal -> primary .)
    RPAREN          reduce using rule 80 (variable_literal -> primary .)
    RBRAC           reduce using rule 80 (variable_literal -> primary .)
    COMMA           reduce using rule 80 (variable_literal -> primary .)
    FUNTYPE         reduce using rule 80 (variable_literal -> primary .)
    KEYWORD_UNTIL   reduce using rule 80 (variable_literal -> primary .)
    KEYWORD_TO      reduce using rule 80 (variable_literal -> primary .)
    KEYWORD_BY      reduce using rule 80 (variable_literal -> primary .)


state 58

    (129) statement -> if_then_statement . marker
    (41) marker -> . empty
    (191) empty -> .

    KEYWORD_IF      reduce using rule 191 (empty -> .)
    KEYWORD_WHILE   reduce using rule 191 (empty -> .)
    KEYWORD_DO      reduce using rule 191 (empty -> .)
    KEYWORD_FOR     reduce using rule 191 (empty -> .)
    KEYWORD_CLASS   reduce using rule 191 (empty -> .)
    KEYWORD_OBJECT  reduce using rule 191 (empty -> .)
    KEYWORD_VAR     reduce using rule 191 (empty -> .)
    KEYWORD_VAL     reduce using rule 191 (empty -> .)
    TERMINATOR      reduce using rule 191 (empty -> .)
    KEYWORD_RETURN  reduce using rule 191 (empty -> .)
    KEYWORD_DEF     reduce using rule 191 (empty -> .)
    BLOCKBEGIN      reduce using rule 191 (empty -> .)
    IDENTIFIER      reduce using rule 191 (empty -> .)
    PLUS            reduce using rule 191 (empty -> .)
    MINUS           reduce using rule 191 (empty -> .)
    TILDA           reduce using rule 191 (empty -> .)
    NOT             reduce using rule 191 (empty -> .)
    LPAREN          reduce using rule 191 (empty -> .)
    INT_NUMBER      reduce using rule 191 (empty -> .)
    BOOL_CONSTT     reduce using rule 191 (empty -> .)
    BOOL_CONSTF     reduce using rule 191 (empty -> .)
    BLOCKEND        reduce using rule 191 (empty -> .)

    marker                         shift and go to state 131
    empty                          shift and go to state 99

state 59

    (61) shift_expression -> additive_expression .
    (65) additive_expression -> additive_expression . PLUS multiplicative_expression
    (66) additive_expression -> additive_expression . MINUS multiplicative_expression

    LSHIFT          reduce using rule 61 (shift_expression -> additive_expression .)
    RSHIFT          reduce using rule 61 (shift_expression -> additive_expression .)
    GREATER         reduce using rule 61 (shift_expression -> additive_expression .)
    LESS            reduce using rule 61 (shift_expression -> additive_expression .)
    GEQ             reduce using rule 61 (shift_expression -> additive_expression .)
    LEQ             reduce using rule 61 (shift_expression -> additive_expression .)
    EQUAL           reduce using rule 61 (shift_expression -> additive_expression .)
    NEQUAL          reduce using rule 61 (shift_expression -> additive_expression .)
    AND_BITWISE     reduce using rule 61 (shift_expression -> additive_expression .)
    XOR             reduce using rule 61 (shift_expression -> additive_expression .)
    OR_BITWISE      reduce using rule 61 (shift_expression -> additive_expression .)
    AND             reduce using rule 61 (shift_expression -> additive_expression .)
    OR              reduce using rule 61 (shift_expression -> additive_expression .)
    KEYWORD_MATCH   reduce using rule 61 (shift_expression -> additive_expression .)
    RPAREN          reduce using rule 61 (shift_expression -> additive_expression .)
    KEYWORD_UNTIL   reduce using rule 61 (shift_expression -> additive_expression .)
    KEYWORD_TO      reduce using rule 61 (shift_expression -> additive_expression .)
    TERMINATOR      reduce using rule 61 (shift_expression -> additive_expression .)
    RBRAC           reduce using rule 61 (shift_expression -> additive_expression .)
    COMMA           reduce using rule 61 (shift_expression -> additive_expression .)
    FUNTYPE         reduce using rule 61 (shift_expression -> additive_expression .)
    KEYWORD_BY      reduce using rule 61 (shift_expression -> additive_expression .)
    PLUS            shift and go to state 132
    MINUS           shift and go to state 133


state 60

    (121) name -> simple_name .

    LPAREN          reduce using rule 121 (name -> simple_name .)
    INST            reduce using rule 121 (name -> simple_name .)
    LBRAC           reduce using rule 121 (name -> simple_name .)
    ASOP            reduce using rule 121 (name -> simple_name .)
    TIMES_ASSIGN    reduce using rule 121 (name -> simple_name .)
    DIVIDE_ASSIGN   reduce using rule 121 (name -> simple_name .)
    REMAINDER_ASSIGN reduce using rule 121 (name -> simple_name .)
    PLUS_ASSIGN     reduce using rule 121 (name -> simple_name .)
    MINUS_ASSIGN    reduce using rule 121 (name -> simple_name .)
    LSHIFT_ASSIGN   reduce using rule 121 (name -> simple_name .)
    RSHIFT_ASSIGN   reduce using rule 121 (name -> simple_name .)
    AND_ASSIGN      reduce using rule 121 (name -> simple_name .)
    OR_ASSIGN       reduce using rule 121 (name -> simple_name .)
    XOR_ASSIGN      reduce using rule 121 (name -> simple_name .)
    TIMES           reduce using rule 121 (name -> simple_name .)
    DIVIDE          reduce using rule 121 (name -> simple_name .)
    REMAINDER       reduce using rule 121 (name -> simple_name .)
    PLUS            reduce using rule 121 (name -> simple_name .)
    MINUS           reduce using rule 121 (name -> simple_name .)
    LSHIFT          reduce using rule 121 (name -> simple_name .)
    RSHIFT          reduce using rule 121 (name -> simple_name .)
    GREATER         reduce using rule 121 (name -> simple_name .)
    LESS            reduce using rule 121 (name -> simple_name .)
    GEQ             reduce using rule 121 (name -> simple_name .)
    LEQ             reduce using rule 121 (name -> simple_name .)
    EQUAL           reduce using rule 121 (name -> simple_name .)
    NEQUAL          reduce using rule 121 (name -> simple_name .)
    AND_BITWISE     reduce using rule 121 (name -> simple_name .)
    XOR             reduce using rule 121 (name -> simple_name .)
    OR_BITWISE      reduce using rule 121 (name -> simple_name .)
    AND             reduce using rule 121 (name -> simple_name .)
    OR              reduce using rule 121 (name -> simple_name .)
    TERMINATOR      reduce using rule 121 (name -> simple_name .)
    KEYWORD_MATCH   reduce using rule 121 (name -> simple_name .)
    RPAREN          reduce using rule 121 (name -> simple_name .)
    RBRAC           reduce using rule 121 (name -> simple_name .)
    COMMA           reduce using rule 121 (name -> simple_name .)
    FUNTYPE         reduce using rule 121 (name -> simple_name .)
    KEYWORD_UNTIL   reduce using rule 121 (name -> simple_name .)
    KEYWORD_TO      reduce using rule 121 (name -> simple_name .)
    KEYWORD_BY      reduce using rule 121 (name -> simple_name .)


state 61

    (164) return_statement -> KEYWORD_RETURN . expression_optional TERMINATOR
    (20) expression_optional -> . expression
    (21) expression_optional -> . empty
    (19) expression -> . assignment_expression
    (191) empty -> .
    (22) assignment_expression -> . assignment
    (23) assignment_expression -> . conditional_or_expression
    (24) assignment_expression -> . method_invocation
    (25) assignment -> . valid_variable assignment_operator assignment_expression
    (43) conditional_or_expression -> . conditional_and_expression
    (44) conditional_or_expression -> . conditional_or_expression OR marker conditional_and_expression
    (88) method_invocation -> . name LPAREN argument_list_opt RPAREN
    (26) valid_variable -> . name
    (27) valid_variable -> . array_access
    (45) conditional_and_expression -> . inclusive_or_expression
    (46) conditional_and_expression -> . conditional_and_expression AND marker inclusive_or_expression
    (121) name -> . simple_name
    (122) name -> . qualified_name
    (28) array_access -> . name dimension
    (47) inclusive_or_expression -> . exclusive_or_expression
    (48) inclusive_or_expression -> . inclusive_or_expression OR_BITWISE exclusive_or_expression
    (123) simple_name -> . IDENTIFIER
    (124) qualified_name -> . name INST simple_name
    (49) exclusive_or_expression -> . and_expression
    (50) exclusive_or_expression -> . exclusive_or_expression XOR and_expression
    (51) and_expression -> . equality_expression
    (52) and_expression -> . and_expression AND_BITWISE equality_expression
    (53) equality_expression -> . relational_expression
    (54) equality_expression -> . equality_expression EQUAL relational_expression
    (55) equality_expression -> . equality_expression NEQUAL relational_expression
    (56) relational_expression -> . shift_expression
    (57) relational_expression -> . relational_expression GREATER shift_expression
    (58) relational_expression -> . relational_expression LESS shift_expression
    (59) relational_expression -> . relational_expression GEQ shift_expression
    (60) relational_expression -> . relational_expression LEQ shift_expression
    (61) shift_expression -> . additive_expression
    (62) shift_expression -> . shift_expression LSHIFT additive_expression
    (63) shift_expression -> . shift_expression RSHIFT additive_expression
    (64) additive_expression -> . multiplicative_expression
    (65) additive_expression -> . additive_expression PLUS multiplicative_expression
    (66) additive_expression -> . additive_expression MINUS multiplicative_expression
    (67) multiplicative_expression -> . unary_expression
    (68) multiplicative_expression -> . multiplicative_expression TIMES unary_expression
    (69) multiplicative_expression -> . multiplicative_expression DIVIDE unary_expression
    (70) multiplicative_expression -> . multiplicative_expression REMAINDER unary_expression
    (71) unary_expression -> . PLUS unary_expression
    (72) unary_expression -> . MINUS unary_expression
    (73) unary_expression -> . unary_expression_not_plus_minus
    (74) unary_expression_not_plus_minus -> . base_variable_set
    (75) unary_expression_not_plus_minus -> . TILDA unary_expression
    (76) unary_expression_not_plus_minus -> . NOT unary_expression
    (77) base_variable_set -> . variable_literal
    (78) base_variable_set -> . LPAREN expression RPAREN
    (79) variable_literal -> . valid_variable
    (80) variable_literal -> . primary
    (81) primary -> . literal
    (82) primary -> . method_invocation
    (83) literal -> . int_float
    (84) literal -> . c_literal
    (87) int_float -> . INT_NUMBER
    (85) c_literal -> . BOOL_CONSTT
    (86) c_literal -> . BOOL_CONSTF

    TERMINATOR      reduce using rule 191 (empty -> .)
    IDENTIFIER      shift and go to state 9
    PLUS            shift and go to state 30
    MINUS           shift and go to state 24
    TILDA           shift and go to state 65
    NOT             shift and go to state 52
    LPAREN          shift and go to state 86
    INT_NUMBER      shift and go to state 38
    BOOL_CONSTT     shift and go to state 29
    BOOL_CONSTF     shift and go to state 25

    unary_expression               shift and go to state 39
    exclusive_or_expression        shift and go to state 56
    primary                        shift and go to state 57
    unary_expression_not_plus_minus shift and go to state 40
    array_access                   shift and go to state 23
    and_expression                 shift and go to state 79
    simple_name                    shift and go to state 60
    c_literal                      shift and go to state 85
    expression_optional            shift and go to state 136
    base_variable_set              shift and go to state 80
    valid_variable                 shift and go to state 87
    inclusive_or_expression        shift and go to state 27
    literal                        shift and go to state 64
    relational_expression          shift and go to state 66
    method_invocation              shift and go to state 134
    conditional_or_expression      shift and go to state 42
    empty                          shift and go to state 135
    assignment_expression          shift and go to state 83
    qualified_name                 shift and go to state 71
    assignment                     shift and go to state 137
    multiplicative_expression      shift and go to state 45
    additive_expression            shift and go to state 59
    shift_expression               shift and go to state 49
    equality_expression            shift and go to state 74
    int_float                      shift and go to state 34
    variable_literal               shift and go to state 50
    name                           shift and go to state 37
    expression                     shift and go to state 138
    conditional_and_expression     shift and go to state 51

state 62

    (18) block_statement -> method_declaration .

    KEYWORD_IF      reduce using rule 18 (block_statement -> method_declaration .)
    KEYWORD_WHILE   reduce using rule 18 (block_statement -> method_declaration .)
    KEYWORD_DO      reduce using rule 18 (block_statement -> method_declaration .)
    KEYWORD_FOR     reduce using rule 18 (block_statement -> method_declaration .)
    KEYWORD_CLASS   reduce using rule 18 (block_statement -> method_declaration .)
    KEYWORD_OBJECT  reduce using rule 18 (block_statement -> method_declaration .)
    KEYWORD_VAR     reduce using rule 18 (block_statement -> method_declaration .)
    KEYWORD_VAL     reduce using rule 18 (block_statement -> method_declaration .)
    TERMINATOR      reduce using rule 18 (block_statement -> method_declaration .)
    KEYWORD_RETURN  reduce using rule 18 (block_statement -> method_declaration .)
    KEYWORD_DEF     reduce using rule 18 (block_statement -> method_declaration .)
    BLOCKBEGIN      reduce using rule 18 (block_statement -> method_declaration .)
    IDENTIFIER      reduce using rule 18 (block_statement -> method_declaration .)
    PLUS            reduce using rule 18 (block_statement -> method_declaration .)
    MINUS           reduce using rule 18 (block_statement -> method_declaration .)
    TILDA           reduce using rule 18 (block_statement -> method_declaration .)
    NOT             reduce using rule 18 (block_statement -> method_declaration .)
    LPAREN          reduce using rule 18 (block_statement -> method_declaration .)
    INT_NUMBER      reduce using rule 18 (block_statement -> method_declaration .)
    BOOL_CONSTT     reduce using rule 18 (block_statement -> method_declaration .)
    BOOL_CONSTF     reduce using rule 18 (block_statement -> method_declaration .)
    BLOCKEND        reduce using rule 18 (block_statement -> method_declaration .)


state 63

    (12) block_statements -> block_statement .

    KEYWORD_IF      reduce using rule 12 (block_statements -> block_statement .)
    KEYWORD_WHILE   reduce using rule 12 (block_statements -> block_statement .)
    KEYWORD_DO      reduce using rule 12 (block_statements -> block_statement .)
    KEYWORD_FOR     reduce using rule 12 (block_statements -> block_statement .)
    KEYWORD_CLASS   reduce using rule 12 (block_statements -> block_statement .)
    KEYWORD_OBJECT  reduce using rule 12 (block_statements -> block_statement .)
    KEYWORD_VAR     reduce using rule 12 (block_statements -> block_statement .)
    KEYWORD_VAL     reduce using rule 12 (block_statements -> block_statement .)
    TERMINATOR      reduce using rule 12 (block_statements -> block_statement .)
    KEYWORD_RETURN  reduce using rule 12 (block_statements -> block_statement .)
    KEYWORD_DEF     reduce using rule 12 (block_statements -> block_statement .)
    BLOCKBEGIN      reduce using rule 12 (block_statements -> block_statement .)
    IDENTIFIER      reduce using rule 12 (block_statements -> block_statement .)
    PLUS            reduce using rule 12 (block_statements -> block_statement .)
    MINUS           reduce using rule 12 (block_statements -> block_statement .)
    TILDA           reduce using rule 12 (block_statements -> block_statement .)
    NOT             reduce using rule 12 (block_statements -> block_statement .)
    LPAREN          reduce using rule 12 (block_statements -> block_statement .)
    INT_NUMBER      reduce using rule 12 (block_statements -> block_statement .)
    BOOL_CONSTT     reduce using rule 12 (block_statements -> block_statement .)
    BOOL_CONSTF     reduce using rule 12 (block_statements -> block_statement .)
    BLOCKEND        reduce using rule 12 (block_statements -> block_statement .)


state 64

    (81) primary -> literal .

    TIMES           reduce using rule 81 (primary -> literal .)
    DIVIDE          reduce using rule 81 (primary -> literal .)
    REMAINDER       reduce using rule 81 (primary -> literal .)
    PLUS            reduce using rule 81 (primary -> literal .)
    MINUS           reduce using rule 81 (primary -> literal .)
    LSHIFT          reduce using rule 81 (primary -> literal .)
    RSHIFT          reduce using rule 81 (primary -> literal .)
    GREATER         reduce using rule 81 (primary -> literal .)
    LESS            reduce using rule 81 (primary -> literal .)
    GEQ             reduce using rule 81 (primary -> literal .)
    LEQ             reduce using rule 81 (primary -> literal .)
    EQUAL           reduce using rule 81 (primary -> literal .)
    NEQUAL          reduce using rule 81 (primary -> literal .)
    AND_BITWISE     reduce using rule 81 (primary -> literal .)
    XOR             reduce using rule 81 (primary -> literal .)
    OR_BITWISE      reduce using rule 81 (primary -> literal .)
    AND             reduce using rule 81 (primary -> literal .)
    OR              reduce using rule 81 (primary -> literal .)
    KEYWORD_MATCH   reduce using rule 81 (primary -> literal .)
    TERMINATOR      reduce using rule 81 (primary -> literal .)
    RPAREN          reduce using rule 81 (primary -> literal .)
    RBRAC           reduce using rule 81 (primary -> literal .)
    COMMA           reduce using rule 81 (primary -> literal .)
    FUNTYPE         reduce using rule 81 (primary -> literal .)
    KEYWORD_UNTIL   reduce using rule 81 (primary -> literal .)
    KEYWORD_TO      reduce using rule 81 (primary -> literal .)
    KEYWORD_BY      reduce using rule 81 (primary -> literal .)


state 65

    (75) unary_expression_not_plus_minus -> TILDA . unary_expression
    (71) unary_expression -> . PLUS unary_expression
    (72) unary_expression -> . MINUS unary_expression
    (73) unary_expression -> . unary_expression_not_plus_minus
    (74) unary_expression_not_plus_minus -> . base_variable_set
    (75) unary_expression_not_plus_minus -> . TILDA unary_expression
    (76) unary_expression_not_plus_minus -> . NOT unary_expression
    (77) base_variable_set -> . variable_literal
    (78) base_variable_set -> . LPAREN expression RPAREN
    (79) variable_literal -> . valid_variable
    (80) variable_literal -> . primary
    (26) valid_variable -> . name
    (27) valid_variable -> . array_access
    (81) primary -> . literal
    (82) primary -> . method_invocation
    (121) name -> . simple_name
    (122) name -> . qualified_name
    (28) array_access -> . name dimension
    (83) literal -> . int_float
    (84) literal -> . c_literal
    (88) method_invocation -> . name LPAREN argument_list_opt RPAREN
    (123) simple_name -> . IDENTIFIER
    (124) qualified_name -> . name INST simple_name
    (87) int_float -> . INT_NUMBER
    (85) c_literal -> . BOOL_CONSTT
    (86) c_literal -> . BOOL_CONSTF

    PLUS            shift and go to state 30
    MINUS           shift and go to state 24
    TILDA           shift and go to state 65
    NOT             shift and go to state 52
    LPAREN          shift and go to state 86
    IDENTIFIER      shift and go to state 9
    INT_NUMBER      shift and go to state 38
    BOOL_CONSTT     shift and go to state 29
    BOOL_CONSTF     shift and go to state 25

    qualified_name                 shift and go to state 71
    int_float                      shift and go to state 34
    c_literal                      shift and go to state 85
    variable_literal               shift and go to state 50
    unary_expression               shift and go to state 139
    base_variable_set              shift and go to state 80
    valid_variable                 shift and go to state 101
    array_access                   shift and go to state 23
    primary                        shift and go to state 57
    unary_expression_not_plus_minus shift and go to state 40
    literal                        shift and go to state 64
    method_invocation              shift and go to state 102
    simple_name                    shift and go to state 60
    name                           shift and go to state 103

state 66

    (53) equality_expression -> relational_expression .
    (57) relational_expression -> relational_expression . GREATER shift_expression
    (58) relational_expression -> relational_expression . LESS shift_expression
    (59) relational_expression -> relational_expression . GEQ shift_expression
    (60) relational_expression -> relational_expression . LEQ shift_expression

    EQUAL           reduce using rule 53 (equality_expression -> relational_expression .)
    NEQUAL          reduce using rule 53 (equality_expression -> relational_expression .)
    AND_BITWISE     reduce using rule 53 (equality_expression -> relational_expression .)
    XOR             reduce using rule 53 (equality_expression -> relational_expression .)
    OR_BITWISE      reduce using rule 53 (equality_expression -> relational_expression .)
    AND             reduce using rule 53 (equality_expression -> relational_expression .)
    OR              reduce using rule 53 (equality_expression -> relational_expression .)
    RPAREN          reduce using rule 53 (equality_expression -> relational_expression .)
    KEYWORD_MATCH   reduce using rule 53 (equality_expression -> relational_expression .)
    TERMINATOR      reduce using rule 53 (equality_expression -> relational_expression .)
    RBRAC           reduce using rule 53 (equality_expression -> relational_expression .)
    COMMA           reduce using rule 53 (equality_expression -> relational_expression .)
    FUNTYPE         reduce using rule 53 (equality_expression -> relational_expression .)
    KEYWORD_UNTIL   reduce using rule 53 (equality_expression -> relational_expression .)
    KEYWORD_TO      reduce using rule 53 (equality_expression -> relational_expression .)
    KEYWORD_BY      reduce using rule 53 (equality_expression -> relational_expression .)
    GREATER         shift and go to state 141
    LESS            shift and go to state 142
    GEQ             shift and go to state 140
    LEQ             shift and go to state 143


state 67

    (15) block_statement -> statement .

    KEYWORD_IF      reduce using rule 15 (block_statement -> statement .)
    KEYWORD_WHILE   reduce using rule 15 (block_statement -> statement .)
    KEYWORD_DO      reduce using rule 15 (block_statement -> statement .)
    KEYWORD_FOR     reduce using rule 15 (block_statement -> statement .)
    KEYWORD_CLASS   reduce using rule 15 (block_statement -> statement .)
    KEYWORD_OBJECT  reduce using rule 15 (block_statement -> statement .)
    KEYWORD_VAR     reduce using rule 15 (block_statement -> statement .)
    KEYWORD_VAL     reduce using rule 15 (block_statement -> statement .)
    TERMINATOR      reduce using rule 15 (block_statement -> statement .)
    KEYWORD_RETURN  reduce using rule 15 (block_statement -> statement .)
    KEYWORD_DEF     reduce using rule 15 (block_statement -> statement .)
    BLOCKBEGIN      reduce using rule 15 (block_statement -> statement .)
    IDENTIFIER      reduce using rule 15 (block_statement -> statement .)
    PLUS            reduce using rule 15 (block_statement -> statement .)
    MINUS           reduce using rule 15 (block_statement -> statement .)
    TILDA           reduce using rule 15 (block_statement -> statement .)
    NOT             reduce using rule 15 (block_statement -> statement .)
    LPAREN          reduce using rule 15 (block_statement -> statement .)
    INT_NUMBER      reduce using rule 15 (block_statement -> statement .)
    BOOL_CONSTT     reduce using rule 15 (block_statement -> statement .)
    BOOL_CONSTF     reduce using rule 15 (block_statement -> statement .)
    BLOCKEND        reduce using rule 15 (block_statement -> statement .)


state 68

    (141) statement_expression -> method_invocation .
    (24) assignment_expression -> method_invocation .
    (82) primary -> method_invocation .

  ! reduce/reduce conflict for KEYWORD_MATCH resolved using rule 24 (assignment_expression -> method_invocation .)
    TERMINATOR      reduce using rule 141 (statement_expression -> method_invocation .)
    KEYWORD_MATCH   reduce using rule 24 (assignment_expression -> method_invocation .)
    TIMES           reduce using rule 82 (primary -> method_invocation .)
    DIVIDE          reduce using rule 82 (primary -> method_invocation .)
    REMAINDER       reduce using rule 82 (primary -> method_invocation .)
    PLUS            reduce using rule 82 (primary -> method_invocation .)
    MINUS           reduce using rule 82 (primary -> method_invocation .)
    LSHIFT          reduce using rule 82 (primary -> method_invocation .)
    RSHIFT          reduce using rule 82 (primary -> method_invocation .)
    GREATER         reduce using rule 82 (primary -> method_invocation .)
    LESS            reduce using rule 82 (primary -> method_invocation .)
    GEQ             reduce using rule 82 (primary -> method_invocation .)
    LEQ             reduce using rule 82 (primary -> method_invocation .)
    EQUAL           reduce using rule 82 (primary -> method_invocation .)
    NEQUAL          reduce using rule 82 (primary -> method_invocation .)
    AND_BITWISE     reduce using rule 82 (primary -> method_invocation .)
    XOR             reduce using rule 82 (primary -> method_invocation .)
    OR_BITWISE      reduce using rule 82 (primary -> method_invocation .)
    AND             reduce using rule 82 (primary -> method_invocation .)
    OR              reduce using rule 82 (primary -> method_invocation .)

  ! KEYWORD_MATCH   [ reduce using rule 82 (primary -> method_invocation .) ]


state 69

    (11) block_statements_opt -> empty .

    BLOCKEND        reduce using rule 11 (block_statements_opt -> empty .)


state 70

    (96) local_variable_declaration -> declaration_keyword . variable_declaration_body
    (102) variable_declaration_body -> . identifiers COLON type ASOP variable_declaration_initializer
    (103) identifiers -> . identifiers COMMA IDENTIFIER
    (104) identifiers -> . IDENTIFIER

    IDENTIFIER      shift and go to state 146

    variable_declaration_body      shift and go to state 144
    identifiers                    shift and go to state 145

state 71

    (122) name -> qualified_name .

    LPAREN          reduce using rule 122 (name -> qualified_name .)
    INST            reduce using rule 122 (name -> qualified_name .)
    LBRAC           reduce using rule 122 (name -> qualified_name .)
    ASOP            reduce using rule 122 (name -> qualified_name .)
    TIMES_ASSIGN    reduce using rule 122 (name -> qualified_name .)
    DIVIDE_ASSIGN   reduce using rule 122 (name -> qualified_name .)
    REMAINDER_ASSIGN reduce using rule 122 (name -> qualified_name .)
    PLUS_ASSIGN     reduce using rule 122 (name -> qualified_name .)
    MINUS_ASSIGN    reduce using rule 122 (name -> qualified_name .)
    LSHIFT_ASSIGN   reduce using rule 122 (name -> qualified_name .)
    RSHIFT_ASSIGN   reduce using rule 122 (name -> qualified_name .)
    AND_ASSIGN      reduce using rule 122 (name -> qualified_name .)
    OR_ASSIGN       reduce using rule 122 (name -> qualified_name .)
    XOR_ASSIGN      reduce using rule 122 (name -> qualified_name .)
    TIMES           reduce using rule 122 (name -> qualified_name .)
    DIVIDE          reduce using rule 122 (name -> qualified_name .)
    REMAINDER       reduce using rule 122 (name -> qualified_name .)
    PLUS            reduce using rule 122 (name -> qualified_name .)
    MINUS           reduce using rule 122 (name -> qualified_name .)
    LSHIFT          reduce using rule 122 (name -> qualified_name .)
    RSHIFT          reduce using rule 122 (name -> qualified_name .)
    GREATER         reduce using rule 122 (name -> qualified_name .)
    LESS            reduce using rule 122 (name -> qualified_name .)
    GEQ             reduce using rule 122 (name -> qualified_name .)
    LEQ             reduce using rule 122 (name -> qualified_name .)
    EQUAL           reduce using rule 122 (name -> qualified_name .)
    NEQUAL          reduce using rule 122 (name -> qualified_name .)
    AND_BITWISE     reduce using rule 122 (name -> qualified_name .)
    XOR             reduce using rule 122 (name -> qualified_name .)
    OR_BITWISE      reduce using rule 122 (name -> qualified_name .)
    AND             reduce using rule 122 (name -> qualified_name .)
    OR              reduce using rule 122 (name -> qualified_name .)
    TERMINATOR      reduce using rule 122 (name -> qualified_name .)
    KEYWORD_MATCH   reduce using rule 122 (name -> qualified_name .)
    RPAREN          reduce using rule 122 (name -> qualified_name .)
    RBRAC           reduce using rule 122 (name -> qualified_name .)
    COMMA           reduce using rule 122 (name -> qualified_name .)
    FUNTYPE         reduce using rule 122 (name -> qualified_name .)
    KEYWORD_UNTIL   reduce using rule 122 (name -> qualified_name .)
    KEYWORD_TO      reduce using rule 122 (name -> qualified_name .)
    KEYWORD_BY      reduce using rule 122 (name -> qualified_name .)


state 72

    (174) method_header_name -> KEYWORD_DEF . IDENTIFIER

    IDENTIFIER      shift and go to state 147


state 73

    (142) if_then_statement -> KEYWORD_IF . LPAREN expression RPAREN marker block
    (143) if_then_else_statement -> KEYWORD_IF . LPAREN expression RPAREN marker if_then_else_intermediate narker KEYWORD_ELSE marker block

    LPAREN          shift and go to state 148


state 74

    (51) and_expression -> equality_expression .
    (54) equality_expression -> equality_expression . EQUAL relational_expression
    (55) equality_expression -> equality_expression . NEQUAL relational_expression

    AND_BITWISE     reduce using rule 51 (and_expression -> equality_expression .)
    XOR             reduce using rule 51 (and_expression -> equality_expression .)
    OR_BITWISE      reduce using rule 51 (and_expression -> equality_expression .)
    AND             reduce using rule 51 (and_expression -> equality_expression .)
    OR              reduce using rule 51 (and_expression -> equality_expression .)
    KEYWORD_MATCH   reduce using rule 51 (and_expression -> equality_expression .)
    TERMINATOR      reduce using rule 51 (and_expression -> equality_expression .)
    RPAREN          reduce using rule 51 (and_expression -> equality_expression .)
    RBRAC           reduce using rule 51 (and_expression -> equality_expression .)
    COMMA           reduce using rule 51 (and_expression -> equality_expression .)
    FUNTYPE         reduce using rule 51 (and_expression -> equality_expression .)
    KEYWORD_UNTIL   reduce using rule 51 (and_expression -> equality_expression .)
    KEYWORD_TO      reduce using rule 51 (and_expression -> equality_expression .)
    KEYWORD_BY      reduce using rule 51 (and_expression -> equality_expression .)
    EQUAL           shift and go to state 150
    NEQUAL          shift and go to state 149


state 75

    (165) method_declaration -> method_header . method_body
    (175) method_body -> . method_start_scope block_statements_opt end_scope
    (176) method_start_scope -> . BLOCKBEGIN

    BLOCKBEGIN      shift and go to state 153

    method_body                    shift and go to state 152
    method_start_scope             shift and go to state 151

state 76

    (136) normal_statement -> empty_statement . marker
    (41) marker -> . empty
    (191) empty -> .

    KEYWORD_IF      reduce using rule 191 (empty -> .)
    KEYWORD_WHILE   reduce using rule 191 (empty -> .)
    KEYWORD_DO      reduce using rule 191 (empty -> .)
    KEYWORD_FOR     reduce using rule 191 (empty -> .)
    KEYWORD_CLASS   reduce using rule 191 (empty -> .)
    KEYWORD_OBJECT  reduce using rule 191 (empty -> .)
    KEYWORD_VAR     reduce using rule 191 (empty -> .)
    KEYWORD_VAL     reduce using rule 191 (empty -> .)
    TERMINATOR      reduce using rule 191 (empty -> .)
    KEYWORD_RETURN  reduce using rule 191 (empty -> .)
    KEYWORD_DEF     reduce using rule 191 (empty -> .)
    BLOCKBEGIN      reduce using rule 191 (empty -> .)
    IDENTIFIER      reduce using rule 191 (empty -> .)
    PLUS            reduce using rule 191 (empty -> .)
    MINUS           reduce using rule 191 (empty -> .)
    TILDA           reduce using rule 191 (empty -> .)
    NOT             reduce using rule 191 (empty -> .)
    LPAREN          reduce using rule 191 (empty -> .)
    INT_NUMBER      reduce using rule 191 (empty -> .)
    BOOL_CONSTT     reduce using rule 191 (empty -> .)
    BOOL_CONSTF     reduce using rule 191 (empty -> .)
    BLOCKEND        reduce using rule 191 (empty -> .)
    KEYWORD_ELSE    reduce using rule 191 (empty -> .)

    marker                         shift and go to state 154
    empty                          shift and go to state 99

state 77

    (95) local_variable_declaration_statement -> local_variable_declaration . TERMINATOR

    TERMINATOR      shift and go to state 155


state 78

    (128) statement -> normal_statement . marker
    (41) marker -> . empty
    (191) empty -> .

    KEYWORD_IF      reduce using rule 191 (empty -> .)
    KEYWORD_WHILE   reduce using rule 191 (empty -> .)
    KEYWORD_DO      reduce using rule 191 (empty -> .)
    KEYWORD_FOR     reduce using rule 191 (empty -> .)
    KEYWORD_CLASS   reduce using rule 191 (empty -> .)
    KEYWORD_OBJECT  reduce using rule 191 (empty -> .)
    KEYWORD_VAR     reduce using rule 191 (empty -> .)
    KEYWORD_VAL     reduce using rule 191 (empty -> .)
    TERMINATOR      reduce using rule 191 (empty -> .)
    KEYWORD_RETURN  reduce using rule 191 (empty -> .)
    KEYWORD_DEF     reduce using rule 191 (empty -> .)
    BLOCKBEGIN      reduce using rule 191 (empty -> .)
    IDENTIFIER      reduce using rule 191 (empty -> .)
    PLUS            reduce using rule 191 (empty -> .)
    MINUS           reduce using rule 191 (empty -> .)
    TILDA           reduce using rule 191 (empty -> .)
    NOT             reduce using rule 191 (empty -> .)
    LPAREN          reduce using rule 191 (empty -> .)
    INT_NUMBER      reduce using rule 191 (empty -> .)
    BOOL_CONSTT     reduce using rule 191 (empty -> .)
    BOOL_CONSTF     reduce using rule 191 (empty -> .)
    BLOCKEND        reduce using rule 191 (empty -> .)

    marker                         shift and go to state 156
    empty                          shift and go to state 99

state 79

    (49) exclusive_or_expression -> and_expression .
    (52) and_expression -> and_expression . AND_BITWISE equality_expression

    XOR             reduce using rule 49 (exclusive_or_expression -> and_expression .)
    OR_BITWISE      reduce using rule 49 (exclusive_or_expression -> and_expression .)
    AND             reduce using rule 49 (exclusive_or_expression -> and_expression .)
    OR              reduce using rule 49 (exclusive_or_expression -> and_expression .)
    TERMINATOR      reduce using rule 49 (exclusive_or_expression -> and_expression .)
    KEYWORD_MATCH   reduce using rule 49 (exclusive_or_expression -> and_expression .)
    RPAREN          reduce using rule 49 (exclusive_or_expression -> and_expression .)
    RBRAC           reduce using rule 49 (exclusive_or_expression -> and_expression .)
    COMMA           reduce using rule 49 (exclusive_or_expression -> and_expression .)
    FUNTYPE         reduce using rule 49 (exclusive_or_expression -> and_expression .)
    KEYWORD_UNTIL   reduce using rule 49 (exclusive_or_expression -> and_expression .)
    KEYWORD_TO      reduce using rule 49 (exclusive_or_expression -> and_expression .)
    KEYWORD_BY      reduce using rule 49 (exclusive_or_expression -> and_expression .)
    AND_BITWISE     shift and go to state 157


state 80

    (74) unary_expression_not_plus_minus -> base_variable_set .

    TIMES           reduce using rule 74 (unary_expression_not_plus_minus -> base_variable_set .)
    DIVIDE          reduce using rule 74 (unary_expression_not_plus_minus -> base_variable_set .)
    REMAINDER       reduce using rule 74 (unary_expression_not_plus_minus -> base_variable_set .)
    PLUS            reduce using rule 74 (unary_expression_not_plus_minus -> base_variable_set .)
    MINUS           reduce using rule 74 (unary_expression_not_plus_minus -> base_variable_set .)
    LSHIFT          reduce using rule 74 (unary_expression_not_plus_minus -> base_variable_set .)
    RSHIFT          reduce using rule 74 (unary_expression_not_plus_minus -> base_variable_set .)
    GREATER         reduce using rule 74 (unary_expression_not_plus_minus -> base_variable_set .)
    LESS            reduce using rule 74 (unary_expression_not_plus_minus -> base_variable_set .)
    GEQ             reduce using rule 74 (unary_expression_not_plus_minus -> base_variable_set .)
    LEQ             reduce using rule 74 (unary_expression_not_plus_minus -> base_variable_set .)
    EQUAL           reduce using rule 74 (unary_expression_not_plus_minus -> base_variable_set .)
    NEQUAL          reduce using rule 74 (unary_expression_not_plus_minus -> base_variable_set .)
    AND_BITWISE     reduce using rule 74 (unary_expression_not_plus_minus -> base_variable_set .)
    XOR             reduce using rule 74 (unary_expression_not_plus_minus -> base_variable_set .)
    OR_BITWISE      reduce using rule 74 (unary_expression_not_plus_minus -> base_variable_set .)
    AND             reduce using rule 74 (unary_expression_not_plus_minus -> base_variable_set .)
    OR              reduce using rule 74 (unary_expression_not_plus_minus -> base_variable_set .)
    KEYWORD_MATCH   reduce using rule 74 (unary_expression_not_plus_minus -> base_variable_set .)
    TERMINATOR      reduce using rule 74 (unary_expression_not_plus_minus -> base_variable_set .)
    RPAREN          reduce using rule 74 (unary_expression_not_plus_minus -> base_variable_set .)
    RBRAC           reduce using rule 74 (unary_expression_not_plus_minus -> base_variable_set .)
    COMMA           reduce using rule 74 (unary_expression_not_plus_minus -> base_variable_set .)
    FUNTYPE         reduce using rule 74 (unary_expression_not_plus_minus -> base_variable_set .)
    KEYWORD_UNTIL   reduce using rule 74 (unary_expression_not_plus_minus -> base_variable_set .)
    KEYWORD_TO      reduce using rule 74 (unary_expression_not_plus_minus -> base_variable_set .)
    KEYWORD_BY      reduce using rule 74 (unary_expression_not_plus_minus -> base_variable_set .)


state 81

    (137) normal_statement -> return_statement . marker
    (41) marker -> . empty
    (191) empty -> .

    KEYWORD_IF      reduce using rule 191 (empty -> .)
    KEYWORD_WHILE   reduce using rule 191 (empty -> .)
    KEYWORD_DO      reduce using rule 191 (empty -> .)
    KEYWORD_FOR     reduce using rule 191 (empty -> .)
    KEYWORD_CLASS   reduce using rule 191 (empty -> .)
    KEYWORD_OBJECT  reduce using rule 191 (empty -> .)
    KEYWORD_VAR     reduce using rule 191 (empty -> .)
    KEYWORD_VAL     reduce using rule 191 (empty -> .)
    TERMINATOR      reduce using rule 191 (empty -> .)
    KEYWORD_RETURN  reduce using rule 191 (empty -> .)
    KEYWORD_DEF     reduce using rule 191 (empty -> .)
    BLOCKBEGIN      reduce using rule 191 (empty -> .)
    IDENTIFIER      reduce using rule 191 (empty -> .)
    PLUS            reduce using rule 191 (empty -> .)
    MINUS           reduce using rule 191 (empty -> .)
    TILDA           reduce using rule 191 (empty -> .)
    NOT             reduce using rule 191 (empty -> .)
    LPAREN          reduce using rule 191 (empty -> .)
    INT_NUMBER      reduce using rule 191 (empty -> .)
    BOOL_CONSTT     reduce using rule 191 (empty -> .)
    BOOL_CONSTF     reduce using rule 191 (empty -> .)
    BLOCKEND        reduce using rule 191 (empty -> .)
    KEYWORD_ELSE    reduce using rule 191 (empty -> .)

    marker                         shift and go to state 158
    empty                          shift and go to state 99

state 82

    (10) block_statements_opt -> block_statements .
    (13) block_statements -> block_statements . marker block_statement
    (41) marker -> . empty
    (191) empty -> .

    BLOCKEND        reduce using rule 10 (block_statements_opt -> block_statements .)
    KEYWORD_IF      reduce using rule 191 (empty -> .)
    KEYWORD_WHILE   reduce using rule 191 (empty -> .)
    KEYWORD_DO      reduce using rule 191 (empty -> .)
    KEYWORD_FOR     reduce using rule 191 (empty -> .)
    KEYWORD_CLASS   reduce using rule 191 (empty -> .)
    KEYWORD_OBJECT  reduce using rule 191 (empty -> .)
    KEYWORD_VAR     reduce using rule 191 (empty -> .)
    KEYWORD_VAL     reduce using rule 191 (empty -> .)
    TERMINATOR      reduce using rule 191 (empty -> .)
    KEYWORD_RETURN  reduce using rule 191 (empty -> .)
    KEYWORD_DEF     reduce using rule 191 (empty -> .)
    BLOCKBEGIN      reduce using rule 191 (empty -> .)
    IDENTIFIER      reduce using rule 191 (empty -> .)
    PLUS            reduce using rule 191 (empty -> .)
    MINUS           reduce using rule 191 (empty -> .)
    TILDA           reduce using rule 191 (empty -> .)
    NOT             reduce using rule 191 (empty -> .)
    LPAREN          reduce using rule 191 (empty -> .)
    INT_NUMBER      reduce using rule 191 (empty -> .)
    BOOL_CONSTT     reduce using rule 191 (empty -> .)
    BOOL_CONSTF     reduce using rule 191 (empty -> .)

    marker                         shift and go to state 159
    empty                          shift and go to state 99

state 83

    (19) expression -> assignment_expression .

    RPAREN          reduce using rule 19 (expression -> assignment_expression .)
    RBRAC           reduce using rule 19 (expression -> assignment_expression .)
    COMMA           reduce using rule 19 (expression -> assignment_expression .)
    TERMINATOR      reduce using rule 19 (expression -> assignment_expression .)
    KEYWORD_MATCH   reduce using rule 19 (expression -> assignment_expression .)
    FUNTYPE         reduce using rule 19 (expression -> assignment_expression .)
    KEYWORD_BY      reduce using rule 19 (expression -> assignment_expression .)
    KEYWORD_UNTIL   reduce using rule 19 (expression -> assignment_expression .)
    KEYWORD_TO      reduce using rule 19 (expression -> assignment_expression .)


state 84

    (140) statement_expression -> assignment .
    (22) assignment_expression -> assignment .

    TERMINATOR      reduce using rule 140 (statement_expression -> assignment .)
    KEYWORD_MATCH   reduce using rule 22 (assignment_expression -> assignment .)


state 85

    (84) literal -> c_literal .

    TIMES           reduce using rule 84 (literal -> c_literal .)
    DIVIDE          reduce using rule 84 (literal -> c_literal .)
    REMAINDER       reduce using rule 84 (literal -> c_literal .)
    PLUS            reduce using rule 84 (literal -> c_literal .)
    MINUS           reduce using rule 84 (literal -> c_literal .)
    LSHIFT          reduce using rule 84 (literal -> c_literal .)
    RSHIFT          reduce using rule 84 (literal -> c_literal .)
    GREATER         reduce using rule 84 (literal -> c_literal .)
    LESS            reduce using rule 84 (literal -> c_literal .)
    GEQ             reduce using rule 84 (literal -> c_literal .)
    LEQ             reduce using rule 84 (literal -> c_literal .)
    EQUAL           reduce using rule 84 (literal -> c_literal .)
    NEQUAL          reduce using rule 84 (literal -> c_literal .)
    AND_BITWISE     reduce using rule 84 (literal -> c_literal .)
    XOR             reduce using rule 84 (literal -> c_literal .)
    OR_BITWISE      reduce using rule 84 (literal -> c_literal .)
    AND             reduce using rule 84 (literal -> c_literal .)
    OR              reduce using rule 84 (literal -> c_literal .)
    KEYWORD_MATCH   reduce using rule 84 (literal -> c_literal .)
    FUNTYPE         reduce using rule 84 (literal -> c_literal .)
    TERMINATOR      reduce using rule 84 (literal -> c_literal .)
    RPAREN          reduce using rule 84 (literal -> c_literal .)
    RBRAC           reduce using rule 84 (literal -> c_literal .)
    COMMA           reduce using rule 84 (literal -> c_literal .)
    KEYWORD_UNTIL   reduce using rule 84 (literal -> c_literal .)
    KEYWORD_TO      reduce using rule 84 (literal -> c_literal .)
    KEYWORD_BY      reduce using rule 84 (literal -> c_literal .)


state 86

    (78) base_variable_set -> LPAREN . expression RPAREN
    (19) expression -> . assignment_expression
    (22) assignment_expression -> . assignment
    (23) assignment_expression -> . conditional_or_expression
    (24) assignment_expression -> . method_invocation
    (25) assignment -> . valid_variable assignment_operator assignment_expression
    (43) conditional_or_expression -> . conditional_and_expression
    (44) conditional_or_expression -> . conditional_or_expression OR marker conditional_and_expression
    (88) method_invocation -> . name LPAREN argument_list_opt RPAREN
    (26) valid_variable -> . name
    (27) valid_variable -> . array_access
    (45) conditional_and_expression -> . inclusive_or_expression
    (46) conditional_and_expression -> . conditional_and_expression AND marker inclusive_or_expression
    (121) name -> . simple_name
    (122) name -> . qualified_name
    (28) array_access -> . name dimension
    (47) inclusive_or_expression -> . exclusive_or_expression
    (48) inclusive_or_expression -> . inclusive_or_expression OR_BITWISE exclusive_or_expression
    (123) simple_name -> . IDENTIFIER
    (124) qualified_name -> . name INST simple_name
    (49) exclusive_or_expression -> . and_expression
    (50) exclusive_or_expression -> . exclusive_or_expression XOR and_expression
    (51) and_expression -> . equality_expression
    (52) and_expression -> . and_expression AND_BITWISE equality_expression
    (53) equality_expression -> . relational_expression
    (54) equality_expression -> . equality_expression EQUAL relational_expression
    (55) equality_expression -> . equality_expression NEQUAL relational_expression
    (56) relational_expression -> . shift_expression
    (57) relational_expression -> . relational_expression GREATER shift_expression
    (58) relational_expression -> . relational_expression LESS shift_expression
    (59) relational_expression -> . relational_expression GEQ shift_expression
    (60) relational_expression -> . relational_expression LEQ shift_expression
    (61) shift_expression -> . additive_expression
    (62) shift_expression -> . shift_expression LSHIFT additive_expression
    (63) shift_expression -> . shift_expression RSHIFT additive_expression
    (64) additive_expression -> . multiplicative_expression
    (65) additive_expression -> . additive_expression PLUS multiplicative_expression
    (66) additive_expression -> . additive_expression MINUS multiplicative_expression
    (67) multiplicative_expression -> . unary_expression
    (68) multiplicative_expression -> . multiplicative_expression TIMES unary_expression
    (69) multiplicative_expression -> . multiplicative_expression DIVIDE unary_expression
    (70) multiplicative_expression -> . multiplicative_expression REMAINDER unary_expression
    (71) unary_expression -> . PLUS unary_expression
    (72) unary_expression -> . MINUS unary_expression
    (73) unary_expression -> . unary_expression_not_plus_minus
    (74) unary_expression_not_plus_minus -> . base_variable_set
    (75) unary_expression_not_plus_minus -> . TILDA unary_expression
    (76) unary_expression_not_plus_minus -> . NOT unary_expression
    (77) base_variable_set -> . variable_literal
    (78) base_variable_set -> . LPAREN expression RPAREN
    (79) variable_literal -> . valid_variable
    (80) variable_literal -> . primary
    (81) primary -> . literal
    (82) primary -> . method_invocation
    (83) literal -> . int_float
    (84) literal -> . c_literal
    (87) int_float -> . INT_NUMBER
    (85) c_literal -> . BOOL_CONSTT
    (86) c_literal -> . BOOL_CONSTF

    IDENTIFIER      shift and go to state 9
    PLUS            shift and go to state 30
    MINUS           shift and go to state 24
    TILDA           shift and go to state 65
    NOT             shift and go to state 52
    LPAREN          shift and go to state 86
    INT_NUMBER      shift and go to state 38
    BOOL_CONSTT     shift and go to state 29
    BOOL_CONSTF     shift and go to state 25

    and_expression                 shift and go to state 79
    exclusive_or_expression        shift and go to state 56
    primary                        shift and go to state 57
    unary_expression_not_plus_minus shift and go to state 40
    array_access                   shift and go to state 23
    additive_expression            shift and go to state 59
    simple_name                    shift and go to state 60
    c_literal                      shift and go to state 85
    unary_expression               shift and go to state 39
    base_variable_set              shift and go to state 80
    valid_variable                 shift and go to state 87
    inclusive_or_expression        shift and go to state 27
    literal                        shift and go to state 64
    relational_expression          shift and go to state 66
    method_invocation              shift and go to state 134
    conditional_or_expression      shift and go to state 42
    assignment_expression          shift and go to state 83
    qualified_name                 shift and go to state 71
    assignment                     shift and go to state 137
    multiplicative_expression      shift and go to state 45
    shift_expression               shift and go to state 49
    equality_expression            shift and go to state 74
    int_float                      shift and go to state 34
    variable_literal               shift and go to state 50
    name                           shift and go to state 37
    expression                     shift and go to state 160
    conditional_and_expression     shift and go to state 51

state 87

    (25) assignment -> valid_variable . assignment_operator assignment_expression
    (79) variable_literal -> valid_variable .
    (30) assignment_operator -> . ASOP
    (31) assignment_operator -> . TIMES_ASSIGN
    (32) assignment_operator -> . DIVIDE_ASSIGN
    (33) assignment_operator -> . REMAINDER_ASSIGN
    (34) assignment_operator -> . PLUS_ASSIGN
    (35) assignment_operator -> . MINUS_ASSIGN
    (36) assignment_operator -> . LSHIFT_ASSIGN
    (37) assignment_operator -> . RSHIFT_ASSIGN
    (38) assignment_operator -> . AND_ASSIGN
    (39) assignment_operator -> . OR_ASSIGN
    (40) assignment_operator -> . XOR_ASSIGN

    TIMES           reduce using rule 79 (variable_literal -> valid_variable .)
    DIVIDE          reduce using rule 79 (variable_literal -> valid_variable .)
    REMAINDER       reduce using rule 79 (variable_literal -> valid_variable .)
    PLUS            reduce using rule 79 (variable_literal -> valid_variable .)
    MINUS           reduce using rule 79 (variable_literal -> valid_variable .)
    LSHIFT          reduce using rule 79 (variable_literal -> valid_variable .)
    RSHIFT          reduce using rule 79 (variable_literal -> valid_variable .)
    GREATER         reduce using rule 79 (variable_literal -> valid_variable .)
    LESS            reduce using rule 79 (variable_literal -> valid_variable .)
    GEQ             reduce using rule 79 (variable_literal -> valid_variable .)
    LEQ             reduce using rule 79 (variable_literal -> valid_variable .)
    EQUAL           reduce using rule 79 (variable_literal -> valid_variable .)
    NEQUAL          reduce using rule 79 (variable_literal -> valid_variable .)
    AND_BITWISE     reduce using rule 79 (variable_literal -> valid_variable .)
    XOR             reduce using rule 79 (variable_literal -> valid_variable .)
    OR_BITWISE      reduce using rule 79 (variable_literal -> valid_variable .)
    AND             reduce using rule 79 (variable_literal -> valid_variable .)
    OR              reduce using rule 79 (variable_literal -> valid_variable .)
    RPAREN          reduce using rule 79 (variable_literal -> valid_variable .)
    COMMA           reduce using rule 79 (variable_literal -> valid_variable .)
    FUNTYPE         reduce using rule 79 (variable_literal -> valid_variable .)
    KEYWORD_MATCH   reduce using rule 79 (variable_literal -> valid_variable .)
    TERMINATOR      reduce using rule 79 (variable_literal -> valid_variable .)
    KEYWORD_BY      reduce using rule 79 (variable_literal -> valid_variable .)
    RBRAC           reduce using rule 79 (variable_literal -> valid_variable .)
    KEYWORD_UNTIL   reduce using rule 79 (variable_literal -> valid_variable .)
    KEYWORD_TO      reduce using rule 79 (variable_literal -> valid_variable .)
    ASOP            shift and go to state 164
    TIMES_ASSIGN    shift and go to state 161
    DIVIDE_ASSIGN   shift and go to state 169
    REMAINDER_ASSIGN shift and go to state 165
    PLUS_ASSIGN     shift and go to state 171
    MINUS_ASSIGN    shift and go to state 163
    LSHIFT_ASSIGN   shift and go to state 167
    RSHIFT_ASSIGN   shift and go to state 162
    AND_ASSIGN      shift and go to state 168
    OR_ASSIGN       shift and go to state 166
    XOR_ASSIGN      shift and go to state 172

    assignment_operator            shift and go to state 170

state 88

    (16) block_statement -> class_declaration .

    KEYWORD_IF      reduce using rule 16 (block_statement -> class_declaration .)
    KEYWORD_WHILE   reduce using rule 16 (block_statement -> class_declaration .)
    KEYWORD_DO      reduce using rule 16 (block_statement -> class_declaration .)
    KEYWORD_FOR     reduce using rule 16 (block_statement -> class_declaration .)
    KEYWORD_CLASS   reduce using rule 16 (block_statement -> class_declaration .)
    KEYWORD_OBJECT  reduce using rule 16 (block_statement -> class_declaration .)
    KEYWORD_VAR     reduce using rule 16 (block_statement -> class_declaration .)
    KEYWORD_VAL     reduce using rule 16 (block_statement -> class_declaration .)
    TERMINATOR      reduce using rule 16 (block_statement -> class_declaration .)
    KEYWORD_RETURN  reduce using rule 16 (block_statement -> class_declaration .)
    KEYWORD_DEF     reduce using rule 16 (block_statement -> class_declaration .)
    BLOCKBEGIN      reduce using rule 16 (block_statement -> class_declaration .)
    IDENTIFIER      reduce using rule 16 (block_statement -> class_declaration .)
    PLUS            reduce using rule 16 (block_statement -> class_declaration .)
    MINUS           reduce using rule 16 (block_statement -> class_declaration .)
    TILDA           reduce using rule 16 (block_statement -> class_declaration .)
    NOT             reduce using rule 16 (block_statement -> class_declaration .)
    LPAREN          reduce using rule 16 (block_statement -> class_declaration .)
    INT_NUMBER      reduce using rule 16 (block_statement -> class_declaration .)
    BOOL_CONSTT     reduce using rule 16 (block_statement -> class_declaration .)
    BOOL_CONSTF     reduce using rule 16 (block_statement -> class_declaration .)
    BLOCKEND        reduce using rule 16 (block_statement -> class_declaration .)


state 89

    (149) for_statement -> KEYWORD_FOR . LPAREN for_update RPAREN marker block

    LPAREN          shift and go to state 173


state 90

    (148) do_while_statement -> KEYWORD_DO . marker block KEYWORD_WHILE LPAREN marker expression RPAREN TERMINATOR
    (41) marker -> . empty
    (191) empty -> .

    BLOCKBEGIN      reduce using rule 191 (empty -> .)

    marker                         shift and go to state 174
    empty                          shift and go to state 99

state 91

    (189) class_body -> class_body_start block_statements_opt . end_scope
    (9) end_scope -> . BLOCKEND

    BLOCKEND        shift and go to state 104

    end_scope                      shift and go to state 175

state 92

    (179) class_param_clause -> func_arg_start class_params_opt . RPAREN

    RPAREN          shift and go to state 176


state 93

    (185) class_declaration_keyword_opt -> declaration_keyword .

    IDENTIFIER      reduce using rule 185 (class_declaration_keyword_opt -> declaration_keyword .)


state 94

    (182) class_params -> class_param .

    COMMA           reduce using rule 182 (class_params -> class_param .)
    RPAREN          reduce using rule 182 (class_params -> class_param .)


state 95

    (180) class_params_opt -> class_params .
    (183) class_params -> class_params . COMMA class_param

    RPAREN          reduce using rule 180 (class_params_opt -> class_params .)
    COMMA           shift and go to state 177


state 96

    (184) class_param -> class_declaration_keyword_opt . variable_declarator_id
    (107) variable_declarator_id -> . IDENTIFIER COLON type

    IDENTIFIER      shift and go to state 178

    variable_declarator_id         shift and go to state 179

state 97

    (181) class_params_opt -> empty .
    (186) class_declaration_keyword_opt -> empty .

    RPAREN          reduce using rule 181 (class_params_opt -> empty .)
    IDENTIFIER      reduce using rule 186 (class_declaration_keyword_opt -> empty .)


state 98

    (135) normal_statement -> expression_statement marker .

    KEYWORD_IF      reduce using rule 135 (normal_statement -> expression_statement marker .)
    KEYWORD_WHILE   reduce using rule 135 (normal_statement -> expression_statement marker .)
    KEYWORD_DO      reduce using rule 135 (normal_statement -> expression_statement marker .)
    KEYWORD_FOR     reduce using rule 135 (normal_statement -> expression_statement marker .)
    KEYWORD_CLASS   reduce using rule 135 (normal_statement -> expression_statement marker .)
    KEYWORD_OBJECT  reduce using rule 135 (normal_statement -> expression_statement marker .)
    KEYWORD_VAR     reduce using rule 135 (normal_statement -> expression_statement marker .)
    KEYWORD_VAL     reduce using rule 135 (normal_statement -> expression_statement marker .)
    TERMINATOR      reduce using rule 135 (normal_statement -> expression_statement marker .)
    KEYWORD_RETURN  reduce using rule 135 (normal_statement -> expression_statement marker .)
    KEYWORD_DEF     reduce using rule 135 (normal_statement -> expression_statement marker .)
    BLOCKBEGIN      reduce using rule 135 (normal_statement -> expression_statement marker .)
    IDENTIFIER      reduce using rule 135 (normal_statement -> expression_statement marker .)
    PLUS            reduce using rule 135 (normal_statement -> expression_statement marker .)
    MINUS           reduce using rule 135 (normal_statement -> expression_statement marker .)
    TILDA           reduce using rule 135 (normal_statement -> expression_statement marker .)
    NOT             reduce using rule 135 (normal_statement -> expression_statement marker .)
    LPAREN          reduce using rule 135 (normal_statement -> expression_statement marker .)
    INT_NUMBER      reduce using rule 135 (normal_statement -> expression_statement marker .)
    BOOL_CONSTT     reduce using rule 135 (normal_statement -> expression_statement marker .)
    BOOL_CONSTF     reduce using rule 135 (normal_statement -> expression_statement marker .)
    BLOCKEND        reduce using rule 135 (normal_statement -> expression_statement marker .)
    KEYWORD_ELSE    reduce using rule 135 (normal_statement -> expression_statement marker .)


state 99

    (41) marker -> empty .

    BLOCKBEGIN      reduce using rule 41 (marker -> empty .)
    BLOCKEND        reduce using rule 41 (marker -> empty .)
    KEYWORD_CASE    reduce using rule 41 (marker -> empty .)
    PLUS            reduce using rule 41 (marker -> empty .)
    MINUS           reduce using rule 41 (marker -> empty .)
    TILDA           reduce using rule 41 (marker -> empty .)
    NOT             reduce using rule 41 (marker -> empty .)
    LPAREN          reduce using rule 41 (marker -> empty .)
    IDENTIFIER      reduce using rule 41 (marker -> empty .)
    INT_NUMBER      reduce using rule 41 (marker -> empty .)
    BOOL_CONSTT     reduce using rule 41 (marker -> empty .)
    BOOL_CONSTF     reduce using rule 41 (marker -> empty .)
    KEYWORD_IF      reduce using rule 41 (marker -> empty .)
    KEYWORD_WHILE   reduce using rule 41 (marker -> empty .)
    KEYWORD_DO      reduce using rule 41 (marker -> empty .)
    KEYWORD_FOR     reduce using rule 41 (marker -> empty .)
    KEYWORD_CLASS   reduce using rule 41 (marker -> empty .)
    KEYWORD_OBJECT  reduce using rule 41 (marker -> empty .)
    KEYWORD_VAR     reduce using rule 41 (marker -> empty .)
    KEYWORD_VAL     reduce using rule 41 (marker -> empty .)
    TERMINATOR      reduce using rule 41 (marker -> empty .)
    KEYWORD_RETURN  reduce using rule 41 (marker -> empty .)
    KEYWORD_DEF     reduce using rule 41 (marker -> empty .)
    KEYWORD_ELSE    reduce using rule 41 (marker -> empty .)
    KEYWORD_BY      reduce using rule 41 (marker -> empty .)
    RPAREN          reduce using rule 41 (marker -> empty .)


state 100

    (72) unary_expression -> MINUS unary_expression .

    TIMES           reduce using rule 72 (unary_expression -> MINUS unary_expression .)
    DIVIDE          reduce using rule 72 (unary_expression -> MINUS unary_expression .)
    REMAINDER       reduce using rule 72 (unary_expression -> MINUS unary_expression .)
    PLUS            reduce using rule 72 (unary_expression -> MINUS unary_expression .)
    MINUS           reduce using rule 72 (unary_expression -> MINUS unary_expression .)
    LSHIFT          reduce using rule 72 (unary_expression -> MINUS unary_expression .)
    RSHIFT          reduce using rule 72 (unary_expression -> MINUS unary_expression .)
    GREATER         reduce using rule 72 (unary_expression -> MINUS unary_expression .)
    LESS            reduce using rule 72 (unary_expression -> MINUS unary_expression .)
    GEQ             reduce using rule 72 (unary_expression -> MINUS unary_expression .)
    LEQ             reduce using rule 72 (unary_expression -> MINUS unary_expression .)
    EQUAL           reduce using rule 72 (unary_expression -> MINUS unary_expression .)
    NEQUAL          reduce using rule 72 (unary_expression -> MINUS unary_expression .)
    AND_BITWISE     reduce using rule 72 (unary_expression -> MINUS unary_expression .)
    XOR             reduce using rule 72 (unary_expression -> MINUS unary_expression .)
    OR_BITWISE      reduce using rule 72 (unary_expression -> MINUS unary_expression .)
    AND             reduce using rule 72 (unary_expression -> MINUS unary_expression .)
    OR              reduce using rule 72 (unary_expression -> MINUS unary_expression .)
    COMMA           reduce using rule 72 (unary_expression -> MINUS unary_expression .)
    RPAREN          reduce using rule 72 (unary_expression -> MINUS unary_expression .)
    KEYWORD_MATCH   reduce using rule 72 (unary_expression -> MINUS unary_expression .)
    TERMINATOR      reduce using rule 72 (unary_expression -> MINUS unary_expression .)
    RBRAC           reduce using rule 72 (unary_expression -> MINUS unary_expression .)
    FUNTYPE         reduce using rule 72 (unary_expression -> MINUS unary_expression .)
    KEYWORD_UNTIL   reduce using rule 72 (unary_expression -> MINUS unary_expression .)
    KEYWORD_TO      reduce using rule 72 (unary_expression -> MINUS unary_expression .)
    KEYWORD_BY      reduce using rule 72 (unary_expression -> MINUS unary_expression .)


state 101

    (79) variable_literal -> valid_variable .

    TIMES           reduce using rule 79 (variable_literal -> valid_variable .)
    DIVIDE          reduce using rule 79 (variable_literal -> valid_variable .)
    REMAINDER       reduce using rule 79 (variable_literal -> valid_variable .)
    PLUS            reduce using rule 79 (variable_literal -> valid_variable .)
    MINUS           reduce using rule 79 (variable_literal -> valid_variable .)
    LSHIFT          reduce using rule 79 (variable_literal -> valid_variable .)
    RSHIFT          reduce using rule 79 (variable_literal -> valid_variable .)
    GREATER         reduce using rule 79 (variable_literal -> valid_variable .)
    LESS            reduce using rule 79 (variable_literal -> valid_variable .)
    GEQ             reduce using rule 79 (variable_literal -> valid_variable .)
    LEQ             reduce using rule 79 (variable_literal -> valid_variable .)
    EQUAL           reduce using rule 79 (variable_literal -> valid_variable .)
    NEQUAL          reduce using rule 79 (variable_literal -> valid_variable .)
    AND_BITWISE     reduce using rule 79 (variable_literal -> valid_variable .)
    XOR             reduce using rule 79 (variable_literal -> valid_variable .)
    OR_BITWISE      reduce using rule 79 (variable_literal -> valid_variable .)
    AND             reduce using rule 79 (variable_literal -> valid_variable .)
    OR              reduce using rule 79 (variable_literal -> valid_variable .)
    KEYWORD_MATCH   reduce using rule 79 (variable_literal -> valid_variable .)
    TERMINATOR      reduce using rule 79 (variable_literal -> valid_variable .)
    RPAREN          reduce using rule 79 (variable_literal -> valid_variable .)
    RBRAC           reduce using rule 79 (variable_literal -> valid_variable .)
    COMMA           reduce using rule 79 (variable_literal -> valid_variable .)
    FUNTYPE         reduce using rule 79 (variable_literal -> valid_variable .)
    KEYWORD_UNTIL   reduce using rule 79 (variable_literal -> valid_variable .)
    KEYWORD_TO      reduce using rule 79 (variable_literal -> valid_variable .)
    KEYWORD_BY      reduce using rule 79 (variable_literal -> valid_variable .)


state 102

    (82) primary -> method_invocation .

    TIMES           reduce using rule 82 (primary -> method_invocation .)
    DIVIDE          reduce using rule 82 (primary -> method_invocation .)
    REMAINDER       reduce using rule 82 (primary -> method_invocation .)
    PLUS            reduce using rule 82 (primary -> method_invocation .)
    MINUS           reduce using rule 82 (primary -> method_invocation .)
    LSHIFT          reduce using rule 82 (primary -> method_invocation .)
    RSHIFT          reduce using rule 82 (primary -> method_invocation .)
    GREATER         reduce using rule 82 (primary -> method_invocation .)
    LESS            reduce using rule 82 (primary -> method_invocation .)
    GEQ             reduce using rule 82 (primary -> method_invocation .)
    LEQ             reduce using rule 82 (primary -> method_invocation .)
    EQUAL           reduce using rule 82 (primary -> method_invocation .)
    NEQUAL          reduce using rule 82 (primary -> method_invocation .)
    AND_BITWISE     reduce using rule 82 (primary -> method_invocation .)
    XOR             reduce using rule 82 (primary -> method_invocation .)
    OR_BITWISE      reduce using rule 82 (primary -> method_invocation .)
    AND             reduce using rule 82 (primary -> method_invocation .)
    OR              reduce using rule 82 (primary -> method_invocation .)
    KEYWORD_MATCH   reduce using rule 82 (primary -> method_invocation .)
    TERMINATOR      reduce using rule 82 (primary -> method_invocation .)
    RPAREN          reduce using rule 82 (primary -> method_invocation .)
    RBRAC           reduce using rule 82 (primary -> method_invocation .)
    COMMA           reduce using rule 82 (primary -> method_invocation .)
    FUNTYPE         reduce using rule 82 (primary -> method_invocation .)
    KEYWORD_UNTIL   reduce using rule 82 (primary -> method_invocation .)
    KEYWORD_TO      reduce using rule 82 (primary -> method_invocation .)
    KEYWORD_BY      reduce using rule 82 (primary -> method_invocation .)


state 103

    (26) valid_variable -> name .
    (28) array_access -> name . dimension
    (88) method_invocation -> name . LPAREN argument_list_opt RPAREN
    (124) qualified_name -> name . INST simple_name
    (29) dimension -> . LBRAC expression RBRAC

    TIMES           reduce using rule 26 (valid_variable -> name .)
    DIVIDE          reduce using rule 26 (valid_variable -> name .)
    REMAINDER       reduce using rule 26 (valid_variable -> name .)
    PLUS            reduce using rule 26 (valid_variable -> name .)
    MINUS           reduce using rule 26 (valid_variable -> name .)
    LSHIFT          reduce using rule 26 (valid_variable -> name .)
    RSHIFT          reduce using rule 26 (valid_variable -> name .)
    GREATER         reduce using rule 26 (valid_variable -> name .)
    LESS            reduce using rule 26 (valid_variable -> name .)
    GEQ             reduce using rule 26 (valid_variable -> name .)
    LEQ             reduce using rule 26 (valid_variable -> name .)
    EQUAL           reduce using rule 26 (valid_variable -> name .)
    NEQUAL          reduce using rule 26 (valid_variable -> name .)
    AND_BITWISE     reduce using rule 26 (valid_variable -> name .)
    XOR             reduce using rule 26 (valid_variable -> name .)
    OR_BITWISE      reduce using rule 26 (valid_variable -> name .)
    AND             reduce using rule 26 (valid_variable -> name .)
    OR              reduce using rule 26 (valid_variable -> name .)
    KEYWORD_MATCH   reduce using rule 26 (valid_variable -> name .)
    TERMINATOR      reduce using rule 26 (valid_variable -> name .)
    RPAREN          reduce using rule 26 (valid_variable -> name .)
    RBRAC           reduce using rule 26 (valid_variable -> name .)
    COMMA           reduce using rule 26 (valid_variable -> name .)
    FUNTYPE         reduce using rule 26 (valid_variable -> name .)
    KEYWORD_UNTIL   reduce using rule 26 (valid_variable -> name .)
    KEYWORD_TO      reduce using rule 26 (valid_variable -> name .)
    KEYWORD_BY      reduce using rule 26 (valid_variable -> name .)
    LPAREN          shift and go to state 114
    INST            shift and go to state 113
    LBRAC           shift and go to state 112

    dimension                      shift and go to state 115

state 104

    (9) end_scope -> BLOCKEND .

    KEYWORD_OBJECT  reduce using rule 9 (end_scope -> BLOCKEND .)
    KEYWORD_CLASS   reduce using rule 9 (end_scope -> BLOCKEND .)
    $end            reduce using rule 9 (end_scope -> BLOCKEND .)
    KEYWORD_IF      reduce using rule 9 (end_scope -> BLOCKEND .)
    KEYWORD_WHILE   reduce using rule 9 (end_scope -> BLOCKEND .)
    KEYWORD_DO      reduce using rule 9 (end_scope -> BLOCKEND .)
    KEYWORD_FOR     reduce using rule 9 (end_scope -> BLOCKEND .)
    KEYWORD_VAR     reduce using rule 9 (end_scope -> BLOCKEND .)
    KEYWORD_VAL     reduce using rule 9 (end_scope -> BLOCKEND .)
    TERMINATOR      reduce using rule 9 (end_scope -> BLOCKEND .)
    KEYWORD_RETURN  reduce using rule 9 (end_scope -> BLOCKEND .)
    KEYWORD_DEF     reduce using rule 9 (end_scope -> BLOCKEND .)
    BLOCKBEGIN      reduce using rule 9 (end_scope -> BLOCKEND .)
    IDENTIFIER      reduce using rule 9 (end_scope -> BLOCKEND .)
    PLUS            reduce using rule 9 (end_scope -> BLOCKEND .)
    MINUS           reduce using rule 9 (end_scope -> BLOCKEND .)
    TILDA           reduce using rule 9 (end_scope -> BLOCKEND .)
    NOT             reduce using rule 9 (end_scope -> BLOCKEND .)
    LPAREN          reduce using rule 9 (end_scope -> BLOCKEND .)
    INT_NUMBER      reduce using rule 9 (end_scope -> BLOCKEND .)
    BOOL_CONSTT     reduce using rule 9 (end_scope -> BLOCKEND .)
    BOOL_CONSTF     reduce using rule 9 (end_scope -> BLOCKEND .)
    BLOCKEND        reduce using rule 9 (end_scope -> BLOCKEND .)
    KEYWORD_ELSE    reduce using rule 9 (end_scope -> BLOCKEND .)
    KEYWORD_CASE    reduce using rule 9 (end_scope -> BLOCKEND .)


state 105

    (7) block -> start_scope block_statements_opt end_scope .

    KEYWORD_IF      reduce using rule 7 (block -> start_scope block_statements_opt end_scope .)
    KEYWORD_WHILE   reduce using rule 7 (block -> start_scope block_statements_opt end_scope .)
    KEYWORD_DO      reduce using rule 7 (block -> start_scope block_statements_opt end_scope .)
    KEYWORD_FOR     reduce using rule 7 (block -> start_scope block_statements_opt end_scope .)
    KEYWORD_CLASS   reduce using rule 7 (block -> start_scope block_statements_opt end_scope .)
    KEYWORD_OBJECT  reduce using rule 7 (block -> start_scope block_statements_opt end_scope .)
    KEYWORD_VAR     reduce using rule 7 (block -> start_scope block_statements_opt end_scope .)
    KEYWORD_VAL     reduce using rule 7 (block -> start_scope block_statements_opt end_scope .)
    TERMINATOR      reduce using rule 7 (block -> start_scope block_statements_opt end_scope .)
    KEYWORD_RETURN  reduce using rule 7 (block -> start_scope block_statements_opt end_scope .)
    KEYWORD_DEF     reduce using rule 7 (block -> start_scope block_statements_opt end_scope .)
    BLOCKBEGIN      reduce using rule 7 (block -> start_scope block_statements_opt end_scope .)
    IDENTIFIER      reduce using rule 7 (block -> start_scope block_statements_opt end_scope .)
    PLUS            reduce using rule 7 (block -> start_scope block_statements_opt end_scope .)
    MINUS           reduce using rule 7 (block -> start_scope block_statements_opt end_scope .)
    TILDA           reduce using rule 7 (block -> start_scope block_statements_opt end_scope .)
    NOT             reduce using rule 7 (block -> start_scope block_statements_opt end_scope .)
    LPAREN          reduce using rule 7 (block -> start_scope block_statements_opt end_scope .)
    INT_NUMBER      reduce using rule 7 (block -> start_scope block_statements_opt end_scope .)
    BOOL_CONSTT     reduce using rule 7 (block -> start_scope block_statements_opt end_scope .)
    BOOL_CONSTF     reduce using rule 7 (block -> start_scope block_statements_opt end_scope .)
    BLOCKEND        reduce using rule 7 (block -> start_scope block_statements_opt end_scope .)
    KEYWORD_ELSE    reduce using rule 7 (block -> start_scope block_statements_opt end_scope .)
    $end            reduce using rule 7 (block -> start_scope block_statements_opt end_scope .)
    KEYWORD_CASE    reduce using rule 7 (block -> start_scope block_statements_opt end_scope .)


state 106

    (48) inclusive_or_expression -> inclusive_or_expression OR_BITWISE . exclusive_or_expression
    (49) exclusive_or_expression -> . and_expression
    (50) exclusive_or_expression -> . exclusive_or_expression XOR and_expression
    (51) and_expression -> . equality_expression
    (52) and_expression -> . and_expression AND_BITWISE equality_expression
    (53) equality_expression -> . relational_expression
    (54) equality_expression -> . equality_expression EQUAL relational_expression
    (55) equality_expression -> . equality_expression NEQUAL relational_expression
    (56) relational_expression -> . shift_expression
    (57) relational_expression -> . relational_expression GREATER shift_expression
    (58) relational_expression -> . relational_expression LESS shift_expression
    (59) relational_expression -> . relational_expression GEQ shift_expression
    (60) relational_expression -> . relational_expression LEQ shift_expression
    (61) shift_expression -> . additive_expression
    (62) shift_expression -> . shift_expression LSHIFT additive_expression
    (63) shift_expression -> . shift_expression RSHIFT additive_expression
    (64) additive_expression -> . multiplicative_expression
    (65) additive_expression -> . additive_expression PLUS multiplicative_expression
    (66) additive_expression -> . additive_expression MINUS multiplicative_expression
    (67) multiplicative_expression -> . unary_expression
    (68) multiplicative_expression -> . multiplicative_expression TIMES unary_expression
    (69) multiplicative_expression -> . multiplicative_expression DIVIDE unary_expression
    (70) multiplicative_expression -> . multiplicative_expression REMAINDER unary_expression
    (71) unary_expression -> . PLUS unary_expression
    (72) unary_expression -> . MINUS unary_expression
    (73) unary_expression -> . unary_expression_not_plus_minus
    (74) unary_expression_not_plus_minus -> . base_variable_set
    (75) unary_expression_not_plus_minus -> . TILDA unary_expression
    (76) unary_expression_not_plus_minus -> . NOT unary_expression
    (77) base_variable_set -> . variable_literal
    (78) base_variable_set -> . LPAREN expression RPAREN
    (79) variable_literal -> . valid_variable
    (80) variable_literal -> . primary
    (26) valid_variable -> . name
    (27) valid_variable -> . array_access
    (81) primary -> . literal
    (82) primary -> . method_invocation
    (121) name -> . simple_name
    (122) name -> . qualified_name
    (28) array_access -> . name dimension
    (83) literal -> . int_float
    (84) literal -> . c_literal
    (88) method_invocation -> . name LPAREN argument_list_opt RPAREN
    (123) simple_name -> . IDENTIFIER
    (124) qualified_name -> . name INST simple_name
    (87) int_float -> . INT_NUMBER
    (85) c_literal -> . BOOL_CONSTT
    (86) c_literal -> . BOOL_CONSTF

    PLUS            shift and go to state 30
    MINUS           shift and go to state 24
    TILDA           shift and go to state 65
    NOT             shift and go to state 52
    LPAREN          shift and go to state 86
    IDENTIFIER      shift and go to state 9
    INT_NUMBER      shift and go to state 38
    BOOL_CONSTT     shift and go to state 29
    BOOL_CONSTF     shift and go to state 25

    unary_expression               shift and go to state 39
    exclusive_or_expression        shift and go to state 180
    primary                        shift and go to state 57
    unary_expression_not_plus_minus shift and go to state 40
    array_access                   shift and go to state 23
    additive_expression            shift and go to state 59
    simple_name                    shift and go to state 60
    c_literal                      shift and go to state 85
    base_variable_set              shift and go to state 80
    valid_variable                 shift and go to state 101
    literal                        shift and go to state 64
    and_expression                 shift and go to state 79
    method_invocation              shift and go to state 102
    relational_expression          shift and go to state 66
    qualified_name                 shift and go to state 71
    multiplicative_expression      shift and go to state 45
    shift_expression               shift and go to state 49
    equality_expression            shift and go to state 74
    int_float                      shift and go to state 34
    variable_literal               shift and go to state 50
    name                           shift and go to state 103

state 107

    (131) statement -> while_statement marker .

    KEYWORD_IF      reduce using rule 131 (statement -> while_statement marker .)
    KEYWORD_WHILE   reduce using rule 131 (statement -> while_statement marker .)
    KEYWORD_DO      reduce using rule 131 (statement -> while_statement marker .)
    KEYWORD_FOR     reduce using rule 131 (statement -> while_statement marker .)
    KEYWORD_CLASS   reduce using rule 131 (statement -> while_statement marker .)
    KEYWORD_OBJECT  reduce using rule 131 (statement -> while_statement marker .)
    KEYWORD_VAR     reduce using rule 131 (statement -> while_statement marker .)
    KEYWORD_VAL     reduce using rule 131 (statement -> while_statement marker .)
    TERMINATOR      reduce using rule 131 (statement -> while_statement marker .)
    KEYWORD_RETURN  reduce using rule 131 (statement -> while_statement marker .)
    KEYWORD_DEF     reduce using rule 131 (statement -> while_statement marker .)
    BLOCKBEGIN      reduce using rule 131 (statement -> while_statement marker .)
    IDENTIFIER      reduce using rule 131 (statement -> while_statement marker .)
    PLUS            reduce using rule 131 (statement -> while_statement marker .)
    MINUS           reduce using rule 131 (statement -> while_statement marker .)
    TILDA           reduce using rule 131 (statement -> while_statement marker .)
    NOT             reduce using rule 131 (statement -> while_statement marker .)
    LPAREN          reduce using rule 131 (statement -> while_statement marker .)
    INT_NUMBER      reduce using rule 131 (statement -> while_statement marker .)
    BOOL_CONSTT     reduce using rule 131 (statement -> while_statement marker .)
    BOOL_CONSTF     reduce using rule 131 (statement -> while_statement marker .)
    BLOCKEND        reduce using rule 131 (statement -> while_statement marker .)


state 108

    (71) unary_expression -> PLUS unary_expression .

    TIMES           reduce using rule 71 (unary_expression -> PLUS unary_expression .)
    DIVIDE          reduce using rule 71 (unary_expression -> PLUS unary_expression .)
    REMAINDER       reduce using rule 71 (unary_expression -> PLUS unary_expression .)
    PLUS            reduce using rule 71 (unary_expression -> PLUS unary_expression .)
    MINUS           reduce using rule 71 (unary_expression -> PLUS unary_expression .)
    LSHIFT          reduce using rule 71 (unary_expression -> PLUS unary_expression .)
    RSHIFT          reduce using rule 71 (unary_expression -> PLUS unary_expression .)
    GREATER         reduce using rule 71 (unary_expression -> PLUS unary_expression .)
    LESS            reduce using rule 71 (unary_expression -> PLUS unary_expression .)
    GEQ             reduce using rule 71 (unary_expression -> PLUS unary_expression .)
    LEQ             reduce using rule 71 (unary_expression -> PLUS unary_expression .)
    EQUAL           reduce using rule 71 (unary_expression -> PLUS unary_expression .)
    NEQUAL          reduce using rule 71 (unary_expression -> PLUS unary_expression .)
    AND_BITWISE     reduce using rule 71 (unary_expression -> PLUS unary_expression .)
    XOR             reduce using rule 71 (unary_expression -> PLUS unary_expression .)
    OR_BITWISE      reduce using rule 71 (unary_expression -> PLUS unary_expression .)
    AND             reduce using rule 71 (unary_expression -> PLUS unary_expression .)
    OR              reduce using rule 71 (unary_expression -> PLUS unary_expression .)
    COMMA           reduce using rule 71 (unary_expression -> PLUS unary_expression .)
    RPAREN          reduce using rule 71 (unary_expression -> PLUS unary_expression .)
    KEYWORD_MATCH   reduce using rule 71 (unary_expression -> PLUS unary_expression .)
    TERMINATOR      reduce using rule 71 (unary_expression -> PLUS unary_expression .)
    RBRAC           reduce using rule 71 (unary_expression -> PLUS unary_expression .)
    FUNTYPE         reduce using rule 71 (unary_expression -> PLUS unary_expression .)
    KEYWORD_UNTIL   reduce using rule 71 (unary_expression -> PLUS unary_expression .)
    KEYWORD_TO      reduce using rule 71 (unary_expression -> PLUS unary_expression .)
    KEYWORD_BY      reduce using rule 71 (unary_expression -> PLUS unary_expression .)


state 109

    (139) expression_statement -> statement_expression TERMINATOR .

    KEYWORD_IF      reduce using rule 139 (expression_statement -> statement_expression TERMINATOR .)
    KEYWORD_WHILE   reduce using rule 139 (expression_statement -> statement_expression TERMINATOR .)
    KEYWORD_DO      reduce using rule 139 (expression_statement -> statement_expression TERMINATOR .)
    KEYWORD_FOR     reduce using rule 139 (expression_statement -> statement_expression TERMINATOR .)
    KEYWORD_CLASS   reduce using rule 139 (expression_statement -> statement_expression TERMINATOR .)
    KEYWORD_OBJECT  reduce using rule 139 (expression_statement -> statement_expression TERMINATOR .)
    KEYWORD_VAR     reduce using rule 139 (expression_statement -> statement_expression TERMINATOR .)
    KEYWORD_VAL     reduce using rule 139 (expression_statement -> statement_expression TERMINATOR .)
    TERMINATOR      reduce using rule 139 (expression_statement -> statement_expression TERMINATOR .)
    KEYWORD_RETURN  reduce using rule 139 (expression_statement -> statement_expression TERMINATOR .)
    KEYWORD_DEF     reduce using rule 139 (expression_statement -> statement_expression TERMINATOR .)
    BLOCKBEGIN      reduce using rule 139 (expression_statement -> statement_expression TERMINATOR .)
    IDENTIFIER      reduce using rule 139 (expression_statement -> statement_expression TERMINATOR .)
    PLUS            reduce using rule 139 (expression_statement -> statement_expression TERMINATOR .)
    MINUS           reduce using rule 139 (expression_statement -> statement_expression TERMINATOR .)
    TILDA           reduce using rule 139 (expression_statement -> statement_expression TERMINATOR .)
    NOT             reduce using rule 139 (expression_statement -> statement_expression TERMINATOR .)
    LPAREN          reduce using rule 139 (expression_statement -> statement_expression TERMINATOR .)
    INT_NUMBER      reduce using rule 139 (expression_statement -> statement_expression TERMINATOR .)
    BOOL_CONSTT     reduce using rule 139 (expression_statement -> statement_expression TERMINATOR .)
    BOOL_CONSTF     reduce using rule 139 (expression_statement -> statement_expression TERMINATOR .)
    BLOCKEND        reduce using rule 139 (expression_statement -> statement_expression TERMINATOR .)
    KEYWORD_ELSE    reduce using rule 139 (expression_statement -> statement_expression TERMINATOR .)


state 110

    (133) statement -> for_statement marker .

    KEYWORD_IF      reduce using rule 133 (statement -> for_statement marker .)
    KEYWORD_WHILE   reduce using rule 133 (statement -> for_statement marker .)
    KEYWORD_DO      reduce using rule 133 (statement -> for_statement marker .)
    KEYWORD_FOR     reduce using rule 133 (statement -> for_statement marker .)
    KEYWORD_CLASS   reduce using rule 133 (statement -> for_statement marker .)
    KEYWORD_OBJECT  reduce using rule 133 (statement -> for_statement marker .)
    KEYWORD_VAR     reduce using rule 133 (statement -> for_statement marker .)
    KEYWORD_VAL     reduce using rule 133 (statement -> for_statement marker .)
    TERMINATOR      reduce using rule 133 (statement -> for_statement marker .)
    KEYWORD_RETURN  reduce using rule 133 (statement -> for_statement marker .)
    KEYWORD_DEF     reduce using rule 133 (statement -> for_statement marker .)
    BLOCKBEGIN      reduce using rule 133 (statement -> for_statement marker .)
    IDENTIFIER      reduce using rule 133 (statement -> for_statement marker .)
    PLUS            reduce using rule 133 (statement -> for_statement marker .)
    MINUS           reduce using rule 133 (statement -> for_statement marker .)
    TILDA           reduce using rule 133 (statement -> for_statement marker .)
    NOT             reduce using rule 133 (statement -> for_statement marker .)
    LPAREN          reduce using rule 133 (statement -> for_statement marker .)
    INT_NUMBER      reduce using rule 133 (statement -> for_statement marker .)
    BOOL_CONSTT     reduce using rule 133 (statement -> for_statement marker .)
    BOOL_CONSTF     reduce using rule 133 (statement -> for_statement marker .)
    BLOCKEND        reduce using rule 133 (statement -> for_statement marker .)


state 111

    (166) method_header -> method_header_name func_arg_start . fun_params_opt RPAREN COLON method_return_type ASOP
    (168) fun_params_opt -> . fun_params
    (169) fun_params_opt -> . empty
    (170) fun_params -> . fun_variable_declarator_id
    (171) fun_params -> . fun_params COMMA fun_variable_declarator_id
    (191) empty -> .
    (108) fun_variable_declarator_id -> . IDENTIFIER COLON type

    RPAREN          reduce using rule 191 (empty -> .)
    IDENTIFIER      shift and go to state 184

    fun_variable_declarator_id     shift and go to state 181
    fun_params_opt                 shift and go to state 182
    fun_params                     shift and go to state 183
    empty                          shift and go to state 185

state 112

    (29) dimension -> LBRAC . expression RBRAC
    (19) expression -> . assignment_expression
    (22) assignment_expression -> . assignment
    (23) assignment_expression -> . conditional_or_expression
    (24) assignment_expression -> . method_invocation
    (25) assignment -> . valid_variable assignment_operator assignment_expression
    (43) conditional_or_expression -> . conditional_and_expression
    (44) conditional_or_expression -> . conditional_or_expression OR marker conditional_and_expression
    (88) method_invocation -> . name LPAREN argument_list_opt RPAREN
    (26) valid_variable -> . name
    (27) valid_variable -> . array_access
    (45) conditional_and_expression -> . inclusive_or_expression
    (46) conditional_and_expression -> . conditional_and_expression AND marker inclusive_or_expression
    (121) name -> . simple_name
    (122) name -> . qualified_name
    (28) array_access -> . name dimension
    (47) inclusive_or_expression -> . exclusive_or_expression
    (48) inclusive_or_expression -> . inclusive_or_expression OR_BITWISE exclusive_or_expression
    (123) simple_name -> . IDENTIFIER
    (124) qualified_name -> . name INST simple_name
    (49) exclusive_or_expression -> . and_expression
    (50) exclusive_or_expression -> . exclusive_or_expression XOR and_expression
    (51) and_expression -> . equality_expression
    (52) and_expression -> . and_expression AND_BITWISE equality_expression
    (53) equality_expression -> . relational_expression
    (54) equality_expression -> . equality_expression EQUAL relational_expression
    (55) equality_expression -> . equality_expression NEQUAL relational_expression
    (56) relational_expression -> . shift_expression
    (57) relational_expression -> . relational_expression GREATER shift_expression
    (58) relational_expression -> . relational_expression LESS shift_expression
    (59) relational_expression -> . relational_expression GEQ shift_expression
    (60) relational_expression -> . relational_expression LEQ shift_expression
    (61) shift_expression -> . additive_expression
    (62) shift_expression -> . shift_expression LSHIFT additive_expression
    (63) shift_expression -> . shift_expression RSHIFT additive_expression
    (64) additive_expression -> . multiplicative_expression
    (65) additive_expression -> . additive_expression PLUS multiplicative_expression
    (66) additive_expression -> . additive_expression MINUS multiplicative_expression
    (67) multiplicative_expression -> . unary_expression
    (68) multiplicative_expression -> . multiplicative_expression TIMES unary_expression
    (69) multiplicative_expression -> . multiplicative_expression DIVIDE unary_expression
    (70) multiplicative_expression -> . multiplicative_expression REMAINDER unary_expression
    (71) unary_expression -> . PLUS unary_expression
    (72) unary_expression -> . MINUS unary_expression
    (73) unary_expression -> . unary_expression_not_plus_minus
    (74) unary_expression_not_plus_minus -> . base_variable_set
    (75) unary_expression_not_plus_minus -> . TILDA unary_expression
    (76) unary_expression_not_plus_minus -> . NOT unary_expression
    (77) base_variable_set -> . variable_literal
    (78) base_variable_set -> . LPAREN expression RPAREN
    (79) variable_literal -> . valid_variable
    (80) variable_literal -> . primary
    (81) primary -> . literal
    (82) primary -> . method_invocation
    (83) literal -> . int_float
    (84) literal -> . c_literal
    (87) int_float -> . INT_NUMBER
    (85) c_literal -> . BOOL_CONSTT
    (86) c_literal -> . BOOL_CONSTF

    IDENTIFIER      shift and go to state 9
    PLUS            shift and go to state 30
    MINUS           shift and go to state 24
    TILDA           shift and go to state 65
    NOT             shift and go to state 52
    LPAREN          shift and go to state 86
    INT_NUMBER      shift and go to state 38
    BOOL_CONSTT     shift and go to state 29
    BOOL_CONSTF     shift and go to state 25

    and_expression                 shift and go to state 79
    exclusive_or_expression        shift and go to state 56
    primary                        shift and go to state 57
    unary_expression_not_plus_minus shift and go to state 40
    array_access                   shift and go to state 23
    additive_expression            shift and go to state 59
    simple_name                    shift and go to state 60
    c_literal                      shift and go to state 85
    unary_expression               shift and go to state 39
    base_variable_set              shift and go to state 80
    valid_variable                 shift and go to state 87
    inclusive_or_expression        shift and go to state 27
    literal                        shift and go to state 64
    relational_expression          shift and go to state 66
    method_invocation              shift and go to state 134
    conditional_or_expression      shift and go to state 42
    assignment_expression          shift and go to state 83
    qualified_name                 shift and go to state 71
    assignment                     shift and go to state 137
    multiplicative_expression      shift and go to state 45
    shift_expression               shift and go to state 49
    equality_expression            shift and go to state 74
    int_float                      shift and go to state 34
    variable_literal               shift and go to state 50
    name                           shift and go to state 37
    expression                     shift and go to state 186
    conditional_and_expression     shift and go to state 51

state 113

    (124) qualified_name -> name INST . simple_name
    (123) simple_name -> . IDENTIFIER

    IDENTIFIER      shift and go to state 9

    simple_name                    shift and go to state 187

state 114

    (88) method_invocation -> name LPAREN . argument_list_opt RPAREN
    (89) argument_list_opt -> . argument_list
    (90) argument_list_opt -> . empty
    (91) argument_list -> . expression
    (92) argument_list -> . argument_list COMMA expression
    (191) empty -> .
    (19) expression -> . assignment_expression
    (22) assignment_expression -> . assignment
    (23) assignment_expression -> . conditional_or_expression
    (24) assignment_expression -> . method_invocation
    (25) assignment -> . valid_variable assignment_operator assignment_expression
    (43) conditional_or_expression -> . conditional_and_expression
    (44) conditional_or_expression -> . conditional_or_expression OR marker conditional_and_expression
    (88) method_invocation -> . name LPAREN argument_list_opt RPAREN
    (26) valid_variable -> . name
    (27) valid_variable -> . array_access
    (45) conditional_and_expression -> . inclusive_or_expression
    (46) conditional_and_expression -> . conditional_and_expression AND marker inclusive_or_expression
    (121) name -> . simple_name
    (122) name -> . qualified_name
    (28) array_access -> . name dimension
    (47) inclusive_or_expression -> . exclusive_or_expression
    (48) inclusive_or_expression -> . inclusive_or_expression OR_BITWISE exclusive_or_expression
    (123) simple_name -> . IDENTIFIER
    (124) qualified_name -> . name INST simple_name
    (49) exclusive_or_expression -> . and_expression
    (50) exclusive_or_expression -> . exclusive_or_expression XOR and_expression
    (51) and_expression -> . equality_expression
    (52) and_expression -> . and_expression AND_BITWISE equality_expression
    (53) equality_expression -> . relational_expression
    (54) equality_expression -> . equality_expression EQUAL relational_expression
    (55) equality_expression -> . equality_expression NEQUAL relational_expression
    (56) relational_expression -> . shift_expression
    (57) relational_expression -> . relational_expression GREATER shift_expression
    (58) relational_expression -> . relational_expression LESS shift_expression
    (59) relational_expression -> . relational_expression GEQ shift_expression
    (60) relational_expression -> . relational_expression LEQ shift_expression
    (61) shift_expression -> . additive_expression
    (62) shift_expression -> . shift_expression LSHIFT additive_expression
    (63) shift_expression -> . shift_expression RSHIFT additive_expression
    (64) additive_expression -> . multiplicative_expression
    (65) additive_expression -> . additive_expression PLUS multiplicative_expression
    (66) additive_expression -> . additive_expression MINUS multiplicative_expression
    (67) multiplicative_expression -> . unary_expression
    (68) multiplicative_expression -> . multiplicative_expression TIMES unary_expression
    (69) multiplicative_expression -> . multiplicative_expression DIVIDE unary_expression
    (70) multiplicative_expression -> . multiplicative_expression REMAINDER unary_expression
    (71) unary_expression -> . PLUS unary_expression
    (72) unary_expression -> . MINUS unary_expression
    (73) unary_expression -> . unary_expression_not_plus_minus
    (74) unary_expression_not_plus_minus -> . base_variable_set
    (75) unary_expression_not_plus_minus -> . TILDA unary_expression
    (76) unary_expression_not_plus_minus -> . NOT unary_expression
    (77) base_variable_set -> . variable_literal
    (78) base_variable_set -> . LPAREN expression RPAREN
    (79) variable_literal -> . valid_variable
    (80) variable_literal -> . primary
    (81) primary -> . literal
    (82) primary -> . method_invocation
    (83) literal -> . int_float
    (84) literal -> . c_literal
    (87) int_float -> . INT_NUMBER
    (85) c_literal -> . BOOL_CONSTT
    (86) c_literal -> . BOOL_CONSTF

    RPAREN          reduce using rule 191 (empty -> .)
    IDENTIFIER      shift and go to state 9
    PLUS            shift and go to state 30
    MINUS           shift and go to state 24
    TILDA           shift and go to state 65
    NOT             shift and go to state 52
    LPAREN          shift and go to state 86
    INT_NUMBER      shift and go to state 38
    BOOL_CONSTT     shift and go to state 29
    BOOL_CONSTF     shift and go to state 25

    unary_expression               shift and go to state 39
    exclusive_or_expression        shift and go to state 56
    primary                        shift and go to state 57
    unary_expression_not_plus_minus shift and go to state 40
    array_access                   shift and go to state 23
    and_expression                 shift and go to state 79
    simple_name                    shift and go to state 60
    c_literal                      shift and go to state 85
    base_variable_set              shift and go to state 80
    valid_variable                 shift and go to state 87
    inclusive_or_expression        shift and go to state 27
    literal                        shift and go to state 64
    relational_expression          shift and go to state 66
    method_invocation              shift and go to state 134
    conditional_or_expression      shift and go to state 42
    empty                          shift and go to state 189
    argument_list                  shift and go to state 188
    assignment_expression          shift and go to state 83
    qualified_name                 shift and go to state 71
    assignment                     shift and go to state 137
    multiplicative_expression      shift and go to state 45
    additive_expression            shift and go to state 59
    shift_expression               shift and go to state 49
    equality_expression            shift and go to state 74
    int_float                      shift and go to state 34
    variable_literal               shift and go to state 50
    name                           shift and go to state 37
    argument_list_opt              shift and go to state 190
    expression                     shift and go to state 191
    conditional_and_expression     shift and go to state 51

state 115

    (28) array_access -> name dimension .

    TIMES           reduce using rule 28 (array_access -> name dimension .)
    DIVIDE          reduce using rule 28 (array_access -> name dimension .)
    REMAINDER       reduce using rule 28 (array_access -> name dimension .)
    PLUS            reduce using rule 28 (array_access -> name dimension .)
    MINUS           reduce using rule 28 (array_access -> name dimension .)
    LSHIFT          reduce using rule 28 (array_access -> name dimension .)
    RSHIFT          reduce using rule 28 (array_access -> name dimension .)
    GREATER         reduce using rule 28 (array_access -> name dimension .)
    LESS            reduce using rule 28 (array_access -> name dimension .)
    GEQ             reduce using rule 28 (array_access -> name dimension .)
    LEQ             reduce using rule 28 (array_access -> name dimension .)
    EQUAL           reduce using rule 28 (array_access -> name dimension .)
    NEQUAL          reduce using rule 28 (array_access -> name dimension .)
    AND_BITWISE     reduce using rule 28 (array_access -> name dimension .)
    XOR             reduce using rule 28 (array_access -> name dimension .)
    OR_BITWISE      reduce using rule 28 (array_access -> name dimension .)
    AND             reduce using rule 28 (array_access -> name dimension .)
    OR              reduce using rule 28 (array_access -> name dimension .)
    KEYWORD_MATCH   reduce using rule 28 (array_access -> name dimension .)
    TERMINATOR      reduce using rule 28 (array_access -> name dimension .)
    RPAREN          reduce using rule 28 (array_access -> name dimension .)
    RBRAC           reduce using rule 28 (array_access -> name dimension .)
    COMMA           reduce using rule 28 (array_access -> name dimension .)
    FUNTYPE         reduce using rule 28 (array_access -> name dimension .)
    KEYWORD_UNTIL   reduce using rule 28 (array_access -> name dimension .)
    KEYWORD_TO      reduce using rule 28 (array_access -> name dimension .)
    KEYWORD_BY      reduce using rule 28 (array_access -> name dimension .)
    ASOP            reduce using rule 28 (array_access -> name dimension .)
    TIMES_ASSIGN    reduce using rule 28 (array_access -> name dimension .)
    DIVIDE_ASSIGN   reduce using rule 28 (array_access -> name dimension .)
    REMAINDER_ASSIGN reduce using rule 28 (array_access -> name dimension .)
    PLUS_ASSIGN     reduce using rule 28 (array_access -> name dimension .)
    MINUS_ASSIGN    reduce using rule 28 (array_access -> name dimension .)
    LSHIFT_ASSIGN   reduce using rule 28 (array_access -> name dimension .)
    RSHIFT_ASSIGN   reduce using rule 28 (array_access -> name dimension .)
    AND_ASSIGN      reduce using rule 28 (array_access -> name dimension .)
    OR_ASSIGN       reduce using rule 28 (array_access -> name dimension .)
    XOR_ASSIGN      reduce using rule 28 (array_access -> name dimension .)


state 116

    (138) normal_statement -> switch_statement marker .

    KEYWORD_IF      reduce using rule 138 (normal_statement -> switch_statement marker .)
    KEYWORD_WHILE   reduce using rule 138 (normal_statement -> switch_statement marker .)
    KEYWORD_DO      reduce using rule 138 (normal_statement -> switch_statement marker .)
    KEYWORD_FOR     reduce using rule 138 (normal_statement -> switch_statement marker .)
    KEYWORD_CLASS   reduce using rule 138 (normal_statement -> switch_statement marker .)
    KEYWORD_OBJECT  reduce using rule 138 (normal_statement -> switch_statement marker .)
    KEYWORD_VAR     reduce using rule 138 (normal_statement -> switch_statement marker .)
    KEYWORD_VAL     reduce using rule 138 (normal_statement -> switch_statement marker .)
    TERMINATOR      reduce using rule 138 (normal_statement -> switch_statement marker .)
    KEYWORD_RETURN  reduce using rule 138 (normal_statement -> switch_statement marker .)
    KEYWORD_DEF     reduce using rule 138 (normal_statement -> switch_statement marker .)
    BLOCKBEGIN      reduce using rule 138 (normal_statement -> switch_statement marker .)
    IDENTIFIER      reduce using rule 138 (normal_statement -> switch_statement marker .)
    PLUS            reduce using rule 138 (normal_statement -> switch_statement marker .)
    MINUS           reduce using rule 138 (normal_statement -> switch_statement marker .)
    TILDA           reduce using rule 138 (normal_statement -> switch_statement marker .)
    NOT             reduce using rule 138 (normal_statement -> switch_statement marker .)
    LPAREN          reduce using rule 138 (normal_statement -> switch_statement marker .)
    INT_NUMBER      reduce using rule 138 (normal_statement -> switch_statement marker .)
    BOOL_CONSTT     reduce using rule 138 (normal_statement -> switch_statement marker .)
    BOOL_CONSTF     reduce using rule 138 (normal_statement -> switch_statement marker .)
    BLOCKEND        reduce using rule 138 (normal_statement -> switch_statement marker .)
    KEYWORD_ELSE    reduce using rule 138 (normal_statement -> switch_statement marker .)


state 117

    (44) conditional_or_expression -> conditional_or_expression OR . marker conditional_and_expression
    (41) marker -> . empty
    (191) empty -> .

    PLUS            reduce using rule 191 (empty -> .)
    MINUS           reduce using rule 191 (empty -> .)
    TILDA           reduce using rule 191 (empty -> .)
    NOT             reduce using rule 191 (empty -> .)
    LPAREN          reduce using rule 191 (empty -> .)
    IDENTIFIER      reduce using rule 191 (empty -> .)
    INT_NUMBER      reduce using rule 191 (empty -> .)
    BOOL_CONSTT     reduce using rule 191 (empty -> .)
    BOOL_CONSTF     reduce using rule 191 (empty -> .)

    marker                         shift and go to state 192
    empty                          shift and go to state 99

state 118

    (147) while_statement -> KEYWORD_WHILE LPAREN . marker expression RPAREN marker block
    (41) marker -> . empty
    (191) empty -> .

    IDENTIFIER      reduce using rule 191 (empty -> .)
    PLUS            reduce using rule 191 (empty -> .)
    MINUS           reduce using rule 191 (empty -> .)
    TILDA           reduce using rule 191 (empty -> .)
    NOT             reduce using rule 191 (empty -> .)
    LPAREN          reduce using rule 191 (empty -> .)
    INT_NUMBER      reduce using rule 191 (empty -> .)
    BOOL_CONSTT     reduce using rule 191 (empty -> .)
    BOOL_CONSTF     reduce using rule 191 (empty -> .)

    marker                         shift and go to state 193
    empty                          shift and go to state 99

state 119

    (132) statement -> do_while_statement marker .

    KEYWORD_IF      reduce using rule 132 (statement -> do_while_statement marker .)
    KEYWORD_WHILE   reduce using rule 132 (statement -> do_while_statement marker .)
    KEYWORD_DO      reduce using rule 132 (statement -> do_while_statement marker .)
    KEYWORD_FOR     reduce using rule 132 (statement -> do_while_statement marker .)
    KEYWORD_CLASS   reduce using rule 132 (statement -> do_while_statement marker .)
    KEYWORD_OBJECT  reduce using rule 132 (statement -> do_while_statement marker .)
    KEYWORD_VAR     reduce using rule 132 (statement -> do_while_statement marker .)
    KEYWORD_VAL     reduce using rule 132 (statement -> do_while_statement marker .)
    TERMINATOR      reduce using rule 132 (statement -> do_while_statement marker .)
    KEYWORD_RETURN  reduce using rule 132 (statement -> do_while_statement marker .)
    KEYWORD_DEF     reduce using rule 132 (statement -> do_while_statement marker .)
    BLOCKBEGIN      reduce using rule 132 (statement -> do_while_statement marker .)
    IDENTIFIER      reduce using rule 132 (statement -> do_while_statement marker .)
    PLUS            reduce using rule 132 (statement -> do_while_statement marker .)
    MINUS           reduce using rule 132 (statement -> do_while_statement marker .)
    TILDA           reduce using rule 132 (statement -> do_while_statement marker .)
    NOT             reduce using rule 132 (statement -> do_while_statement marker .)
    LPAREN          reduce using rule 132 (statement -> do_while_statement marker .)
    INT_NUMBER      reduce using rule 132 (statement -> do_while_statement marker .)
    BOOL_CONSTT     reduce using rule 132 (statement -> do_while_statement marker .)
    BOOL_CONSTF     reduce using rule 132 (statement -> do_while_statement marker .)
    BLOCKEND        reduce using rule 132 (statement -> do_while_statement marker .)


state 120

    (70) multiplicative_expression -> multiplicative_expression REMAINDER . unary_expression
    (71) unary_expression -> . PLUS unary_expression
    (72) unary_expression -> . MINUS unary_expression
    (73) unary_expression -> . unary_expression_not_plus_minus
    (74) unary_expression_not_plus_minus -> . base_variable_set
    (75) unary_expression_not_plus_minus -> . TILDA unary_expression
    (76) unary_expression_not_plus_minus -> . NOT unary_expression
    (77) base_variable_set -> . variable_literal
    (78) base_variable_set -> . LPAREN expression RPAREN
    (79) variable_literal -> . valid_variable
    (80) variable_literal -> . primary
    (26) valid_variable -> . name
    (27) valid_variable -> . array_access
    (81) primary -> . literal
    (82) primary -> . method_invocation
    (121) name -> . simple_name
    (122) name -> . qualified_name
    (28) array_access -> . name dimension
    (83) literal -> . int_float
    (84) literal -> . c_literal
    (88) method_invocation -> . name LPAREN argument_list_opt RPAREN
    (123) simple_name -> . IDENTIFIER
    (124) qualified_name -> . name INST simple_name
    (87) int_float -> . INT_NUMBER
    (85) c_literal -> . BOOL_CONSTT
    (86) c_literal -> . BOOL_CONSTF

    PLUS            shift and go to state 30
    MINUS           shift and go to state 24
    TILDA           shift and go to state 65
    NOT             shift and go to state 52
    LPAREN          shift and go to state 86
    IDENTIFIER      shift and go to state 9
    INT_NUMBER      shift and go to state 38
    BOOL_CONSTT     shift and go to state 29
    BOOL_CONSTF     shift and go to state 25

    qualified_name                 shift and go to state 71
    int_float                      shift and go to state 34
    c_literal                      shift and go to state 85
    variable_literal               shift and go to state 50
    unary_expression               shift and go to state 194
    base_variable_set              shift and go to state 80
    valid_variable                 shift and go to state 101
    array_access                   shift and go to state 23
    primary                        shift and go to state 57
    unary_expression_not_plus_minus shift and go to state 40
    literal                        shift and go to state 64
    method_invocation              shift and go to state 102
    simple_name                    shift and go to state 60
    name                           shift and go to state 103

state 121

    (69) multiplicative_expression -> multiplicative_expression DIVIDE . unary_expression
    (71) unary_expression -> . PLUS unary_expression
    (72) unary_expression -> . MINUS unary_expression
    (73) unary_expression -> . unary_expression_not_plus_minus
    (74) unary_expression_not_plus_minus -> . base_variable_set
    (75) unary_expression_not_plus_minus -> . TILDA unary_expression
    (76) unary_expression_not_plus_minus -> . NOT unary_expression
    (77) base_variable_set -> . variable_literal
    (78) base_variable_set -> . LPAREN expression RPAREN
    (79) variable_literal -> . valid_variable
    (80) variable_literal -> . primary
    (26) valid_variable -> . name
    (27) valid_variable -> . array_access
    (81) primary -> . literal
    (82) primary -> . method_invocation
    (121) name -> . simple_name
    (122) name -> . qualified_name
    (28) array_access -> . name dimension
    (83) literal -> . int_float
    (84) literal -> . c_literal
    (88) method_invocation -> . name LPAREN argument_list_opt RPAREN
    (123) simple_name -> . IDENTIFIER
    (124) qualified_name -> . name INST simple_name
    (87) int_float -> . INT_NUMBER
    (85) c_literal -> . BOOL_CONSTT
    (86) c_literal -> . BOOL_CONSTF

    PLUS            shift and go to state 30
    MINUS           shift and go to state 24
    TILDA           shift and go to state 65
    NOT             shift and go to state 52
    LPAREN          shift and go to state 86
    IDENTIFIER      shift and go to state 9
    INT_NUMBER      shift and go to state 38
    BOOL_CONSTT     shift and go to state 29
    BOOL_CONSTF     shift and go to state 25

    qualified_name                 shift and go to state 71
    int_float                      shift and go to state 34
    c_literal                      shift and go to state 85
    variable_literal               shift and go to state 50
    unary_expression               shift and go to state 195
    base_variable_set              shift and go to state 80
    valid_variable                 shift and go to state 101
    array_access                   shift and go to state 23
    primary                        shift and go to state 57
    unary_expression_not_plus_minus shift and go to state 40
    literal                        shift and go to state 64
    method_invocation              shift and go to state 102
    simple_name                    shift and go to state 60
    name                           shift and go to state 103

state 122

    (68) multiplicative_expression -> multiplicative_expression TIMES . unary_expression
    (71) unary_expression -> . PLUS unary_expression
    (72) unary_expression -> . MINUS unary_expression
    (73) unary_expression -> . unary_expression_not_plus_minus
    (74) unary_expression_not_plus_minus -> . base_variable_set
    (75) unary_expression_not_plus_minus -> . TILDA unary_expression
    (76) unary_expression_not_plus_minus -> . NOT unary_expression
    (77) base_variable_set -> . variable_literal
    (78) base_variable_set -> . LPAREN expression RPAREN
    (79) variable_literal -> . valid_variable
    (80) variable_literal -> . primary
    (26) valid_variable -> . name
    (27) valid_variable -> . array_access
    (81) primary -> . literal
    (82) primary -> . method_invocation
    (121) name -> . simple_name
    (122) name -> . qualified_name
    (28) array_access -> . name dimension
    (83) literal -> . int_float
    (84) literal -> . c_literal
    (88) method_invocation -> . name LPAREN argument_list_opt RPAREN
    (123) simple_name -> . IDENTIFIER
    (124) qualified_name -> . name INST simple_name
    (87) int_float -> . INT_NUMBER
    (85) c_literal -> . BOOL_CONSTT
    (86) c_literal -> . BOOL_CONSTF

    PLUS            shift and go to state 30
    MINUS           shift and go to state 24
    TILDA           shift and go to state 65
    NOT             shift and go to state 52
    LPAREN          shift and go to state 86
    IDENTIFIER      shift and go to state 9
    INT_NUMBER      shift and go to state 38
    BOOL_CONSTT     shift and go to state 29
    BOOL_CONSTF     shift and go to state 25

    qualified_name                 shift and go to state 71
    int_float                      shift and go to state 34
    c_literal                      shift and go to state 85
    variable_literal               shift and go to state 50
    unary_expression               shift and go to state 196
    base_variable_set              shift and go to state 80
    valid_variable                 shift and go to state 101
    array_access                   shift and go to state 23
    primary                        shift and go to state 57
    unary_expression_not_plus_minus shift and go to state 40
    literal                        shift and go to state 64
    method_invocation              shift and go to state 102
    simple_name                    shift and go to state 60
    name                           shift and go to state 103

state 123

    (63) shift_expression -> shift_expression RSHIFT . additive_expression
    (64) additive_expression -> . multiplicative_expression
    (65) additive_expression -> . additive_expression PLUS multiplicative_expression
    (66) additive_expression -> . additive_expression MINUS multiplicative_expression
    (67) multiplicative_expression -> . unary_expression
    (68) multiplicative_expression -> . multiplicative_expression TIMES unary_expression
    (69) multiplicative_expression -> . multiplicative_expression DIVIDE unary_expression
    (70) multiplicative_expression -> . multiplicative_expression REMAINDER unary_expression
    (71) unary_expression -> . PLUS unary_expression
    (72) unary_expression -> . MINUS unary_expression
    (73) unary_expression -> . unary_expression_not_plus_minus
    (74) unary_expression_not_plus_minus -> . base_variable_set
    (75) unary_expression_not_plus_minus -> . TILDA unary_expression
    (76) unary_expression_not_plus_minus -> . NOT unary_expression
    (77) base_variable_set -> . variable_literal
    (78) base_variable_set -> . LPAREN expression RPAREN
    (79) variable_literal -> . valid_variable
    (80) variable_literal -> . primary
    (26) valid_variable -> . name
    (27) valid_variable -> . array_access
    (81) primary -> . literal
    (82) primary -> . method_invocation
    (121) name -> . simple_name
    (122) name -> . qualified_name
    (28) array_access -> . name dimension
    (83) literal -> . int_float
    (84) literal -> . c_literal
    (88) method_invocation -> . name LPAREN argument_list_opt RPAREN
    (123) simple_name -> . IDENTIFIER
    (124) qualified_name -> . name INST simple_name
    (87) int_float -> . INT_NUMBER
    (85) c_literal -> . BOOL_CONSTT
    (86) c_literal -> . BOOL_CONSTF

    PLUS            shift and go to state 30
    MINUS           shift and go to state 24
    TILDA           shift and go to state 65
    NOT             shift and go to state 52
    LPAREN          shift and go to state 86
    IDENTIFIER      shift and go to state 9
    INT_NUMBER      shift and go to state 38
    BOOL_CONSTT     shift and go to state 29
    BOOL_CONSTF     shift and go to state 25

    qualified_name                 shift and go to state 71
    int_float                      shift and go to state 34
    c_literal                      shift and go to state 85
    variable_literal               shift and go to state 50
    base_variable_set              shift and go to state 80
    unary_expression               shift and go to state 39
    valid_variable                 shift and go to state 101
    array_access                   shift and go to state 23
    multiplicative_expression      shift and go to state 45
    primary                        shift and go to state 57
    unary_expression_not_plus_minus shift and go to state 40
    literal                        shift and go to state 64
    method_invocation              shift and go to state 102
    simple_name                    shift and go to state 60
    additive_expression            shift and go to state 197
    name                           shift and go to state 103

state 124

    (62) shift_expression -> shift_expression LSHIFT . additive_expression
    (64) additive_expression -> . multiplicative_expression
    (65) additive_expression -> . additive_expression PLUS multiplicative_expression
    (66) additive_expression -> . additive_expression MINUS multiplicative_expression
    (67) multiplicative_expression -> . unary_expression
    (68) multiplicative_expression -> . multiplicative_expression TIMES unary_expression
    (69) multiplicative_expression -> . multiplicative_expression DIVIDE unary_expression
    (70) multiplicative_expression -> . multiplicative_expression REMAINDER unary_expression
    (71) unary_expression -> . PLUS unary_expression
    (72) unary_expression -> . MINUS unary_expression
    (73) unary_expression -> . unary_expression_not_plus_minus
    (74) unary_expression_not_plus_minus -> . base_variable_set
    (75) unary_expression_not_plus_minus -> . TILDA unary_expression
    (76) unary_expression_not_plus_minus -> . NOT unary_expression
    (77) base_variable_set -> . variable_literal
    (78) base_variable_set -> . LPAREN expression RPAREN
    (79) variable_literal -> . valid_variable
    (80) variable_literal -> . primary
    (26) valid_variable -> . name
    (27) valid_variable -> . array_access
    (81) primary -> . literal
    (82) primary -> . method_invocation
    (121) name -> . simple_name
    (122) name -> . qualified_name
    (28) array_access -> . name dimension
    (83) literal -> . int_float
    (84) literal -> . c_literal
    (88) method_invocation -> . name LPAREN argument_list_opt RPAREN
    (123) simple_name -> . IDENTIFIER
    (124) qualified_name -> . name INST simple_name
    (87) int_float -> . INT_NUMBER
    (85) c_literal -> . BOOL_CONSTT
    (86) c_literal -> . BOOL_CONSTF

    PLUS            shift and go to state 30
    MINUS           shift and go to state 24
    TILDA           shift and go to state 65
    NOT             shift and go to state 52
    LPAREN          shift and go to state 86
    IDENTIFIER      shift and go to state 9
    INT_NUMBER      shift and go to state 38
    BOOL_CONSTT     shift and go to state 29
    BOOL_CONSTF     shift and go to state 25

    qualified_name                 shift and go to state 71
    int_float                      shift and go to state 34
    c_literal                      shift and go to state 85
    variable_literal               shift and go to state 50
    base_variable_set              shift and go to state 80
    unary_expression               shift and go to state 39
    valid_variable                 shift and go to state 101
    array_access                   shift and go to state 23
    multiplicative_expression      shift and go to state 45
    primary                        shift and go to state 57
    unary_expression_not_plus_minus shift and go to state 40
    literal                        shift and go to state 64
    method_invocation              shift and go to state 102
    simple_name                    shift and go to state 60
    additive_expression            shift and go to state 198
    name                           shift and go to state 103

state 125

    (46) conditional_and_expression -> conditional_and_expression AND . marker inclusive_or_expression
    (41) marker -> . empty
    (191) empty -> .

    PLUS            reduce using rule 191 (empty -> .)
    MINUS           reduce using rule 191 (empty -> .)
    TILDA           reduce using rule 191 (empty -> .)
    NOT             reduce using rule 191 (empty -> .)
    LPAREN          reduce using rule 191 (empty -> .)
    IDENTIFIER      reduce using rule 191 (empty -> .)
    INT_NUMBER      reduce using rule 191 (empty -> .)
    BOOL_CONSTT     reduce using rule 191 (empty -> .)
    BOOL_CONSTF     reduce using rule 191 (empty -> .)

    marker                         shift and go to state 199
    empty                          shift and go to state 99

state 126

    (76) unary_expression_not_plus_minus -> NOT unary_expression .

    TIMES           reduce using rule 76 (unary_expression_not_plus_minus -> NOT unary_expression .)
    DIVIDE          reduce using rule 76 (unary_expression_not_plus_minus -> NOT unary_expression .)
    REMAINDER       reduce using rule 76 (unary_expression_not_plus_minus -> NOT unary_expression .)
    PLUS            reduce using rule 76 (unary_expression_not_plus_minus -> NOT unary_expression .)
    MINUS           reduce using rule 76 (unary_expression_not_plus_minus -> NOT unary_expression .)
    LSHIFT          reduce using rule 76 (unary_expression_not_plus_minus -> NOT unary_expression .)
    RSHIFT          reduce using rule 76 (unary_expression_not_plus_minus -> NOT unary_expression .)
    GREATER         reduce using rule 76 (unary_expression_not_plus_minus -> NOT unary_expression .)
    LESS            reduce using rule 76 (unary_expression_not_plus_minus -> NOT unary_expression .)
    GEQ             reduce using rule 76 (unary_expression_not_plus_minus -> NOT unary_expression .)
    LEQ             reduce using rule 76 (unary_expression_not_plus_minus -> NOT unary_expression .)
    EQUAL           reduce using rule 76 (unary_expression_not_plus_minus -> NOT unary_expression .)
    NEQUAL          reduce using rule 76 (unary_expression_not_plus_minus -> NOT unary_expression .)
    AND_BITWISE     reduce using rule 76 (unary_expression_not_plus_minus -> NOT unary_expression .)
    XOR             reduce using rule 76 (unary_expression_not_plus_minus -> NOT unary_expression .)
    OR_BITWISE      reduce using rule 76 (unary_expression_not_plus_minus -> NOT unary_expression .)
    AND             reduce using rule 76 (unary_expression_not_plus_minus -> NOT unary_expression .)
    OR              reduce using rule 76 (unary_expression_not_plus_minus -> NOT unary_expression .)
    KEYWORD_MATCH   reduce using rule 76 (unary_expression_not_plus_minus -> NOT unary_expression .)
    TERMINATOR      reduce using rule 76 (unary_expression_not_plus_minus -> NOT unary_expression .)
    RPAREN          reduce using rule 76 (unary_expression_not_plus_minus -> NOT unary_expression .)
    RBRAC           reduce using rule 76 (unary_expression_not_plus_minus -> NOT unary_expression .)
    COMMA           reduce using rule 76 (unary_expression_not_plus_minus -> NOT unary_expression .)
    FUNTYPE         reduce using rule 76 (unary_expression_not_plus_minus -> NOT unary_expression .)
    KEYWORD_UNTIL   reduce using rule 76 (unary_expression_not_plus_minus -> NOT unary_expression .)
    KEYWORD_TO      reduce using rule 76 (unary_expression_not_plus_minus -> NOT unary_expression .)
    KEYWORD_BY      reduce using rule 76 (unary_expression_not_plus_minus -> NOT unary_expression .)


state 127

    (156) switch_statement -> expression KEYWORD_MATCH . switch_block marker
    (157) switch_block -> . BLOCKBEGIN BLOCKEND
    (158) switch_block -> . BLOCKBEGIN switch_block_statements BLOCKEND

    BLOCKBEGIN      shift and go to state 200

    switch_block                   shift and go to state 201

state 128

    (134) normal_statement -> block marker .

    KEYWORD_IF      reduce using rule 134 (normal_statement -> block marker .)
    KEYWORD_WHILE   reduce using rule 134 (normal_statement -> block marker .)
    KEYWORD_DO      reduce using rule 134 (normal_statement -> block marker .)
    KEYWORD_FOR     reduce using rule 134 (normal_statement -> block marker .)
    KEYWORD_CLASS   reduce using rule 134 (normal_statement -> block marker .)
    KEYWORD_OBJECT  reduce using rule 134 (normal_statement -> block marker .)
    KEYWORD_VAR     reduce using rule 134 (normal_statement -> block marker .)
    KEYWORD_VAL     reduce using rule 134 (normal_statement -> block marker .)
    TERMINATOR      reduce using rule 134 (normal_statement -> block marker .)
    KEYWORD_RETURN  reduce using rule 134 (normal_statement -> block marker .)
    KEYWORD_DEF     reduce using rule 134 (normal_statement -> block marker .)
    BLOCKBEGIN      reduce using rule 134 (normal_statement -> block marker .)
    IDENTIFIER      reduce using rule 134 (normal_statement -> block marker .)
    PLUS            reduce using rule 134 (normal_statement -> block marker .)
    MINUS           reduce using rule 134 (normal_statement -> block marker .)
    TILDA           reduce using rule 134 (normal_statement -> block marker .)
    NOT             reduce using rule 134 (normal_statement -> block marker .)
    LPAREN          reduce using rule 134 (normal_statement -> block marker .)
    INT_NUMBER      reduce using rule 134 (normal_statement -> block marker .)
    BOOL_CONSTT     reduce using rule 134 (normal_statement -> block marker .)
    BOOL_CONSTF     reduce using rule 134 (normal_statement -> block marker .)
    BLOCKEND        reduce using rule 134 (normal_statement -> block marker .)
    KEYWORD_ELSE    reduce using rule 134 (normal_statement -> block marker .)


state 129

    (130) statement -> if_then_else_statement marker .

    KEYWORD_IF      reduce using rule 130 (statement -> if_then_else_statement marker .)
    KEYWORD_WHILE   reduce using rule 130 (statement -> if_then_else_statement marker .)
    KEYWORD_DO      reduce using rule 130 (statement -> if_then_else_statement marker .)
    KEYWORD_FOR     reduce using rule 130 (statement -> if_then_else_statement marker .)
    KEYWORD_CLASS   reduce using rule 130 (statement -> if_then_else_statement marker .)
    KEYWORD_OBJECT  reduce using rule 130 (statement -> if_then_else_statement marker .)
    KEYWORD_VAR     reduce using rule 130 (statement -> if_then_else_statement marker .)
    KEYWORD_VAL     reduce using rule 130 (statement -> if_then_else_statement marker .)
    TERMINATOR      reduce using rule 130 (statement -> if_then_else_statement marker .)
    KEYWORD_RETURN  reduce using rule 130 (statement -> if_then_else_statement marker .)
    KEYWORD_DEF     reduce using rule 130 (statement -> if_then_else_statement marker .)
    BLOCKBEGIN      reduce using rule 130 (statement -> if_then_else_statement marker .)
    IDENTIFIER      reduce using rule 130 (statement -> if_then_else_statement marker .)
    PLUS            reduce using rule 130 (statement -> if_then_else_statement marker .)
    MINUS           reduce using rule 130 (statement -> if_then_else_statement marker .)
    TILDA           reduce using rule 130 (statement -> if_then_else_statement marker .)
    NOT             reduce using rule 130 (statement -> if_then_else_statement marker .)
    LPAREN          reduce using rule 130 (statement -> if_then_else_statement marker .)
    INT_NUMBER      reduce using rule 130 (statement -> if_then_else_statement marker .)
    BOOL_CONSTT     reduce using rule 130 (statement -> if_then_else_statement marker .)
    BOOL_CONSTF     reduce using rule 130 (statement -> if_then_else_statement marker .)
    BLOCKEND        reduce using rule 130 (statement -> if_then_else_statement marker .)


state 130

    (50) exclusive_or_expression -> exclusive_or_expression XOR . and_expression
    (51) and_expression -> . equality_expression
    (52) and_expression -> . and_expression AND_BITWISE equality_expression
    (53) equality_expression -> . relational_expression
    (54) equality_expression -> . equality_expression EQUAL relational_expression
    (55) equality_expression -> . equality_expression NEQUAL relational_expression
    (56) relational_expression -> . shift_expression
    (57) relational_expression -> . relational_expression GREATER shift_expression
    (58) relational_expression -> . relational_expression LESS shift_expression
    (59) relational_expression -> . relational_expression GEQ shift_expression
    (60) relational_expression -> . relational_expression LEQ shift_expression
    (61) shift_expression -> . additive_expression
    (62) shift_expression -> . shift_expression LSHIFT additive_expression
    (63) shift_expression -> . shift_expression RSHIFT additive_expression
    (64) additive_expression -> . multiplicative_expression
    (65) additive_expression -> . additive_expression PLUS multiplicative_expression
    (66) additive_expression -> . additive_expression MINUS multiplicative_expression
    (67) multiplicative_expression -> . unary_expression
    (68) multiplicative_expression -> . multiplicative_expression TIMES unary_expression
    (69) multiplicative_expression -> . multiplicative_expression DIVIDE unary_expression
    (70) multiplicative_expression -> . multiplicative_expression REMAINDER unary_expression
    (71) unary_expression -> . PLUS unary_expression
    (72) unary_expression -> . MINUS unary_expression
    (73) unary_expression -> . unary_expression_not_plus_minus
    (74) unary_expression_not_plus_minus -> . base_variable_set
    (75) unary_expression_not_plus_minus -> . TILDA unary_expression
    (76) unary_expression_not_plus_minus -> . NOT unary_expression
    (77) base_variable_set -> . variable_literal
    (78) base_variable_set -> . LPAREN expression RPAREN
    (79) variable_literal -> . valid_variable
    (80) variable_literal -> . primary
    (26) valid_variable -> . name
    (27) valid_variable -> . array_access
    (81) primary -> . literal
    (82) primary -> . method_invocation
    (121) name -> . simple_name
    (122) name -> . qualified_name
    (28) array_access -> . name dimension
    (83) literal -> . int_float
    (84) literal -> . c_literal
    (88) method_invocation -> . name LPAREN argument_list_opt RPAREN
    (123) simple_name -> . IDENTIFIER
    (124) qualified_name -> . name INST simple_name
    (87) int_float -> . INT_NUMBER
    (85) c_literal -> . BOOL_CONSTT
    (86) c_literal -> . BOOL_CONSTF

    PLUS            shift and go to state 30
    MINUS           shift and go to state 24
    TILDA           shift and go to state 65
    NOT             shift and go to state 52
    LPAREN          shift and go to state 86
    IDENTIFIER      shift and go to state 9
    INT_NUMBER      shift and go to state 38
    BOOL_CONSTT     shift and go to state 29
    BOOL_CONSTF     shift and go to state 25

    unary_expression               shift and go to state 39
    primary                        shift and go to state 57
    unary_expression_not_plus_minus shift and go to state 40
    array_access                   shift and go to state 23
    and_expression                 shift and go to state 202
    simple_name                    shift and go to state 60
    c_literal                      shift and go to state 85
    base_variable_set              shift and go to state 80
    valid_variable                 shift and go to state 101
    literal                        shift and go to state 64
    additive_expression            shift and go to state 59
    method_invocation              shift and go to state 102
    relational_expression          shift and go to state 66
    qualified_name                 shift and go to state 71
    multiplicative_expression      shift and go to state 45
    shift_expression               shift and go to state 49
    equality_expression            shift and go to state 74
    int_float                      shift and go to state 34
    variable_literal               shift and go to state 50
    name                           shift and go to state 103

state 131

    (129) statement -> if_then_statement marker .

    KEYWORD_IF      reduce using rule 129 (statement -> if_then_statement marker .)
    KEYWORD_WHILE   reduce using rule 129 (statement -> if_then_statement marker .)
    KEYWORD_DO      reduce using rule 129 (statement -> if_then_statement marker .)
    KEYWORD_FOR     reduce using rule 129 (statement -> if_then_statement marker .)
    KEYWORD_CLASS   reduce using rule 129 (statement -> if_then_statement marker .)
    KEYWORD_OBJECT  reduce using rule 129 (statement -> if_then_statement marker .)
    KEYWORD_VAR     reduce using rule 129 (statement -> if_then_statement marker .)
    KEYWORD_VAL     reduce using rule 129 (statement -> if_then_statement marker .)
    TERMINATOR      reduce using rule 129 (statement -> if_then_statement marker .)
    KEYWORD_RETURN  reduce using rule 129 (statement -> if_then_statement marker .)
    KEYWORD_DEF     reduce using rule 129 (statement -> if_then_statement marker .)
    BLOCKBEGIN      reduce using rule 129 (statement -> if_then_statement marker .)
    IDENTIFIER      reduce using rule 129 (statement -> if_then_statement marker .)
    PLUS            reduce using rule 129 (statement -> if_then_statement marker .)
    MINUS           reduce using rule 129 (statement -> if_then_statement marker .)
    TILDA           reduce using rule 129 (statement -> if_then_statement marker .)
    NOT             reduce using rule 129 (statement -> if_then_statement marker .)
    LPAREN          reduce using rule 129 (statement -> if_then_statement marker .)
    INT_NUMBER      reduce using rule 129 (statement -> if_then_statement marker .)
    BOOL_CONSTT     reduce using rule 129 (statement -> if_then_statement marker .)
    BOOL_CONSTF     reduce using rule 129 (statement -> if_then_statement marker .)
    BLOCKEND        reduce using rule 129 (statement -> if_then_statement marker .)


state 132

    (65) additive_expression -> additive_expression PLUS . multiplicative_expression
    (67) multiplicative_expression -> . unary_expression
    (68) multiplicative_expression -> . multiplicative_expression TIMES unary_expression
    (69) multiplicative_expression -> . multiplicative_expression DIVIDE unary_expression
    (70) multiplicative_expression -> . multiplicative_expression REMAINDER unary_expression
    (71) unary_expression -> . PLUS unary_expression
    (72) unary_expression -> . MINUS unary_expression
    (73) unary_expression -> . unary_expression_not_plus_minus
    (74) unary_expression_not_plus_minus -> . base_variable_set
    (75) unary_expression_not_plus_minus -> . TILDA unary_expression
    (76) unary_expression_not_plus_minus -> . NOT unary_expression
    (77) base_variable_set -> . variable_literal
    (78) base_variable_set -> . LPAREN expression RPAREN
    (79) variable_literal -> . valid_variable
    (80) variable_literal -> . primary
    (26) valid_variable -> . name
    (27) valid_variable -> . array_access
    (81) primary -> . literal
    (82) primary -> . method_invocation
    (121) name -> . simple_name
    (122) name -> . qualified_name
    (28) array_access -> . name dimension
    (83) literal -> . int_float
    (84) literal -> . c_literal
    (88) method_invocation -> . name LPAREN argument_list_opt RPAREN
    (123) simple_name -> . IDENTIFIER
    (124) qualified_name -> . name INST simple_name
    (87) int_float -> . INT_NUMBER
    (85) c_literal -> . BOOL_CONSTT
    (86) c_literal -> . BOOL_CONSTF

    PLUS            shift and go to state 30
    MINUS           shift and go to state 24
    TILDA           shift and go to state 65
    NOT             shift and go to state 52
    LPAREN          shift and go to state 86
    IDENTIFIER      shift and go to state 9
    INT_NUMBER      shift and go to state 38
    BOOL_CONSTT     shift and go to state 29
    BOOL_CONSTF     shift and go to state 25

    qualified_name                 shift and go to state 71
    int_float                      shift and go to state 34
    c_literal                      shift and go to state 85
    variable_literal               shift and go to state 50
    base_variable_set              shift and go to state 80
    unary_expression               shift and go to state 39
    valid_variable                 shift and go to state 101
    array_access                   shift and go to state 23
    multiplicative_expression      shift and go to state 203
    primary                        shift and go to state 57
    unary_expression_not_plus_minus shift and go to state 40
    literal                        shift and go to state 64
    method_invocation              shift and go to state 102
    simple_name                    shift and go to state 60
    name                           shift and go to state 103

state 133

    (66) additive_expression -> additive_expression MINUS . multiplicative_expression
    (67) multiplicative_expression -> . unary_expression
    (68) multiplicative_expression -> . multiplicative_expression TIMES unary_expression
    (69) multiplicative_expression -> . multiplicative_expression DIVIDE unary_expression
    (70) multiplicative_expression -> . multiplicative_expression REMAINDER unary_expression
    (71) unary_expression -> . PLUS unary_expression
    (72) unary_expression -> . MINUS unary_expression
    (73) unary_expression -> . unary_expression_not_plus_minus
    (74) unary_expression_not_plus_minus -> . base_variable_set
    (75) unary_expression_not_plus_minus -> . TILDA unary_expression
    (76) unary_expression_not_plus_minus -> . NOT unary_expression
    (77) base_variable_set -> . variable_literal
    (78) base_variable_set -> . LPAREN expression RPAREN
    (79) variable_literal -> . valid_variable
    (80) variable_literal -> . primary
    (26) valid_variable -> . name
    (27) valid_variable -> . array_access
    (81) primary -> . literal
    (82) primary -> . method_invocation
    (121) name -> . simple_name
    (122) name -> . qualified_name
    (28) array_access -> . name dimension
    (83) literal -> . int_float
    (84) literal -> . c_literal
    (88) method_invocation -> . name LPAREN argument_list_opt RPAREN
    (123) simple_name -> . IDENTIFIER
    (124) qualified_name -> . name INST simple_name
    (87) int_float -> . INT_NUMBER
    (85) c_literal -> . BOOL_CONSTT
    (86) c_literal -> . BOOL_CONSTF

    PLUS            shift and go to state 30
    MINUS           shift and go to state 24
    TILDA           shift and go to state 65
    NOT             shift and go to state 52
    LPAREN          shift and go to state 86
    IDENTIFIER      shift and go to state 9
    INT_NUMBER      shift and go to state 38
    BOOL_CONSTT     shift and go to state 29
    BOOL_CONSTF     shift and go to state 25

    qualified_name                 shift and go to state 71
    int_float                      shift and go to state 34
    c_literal                      shift and go to state 85
    variable_literal               shift and go to state 50
    base_variable_set              shift and go to state 80
    unary_expression               shift and go to state 39
    valid_variable                 shift and go to state 101
    array_access                   shift and go to state 23
    multiplicative_expression      shift and go to state 204
    primary                        shift and go to state 57
    unary_expression_not_plus_minus shift and go to state 40
    literal                        shift and go to state 64
    method_invocation              shift and go to state 102
    simple_name                    shift and go to state 60
    name                           shift and go to state 103

state 134

    (24) assignment_expression -> method_invocation .
    (82) primary -> method_invocation .

  ! reduce/reduce conflict for RPAREN resolved using rule 24 (assignment_expression -> method_invocation .)
  ! reduce/reduce conflict for KEYWORD_BY resolved using rule 24 (assignment_expression -> method_invocation .)
  ! reduce/reduce conflict for TERMINATOR resolved using rule 24 (assignment_expression -> method_invocation .)
  ! reduce/reduce conflict for KEYWORD_MATCH resolved using rule 24 (assignment_expression -> method_invocation .)
  ! reduce/reduce conflict for RBRAC resolved using rule 24 (assignment_expression -> method_invocation .)
  ! reduce/reduce conflict for COMMA resolved using rule 24 (assignment_expression -> method_invocation .)
  ! reduce/reduce conflict for FUNTYPE resolved using rule 24 (assignment_expression -> method_invocation .)
  ! reduce/reduce conflict for KEYWORD_UNTIL resolved using rule 24 (assignment_expression -> method_invocation .)
  ! reduce/reduce conflict for KEYWORD_TO resolved using rule 24 (assignment_expression -> method_invocation .)
    RBRAC           reduce using rule 24 (assignment_expression -> method_invocation .)
    RPAREN          reduce using rule 24 (assignment_expression -> method_invocation .)
    COMMA           reduce using rule 24 (assignment_expression -> method_invocation .)
    KEYWORD_BY      reduce using rule 24 (assignment_expression -> method_invocation .)
    KEYWORD_UNTIL   reduce using rule 24 (assignment_expression -> method_invocation .)
    KEYWORD_TO      reduce using rule 24 (assignment_expression -> method_invocation .)
    FUNTYPE         reduce using rule 24 (assignment_expression -> method_invocation .)
    TERMINATOR      reduce using rule 24 (assignment_expression -> method_invocation .)
    KEYWORD_MATCH   reduce using rule 24 (assignment_expression -> method_invocation .)
    TIMES           reduce using rule 82 (primary -> method_invocation .)
    DIVIDE          reduce using rule 82 (primary -> method_invocation .)
    REMAINDER       reduce using rule 82 (primary -> method_invocation .)
    PLUS            reduce using rule 82 (primary -> method_invocation .)
    MINUS           reduce using rule 82 (primary -> method_invocation .)
    LSHIFT          reduce using rule 82 (primary -> method_invocation .)
    RSHIFT          reduce using rule 82 (primary -> method_invocation .)
    GREATER         reduce using rule 82 (primary -> method_invocation .)
    LESS            reduce using rule 82 (primary -> method_invocation .)
    GEQ             reduce using rule 82 (primary -> method_invocation .)
    LEQ             reduce using rule 82 (primary -> method_invocation .)
    EQUAL           reduce using rule 82 (primary -> method_invocation .)
    NEQUAL          reduce using rule 82 (primary -> method_invocation .)
    AND_BITWISE     reduce using rule 82 (primary -> method_invocation .)
    XOR             reduce using rule 82 (primary -> method_invocation .)
    OR_BITWISE      reduce using rule 82 (primary -> method_invocation .)
    AND             reduce using rule 82 (primary -> method_invocation .)
    OR              reduce using rule 82 (primary -> method_invocation .)

  ! RPAREN          [ reduce using rule 82 (primary -> method_invocation .) ]
  ! KEYWORD_BY      [ reduce using rule 82 (primary -> method_invocation .) ]
  ! TERMINATOR      [ reduce using rule 82 (primary -> method_invocation .) ]
  ! KEYWORD_MATCH   [ reduce using rule 82 (primary -> method_invocation .) ]
  ! RBRAC           [ reduce using rule 82 (primary -> method_invocation .) ]
  ! COMMA           [ reduce using rule 82 (primary -> method_invocation .) ]
  ! FUNTYPE         [ reduce using rule 82 (primary -> method_invocation .) ]
  ! KEYWORD_UNTIL   [ reduce using rule 82 (primary -> method_invocation .) ]
  ! KEYWORD_TO      [ reduce using rule 82 (primary -> method_invocation .) ]


state 135

    (21) expression_optional -> empty .

    TERMINATOR      reduce using rule 21 (expression_optional -> empty .)


state 136

    (164) return_statement -> KEYWORD_RETURN expression_optional . TERMINATOR

    TERMINATOR      shift and go to state 205


state 137

    (22) assignment_expression -> assignment .

    RBRAC           reduce using rule 22 (assignment_expression -> assignment .)
    RPAREN          reduce using rule 22 (assignment_expression -> assignment .)
    COMMA           reduce using rule 22 (assignment_expression -> assignment .)
    KEYWORD_BY      reduce using rule 22 (assignment_expression -> assignment .)
    KEYWORD_UNTIL   reduce using rule 22 (assignment_expression -> assignment .)
    KEYWORD_TO      reduce using rule 22 (assignment_expression -> assignment .)
    FUNTYPE         reduce using rule 22 (assignment_expression -> assignment .)
    TERMINATOR      reduce using rule 22 (assignment_expression -> assignment .)
    KEYWORD_MATCH   reduce using rule 22 (assignment_expression -> assignment .)


state 138

    (20) expression_optional -> expression .

    TERMINATOR      reduce using rule 20 (expression_optional -> expression .)


state 139

    (75) unary_expression_not_plus_minus -> TILDA unary_expression .

    TIMES           reduce using rule 75 (unary_expression_not_plus_minus -> TILDA unary_expression .)
    DIVIDE          reduce using rule 75 (unary_expression_not_plus_minus -> TILDA unary_expression .)
    REMAINDER       reduce using rule 75 (unary_expression_not_plus_minus -> TILDA unary_expression .)
    PLUS            reduce using rule 75 (unary_expression_not_plus_minus -> TILDA unary_expression .)
    MINUS           reduce using rule 75 (unary_expression_not_plus_minus -> TILDA unary_expression .)
    LSHIFT          reduce using rule 75 (unary_expression_not_plus_minus -> TILDA unary_expression .)
    RSHIFT          reduce using rule 75 (unary_expression_not_plus_minus -> TILDA unary_expression .)
    GREATER         reduce using rule 75 (unary_expression_not_plus_minus -> TILDA unary_expression .)
    LESS            reduce using rule 75 (unary_expression_not_plus_minus -> TILDA unary_expression .)
    GEQ             reduce using rule 75 (unary_expression_not_plus_minus -> TILDA unary_expression .)
    LEQ             reduce using rule 75 (unary_expression_not_plus_minus -> TILDA unary_expression .)
    EQUAL           reduce using rule 75 (unary_expression_not_plus_minus -> TILDA unary_expression .)
    NEQUAL          reduce using rule 75 (unary_expression_not_plus_minus -> TILDA unary_expression .)
    AND_BITWISE     reduce using rule 75 (unary_expression_not_plus_minus -> TILDA unary_expression .)
    XOR             reduce using rule 75 (unary_expression_not_plus_minus -> TILDA unary_expression .)
    OR_BITWISE      reduce using rule 75 (unary_expression_not_plus_minus -> TILDA unary_expression .)
    AND             reduce using rule 75 (unary_expression_not_plus_minus -> TILDA unary_expression .)
    OR              reduce using rule 75 (unary_expression_not_plus_minus -> TILDA unary_expression .)
    KEYWORD_MATCH   reduce using rule 75 (unary_expression_not_plus_minus -> TILDA unary_expression .)
    TERMINATOR      reduce using rule 75 (unary_expression_not_plus_minus -> TILDA unary_expression .)
    RPAREN          reduce using rule 75 (unary_expression_not_plus_minus -> TILDA unary_expression .)
    RBRAC           reduce using rule 75 (unary_expression_not_plus_minus -> TILDA unary_expression .)
    COMMA           reduce using rule 75 (unary_expression_not_plus_minus -> TILDA unary_expression .)
    FUNTYPE         reduce using rule 75 (unary_expression_not_plus_minus -> TILDA unary_expression .)
    KEYWORD_UNTIL   reduce using rule 75 (unary_expression_not_plus_minus -> TILDA unary_expression .)
    KEYWORD_TO      reduce using rule 75 (unary_expression_not_plus_minus -> TILDA unary_expression .)
    KEYWORD_BY      reduce using rule 75 (unary_expression_not_plus_minus -> TILDA unary_expression .)


state 140

    (59) relational_expression -> relational_expression GEQ . shift_expression
    (61) shift_expression -> . additive_expression
    (62) shift_expression -> . shift_expression LSHIFT additive_expression
    (63) shift_expression -> . shift_expression RSHIFT additive_expression
    (64) additive_expression -> . multiplicative_expression
    (65) additive_expression -> . additive_expression PLUS multiplicative_expression
    (66) additive_expression -> . additive_expression MINUS multiplicative_expression
    (67) multiplicative_expression -> . unary_expression
    (68) multiplicative_expression -> . multiplicative_expression TIMES unary_expression
    (69) multiplicative_expression -> . multiplicative_expression DIVIDE unary_expression
    (70) multiplicative_expression -> . multiplicative_expression REMAINDER unary_expression
    (71) unary_expression -> . PLUS unary_expression
    (72) unary_expression -> . MINUS unary_expression
    (73) unary_expression -> . unary_expression_not_plus_minus
    (74) unary_expression_not_plus_minus -> . base_variable_set
    (75) unary_expression_not_plus_minus -> . TILDA unary_expression
    (76) unary_expression_not_plus_minus -> . NOT unary_expression
    (77) base_variable_set -> . variable_literal
    (78) base_variable_set -> . LPAREN expression RPAREN
    (79) variable_literal -> . valid_variable
    (80) variable_literal -> . primary
    (26) valid_variable -> . name
    (27) valid_variable -> . array_access
    (81) primary -> . literal
    (82) primary -> . method_invocation
    (121) name -> . simple_name
    (122) name -> . qualified_name
    (28) array_access -> . name dimension
    (83) literal -> . int_float
    (84) literal -> . c_literal
    (88) method_invocation -> . name LPAREN argument_list_opt RPAREN
    (123) simple_name -> . IDENTIFIER
    (124) qualified_name -> . name INST simple_name
    (87) int_float -> . INT_NUMBER
    (85) c_literal -> . BOOL_CONSTT
    (86) c_literal -> . BOOL_CONSTF

    PLUS            shift and go to state 30
    MINUS           shift and go to state 24
    TILDA           shift and go to state 65
    NOT             shift and go to state 52
    LPAREN          shift and go to state 86
    IDENTIFIER      shift and go to state 9
    INT_NUMBER      shift and go to state 38
    BOOL_CONSTT     shift and go to state 29
    BOOL_CONSTF     shift and go to state 25

    qualified_name                 shift and go to state 71
    int_float                      shift and go to state 34
    c_literal                      shift and go to state 85
    variable_literal               shift and go to state 50
    base_variable_set              shift and go to state 80
    unary_expression               shift and go to state 39
    valid_variable                 shift and go to state 101
    array_access                   shift and go to state 23
    multiplicative_expression      shift and go to state 45
    primary                        shift and go to state 57
    unary_expression_not_plus_minus shift and go to state 40
    literal                        shift and go to state 64
    method_invocation              shift and go to state 102
    simple_name                    shift and go to state 60
    shift_expression               shift and go to state 206
    additive_expression            shift and go to state 59
    name                           shift and go to state 103

state 141

    (57) relational_expression -> relational_expression GREATER . shift_expression
    (61) shift_expression -> . additive_expression
    (62) shift_expression -> . shift_expression LSHIFT additive_expression
    (63) shift_expression -> . shift_expression RSHIFT additive_expression
    (64) additive_expression -> . multiplicative_expression
    (65) additive_expression -> . additive_expression PLUS multiplicative_expression
    (66) additive_expression -> . additive_expression MINUS multiplicative_expression
    (67) multiplicative_expression -> . unary_expression
    (68) multiplicative_expression -> . multiplicative_expression TIMES unary_expression
    (69) multiplicative_expression -> . multiplicative_expression DIVIDE unary_expression
    (70) multiplicative_expression -> . multiplicative_expression REMAINDER unary_expression
    (71) unary_expression -> . PLUS unary_expression
    (72) unary_expression -> . MINUS unary_expression
    (73) unary_expression -> . unary_expression_not_plus_minus
    (74) unary_expression_not_plus_minus -> . base_variable_set
    (75) unary_expression_not_plus_minus -> . TILDA unary_expression
    (76) unary_expression_not_plus_minus -> . NOT unary_expression
    (77) base_variable_set -> . variable_literal
    (78) base_variable_set -> . LPAREN expression RPAREN
    (79) variable_literal -> . valid_variable
    (80) variable_literal -> . primary
    (26) valid_variable -> . name
    (27) valid_variable -> . array_access
    (81) primary -> . literal
    (82) primary -> . method_invocation
    (121) name -> . simple_name
    (122) name -> . qualified_name
    (28) array_access -> . name dimension
    (83) literal -> . int_float
    (84) literal -> . c_literal
    (88) method_invocation -> . name LPAREN argument_list_opt RPAREN
    (123) simple_name -> . IDENTIFIER
    (124) qualified_name -> . name INST simple_name
    (87) int_float -> . INT_NUMBER
    (85) c_literal -> . BOOL_CONSTT
    (86) c_literal -> . BOOL_CONSTF

    PLUS            shift and go to state 30
    MINUS           shift and go to state 24
    TILDA           shift and go to state 65
    NOT             shift and go to state 52
    LPAREN          shift and go to state 86
    IDENTIFIER      shift and go to state 9
    INT_NUMBER      shift and go to state 38
    BOOL_CONSTT     shift and go to state 29
    BOOL_CONSTF     shift and go to state 25

    qualified_name                 shift and go to state 71
    int_float                      shift and go to state 34
    c_literal                      shift and go to state 85
    variable_literal               shift and go to state 50
    base_variable_set              shift and go to state 80
    unary_expression               shift and go to state 39
    valid_variable                 shift and go to state 101
    array_access                   shift and go to state 23
    multiplicative_expression      shift and go to state 45
    primary                        shift and go to state 57
    unary_expression_not_plus_minus shift and go to state 40
    literal                        shift and go to state 64
    method_invocation              shift and go to state 102
    simple_name                    shift and go to state 60
    shift_expression               shift and go to state 207
    additive_expression            shift and go to state 59
    name                           shift and go to state 103

state 142

    (58) relational_expression -> relational_expression LESS . shift_expression
    (61) shift_expression -> . additive_expression
    (62) shift_expression -> . shift_expression LSHIFT additive_expression
    (63) shift_expression -> . shift_expression RSHIFT additive_expression
    (64) additive_expression -> . multiplicative_expression
    (65) additive_expression -> . additive_expression PLUS multiplicative_expression
    (66) additive_expression -> . additive_expression MINUS multiplicative_expression
    (67) multiplicative_expression -> . unary_expression
    (68) multiplicative_expression -> . multiplicative_expression TIMES unary_expression
    (69) multiplicative_expression -> . multiplicative_expression DIVIDE unary_expression
    (70) multiplicative_expression -> . multiplicative_expression REMAINDER unary_expression
    (71) unary_expression -> . PLUS unary_expression
    (72) unary_expression -> . MINUS unary_expression
    (73) unary_expression -> . unary_expression_not_plus_minus
    (74) unary_expression_not_plus_minus -> . base_variable_set
    (75) unary_expression_not_plus_minus -> . TILDA unary_expression
    (76) unary_expression_not_plus_minus -> . NOT unary_expression
    (77) base_variable_set -> . variable_literal
    (78) base_variable_set -> . LPAREN expression RPAREN
    (79) variable_literal -> . valid_variable
    (80) variable_literal -> . primary
    (26) valid_variable -> . name
    (27) valid_variable -> . array_access
    (81) primary -> . literal
    (82) primary -> . method_invocation
    (121) name -> . simple_name
    (122) name -> . qualified_name
    (28) array_access -> . name dimension
    (83) literal -> . int_float
    (84) literal -> . c_literal
    (88) method_invocation -> . name LPAREN argument_list_opt RPAREN
    (123) simple_name -> . IDENTIFIER
    (124) qualified_name -> . name INST simple_name
    (87) int_float -> . INT_NUMBER
    (85) c_literal -> . BOOL_CONSTT
    (86) c_literal -> . BOOL_CONSTF

    PLUS            shift and go to state 30
    MINUS           shift and go to state 24
    TILDA           shift and go to state 65
    NOT             shift and go to state 52
    LPAREN          shift and go to state 86
    IDENTIFIER      shift and go to state 9
    INT_NUMBER      shift and go to state 38
    BOOL_CONSTT     shift and go to state 29
    BOOL_CONSTF     shift and go to state 25

    qualified_name                 shift and go to state 71
    int_float                      shift and go to state 34
    c_literal                      shift and go to state 85
    variable_literal               shift and go to state 50
    base_variable_set              shift and go to state 80
    unary_expression               shift and go to state 39
    valid_variable                 shift and go to state 101
    array_access                   shift and go to state 23
    multiplicative_expression      shift and go to state 45
    primary                        shift and go to state 57
    unary_expression_not_plus_minus shift and go to state 40
    literal                        shift and go to state 64
    method_invocation              shift and go to state 102
    simple_name                    shift and go to state 60
    shift_expression               shift and go to state 208
    additive_expression            shift and go to state 59
    name                           shift and go to state 103

state 143

    (60) relational_expression -> relational_expression LEQ . shift_expression
    (61) shift_expression -> . additive_expression
    (62) shift_expression -> . shift_expression LSHIFT additive_expression
    (63) shift_expression -> . shift_expression RSHIFT additive_expression
    (64) additive_expression -> . multiplicative_expression
    (65) additive_expression -> . additive_expression PLUS multiplicative_expression
    (66) additive_expression -> . additive_expression MINUS multiplicative_expression
    (67) multiplicative_expression -> . unary_expression
    (68) multiplicative_expression -> . multiplicative_expression TIMES unary_expression
    (69) multiplicative_expression -> . multiplicative_expression DIVIDE unary_expression
    (70) multiplicative_expression -> . multiplicative_expression REMAINDER unary_expression
    (71) unary_expression -> . PLUS unary_expression
    (72) unary_expression -> . MINUS unary_expression
    (73) unary_expression -> . unary_expression_not_plus_minus
    (74) unary_expression_not_plus_minus -> . base_variable_set
    (75) unary_expression_not_plus_minus -> . TILDA unary_expression
    (76) unary_expression_not_plus_minus -> . NOT unary_expression
    (77) base_variable_set -> . variable_literal
    (78) base_variable_set -> . LPAREN expression RPAREN
    (79) variable_literal -> . valid_variable
    (80) variable_literal -> . primary
    (26) valid_variable -> . name
    (27) valid_variable -> . array_access
    (81) primary -> . literal
    (82) primary -> . method_invocation
    (121) name -> . simple_name
    (122) name -> . qualified_name
    (28) array_access -> . name dimension
    (83) literal -> . int_float
    (84) literal -> . c_literal
    (88) method_invocation -> . name LPAREN argument_list_opt RPAREN
    (123) simple_name -> . IDENTIFIER
    (124) qualified_name -> . name INST simple_name
    (87) int_float -> . INT_NUMBER
    (85) c_literal -> . BOOL_CONSTT
    (86) c_literal -> . BOOL_CONSTF

    PLUS            shift and go to state 30
    MINUS           shift and go to state 24
    TILDA           shift and go to state 65
    NOT             shift and go to state 52
    LPAREN          shift and go to state 86
    IDENTIFIER      shift and go to state 9
    INT_NUMBER      shift and go to state 38
    BOOL_CONSTT     shift and go to state 29
    BOOL_CONSTF     shift and go to state 25

    qualified_name                 shift and go to state 71
    int_float                      shift and go to state 34
    c_literal                      shift and go to state 85
    variable_literal               shift and go to state 50
    base_variable_set              shift and go to state 80
    unary_expression               shift and go to state 39
    valid_variable                 shift and go to state 101
    array_access                   shift and go to state 23
    multiplicative_expression      shift and go to state 45
    primary                        shift and go to state 57
    unary_expression_not_plus_minus shift and go to state 40
    literal                        shift and go to state 64
    method_invocation              shift and go to state 102
    simple_name                    shift and go to state 60
    shift_expression               shift and go to state 209
    additive_expression            shift and go to state 59
    name                           shift and go to state 103

state 144

    (96) local_variable_declaration -> declaration_keyword variable_declaration_body .

    TERMINATOR      reduce using rule 96 (local_variable_declaration -> declaration_keyword variable_declaration_body .)


state 145

    (102) variable_declaration_body -> identifiers . COLON type ASOP variable_declaration_initializer
    (103) identifiers -> identifiers . COMMA IDENTIFIER

    COLON           shift and go to state 210
    COMMA           shift and go to state 211


state 146

    (104) identifiers -> IDENTIFIER .

    COLON           reduce using rule 104 (identifiers -> IDENTIFIER .)
    COMMA           reduce using rule 104 (identifiers -> IDENTIFIER .)


state 147

    (174) method_header_name -> KEYWORD_DEF IDENTIFIER .

    LPAREN          reduce using rule 174 (method_header_name -> KEYWORD_DEF IDENTIFIER .)


state 148

    (142) if_then_statement -> KEYWORD_IF LPAREN . expression RPAREN marker block
    (143) if_then_else_statement -> KEYWORD_IF LPAREN . expression RPAREN marker if_then_else_intermediate narker KEYWORD_ELSE marker block
    (19) expression -> . assignment_expression
    (22) assignment_expression -> . assignment
    (23) assignment_expression -> . conditional_or_expression
    (24) assignment_expression -> . method_invocation
    (25) assignment -> . valid_variable assignment_operator assignment_expression
    (43) conditional_or_expression -> . conditional_and_expression
    (44) conditional_or_expression -> . conditional_or_expression OR marker conditional_and_expression
    (88) method_invocation -> . name LPAREN argument_list_opt RPAREN
    (26) valid_variable -> . name
    (27) valid_variable -> . array_access
    (45) conditional_and_expression -> . inclusive_or_expression
    (46) conditional_and_expression -> . conditional_and_expression AND marker inclusive_or_expression
    (121) name -> . simple_name
    (122) name -> . qualified_name
    (28) array_access -> . name dimension
    (47) inclusive_or_expression -> . exclusive_or_expression
    (48) inclusive_or_expression -> . inclusive_or_expression OR_BITWISE exclusive_or_expression
    (123) simple_name -> . IDENTIFIER
    (124) qualified_name -> . name INST simple_name
    (49) exclusive_or_expression -> . and_expression
    (50) exclusive_or_expression -> . exclusive_or_expression XOR and_expression
    (51) and_expression -> . equality_expression
    (52) and_expression -> . and_expression AND_BITWISE equality_expression
    (53) equality_expression -> . relational_expression
    (54) equality_expression -> . equality_expression EQUAL relational_expression
    (55) equality_expression -> . equality_expression NEQUAL relational_expression
    (56) relational_expression -> . shift_expression
    (57) relational_expression -> . relational_expression GREATER shift_expression
    (58) relational_expression -> . relational_expression LESS shift_expression
    (59) relational_expression -> . relational_expression GEQ shift_expression
    (60) relational_expression -> . relational_expression LEQ shift_expression
    (61) shift_expression -> . additive_expression
    (62) shift_expression -> . shift_expression LSHIFT additive_expression
    (63) shift_expression -> . shift_expression RSHIFT additive_expression
    (64) additive_expression -> . multiplicative_expression
    (65) additive_expression -> . additive_expression PLUS multiplicative_expression
    (66) additive_expression -> . additive_expression MINUS multiplicative_expression
    (67) multiplicative_expression -> . unary_expression
    (68) multiplicative_expression -> . multiplicative_expression TIMES unary_expression
    (69) multiplicative_expression -> . multiplicative_expression DIVIDE unary_expression
    (70) multiplicative_expression -> . multiplicative_expression REMAINDER unary_expression
    (71) unary_expression -> . PLUS unary_expression
    (72) unary_expression -> . MINUS unary_expression
    (73) unary_expression -> . unary_expression_not_plus_minus
    (74) unary_expression_not_plus_minus -> . base_variable_set
    (75) unary_expression_not_plus_minus -> . TILDA unary_expression
    (76) unary_expression_not_plus_minus -> . NOT unary_expression
    (77) base_variable_set -> . variable_literal
    (78) base_variable_set -> . LPAREN expression RPAREN
    (79) variable_literal -> . valid_variable
    (80) variable_literal -> . primary
    (81) primary -> . literal
    (82) primary -> . method_invocation
    (83) literal -> . int_float
    (84) literal -> . c_literal
    (87) int_float -> . INT_NUMBER
    (85) c_literal -> . BOOL_CONSTT
    (86) c_literal -> . BOOL_CONSTF

    IDENTIFIER      shift and go to state 9
    PLUS            shift and go to state 30
    MINUS           shift and go to state 24
    TILDA           shift and go to state 65
    NOT             shift and go to state 52
    LPAREN          shift and go to state 86
    INT_NUMBER      shift and go to state 38
    BOOL_CONSTT     shift and go to state 29
    BOOL_CONSTF     shift and go to state 25

    unary_expression               shift and go to state 39
    exclusive_or_expression        shift and go to state 56
    primary                        shift and go to state 57
    unary_expression_not_plus_minus shift and go to state 40
    array_access                   shift and go to state 23
    and_expression                 shift and go to state 79
    simple_name                    shift and go to state 60
    c_literal                      shift and go to state 85
    base_variable_set              shift and go to state 80
    valid_variable                 shift and go to state 87
    inclusive_or_expression        shift and go to state 27
    literal                        shift and go to state 64
    relational_expression          shift and go to state 66
    method_invocation              shift and go to state 134
    conditional_or_expression      shift and go to state 42
    assignment_expression          shift and go to state 83
    qualified_name                 shift and go to state 71
    assignment                     shift and go to state 137
    multiplicative_expression      shift and go to state 45
    additive_expression            shift and go to state 59
    shift_expression               shift and go to state 49
    equality_expression            shift and go to state 74
    int_float                      shift and go to state 34
    variable_literal               shift and go to state 50
    name                           shift and go to state 37
    expression                     shift and go to state 212
    conditional_and_expression     shift and go to state 51

state 149

    (55) equality_expression -> equality_expression NEQUAL . relational_expression
    (56) relational_expression -> . shift_expression
    (57) relational_expression -> . relational_expression GREATER shift_expression
    (58) relational_expression -> . relational_expression LESS shift_expression
    (59) relational_expression -> . relational_expression GEQ shift_expression
    (60) relational_expression -> . relational_expression LEQ shift_expression
    (61) shift_expression -> . additive_expression
    (62) shift_expression -> . shift_expression LSHIFT additive_expression
    (63) shift_expression -> . shift_expression RSHIFT additive_expression
    (64) additive_expression -> . multiplicative_expression
    (65) additive_expression -> . additive_expression PLUS multiplicative_expression
    (66) additive_expression -> . additive_expression MINUS multiplicative_expression
    (67) multiplicative_expression -> . unary_expression
    (68) multiplicative_expression -> . multiplicative_expression TIMES unary_expression
    (69) multiplicative_expression -> . multiplicative_expression DIVIDE unary_expression
    (70) multiplicative_expression -> . multiplicative_expression REMAINDER unary_expression
    (71) unary_expression -> . PLUS unary_expression
    (72) unary_expression -> . MINUS unary_expression
    (73) unary_expression -> . unary_expression_not_plus_minus
    (74) unary_expression_not_plus_minus -> . base_variable_set
    (75) unary_expression_not_plus_minus -> . TILDA unary_expression
    (76) unary_expression_not_plus_minus -> . NOT unary_expression
    (77) base_variable_set -> . variable_literal
    (78) base_variable_set -> . LPAREN expression RPAREN
    (79) variable_literal -> . valid_variable
    (80) variable_literal -> . primary
    (26) valid_variable -> . name
    (27) valid_variable -> . array_access
    (81) primary -> . literal
    (82) primary -> . method_invocation
    (121) name -> . simple_name
    (122) name -> . qualified_name
    (28) array_access -> . name dimension
    (83) literal -> . int_float
    (84) literal -> . c_literal
    (88) method_invocation -> . name LPAREN argument_list_opt RPAREN
    (123) simple_name -> . IDENTIFIER
    (124) qualified_name -> . name INST simple_name
    (87) int_float -> . INT_NUMBER
    (85) c_literal -> . BOOL_CONSTT
    (86) c_literal -> . BOOL_CONSTF

    PLUS            shift and go to state 30
    MINUS           shift and go to state 24
    TILDA           shift and go to state 65
    NOT             shift and go to state 52
    LPAREN          shift and go to state 86
    IDENTIFIER      shift and go to state 9
    INT_NUMBER      shift and go to state 38
    BOOL_CONSTT     shift and go to state 29
    BOOL_CONSTF     shift and go to state 25

    unary_expression               shift and go to state 39
    primary                        shift and go to state 57
    unary_expression_not_plus_minus shift and go to state 40
    array_access                   shift and go to state 23
    additive_expression            shift and go to state 59
    simple_name                    shift and go to state 60
    c_literal                      shift and go to state 85
    base_variable_set              shift and go to state 80
    valid_variable                 shift and go to state 101
    literal                        shift and go to state 64
    relational_expression          shift and go to state 213
    method_invocation              shift and go to state 102
    qualified_name                 shift and go to state 71
    multiplicative_expression      shift and go to state 45
    shift_expression               shift and go to state 49
    int_float                      shift and go to state 34
    variable_literal               shift and go to state 50
    name                           shift and go to state 103

state 150

    (54) equality_expression -> equality_expression EQUAL . relational_expression
    (56) relational_expression -> . shift_expression
    (57) relational_expression -> . relational_expression GREATER shift_expression
    (58) relational_expression -> . relational_expression LESS shift_expression
    (59) relational_expression -> . relational_expression GEQ shift_expression
    (60) relational_expression -> . relational_expression LEQ shift_expression
    (61) shift_expression -> . additive_expression
    (62) shift_expression -> . shift_expression LSHIFT additive_expression
    (63) shift_expression -> . shift_expression RSHIFT additive_expression
    (64) additive_expression -> . multiplicative_expression
    (65) additive_expression -> . additive_expression PLUS multiplicative_expression
    (66) additive_expression -> . additive_expression MINUS multiplicative_expression
    (67) multiplicative_expression -> . unary_expression
    (68) multiplicative_expression -> . multiplicative_expression TIMES unary_expression
    (69) multiplicative_expression -> . multiplicative_expression DIVIDE unary_expression
    (70) multiplicative_expression -> . multiplicative_expression REMAINDER unary_expression
    (71) unary_expression -> . PLUS unary_expression
    (72) unary_expression -> . MINUS unary_expression
    (73) unary_expression -> . unary_expression_not_plus_minus
    (74) unary_expression_not_plus_minus -> . base_variable_set
    (75) unary_expression_not_plus_minus -> . TILDA unary_expression
    (76) unary_expression_not_plus_minus -> . NOT unary_expression
    (77) base_variable_set -> . variable_literal
    (78) base_variable_set -> . LPAREN expression RPAREN
    (79) variable_literal -> . valid_variable
    (80) variable_literal -> . primary
    (26) valid_variable -> . name
    (27) valid_variable -> . array_access
    (81) primary -> . literal
    (82) primary -> . method_invocation
    (121) name -> . simple_name
    (122) name -> . qualified_name
    (28) array_access -> . name dimension
    (83) literal -> . int_float
    (84) literal -> . c_literal
    (88) method_invocation -> . name LPAREN argument_list_opt RPAREN
    (123) simple_name -> . IDENTIFIER
    (124) qualified_name -> . name INST simple_name
    (87) int_float -> . INT_NUMBER
    (85) c_literal -> . BOOL_CONSTT
    (86) c_literal -> . BOOL_CONSTF

    PLUS            shift and go to state 30
    MINUS           shift and go to state 24
    TILDA           shift and go to state 65
    NOT             shift and go to state 52
    LPAREN          shift and go to state 86
    IDENTIFIER      shift and go to state 9
    INT_NUMBER      shift and go to state 38
    BOOL_CONSTT     shift and go to state 29
    BOOL_CONSTF     shift and go to state 25

    unary_expression               shift and go to state 39
    primary                        shift and go to state 57
    unary_expression_not_plus_minus shift and go to state 40
    array_access                   shift and go to state 23
    additive_expression            shift and go to state 59
    simple_name                    shift and go to state 60
    c_literal                      shift and go to state 85
    base_variable_set              shift and go to state 80
    valid_variable                 shift and go to state 101
    literal                        shift and go to state 64
    relational_expression          shift and go to state 214
    method_invocation              shift and go to state 102
    qualified_name                 shift and go to state 71
    multiplicative_expression      shift and go to state 45
    shift_expression               shift and go to state 49
    int_float                      shift and go to state 34
    variable_literal               shift and go to state 50
    name                           shift and go to state 103

state 151

    (175) method_body -> method_start_scope . block_statements_opt end_scope
    (10) block_statements_opt -> . block_statements
    (11) block_statements_opt -> . empty
    (12) block_statements -> . block_statement
    (13) block_statements -> . block_statements marker block_statement
    (191) empty -> .
    (14) block_statement -> . local_variable_declaration_statement
    (15) block_statement -> . statement
    (16) block_statement -> . class_declaration
    (17) block_statement -> . SingletonObject
    (18) block_statement -> . method_declaration
    (95) local_variable_declaration_statement -> . local_variable_declaration TERMINATOR
    (128) statement -> . normal_statement marker
    (129) statement -> . if_then_statement marker
    (130) statement -> . if_then_else_statement marker
    (131) statement -> . while_statement marker
    (132) statement -> . do_while_statement marker
    (133) statement -> . for_statement marker
    (177) class_declaration -> . class_header class_body
    (5) SingletonObject -> . ObjectDeclare block
    (165) method_declaration -> . method_header method_body
    (96) local_variable_declaration -> . declaration_keyword variable_declaration_body
    (134) normal_statement -> . block marker
    (135) normal_statement -> . expression_statement marker
    (136) normal_statement -> . empty_statement marker
    (137) normal_statement -> . return_statement marker
    (138) normal_statement -> . switch_statement marker
    (142) if_then_statement -> . KEYWORD_IF LPAREN expression RPAREN marker block
    (143) if_then_else_statement -> . KEYWORD_IF LPAREN expression RPAREN marker if_then_else_intermediate narker KEYWORD_ELSE marker block
    (147) while_statement -> . KEYWORD_WHILE LPAREN marker expression RPAREN marker block
    (148) do_while_statement -> . KEYWORD_DO marker block KEYWORD_WHILE LPAREN marker expression RPAREN TERMINATOR
    (149) for_statement -> . KEYWORD_FOR LPAREN for_update RPAREN marker block
    (178) class_header -> . KEYWORD_CLASS simple_name class_param_clause
    (6) ObjectDeclare -> . KEYWORD_OBJECT IDENTIFIER
    (166) method_header -> . method_header_name func_arg_start fun_params_opt RPAREN COLON method_return_type ASOP
    (93) declaration_keyword -> . KEYWORD_VAR
    (94) declaration_keyword -> . KEYWORD_VAL
    (7) block -> . start_scope block_statements_opt end_scope
    (139) expression_statement -> . statement_expression TERMINATOR
    (163) empty_statement -> . TERMINATOR
    (164) return_statement -> . KEYWORD_RETURN expression_optional TERMINATOR
    (156) switch_statement -> . expression KEYWORD_MATCH switch_block marker
    (174) method_header_name -> . KEYWORD_DEF IDENTIFIER
    (8) start_scope -> . BLOCKBEGIN
    (140) statement_expression -> . assignment
    (141) statement_expression -> . method_invocation
    (19) expression -> . assignment_expression
    (25) assignment -> . valid_variable assignment_operator assignment_expression
    (88) method_invocation -> . name LPAREN argument_list_opt RPAREN
    (22) assignment_expression -> . assignment
    (23) assignment_expression -> . conditional_or_expression
    (24) assignment_expression -> . method_invocation
    (26) valid_variable -> . name
    (27) valid_variable -> . array_access
    (121) name -> . simple_name
    (122) name -> . qualified_name
    (43) conditional_or_expression -> . conditional_and_expression
    (44) conditional_or_expression -> . conditional_or_expression OR marker conditional_and_expression
    (28) array_access -> . name dimension
    (123) simple_name -> . IDENTIFIER
    (124) qualified_name -> . name INST simple_name
    (45) conditional_and_expression -> . inclusive_or_expression
    (46) conditional_and_expression -> . conditional_and_expression AND marker inclusive_or_expression
    (47) inclusive_or_expression -> . exclusive_or_expression
    (48) inclusive_or_expression -> . inclusive_or_expression OR_BITWISE exclusive_or_expression
    (49) exclusive_or_expression -> . and_expression
    (50) exclusive_or_expression -> . exclusive_or_expression XOR and_expression
    (51) and_expression -> . equality_expression
    (52) and_expression -> . and_expression AND_BITWISE equality_expression
    (53) equality_expression -> . relational_expression
    (54) equality_expression -> . equality_expression EQUAL relational_expression
    (55) equality_expression -> . equality_expression NEQUAL relational_expression
    (56) relational_expression -> . shift_expression
    (57) relational_expression -> . relational_expression GREATER shift_expression
    (58) relational_expression -> . relational_expression LESS shift_expression
    (59) relational_expression -> . relational_expression GEQ shift_expression
    (60) relational_expression -> . relational_expression LEQ shift_expression
    (61) shift_expression -> . additive_expression
    (62) shift_expression -> . shift_expression LSHIFT additive_expression
    (63) shift_expression -> . shift_expression RSHIFT additive_expression
    (64) additive_expression -> . multiplicative_expression
    (65) additive_expression -> . additive_expression PLUS multiplicative_expression
    (66) additive_expression -> . additive_expression MINUS multiplicative_expression
    (67) multiplicative_expression -> . unary_expression
    (68) multiplicative_expression -> . multiplicative_expression TIMES unary_expression
    (69) multiplicative_expression -> . multiplicative_expression DIVIDE unary_expression
    (70) multiplicative_expression -> . multiplicative_expression REMAINDER unary_expression
    (71) unary_expression -> . PLUS unary_expression
    (72) unary_expression -> . MINUS unary_expression
    (73) unary_expression -> . unary_expression_not_plus_minus
    (74) unary_expression_not_plus_minus -> . base_variable_set
    (75) unary_expression_not_plus_minus -> . TILDA unary_expression
    (76) unary_expression_not_plus_minus -> . NOT unary_expression
    (77) base_variable_set -> . variable_literal
    (78) base_variable_set -> . LPAREN expression RPAREN
    (79) variable_literal -> . valid_variable
    (80) variable_literal -> . primary
    (81) primary -> . literal
    (82) primary -> . method_invocation
    (83) literal -> . int_float
    (84) literal -> . c_literal
    (87) int_float -> . INT_NUMBER
    (85) c_literal -> . BOOL_CONSTT
    (86) c_literal -> . BOOL_CONSTF

    BLOCKEND        reduce using rule 191 (empty -> .)
    KEYWORD_IF      shift and go to state 73
    KEYWORD_WHILE   shift and go to state 43
    KEYWORD_DO      shift and go to state 90
    KEYWORD_FOR     shift and go to state 89
    KEYWORD_CLASS   shift and go to state 1
    KEYWORD_OBJECT  shift and go to state 8
    KEYWORD_VAR     shift and go to state 46
    KEYWORD_VAL     shift and go to state 47
    TERMINATOR      shift and go to state 48
    KEYWORD_RETURN  shift and go to state 61
    KEYWORD_DEF     shift and go to state 72
    BLOCKBEGIN      shift and go to state 12
    IDENTIFIER      shift and go to state 9
    PLUS            shift and go to state 30
    MINUS           shift and go to state 24
    TILDA           shift and go to state 65
    NOT             shift and go to state 52
    LPAREN          shift and go to state 86
    INT_NUMBER      shift and go to state 38
    BOOL_CONSTT     shift and go to state 29
    BOOL_CONSTF     shift and go to state 25

    expression_statement           shift and go to state 22
    unary_expression               shift and go to state 39
    exclusive_or_expression        shift and go to state 56
    normal_statement               shift and go to state 78
    ObjectDeclare                  shift and go to state 3
    primary                        shift and go to state 57
    declaration_keyword            shift and go to state 70
    if_then_statement              shift and go to state 58
    array_access                   shift and go to state 23
    switch_statement               shift and go to state 41
    simple_name                    shift and go to state 60
    block_statements_opt           shift and go to state 215
    qualified_name                 shift and go to state 71
    base_variable_set              shift and go to state 80
    inclusive_or_expression        shift and go to state 27
    method_declaration             shift and go to state 62
    literal                        shift and go to state 64
    block_statement                shift and go to state 63
    return_statement               shift and go to state 81
    while_statement                shift and go to state 28
    unary_expression_not_plus_minus shift and go to state 40
    and_expression                 shift and go to state 79
    statement                      shift and go to state 67
    c_literal                      shift and go to state 85
    statement_expression           shift and go to state 31
    method_invocation              shift and go to state 68
    conditional_or_expression      shift and go to state 42
    empty                          shift and go to state 69
    relational_expression          shift and go to state 66
    block_statements               shift and go to state 82
    for_statement                  shift and go to state 32
    local_variable_declaration_statement shift and go to state 33
    do_while_statement             shift and go to state 44
    int_float                      shift and go to state 34
    assignment                     shift and go to state 84
    multiplicative_expression      shift and go to state 45
    additive_expression            shift and go to state 59
    SingletonObject                shift and go to state 35
    start_scope                    shift and go to state 13
    method_header_name             shift and go to state 36
    class_header                   shift and go to state 7
    shift_expression               shift and go to state 49
    equality_expression            shift and go to state 74
    name                           shift and go to state 37
    variable_literal               shift and go to state 50
    assignment_expression          shift and go to state 83
    valid_variable                 shift and go to state 87
    method_header                  shift and go to state 75
    empty_statement                shift and go to state 76
    class_declaration              shift and go to state 88
    local_variable_declaration     shift and go to state 77
    expression                     shift and go to state 53
    conditional_and_expression     shift and go to state 51
    block                          shift and go to state 54
    if_then_else_statement         shift and go to state 55

state 152

    (165) method_declaration -> method_header method_body .

    KEYWORD_IF      reduce using rule 165 (method_declaration -> method_header method_body .)
    KEYWORD_WHILE   reduce using rule 165 (method_declaration -> method_header method_body .)
    KEYWORD_DO      reduce using rule 165 (method_declaration -> method_header method_body .)
    KEYWORD_FOR     reduce using rule 165 (method_declaration -> method_header method_body .)
    KEYWORD_CLASS   reduce using rule 165 (method_declaration -> method_header method_body .)
    KEYWORD_OBJECT  reduce using rule 165 (method_declaration -> method_header method_body .)
    KEYWORD_VAR     reduce using rule 165 (method_declaration -> method_header method_body .)
    KEYWORD_VAL     reduce using rule 165 (method_declaration -> method_header method_body .)
    TERMINATOR      reduce using rule 165 (method_declaration -> method_header method_body .)
    KEYWORD_RETURN  reduce using rule 165 (method_declaration -> method_header method_body .)
    KEYWORD_DEF     reduce using rule 165 (method_declaration -> method_header method_body .)
    BLOCKBEGIN      reduce using rule 165 (method_declaration -> method_header method_body .)
    IDENTIFIER      reduce using rule 165 (method_declaration -> method_header method_body .)
    PLUS            reduce using rule 165 (method_declaration -> method_header method_body .)
    MINUS           reduce using rule 165 (method_declaration -> method_header method_body .)
    TILDA           reduce using rule 165 (method_declaration -> method_header method_body .)
    NOT             reduce using rule 165 (method_declaration -> method_header method_body .)
    LPAREN          reduce using rule 165 (method_declaration -> method_header method_body .)
    INT_NUMBER      reduce using rule 165 (method_declaration -> method_header method_body .)
    BOOL_CONSTT     reduce using rule 165 (method_declaration -> method_header method_body .)
    BOOL_CONSTF     reduce using rule 165 (method_declaration -> method_header method_body .)
    BLOCKEND        reduce using rule 165 (method_declaration -> method_header method_body .)


state 153

    (176) method_start_scope -> BLOCKBEGIN .

    KEYWORD_IF      reduce using rule 176 (method_start_scope -> BLOCKBEGIN .)
    KEYWORD_WHILE   reduce using rule 176 (method_start_scope -> BLOCKBEGIN .)
    KEYWORD_DO      reduce using rule 176 (method_start_scope -> BLOCKBEGIN .)
    KEYWORD_FOR     reduce using rule 176 (method_start_scope -> BLOCKBEGIN .)
    KEYWORD_CLASS   reduce using rule 176 (method_start_scope -> BLOCKBEGIN .)
    KEYWORD_OBJECT  reduce using rule 176 (method_start_scope -> BLOCKBEGIN .)
    KEYWORD_VAR     reduce using rule 176 (method_start_scope -> BLOCKBEGIN .)
    KEYWORD_VAL     reduce using rule 176 (method_start_scope -> BLOCKBEGIN .)
    TERMINATOR      reduce using rule 176 (method_start_scope -> BLOCKBEGIN .)
    KEYWORD_RETURN  reduce using rule 176 (method_start_scope -> BLOCKBEGIN .)
    KEYWORD_DEF     reduce using rule 176 (method_start_scope -> BLOCKBEGIN .)
    BLOCKBEGIN      reduce using rule 176 (method_start_scope -> BLOCKBEGIN .)
    IDENTIFIER      reduce using rule 176 (method_start_scope -> BLOCKBEGIN .)
    PLUS            reduce using rule 176 (method_start_scope -> BLOCKBEGIN .)
    MINUS           reduce using rule 176 (method_start_scope -> BLOCKBEGIN .)
    TILDA           reduce using rule 176 (method_start_scope -> BLOCKBEGIN .)
    NOT             reduce using rule 176 (method_start_scope -> BLOCKBEGIN .)
    LPAREN          reduce using rule 176 (method_start_scope -> BLOCKBEGIN .)
    INT_NUMBER      reduce using rule 176 (method_start_scope -> BLOCKBEGIN .)
    BOOL_CONSTT     reduce using rule 176 (method_start_scope -> BLOCKBEGIN .)
    BOOL_CONSTF     reduce using rule 176 (method_start_scope -> BLOCKBEGIN .)
    BLOCKEND        reduce using rule 176 (method_start_scope -> BLOCKBEGIN .)


state 154

    (136) normal_statement -> empty_statement marker .

    KEYWORD_IF      reduce using rule 136 (normal_statement -> empty_statement marker .)
    KEYWORD_WHILE   reduce using rule 136 (normal_statement -> empty_statement marker .)
    KEYWORD_DO      reduce using rule 136 (normal_statement -> empty_statement marker .)
    KEYWORD_FOR     reduce using rule 136 (normal_statement -> empty_statement marker .)
    KEYWORD_CLASS   reduce using rule 136 (normal_statement -> empty_statement marker .)
    KEYWORD_OBJECT  reduce using rule 136 (normal_statement -> empty_statement marker .)
    KEYWORD_VAR     reduce using rule 136 (normal_statement -> empty_statement marker .)
    KEYWORD_VAL     reduce using rule 136 (normal_statement -> empty_statement marker .)
    TERMINATOR      reduce using rule 136 (normal_statement -> empty_statement marker .)
    KEYWORD_RETURN  reduce using rule 136 (normal_statement -> empty_statement marker .)
    KEYWORD_DEF     reduce using rule 136 (normal_statement -> empty_statement marker .)
    BLOCKBEGIN      reduce using rule 136 (normal_statement -> empty_statement marker .)
    IDENTIFIER      reduce using rule 136 (normal_statement -> empty_statement marker .)
    PLUS            reduce using rule 136 (normal_statement -> empty_statement marker .)
    MINUS           reduce using rule 136 (normal_statement -> empty_statement marker .)
    TILDA           reduce using rule 136 (normal_statement -> empty_statement marker .)
    NOT             reduce using rule 136 (normal_statement -> empty_statement marker .)
    LPAREN          reduce using rule 136 (normal_statement -> empty_statement marker .)
    INT_NUMBER      reduce using rule 136 (normal_statement -> empty_statement marker .)
    BOOL_CONSTT     reduce using rule 136 (normal_statement -> empty_statement marker .)
    BOOL_CONSTF     reduce using rule 136 (normal_statement -> empty_statement marker .)
    BLOCKEND        reduce using rule 136 (normal_statement -> empty_statement marker .)
    KEYWORD_ELSE    reduce using rule 136 (normal_statement -> empty_statement marker .)


state 155

    (95) local_variable_declaration_statement -> local_variable_declaration TERMINATOR .

    KEYWORD_IF      reduce using rule 95 (local_variable_declaration_statement -> local_variable_declaration TERMINATOR .)
    KEYWORD_WHILE   reduce using rule 95 (local_variable_declaration_statement -> local_variable_declaration TERMINATOR .)
    KEYWORD_DO      reduce using rule 95 (local_variable_declaration_statement -> local_variable_declaration TERMINATOR .)
    KEYWORD_FOR     reduce using rule 95 (local_variable_declaration_statement -> local_variable_declaration TERMINATOR .)
    KEYWORD_CLASS   reduce using rule 95 (local_variable_declaration_statement -> local_variable_declaration TERMINATOR .)
    KEYWORD_OBJECT  reduce using rule 95 (local_variable_declaration_statement -> local_variable_declaration TERMINATOR .)
    KEYWORD_VAR     reduce using rule 95 (local_variable_declaration_statement -> local_variable_declaration TERMINATOR .)
    KEYWORD_VAL     reduce using rule 95 (local_variable_declaration_statement -> local_variable_declaration TERMINATOR .)
    TERMINATOR      reduce using rule 95 (local_variable_declaration_statement -> local_variable_declaration TERMINATOR .)
    KEYWORD_RETURN  reduce using rule 95 (local_variable_declaration_statement -> local_variable_declaration TERMINATOR .)
    KEYWORD_DEF     reduce using rule 95 (local_variable_declaration_statement -> local_variable_declaration TERMINATOR .)
    BLOCKBEGIN      reduce using rule 95 (local_variable_declaration_statement -> local_variable_declaration TERMINATOR .)
    IDENTIFIER      reduce using rule 95 (local_variable_declaration_statement -> local_variable_declaration TERMINATOR .)
    PLUS            reduce using rule 95 (local_variable_declaration_statement -> local_variable_declaration TERMINATOR .)
    MINUS           reduce using rule 95 (local_variable_declaration_statement -> local_variable_declaration TERMINATOR .)
    TILDA           reduce using rule 95 (local_variable_declaration_statement -> local_variable_declaration TERMINATOR .)
    NOT             reduce using rule 95 (local_variable_declaration_statement -> local_variable_declaration TERMINATOR .)
    LPAREN          reduce using rule 95 (local_variable_declaration_statement -> local_variable_declaration TERMINATOR .)
    INT_NUMBER      reduce using rule 95 (local_variable_declaration_statement -> local_variable_declaration TERMINATOR .)
    BOOL_CONSTT     reduce using rule 95 (local_variable_declaration_statement -> local_variable_declaration TERMINATOR .)
    BOOL_CONSTF     reduce using rule 95 (local_variable_declaration_statement -> local_variable_declaration TERMINATOR .)
    BLOCKEND        reduce using rule 95 (local_variable_declaration_statement -> local_variable_declaration TERMINATOR .)


state 156

    (128) statement -> normal_statement marker .

    KEYWORD_IF      reduce using rule 128 (statement -> normal_statement marker .)
    KEYWORD_WHILE   reduce using rule 128 (statement -> normal_statement marker .)
    KEYWORD_DO      reduce using rule 128 (statement -> normal_statement marker .)
    KEYWORD_FOR     reduce using rule 128 (statement -> normal_statement marker .)
    KEYWORD_CLASS   reduce using rule 128 (statement -> normal_statement marker .)
    KEYWORD_OBJECT  reduce using rule 128 (statement -> normal_statement marker .)
    KEYWORD_VAR     reduce using rule 128 (statement -> normal_statement marker .)
    KEYWORD_VAL     reduce using rule 128 (statement -> normal_statement marker .)
    TERMINATOR      reduce using rule 128 (statement -> normal_statement marker .)
    KEYWORD_RETURN  reduce using rule 128 (statement -> normal_statement marker .)
    KEYWORD_DEF     reduce using rule 128 (statement -> normal_statement marker .)
    BLOCKBEGIN      reduce using rule 128 (statement -> normal_statement marker .)
    IDENTIFIER      reduce using rule 128 (statement -> normal_statement marker .)
    PLUS            reduce using rule 128 (statement -> normal_statement marker .)
    MINUS           reduce using rule 128 (statement -> normal_statement marker .)
    TILDA           reduce using rule 128 (statement -> normal_statement marker .)
    NOT             reduce using rule 128 (statement -> normal_statement marker .)
    LPAREN          reduce using rule 128 (statement -> normal_statement marker .)
    INT_NUMBER      reduce using rule 128 (statement -> normal_statement marker .)
    BOOL_CONSTT     reduce using rule 128 (statement -> normal_statement marker .)
    BOOL_CONSTF     reduce using rule 128 (statement -> normal_statement marker .)
    BLOCKEND        reduce using rule 128 (statement -> normal_statement marker .)


state 157

    (52) and_expression -> and_expression AND_BITWISE . equality_expression
    (53) equality_expression -> . relational_expression
    (54) equality_expression -> . equality_expression EQUAL relational_expression
    (55) equality_expression -> . equality_expression NEQUAL relational_expression
    (56) relational_expression -> . shift_expression
    (57) relational_expression -> . relational_expression GREATER shift_expression
    (58) relational_expression -> . relational_expression LESS shift_expression
    (59) relational_expression -> . relational_expression GEQ shift_expression
    (60) relational_expression -> . relational_expression LEQ shift_expression
    (61) shift_expression -> . additive_expression
    (62) shift_expression -> . shift_expression LSHIFT additive_expression
    (63) shift_expression -> . shift_expression RSHIFT additive_expression
    (64) additive_expression -> . multiplicative_expression
    (65) additive_expression -> . additive_expression PLUS multiplicative_expression
    (66) additive_expression -> . additive_expression MINUS multiplicative_expression
    (67) multiplicative_expression -> . unary_expression
    (68) multiplicative_expression -> . multiplicative_expression TIMES unary_expression
    (69) multiplicative_expression -> . multiplicative_expression DIVIDE unary_expression
    (70) multiplicative_expression -> . multiplicative_expression REMAINDER unary_expression
    (71) unary_expression -> . PLUS unary_expression
    (72) unary_expression -> . MINUS unary_expression
    (73) unary_expression -> . unary_expression_not_plus_minus
    (74) unary_expression_not_plus_minus -> . base_variable_set
    (75) unary_expression_not_plus_minus -> . TILDA unary_expression
    (76) unary_expression_not_plus_minus -> . NOT unary_expression
    (77) base_variable_set -> . variable_literal
    (78) base_variable_set -> . LPAREN expression RPAREN
    (79) variable_literal -> . valid_variable
    (80) variable_literal -> . primary
    (26) valid_variable -> . name
    (27) valid_variable -> . array_access
    (81) primary -> . literal
    (82) primary -> . method_invocation
    (121) name -> . simple_name
    (122) name -> . qualified_name
    (28) array_access -> . name dimension
    (83) literal -> . int_float
    (84) literal -> . c_literal
    (88) method_invocation -> . name LPAREN argument_list_opt RPAREN
    (123) simple_name -> . IDENTIFIER
    (124) qualified_name -> . name INST simple_name
    (87) int_float -> . INT_NUMBER
    (85) c_literal -> . BOOL_CONSTT
    (86) c_literal -> . BOOL_CONSTF

    PLUS            shift and go to state 30
    MINUS           shift and go to state 24
    TILDA           shift and go to state 65
    NOT             shift and go to state 52
    LPAREN          shift and go to state 86
    IDENTIFIER      shift and go to state 9
    INT_NUMBER      shift and go to state 38
    BOOL_CONSTT     shift and go to state 29
    BOOL_CONSTF     shift and go to state 25

    unary_expression               shift and go to state 39
    primary                        shift and go to state 57
    unary_expression_not_plus_minus shift and go to state 40
    array_access                   shift and go to state 23
    simple_name                    shift and go to state 60
    c_literal                      shift and go to state 85
    base_variable_set              shift and go to state 80
    valid_variable                 shift and go to state 101
    literal                        shift and go to state 64
    additive_expression            shift and go to state 59
    method_invocation              shift and go to state 102
    relational_expression          shift and go to state 66
    qualified_name                 shift and go to state 71
    multiplicative_expression      shift and go to state 45
    shift_expression               shift and go to state 49
    equality_expression            shift and go to state 216
    int_float                      shift and go to state 34
    variable_literal               shift and go to state 50
    name                           shift and go to state 103

state 158

    (137) normal_statement -> return_statement marker .

    KEYWORD_IF      reduce using rule 137 (normal_statement -> return_statement marker .)
    KEYWORD_WHILE   reduce using rule 137 (normal_statement -> return_statement marker .)
    KEYWORD_DO      reduce using rule 137 (normal_statement -> return_statement marker .)
    KEYWORD_FOR     reduce using rule 137 (normal_statement -> return_statement marker .)
    KEYWORD_CLASS   reduce using rule 137 (normal_statement -> return_statement marker .)
    KEYWORD_OBJECT  reduce using rule 137 (normal_statement -> return_statement marker .)
    KEYWORD_VAR     reduce using rule 137 (normal_statement -> return_statement marker .)
    KEYWORD_VAL     reduce using rule 137 (normal_statement -> return_statement marker .)
    TERMINATOR      reduce using rule 137 (normal_statement -> return_statement marker .)
    KEYWORD_RETURN  reduce using rule 137 (normal_statement -> return_statement marker .)
    KEYWORD_DEF     reduce using rule 137 (normal_statement -> return_statement marker .)
    BLOCKBEGIN      reduce using rule 137 (normal_statement -> return_statement marker .)
    IDENTIFIER      reduce using rule 137 (normal_statement -> return_statement marker .)
    PLUS            reduce using rule 137 (normal_statement -> return_statement marker .)
    MINUS           reduce using rule 137 (normal_statement -> return_statement marker .)
    TILDA           reduce using rule 137 (normal_statement -> return_statement marker .)
    NOT             reduce using rule 137 (normal_statement -> return_statement marker .)
    LPAREN          reduce using rule 137 (normal_statement -> return_statement marker .)
    INT_NUMBER      reduce using rule 137 (normal_statement -> return_statement marker .)
    BOOL_CONSTT     reduce using rule 137 (normal_statement -> return_statement marker .)
    BOOL_CONSTF     reduce using rule 137 (normal_statement -> return_statement marker .)
    BLOCKEND        reduce using rule 137 (normal_statement -> return_statement marker .)
    KEYWORD_ELSE    reduce using rule 137 (normal_statement -> return_statement marker .)


state 159

    (13) block_statements -> block_statements marker . block_statement
    (14) block_statement -> . local_variable_declaration_statement
    (15) block_statement -> . statement
    (16) block_statement -> . class_declaration
    (17) block_statement -> . SingletonObject
    (18) block_statement -> . method_declaration
    (95) local_variable_declaration_statement -> . local_variable_declaration TERMINATOR
    (128) statement -> . normal_statement marker
    (129) statement -> . if_then_statement marker
    (130) statement -> . if_then_else_statement marker
    (131) statement -> . while_statement marker
    (132) statement -> . do_while_statement marker
    (133) statement -> . for_statement marker
    (177) class_declaration -> . class_header class_body
    (5) SingletonObject -> . ObjectDeclare block
    (165) method_declaration -> . method_header method_body
    (96) local_variable_declaration -> . declaration_keyword variable_declaration_body
    (134) normal_statement -> . block marker
    (135) normal_statement -> . expression_statement marker
    (136) normal_statement -> . empty_statement marker
    (137) normal_statement -> . return_statement marker
    (138) normal_statement -> . switch_statement marker
    (142) if_then_statement -> . KEYWORD_IF LPAREN expression RPAREN marker block
    (143) if_then_else_statement -> . KEYWORD_IF LPAREN expression RPAREN marker if_then_else_intermediate narker KEYWORD_ELSE marker block
    (147) while_statement -> . KEYWORD_WHILE LPAREN marker expression RPAREN marker block
    (148) do_while_statement -> . KEYWORD_DO marker block KEYWORD_WHILE LPAREN marker expression RPAREN TERMINATOR
    (149) for_statement -> . KEYWORD_FOR LPAREN for_update RPAREN marker block
    (178) class_header -> . KEYWORD_CLASS simple_name class_param_clause
    (6) ObjectDeclare -> . KEYWORD_OBJECT IDENTIFIER
    (166) method_header -> . method_header_name func_arg_start fun_params_opt RPAREN COLON method_return_type ASOP
    (93) declaration_keyword -> . KEYWORD_VAR
    (94) declaration_keyword -> . KEYWORD_VAL
    (7) block -> . start_scope block_statements_opt end_scope
    (139) expression_statement -> . statement_expression TERMINATOR
    (163) empty_statement -> . TERMINATOR
    (164) return_statement -> . KEYWORD_RETURN expression_optional TERMINATOR
    (156) switch_statement -> . expression KEYWORD_MATCH switch_block marker
    (174) method_header_name -> . KEYWORD_DEF IDENTIFIER
    (8) start_scope -> . BLOCKBEGIN
    (140) statement_expression -> . assignment
    (141) statement_expression -> . method_invocation
    (19) expression -> . assignment_expression
    (25) assignment -> . valid_variable assignment_operator assignment_expression
    (88) method_invocation -> . name LPAREN argument_list_opt RPAREN
    (22) assignment_expression -> . assignment
    (23) assignment_expression -> . conditional_or_expression
    (24) assignment_expression -> . method_invocation
    (26) valid_variable -> . name
    (27) valid_variable -> . array_access
    (121) name -> . simple_name
    (122) name -> . qualified_name
    (43) conditional_or_expression -> . conditional_and_expression
    (44) conditional_or_expression -> . conditional_or_expression OR marker conditional_and_expression
    (28) array_access -> . name dimension
    (123) simple_name -> . IDENTIFIER
    (124) qualified_name -> . name INST simple_name
    (45) conditional_and_expression -> . inclusive_or_expression
    (46) conditional_and_expression -> . conditional_and_expression AND marker inclusive_or_expression
    (47) inclusive_or_expression -> . exclusive_or_expression
    (48) inclusive_or_expression -> . inclusive_or_expression OR_BITWISE exclusive_or_expression
    (49) exclusive_or_expression -> . and_expression
    (50) exclusive_or_expression -> . exclusive_or_expression XOR and_expression
    (51) and_expression -> . equality_expression
    (52) and_expression -> . and_expression AND_BITWISE equality_expression
    (53) equality_expression -> . relational_expression
    (54) equality_expression -> . equality_expression EQUAL relational_expression
    (55) equality_expression -> . equality_expression NEQUAL relational_expression
    (56) relational_expression -> . shift_expression
    (57) relational_expression -> . relational_expression GREATER shift_expression
    (58) relational_expression -> . relational_expression LESS shift_expression
    (59) relational_expression -> . relational_expression GEQ shift_expression
    (60) relational_expression -> . relational_expression LEQ shift_expression
    (61) shift_expression -> . additive_expression
    (62) shift_expression -> . shift_expression LSHIFT additive_expression
    (63) shift_expression -> . shift_expression RSHIFT additive_expression
    (64) additive_expression -> . multiplicative_expression
    (65) additive_expression -> . additive_expression PLUS multiplicative_expression
    (66) additive_expression -> . additive_expression MINUS multiplicative_expression
    (67) multiplicative_expression -> . unary_expression
    (68) multiplicative_expression -> . multiplicative_expression TIMES unary_expression
    (69) multiplicative_expression -> . multiplicative_expression DIVIDE unary_expression
    (70) multiplicative_expression -> . multiplicative_expression REMAINDER unary_expression
    (71) unary_expression -> . PLUS unary_expression
    (72) unary_expression -> . MINUS unary_expression
    (73) unary_expression -> . unary_expression_not_plus_minus
    (74) unary_expression_not_plus_minus -> . base_variable_set
    (75) unary_expression_not_plus_minus -> . TILDA unary_expression
    (76) unary_expression_not_plus_minus -> . NOT unary_expression
    (77) base_variable_set -> . variable_literal
    (78) base_variable_set -> . LPAREN expression RPAREN
    (79) variable_literal -> . valid_variable
    (80) variable_literal -> . primary
    (81) primary -> . literal
    (82) primary -> . method_invocation
    (83) literal -> . int_float
    (84) literal -> . c_literal
    (87) int_float -> . INT_NUMBER
    (85) c_literal -> . BOOL_CONSTT
    (86) c_literal -> . BOOL_CONSTF

    KEYWORD_IF      shift and go to state 73
    KEYWORD_WHILE   shift and go to state 43
    KEYWORD_DO      shift and go to state 90
    KEYWORD_FOR     shift and go to state 89
    KEYWORD_CLASS   shift and go to state 1
    KEYWORD_OBJECT  shift and go to state 8
    KEYWORD_VAR     shift and go to state 46
    KEYWORD_VAL     shift and go to state 47
    TERMINATOR      shift and go to state 48
    KEYWORD_RETURN  shift and go to state 61
    KEYWORD_DEF     shift and go to state 72
    BLOCKBEGIN      shift and go to state 12
    IDENTIFIER      shift and go to state 9
    PLUS            shift and go to state 30
    MINUS           shift and go to state 24
    TILDA           shift and go to state 65
    NOT             shift and go to state 52
    LPAREN          shift and go to state 86
    INT_NUMBER      shift and go to state 38
    BOOL_CONSTT     shift and go to state 29
    BOOL_CONSTF     shift and go to state 25

    expression_statement           shift and go to state 22
    unary_expression               shift and go to state 39
    exclusive_or_expression        shift and go to state 56
    normal_statement               shift and go to state 78
    ObjectDeclare                  shift and go to state 3
    primary                        shift and go to state 57
    declaration_keyword            shift and go to state 70
    if_then_statement              shift and go to state 58
    array_access                   shift and go to state 23
    switch_statement               shift and go to state 41
    simple_name                    shift and go to state 60
    qualified_name                 shift and go to state 71
    base_variable_set              shift and go to state 80
    inclusive_or_expression        shift and go to state 27
    method_declaration             shift and go to state 62
    literal                        shift and go to state 64
    block_statement                shift and go to state 217
    return_statement               shift and go to state 81
    while_statement                shift and go to state 28
    unary_expression_not_plus_minus shift and go to state 40
    and_expression                 shift and go to state 79
    statement                      shift and go to state 67
    c_literal                      shift and go to state 85
    statement_expression           shift and go to state 31
    method_invocation              shift and go to state 68
    conditional_or_expression      shift and go to state 42
    relational_expression          shift and go to state 66
    for_statement                  shift and go to state 32
    local_variable_declaration_statement shift and go to state 33
    do_while_statement             shift and go to state 44
    int_float                      shift and go to state 34
    assignment                     shift and go to state 84
    multiplicative_expression      shift and go to state 45
    additive_expression            shift and go to state 59
    SingletonObject                shift and go to state 35
    start_scope                    shift and go to state 13
    method_header_name             shift and go to state 36
    class_header                   shift and go to state 7
    shift_expression               shift and go to state 49
    equality_expression            shift and go to state 74
    variable_literal               shift and go to state 50
    name                           shift and go to state 37
    assignment_expression          shift and go to state 83
    valid_variable                 shift and go to state 87
    method_header                  shift and go to state 75
    empty_statement                shift and go to state 76
    class_declaration              shift and go to state 88
    local_variable_declaration     shift and go to state 77
    expression                     shift and go to state 53
    conditional_and_expression     shift and go to state 51
    block                          shift and go to state 54
    if_then_else_statement         shift and go to state 55

state 160

    (78) base_variable_set -> LPAREN expression . RPAREN

    RPAREN          shift and go to state 218


state 161

    (31) assignment_operator -> TIMES_ASSIGN .

    IDENTIFIER      reduce using rule 31 (assignment_operator -> TIMES_ASSIGN .)
    PLUS            reduce using rule 31 (assignment_operator -> TIMES_ASSIGN .)
    MINUS           reduce using rule 31 (assignment_operator -> TIMES_ASSIGN .)
    TILDA           reduce using rule 31 (assignment_operator -> TIMES_ASSIGN .)
    NOT             reduce using rule 31 (assignment_operator -> TIMES_ASSIGN .)
    LPAREN          reduce using rule 31 (assignment_operator -> TIMES_ASSIGN .)
    INT_NUMBER      reduce using rule 31 (assignment_operator -> TIMES_ASSIGN .)
    BOOL_CONSTT     reduce using rule 31 (assignment_operator -> TIMES_ASSIGN .)
    BOOL_CONSTF     reduce using rule 31 (assignment_operator -> TIMES_ASSIGN .)


state 162

    (37) assignment_operator -> RSHIFT_ASSIGN .

    IDENTIFIER      reduce using rule 37 (assignment_operator -> RSHIFT_ASSIGN .)
    PLUS            reduce using rule 37 (assignment_operator -> RSHIFT_ASSIGN .)
    MINUS           reduce using rule 37 (assignment_operator -> RSHIFT_ASSIGN .)
    TILDA           reduce using rule 37 (assignment_operator -> RSHIFT_ASSIGN .)
    NOT             reduce using rule 37 (assignment_operator -> RSHIFT_ASSIGN .)
    LPAREN          reduce using rule 37 (assignment_operator -> RSHIFT_ASSIGN .)
    INT_NUMBER      reduce using rule 37 (assignment_operator -> RSHIFT_ASSIGN .)
    BOOL_CONSTT     reduce using rule 37 (assignment_operator -> RSHIFT_ASSIGN .)
    BOOL_CONSTF     reduce using rule 37 (assignment_operator -> RSHIFT_ASSIGN .)


state 163

    (35) assignment_operator -> MINUS_ASSIGN .

    IDENTIFIER      reduce using rule 35 (assignment_operator -> MINUS_ASSIGN .)
    PLUS            reduce using rule 35 (assignment_operator -> MINUS_ASSIGN .)
    MINUS           reduce using rule 35 (assignment_operator -> MINUS_ASSIGN .)
    TILDA           reduce using rule 35 (assignment_operator -> MINUS_ASSIGN .)
    NOT             reduce using rule 35 (assignment_operator -> MINUS_ASSIGN .)
    LPAREN          reduce using rule 35 (assignment_operator -> MINUS_ASSIGN .)
    INT_NUMBER      reduce using rule 35 (assignment_operator -> MINUS_ASSIGN .)
    BOOL_CONSTT     reduce using rule 35 (assignment_operator -> MINUS_ASSIGN .)
    BOOL_CONSTF     reduce using rule 35 (assignment_operator -> MINUS_ASSIGN .)


state 164

    (30) assignment_operator -> ASOP .

    IDENTIFIER      reduce using rule 30 (assignment_operator -> ASOP .)
    PLUS            reduce using rule 30 (assignment_operator -> ASOP .)
    MINUS           reduce using rule 30 (assignment_operator -> ASOP .)
    TILDA           reduce using rule 30 (assignment_operator -> ASOP .)
    NOT             reduce using rule 30 (assignment_operator -> ASOP .)
    LPAREN          reduce using rule 30 (assignment_operator -> ASOP .)
    INT_NUMBER      reduce using rule 30 (assignment_operator -> ASOP .)
    BOOL_CONSTT     reduce using rule 30 (assignment_operator -> ASOP .)
    BOOL_CONSTF     reduce using rule 30 (assignment_operator -> ASOP .)


state 165

    (33) assignment_operator -> REMAINDER_ASSIGN .

    IDENTIFIER      reduce using rule 33 (assignment_operator -> REMAINDER_ASSIGN .)
    PLUS            reduce using rule 33 (assignment_operator -> REMAINDER_ASSIGN .)
    MINUS           reduce using rule 33 (assignment_operator -> REMAINDER_ASSIGN .)
    TILDA           reduce using rule 33 (assignment_operator -> REMAINDER_ASSIGN .)
    NOT             reduce using rule 33 (assignment_operator -> REMAINDER_ASSIGN .)
    LPAREN          reduce using rule 33 (assignment_operator -> REMAINDER_ASSIGN .)
    INT_NUMBER      reduce using rule 33 (assignment_operator -> REMAINDER_ASSIGN .)
    BOOL_CONSTT     reduce using rule 33 (assignment_operator -> REMAINDER_ASSIGN .)
    BOOL_CONSTF     reduce using rule 33 (assignment_operator -> REMAINDER_ASSIGN .)


state 166

    (39) assignment_operator -> OR_ASSIGN .

    IDENTIFIER      reduce using rule 39 (assignment_operator -> OR_ASSIGN .)
    PLUS            reduce using rule 39 (assignment_operator -> OR_ASSIGN .)
    MINUS           reduce using rule 39 (assignment_operator -> OR_ASSIGN .)
    TILDA           reduce using rule 39 (assignment_operator -> OR_ASSIGN .)
    NOT             reduce using rule 39 (assignment_operator -> OR_ASSIGN .)
    LPAREN          reduce using rule 39 (assignment_operator -> OR_ASSIGN .)
    INT_NUMBER      reduce using rule 39 (assignment_operator -> OR_ASSIGN .)
    BOOL_CONSTT     reduce using rule 39 (assignment_operator -> OR_ASSIGN .)
    BOOL_CONSTF     reduce using rule 39 (assignment_operator -> OR_ASSIGN .)


state 167

    (36) assignment_operator -> LSHIFT_ASSIGN .

    IDENTIFIER      reduce using rule 36 (assignment_operator -> LSHIFT_ASSIGN .)
    PLUS            reduce using rule 36 (assignment_operator -> LSHIFT_ASSIGN .)
    MINUS           reduce using rule 36 (assignment_operator -> LSHIFT_ASSIGN .)
    TILDA           reduce using rule 36 (assignment_operator -> LSHIFT_ASSIGN .)
    NOT             reduce using rule 36 (assignment_operator -> LSHIFT_ASSIGN .)
    LPAREN          reduce using rule 36 (assignment_operator -> LSHIFT_ASSIGN .)
    INT_NUMBER      reduce using rule 36 (assignment_operator -> LSHIFT_ASSIGN .)
    BOOL_CONSTT     reduce using rule 36 (assignment_operator -> LSHIFT_ASSIGN .)
    BOOL_CONSTF     reduce using rule 36 (assignment_operator -> LSHIFT_ASSIGN .)


state 168

    (38) assignment_operator -> AND_ASSIGN .

    IDENTIFIER      reduce using rule 38 (assignment_operator -> AND_ASSIGN .)
    PLUS            reduce using rule 38 (assignment_operator -> AND_ASSIGN .)
    MINUS           reduce using rule 38 (assignment_operator -> AND_ASSIGN .)
    TILDA           reduce using rule 38 (assignment_operator -> AND_ASSIGN .)
    NOT             reduce using rule 38 (assignment_operator -> AND_ASSIGN .)
    LPAREN          reduce using rule 38 (assignment_operator -> AND_ASSIGN .)
    INT_NUMBER      reduce using rule 38 (assignment_operator -> AND_ASSIGN .)
    BOOL_CONSTT     reduce using rule 38 (assignment_operator -> AND_ASSIGN .)
    BOOL_CONSTF     reduce using rule 38 (assignment_operator -> AND_ASSIGN .)


state 169

    (32) assignment_operator -> DIVIDE_ASSIGN .

    IDENTIFIER      reduce using rule 32 (assignment_operator -> DIVIDE_ASSIGN .)
    PLUS            reduce using rule 32 (assignment_operator -> DIVIDE_ASSIGN .)
    MINUS           reduce using rule 32 (assignment_operator -> DIVIDE_ASSIGN .)
    TILDA           reduce using rule 32 (assignment_operator -> DIVIDE_ASSIGN .)
    NOT             reduce using rule 32 (assignment_operator -> DIVIDE_ASSIGN .)
    LPAREN          reduce using rule 32 (assignment_operator -> DIVIDE_ASSIGN .)
    INT_NUMBER      reduce using rule 32 (assignment_operator -> DIVIDE_ASSIGN .)
    BOOL_CONSTT     reduce using rule 32 (assignment_operator -> DIVIDE_ASSIGN .)
    BOOL_CONSTF     reduce using rule 32 (assignment_operator -> DIVIDE_ASSIGN .)


state 170

    (25) assignment -> valid_variable assignment_operator . assignment_expression
    (22) assignment_expression -> . assignment
    (23) assignment_expression -> . conditional_or_expression
    (24) assignment_expression -> . method_invocation
    (25) assignment -> . valid_variable assignment_operator assignment_expression
    (43) conditional_or_expression -> . conditional_and_expression
    (44) conditional_or_expression -> . conditional_or_expression OR marker conditional_and_expression
    (88) method_invocation -> . name LPAREN argument_list_opt RPAREN
    (26) valid_variable -> . name
    (27) valid_variable -> . array_access
    (45) conditional_and_expression -> . inclusive_or_expression
    (46) conditional_and_expression -> . conditional_and_expression AND marker inclusive_or_expression
    (121) name -> . simple_name
    (122) name -> . qualified_name
    (28) array_access -> . name dimension
    (47) inclusive_or_expression -> . exclusive_or_expression
    (48) inclusive_or_expression -> . inclusive_or_expression OR_BITWISE exclusive_or_expression
    (123) simple_name -> . IDENTIFIER
    (124) qualified_name -> . name INST simple_name
    (49) exclusive_or_expression -> . and_expression
    (50) exclusive_or_expression -> . exclusive_or_expression XOR and_expression
    (51) and_expression -> . equality_expression
    (52) and_expression -> . and_expression AND_BITWISE equality_expression
    (53) equality_expression -> . relational_expression
    (54) equality_expression -> . equality_expression EQUAL relational_expression
    (55) equality_expression -> . equality_expression NEQUAL relational_expression
    (56) relational_expression -> . shift_expression
    (57) relational_expression -> . relational_expression GREATER shift_expression
    (58) relational_expression -> . relational_expression LESS shift_expression
    (59) relational_expression -> . relational_expression GEQ shift_expression
    (60) relational_expression -> . relational_expression LEQ shift_expression
    (61) shift_expression -> . additive_expression
    (62) shift_expression -> . shift_expression LSHIFT additive_expression
    (63) shift_expression -> . shift_expression RSHIFT additive_expression
    (64) additive_expression -> . multiplicative_expression
    (65) additive_expression -> . additive_expression PLUS multiplicative_expression
    (66) additive_expression -> . additive_expression MINUS multiplicative_expression
    (67) multiplicative_expression -> . unary_expression
    (68) multiplicative_expression -> . multiplicative_expression TIMES unary_expression
    (69) multiplicative_expression -> . multiplicative_expression DIVIDE unary_expression
    (70) multiplicative_expression -> . multiplicative_expression REMAINDER unary_expression
    (71) unary_expression -> . PLUS unary_expression
    (72) unary_expression -> . MINUS unary_expression
    (73) unary_expression -> . unary_expression_not_plus_minus
    (74) unary_expression_not_plus_minus -> . base_variable_set
    (75) unary_expression_not_plus_minus -> . TILDA unary_expression
    (76) unary_expression_not_plus_minus -> . NOT unary_expression
    (77) base_variable_set -> . variable_literal
    (78) base_variable_set -> . LPAREN expression RPAREN
    (79) variable_literal -> . valid_variable
    (80) variable_literal -> . primary
    (81) primary -> . literal
    (82) primary -> . method_invocation
    (83) literal -> . int_float
    (84) literal -> . c_literal
    (87) int_float -> . INT_NUMBER
    (85) c_literal -> . BOOL_CONSTT
    (86) c_literal -> . BOOL_CONSTF

    IDENTIFIER      shift and go to state 9
    PLUS            shift and go to state 30
    MINUS           shift and go to state 24
    TILDA           shift and go to state 65
    NOT             shift and go to state 52
    LPAREN          shift and go to state 86
    INT_NUMBER      shift and go to state 38
    BOOL_CONSTT     shift and go to state 29
    BOOL_CONSTF     shift and go to state 25

    and_expression                 shift and go to state 79
    exclusive_or_expression        shift and go to state 56
    primary                        shift and go to state 57
    unary_expression_not_plus_minus shift and go to state 40
    array_access                   shift and go to state 23
    additive_expression            shift and go to state 59
    simple_name                    shift and go to state 60
    c_literal                      shift and go to state 85
    unary_expression               shift and go to state 39
    base_variable_set              shift and go to state 80
    valid_variable                 shift and go to state 87
    inclusive_or_expression        shift and go to state 27
    literal                        shift and go to state 64
    relational_expression          shift and go to state 66
    method_invocation              shift and go to state 134
    conditional_or_expression      shift and go to state 42
    assignment_expression          shift and go to state 219
    qualified_name                 shift and go to state 71
    assignment                     shift and go to state 137
    multiplicative_expression      shift and go to state 45
    shift_expression               shift and go to state 49
    equality_expression            shift and go to state 74
    int_float                      shift and go to state 34
    variable_literal               shift and go to state 50
    name                           shift and go to state 37
    conditional_and_expression     shift and go to state 51

state 171

    (34) assignment_operator -> PLUS_ASSIGN .

    IDENTIFIER      reduce using rule 34 (assignment_operator -> PLUS_ASSIGN .)
    PLUS            reduce using rule 34 (assignment_operator -> PLUS_ASSIGN .)
    MINUS           reduce using rule 34 (assignment_operator -> PLUS_ASSIGN .)
    TILDA           reduce using rule 34 (assignment_operator -> PLUS_ASSIGN .)
    NOT             reduce using rule 34 (assignment_operator -> PLUS_ASSIGN .)
    LPAREN          reduce using rule 34 (assignment_operator -> PLUS_ASSIGN .)
    INT_NUMBER      reduce using rule 34 (assignment_operator -> PLUS_ASSIGN .)
    BOOL_CONSTT     reduce using rule 34 (assignment_operator -> PLUS_ASSIGN .)
    BOOL_CONSTF     reduce using rule 34 (assignment_operator -> PLUS_ASSIGN .)


state 172

    (40) assignment_operator -> XOR_ASSIGN .

    IDENTIFIER      reduce using rule 40 (assignment_operator -> XOR_ASSIGN .)
    PLUS            reduce using rule 40 (assignment_operator -> XOR_ASSIGN .)
    MINUS           reduce using rule 40 (assignment_operator -> XOR_ASSIGN .)
    TILDA           reduce using rule 40 (assignment_operator -> XOR_ASSIGN .)
    NOT             reduce using rule 40 (assignment_operator -> XOR_ASSIGN .)
    LPAREN          reduce using rule 40 (assignment_operator -> XOR_ASSIGN .)
    INT_NUMBER      reduce using rule 40 (assignment_operator -> XOR_ASSIGN .)
    BOOL_CONSTT     reduce using rule 40 (assignment_operator -> XOR_ASSIGN .)
    BOOL_CONSTF     reduce using rule 40 (assignment_operator -> XOR_ASSIGN .)


state 173

    (149) for_statement -> KEYWORD_FOR LPAREN . for_update RPAREN marker block
    (150) for_update -> . for_loop marker for_step_opts
    (151) for_loop -> . IDENTIFIER CHOOSE expression for_untilTo marker expression

    IDENTIFIER      shift and go to state 222

    for_loop                       shift and go to state 220
    for_update                     shift and go to state 221

state 174

    (148) do_while_statement -> KEYWORD_DO marker . block KEYWORD_WHILE LPAREN marker expression RPAREN TERMINATOR
    (7) block -> . start_scope block_statements_opt end_scope
    (8) start_scope -> . BLOCKBEGIN

    BLOCKBEGIN      shift and go to state 12

    start_scope                    shift and go to state 13
    block                          shift and go to state 223

state 175

    (189) class_body -> class_body_start block_statements_opt end_scope .

    KEYWORD_OBJECT  reduce using rule 189 (class_body -> class_body_start block_statements_opt end_scope .)
    KEYWORD_CLASS   reduce using rule 189 (class_body -> class_body_start block_statements_opt end_scope .)
    $end            reduce using rule 189 (class_body -> class_body_start block_statements_opt end_scope .)
    KEYWORD_IF      reduce using rule 189 (class_body -> class_body_start block_statements_opt end_scope .)
    KEYWORD_WHILE   reduce using rule 189 (class_body -> class_body_start block_statements_opt end_scope .)
    KEYWORD_DO      reduce using rule 189 (class_body -> class_body_start block_statements_opt end_scope .)
    KEYWORD_FOR     reduce using rule 189 (class_body -> class_body_start block_statements_opt end_scope .)
    KEYWORD_VAR     reduce using rule 189 (class_body -> class_body_start block_statements_opt end_scope .)
    KEYWORD_VAL     reduce using rule 189 (class_body -> class_body_start block_statements_opt end_scope .)
    TERMINATOR      reduce using rule 189 (class_body -> class_body_start block_statements_opt end_scope .)
    KEYWORD_RETURN  reduce using rule 189 (class_body -> class_body_start block_statements_opt end_scope .)
    KEYWORD_DEF     reduce using rule 189 (class_body -> class_body_start block_statements_opt end_scope .)
    BLOCKBEGIN      reduce using rule 189 (class_body -> class_body_start block_statements_opt end_scope .)
    IDENTIFIER      reduce using rule 189 (class_body -> class_body_start block_statements_opt end_scope .)
    PLUS            reduce using rule 189 (class_body -> class_body_start block_statements_opt end_scope .)
    MINUS           reduce using rule 189 (class_body -> class_body_start block_statements_opt end_scope .)
    TILDA           reduce using rule 189 (class_body -> class_body_start block_statements_opt end_scope .)
    NOT             reduce using rule 189 (class_body -> class_body_start block_statements_opt end_scope .)
    LPAREN          reduce using rule 189 (class_body -> class_body_start block_statements_opt end_scope .)
    INT_NUMBER      reduce using rule 189 (class_body -> class_body_start block_statements_opt end_scope .)
    BOOL_CONSTT     reduce using rule 189 (class_body -> class_body_start block_statements_opt end_scope .)
    BOOL_CONSTF     reduce using rule 189 (class_body -> class_body_start block_statements_opt end_scope .)
    BLOCKEND        reduce using rule 189 (class_body -> class_body_start block_statements_opt end_scope .)


state 176

    (179) class_param_clause -> func_arg_start class_params_opt RPAREN .

    BLOCKBEGIN      reduce using rule 179 (class_param_clause -> func_arg_start class_params_opt RPAREN .)


state 177

    (183) class_params -> class_params COMMA . class_param
    (184) class_param -> . class_declaration_keyword_opt variable_declarator_id
    (185) class_declaration_keyword_opt -> . declaration_keyword
    (186) class_declaration_keyword_opt -> . empty
    (93) declaration_keyword -> . KEYWORD_VAR
    (94) declaration_keyword -> . KEYWORD_VAL
    (191) empty -> .

    KEYWORD_VAR     shift and go to state 46
    KEYWORD_VAL     shift and go to state 47
    IDENTIFIER      reduce using rule 191 (empty -> .)

    declaration_keyword            shift and go to state 93
    class_param                    shift and go to state 224
    class_declaration_keyword_opt  shift and go to state 96
    empty                          shift and go to state 225

state 178

    (107) variable_declarator_id -> IDENTIFIER . COLON type

    COLON           shift and go to state 226


state 179

    (184) class_param -> class_declaration_keyword_opt variable_declarator_id .

    COMMA           reduce using rule 184 (class_param -> class_declaration_keyword_opt variable_declarator_id .)
    RPAREN          reduce using rule 184 (class_param -> class_declaration_keyword_opt variable_declarator_id .)


state 180

    (48) inclusive_or_expression -> inclusive_or_expression OR_BITWISE exclusive_or_expression .
    (50) exclusive_or_expression -> exclusive_or_expression . XOR and_expression

    OR_BITWISE      reduce using rule 48 (inclusive_or_expression -> inclusive_or_expression OR_BITWISE exclusive_or_expression .)
    AND             reduce using rule 48 (inclusive_or_expression -> inclusive_or_expression OR_BITWISE exclusive_or_expression .)
    OR              reduce using rule 48 (inclusive_or_expression -> inclusive_or_expression OR_BITWISE exclusive_or_expression .)
    FUNTYPE         reduce using rule 48 (inclusive_or_expression -> inclusive_or_expression OR_BITWISE exclusive_or_expression .)
    RBRAC           reduce using rule 48 (inclusive_or_expression -> inclusive_or_expression OR_BITWISE exclusive_or_expression .)
    KEYWORD_MATCH   reduce using rule 48 (inclusive_or_expression -> inclusive_or_expression OR_BITWISE exclusive_or_expression .)
    TERMINATOR      reduce using rule 48 (inclusive_or_expression -> inclusive_or_expression OR_BITWISE exclusive_or_expression .)
    RPAREN          reduce using rule 48 (inclusive_or_expression -> inclusive_or_expression OR_BITWISE exclusive_or_expression .)
    COMMA           reduce using rule 48 (inclusive_or_expression -> inclusive_or_expression OR_BITWISE exclusive_or_expression .)
    KEYWORD_UNTIL   reduce using rule 48 (inclusive_or_expression -> inclusive_or_expression OR_BITWISE exclusive_or_expression .)
    KEYWORD_TO      reduce using rule 48 (inclusive_or_expression -> inclusive_or_expression OR_BITWISE exclusive_or_expression .)
    KEYWORD_BY      reduce using rule 48 (inclusive_or_expression -> inclusive_or_expression OR_BITWISE exclusive_or_expression .)
    XOR             shift and go to state 130


state 181

    (170) fun_params -> fun_variable_declarator_id .

    COMMA           reduce using rule 170 (fun_params -> fun_variable_declarator_id .)
    RPAREN          reduce using rule 170 (fun_params -> fun_variable_declarator_id .)


state 182

    (166) method_header -> method_header_name func_arg_start fun_params_opt . RPAREN COLON method_return_type ASOP

    RPAREN          shift and go to state 227


state 183

    (168) fun_params_opt -> fun_params .
    (171) fun_params -> fun_params . COMMA fun_variable_declarator_id

    RPAREN          reduce using rule 168 (fun_params_opt -> fun_params .)
    COMMA           shift and go to state 228


state 184

    (108) fun_variable_declarator_id -> IDENTIFIER . COLON type

    COLON           shift and go to state 229


state 185

    (169) fun_params_opt -> empty .

    RPAREN          reduce using rule 169 (fun_params_opt -> empty .)


state 186

    (29) dimension -> LBRAC expression . RBRAC

    RBRAC           shift and go to state 230


state 187

    (124) qualified_name -> name INST simple_name .

    INST            reduce using rule 124 (qualified_name -> name INST simple_name .)
    RBRAC           reduce using rule 124 (qualified_name -> name INST simple_name .)
    LPAREN          reduce using rule 124 (qualified_name -> name INST simple_name .)
    LBRAC           reduce using rule 124 (qualified_name -> name INST simple_name .)
    TIMES           reduce using rule 124 (qualified_name -> name INST simple_name .)
    DIVIDE          reduce using rule 124 (qualified_name -> name INST simple_name .)
    REMAINDER       reduce using rule 124 (qualified_name -> name INST simple_name .)
    PLUS            reduce using rule 124 (qualified_name -> name INST simple_name .)
    MINUS           reduce using rule 124 (qualified_name -> name INST simple_name .)
    LSHIFT          reduce using rule 124 (qualified_name -> name INST simple_name .)
    RSHIFT          reduce using rule 124 (qualified_name -> name INST simple_name .)
    GREATER         reduce using rule 124 (qualified_name -> name INST simple_name .)
    LESS            reduce using rule 124 (qualified_name -> name INST simple_name .)
    GEQ             reduce using rule 124 (qualified_name -> name INST simple_name .)
    LEQ             reduce using rule 124 (qualified_name -> name INST simple_name .)
    EQUAL           reduce using rule 124 (qualified_name -> name INST simple_name .)
    NEQUAL          reduce using rule 124 (qualified_name -> name INST simple_name .)
    AND_BITWISE     reduce using rule 124 (qualified_name -> name INST simple_name .)
    XOR             reduce using rule 124 (qualified_name -> name INST simple_name .)
    OR_BITWISE      reduce using rule 124 (qualified_name -> name INST simple_name .)
    AND             reduce using rule 124 (qualified_name -> name INST simple_name .)
    OR              reduce using rule 124 (qualified_name -> name INST simple_name .)
    KEYWORD_MATCH   reduce using rule 124 (qualified_name -> name INST simple_name .)
    TERMINATOR      reduce using rule 124 (qualified_name -> name INST simple_name .)
    RPAREN          reduce using rule 124 (qualified_name -> name INST simple_name .)
    COMMA           reduce using rule 124 (qualified_name -> name INST simple_name .)
    FUNTYPE         reduce using rule 124 (qualified_name -> name INST simple_name .)
    KEYWORD_UNTIL   reduce using rule 124 (qualified_name -> name INST simple_name .)
    KEYWORD_TO      reduce using rule 124 (qualified_name -> name INST simple_name .)
    KEYWORD_BY      reduce using rule 124 (qualified_name -> name INST simple_name .)
    ASOP            reduce using rule 124 (qualified_name -> name INST simple_name .)
    TIMES_ASSIGN    reduce using rule 124 (qualified_name -> name INST simple_name .)
    DIVIDE_ASSIGN   reduce using rule 124 (qualified_name -> name INST simple_name .)
    REMAINDER_ASSIGN reduce using rule 124 (qualified_name -> name INST simple_name .)
    PLUS_ASSIGN     reduce using rule 124 (qualified_name -> name INST simple_name .)
    MINUS_ASSIGN    reduce using rule 124 (qualified_name -> name INST simple_name .)
    LSHIFT_ASSIGN   reduce using rule 124 (qualified_name -> name INST simple_name .)
    RSHIFT_ASSIGN   reduce using rule 124 (qualified_name -> name INST simple_name .)
    AND_ASSIGN      reduce using rule 124 (qualified_name -> name INST simple_name .)
    OR_ASSIGN       reduce using rule 124 (qualified_name -> name INST simple_name .)
    XOR_ASSIGN      reduce using rule 124 (qualified_name -> name INST simple_name .)


state 188

    (89) argument_list_opt -> argument_list .
    (92) argument_list -> argument_list . COMMA expression

    RPAREN          reduce using rule 89 (argument_list_opt -> argument_list .)
    COMMA           shift and go to state 231


state 189

    (90) argument_list_opt -> empty .

    RPAREN          reduce using rule 90 (argument_list_opt -> empty .)


state 190

    (88) method_invocation -> name LPAREN argument_list_opt . RPAREN

    RPAREN          shift and go to state 232


state 191

    (91) argument_list -> expression .

    COMMA           reduce using rule 91 (argument_list -> expression .)
    RPAREN          reduce using rule 91 (argument_list -> expression .)


state 192

    (44) conditional_or_expression -> conditional_or_expression OR marker . conditional_and_expression
    (45) conditional_and_expression -> . inclusive_or_expression
    (46) conditional_and_expression -> . conditional_and_expression AND marker inclusive_or_expression
    (47) inclusive_or_expression -> . exclusive_or_expression
    (48) inclusive_or_expression -> . inclusive_or_expression OR_BITWISE exclusive_or_expression
    (49) exclusive_or_expression -> . and_expression
    (50) exclusive_or_expression -> . exclusive_or_expression XOR and_expression
    (51) and_expression -> . equality_expression
    (52) and_expression -> . and_expression AND_BITWISE equality_expression
    (53) equality_expression -> . relational_expression
    (54) equality_expression -> . equality_expression EQUAL relational_expression
    (55) equality_expression -> . equality_expression NEQUAL relational_expression
    (56) relational_expression -> . shift_expression
    (57) relational_expression -> . relational_expression GREATER shift_expression
    (58) relational_expression -> . relational_expression LESS shift_expression
    (59) relational_expression -> . relational_expression GEQ shift_expression
    (60) relational_expression -> . relational_expression LEQ shift_expression
    (61) shift_expression -> . additive_expression
    (62) shift_expression -> . shift_expression LSHIFT additive_expression
    (63) shift_expression -> . shift_expression RSHIFT additive_expression
    (64) additive_expression -> . multiplicative_expression
    (65) additive_expression -> . additive_expression PLUS multiplicative_expression
    (66) additive_expression -> . additive_expression MINUS multiplicative_expression
    (67) multiplicative_expression -> . unary_expression
    (68) multiplicative_expression -> . multiplicative_expression TIMES unary_expression
    (69) multiplicative_expression -> . multiplicative_expression DIVIDE unary_expression
    (70) multiplicative_expression -> . multiplicative_expression REMAINDER unary_expression
    (71) unary_expression -> . PLUS unary_expression
    (72) unary_expression -> . MINUS unary_expression
    (73) unary_expression -> . unary_expression_not_plus_minus
    (74) unary_expression_not_plus_minus -> . base_variable_set
    (75) unary_expression_not_plus_minus -> . TILDA unary_expression
    (76) unary_expression_not_plus_minus -> . NOT unary_expression
    (77) base_variable_set -> . variable_literal
    (78) base_variable_set -> . LPAREN expression RPAREN
    (79) variable_literal -> . valid_variable
    (80) variable_literal -> . primary
    (26) valid_variable -> . name
    (27) valid_variable -> . array_access
    (81) primary -> . literal
    (82) primary -> . method_invocation
    (121) name -> . simple_name
    (122) name -> . qualified_name
    (28) array_access -> . name dimension
    (83) literal -> . int_float
    (84) literal -> . c_literal
    (88) method_invocation -> . name LPAREN argument_list_opt RPAREN
    (123) simple_name -> . IDENTIFIER
    (124) qualified_name -> . name INST simple_name
    (87) int_float -> . INT_NUMBER
    (85) c_literal -> . BOOL_CONSTT
    (86) c_literal -> . BOOL_CONSTF

    PLUS            shift and go to state 30
    MINUS           shift and go to state 24
    TILDA           shift and go to state 65
    NOT             shift and go to state 52
    LPAREN          shift and go to state 86
    IDENTIFIER      shift and go to state 9
    INT_NUMBER      shift and go to state 38
    BOOL_CONSTT     shift and go to state 29
    BOOL_CONSTF     shift and go to state 25

    unary_expression               shift and go to state 39
    exclusive_or_expression        shift and go to state 56
    primary                        shift and go to state 57
    unary_expression_not_plus_minus shift and go to state 40
    array_access                   shift and go to state 23
    additive_expression            shift and go to state 59
    simple_name                    shift and go to state 60
    c_literal                      shift and go to state 85
    base_variable_set              shift and go to state 80
    valid_variable                 shift and go to state 101
    inclusive_or_expression        shift and go to state 27
    literal                        shift and go to state 64
    and_expression                 shift and go to state 79
    method_invocation              shift and go to state 102
    relational_expression          shift and go to state 66
    qualified_name                 shift and go to state 71
    multiplicative_expression      shift and go to state 45
    shift_expression               shift and go to state 49
    equality_expression            shift and go to state 74
    int_float                      shift and go to state 34
    variable_literal               shift and go to state 50
    name                           shift and go to state 103
    conditional_and_expression     shift and go to state 233

state 193

    (147) while_statement -> KEYWORD_WHILE LPAREN marker . expression RPAREN marker block
    (19) expression -> . assignment_expression
    (22) assignment_expression -> . assignment
    (23) assignment_expression -> . conditional_or_expression
    (24) assignment_expression -> . method_invocation
    (25) assignment -> . valid_variable assignment_operator assignment_expression
    (43) conditional_or_expression -> . conditional_and_expression
    (44) conditional_or_expression -> . conditional_or_expression OR marker conditional_and_expression
    (88) method_invocation -> . name LPAREN argument_list_opt RPAREN
    (26) valid_variable -> . name
    (27) valid_variable -> . array_access
    (45) conditional_and_expression -> . inclusive_or_expression
    (46) conditional_and_expression -> . conditional_and_expression AND marker inclusive_or_expression
    (121) name -> . simple_name
    (122) name -> . qualified_name
    (28) array_access -> . name dimension
    (47) inclusive_or_expression -> . exclusive_or_expression
    (48) inclusive_or_expression -> . inclusive_or_expression OR_BITWISE exclusive_or_expression
    (123) simple_name -> . IDENTIFIER
    (124) qualified_name -> . name INST simple_name
    (49) exclusive_or_expression -> . and_expression
    (50) exclusive_or_expression -> . exclusive_or_expression XOR and_expression
    (51) and_expression -> . equality_expression
    (52) and_expression -> . and_expression AND_BITWISE equality_expression
    (53) equality_expression -> . relational_expression
    (54) equality_expression -> . equality_expression EQUAL relational_expression
    (55) equality_expression -> . equality_expression NEQUAL relational_expression
    (56) relational_expression -> . shift_expression
    (57) relational_expression -> . relational_expression GREATER shift_expression
    (58) relational_expression -> . relational_expression LESS shift_expression
    (59) relational_expression -> . relational_expression GEQ shift_expression
    (60) relational_expression -> . relational_expression LEQ shift_expression
    (61) shift_expression -> . additive_expression
    (62) shift_expression -> . shift_expression LSHIFT additive_expression
    (63) shift_expression -> . shift_expression RSHIFT additive_expression
    (64) additive_expression -> . multiplicative_expression
    (65) additive_expression -> . additive_expression PLUS multiplicative_expression
    (66) additive_expression -> . additive_expression MINUS multiplicative_expression
    (67) multiplicative_expression -> . unary_expression
    (68) multiplicative_expression -> . multiplicative_expression TIMES unary_expression
    (69) multiplicative_expression -> . multiplicative_expression DIVIDE unary_expression
    (70) multiplicative_expression -> . multiplicative_expression REMAINDER unary_expression
    (71) unary_expression -> . PLUS unary_expression
    (72) unary_expression -> . MINUS unary_expression
    (73) unary_expression -> . unary_expression_not_plus_minus
    (74) unary_expression_not_plus_minus -> . base_variable_set
    (75) unary_expression_not_plus_minus -> . TILDA unary_expression
    (76) unary_expression_not_plus_minus -> . NOT unary_expression
    (77) base_variable_set -> . variable_literal
    (78) base_variable_set -> . LPAREN expression RPAREN
    (79) variable_literal -> . valid_variable
    (80) variable_literal -> . primary
    (81) primary -> . literal
    (82) primary -> . method_invocation
    (83) literal -> . int_float
    (84) literal -> . c_literal
    (87) int_float -> . INT_NUMBER
    (85) c_literal -> . BOOL_CONSTT
    (86) c_literal -> . BOOL_CONSTF

    IDENTIFIER      shift and go to state 9
    PLUS            shift and go to state 30
    MINUS           shift and go to state 24
    TILDA           shift and go to state 65
    NOT             shift and go to state 52
    LPAREN          shift and go to state 86
    INT_NUMBER      shift and go to state 38
    BOOL_CONSTT     shift and go to state 29
    BOOL_CONSTF     shift and go to state 25

    unary_expression               shift and go to state 39
    exclusive_or_expression        shift and go to state 56
    primary                        shift and go to state 57
    unary_expression_not_plus_minus shift and go to state 40
    array_access                   shift and go to state 23
    and_expression                 shift and go to state 79
    simple_name                    shift and go to state 60
    c_literal                      shift and go to state 85
    base_variable_set              shift and go to state 80
    valid_variable                 shift and go to state 87
    inclusive_or_expression        shift and go to state 27
    literal                        shift and go to state 64
    relational_expression          shift and go to state 66
    method_invocation              shift and go to state 134
    conditional_or_expression      shift and go to state 42
    assignment_expression          shift and go to state 83
    qualified_name                 shift and go to state 71
    assignment                     shift and go to state 137
    multiplicative_expression      shift and go to state 45
    additive_expression            shift and go to state 59
    shift_expression               shift and go to state 49
    equality_expression            shift and go to state 74
    int_float                      shift and go to state 34
    variable_literal               shift and go to state 50
    name                           shift and go to state 37
    expression                     shift and go to state 234
    conditional_and_expression     shift and go to state 51

state 194

    (70) multiplicative_expression -> multiplicative_expression REMAINDER unary_expression .

    TIMES           reduce using rule 70 (multiplicative_expression -> multiplicative_expression REMAINDER unary_expression .)
    DIVIDE          reduce using rule 70 (multiplicative_expression -> multiplicative_expression REMAINDER unary_expression .)
    REMAINDER       reduce using rule 70 (multiplicative_expression -> multiplicative_expression REMAINDER unary_expression .)
    PLUS            reduce using rule 70 (multiplicative_expression -> multiplicative_expression REMAINDER unary_expression .)
    MINUS           reduce using rule 70 (multiplicative_expression -> multiplicative_expression REMAINDER unary_expression .)
    LSHIFT          reduce using rule 70 (multiplicative_expression -> multiplicative_expression REMAINDER unary_expression .)
    RSHIFT          reduce using rule 70 (multiplicative_expression -> multiplicative_expression REMAINDER unary_expression .)
    GREATER         reduce using rule 70 (multiplicative_expression -> multiplicative_expression REMAINDER unary_expression .)
    LESS            reduce using rule 70 (multiplicative_expression -> multiplicative_expression REMAINDER unary_expression .)
    GEQ             reduce using rule 70 (multiplicative_expression -> multiplicative_expression REMAINDER unary_expression .)
    LEQ             reduce using rule 70 (multiplicative_expression -> multiplicative_expression REMAINDER unary_expression .)
    EQUAL           reduce using rule 70 (multiplicative_expression -> multiplicative_expression REMAINDER unary_expression .)
    NEQUAL          reduce using rule 70 (multiplicative_expression -> multiplicative_expression REMAINDER unary_expression .)
    AND_BITWISE     reduce using rule 70 (multiplicative_expression -> multiplicative_expression REMAINDER unary_expression .)
    XOR             reduce using rule 70 (multiplicative_expression -> multiplicative_expression REMAINDER unary_expression .)
    OR_BITWISE      reduce using rule 70 (multiplicative_expression -> multiplicative_expression REMAINDER unary_expression .)
    AND             reduce using rule 70 (multiplicative_expression -> multiplicative_expression REMAINDER unary_expression .)
    OR              reduce using rule 70 (multiplicative_expression -> multiplicative_expression REMAINDER unary_expression .)
    KEYWORD_MATCH   reduce using rule 70 (multiplicative_expression -> multiplicative_expression REMAINDER unary_expression .)
    TERMINATOR      reduce using rule 70 (multiplicative_expression -> multiplicative_expression REMAINDER unary_expression .)
    RPAREN          reduce using rule 70 (multiplicative_expression -> multiplicative_expression REMAINDER unary_expression .)
    RBRAC           reduce using rule 70 (multiplicative_expression -> multiplicative_expression REMAINDER unary_expression .)
    COMMA           reduce using rule 70 (multiplicative_expression -> multiplicative_expression REMAINDER unary_expression .)
    FUNTYPE         reduce using rule 70 (multiplicative_expression -> multiplicative_expression REMAINDER unary_expression .)
    KEYWORD_UNTIL   reduce using rule 70 (multiplicative_expression -> multiplicative_expression REMAINDER unary_expression .)
    KEYWORD_TO      reduce using rule 70 (multiplicative_expression -> multiplicative_expression REMAINDER unary_expression .)
    KEYWORD_BY      reduce using rule 70 (multiplicative_expression -> multiplicative_expression REMAINDER unary_expression .)


state 195

    (69) multiplicative_expression -> multiplicative_expression DIVIDE unary_expression .

    TIMES           reduce using rule 69 (multiplicative_expression -> multiplicative_expression DIVIDE unary_expression .)
    DIVIDE          reduce using rule 69 (multiplicative_expression -> multiplicative_expression DIVIDE unary_expression .)
    REMAINDER       reduce using rule 69 (multiplicative_expression -> multiplicative_expression DIVIDE unary_expression .)
    PLUS            reduce using rule 69 (multiplicative_expression -> multiplicative_expression DIVIDE unary_expression .)
    MINUS           reduce using rule 69 (multiplicative_expression -> multiplicative_expression DIVIDE unary_expression .)
    LSHIFT          reduce using rule 69 (multiplicative_expression -> multiplicative_expression DIVIDE unary_expression .)
    RSHIFT          reduce using rule 69 (multiplicative_expression -> multiplicative_expression DIVIDE unary_expression .)
    GREATER         reduce using rule 69 (multiplicative_expression -> multiplicative_expression DIVIDE unary_expression .)
    LESS            reduce using rule 69 (multiplicative_expression -> multiplicative_expression DIVIDE unary_expression .)
    GEQ             reduce using rule 69 (multiplicative_expression -> multiplicative_expression DIVIDE unary_expression .)
    LEQ             reduce using rule 69 (multiplicative_expression -> multiplicative_expression DIVIDE unary_expression .)
    EQUAL           reduce using rule 69 (multiplicative_expression -> multiplicative_expression DIVIDE unary_expression .)
    NEQUAL          reduce using rule 69 (multiplicative_expression -> multiplicative_expression DIVIDE unary_expression .)
    AND_BITWISE     reduce using rule 69 (multiplicative_expression -> multiplicative_expression DIVIDE unary_expression .)
    XOR             reduce using rule 69 (multiplicative_expression -> multiplicative_expression DIVIDE unary_expression .)
    OR_BITWISE      reduce using rule 69 (multiplicative_expression -> multiplicative_expression DIVIDE unary_expression .)
    AND             reduce using rule 69 (multiplicative_expression -> multiplicative_expression DIVIDE unary_expression .)
    OR              reduce using rule 69 (multiplicative_expression -> multiplicative_expression DIVIDE unary_expression .)
    KEYWORD_MATCH   reduce using rule 69 (multiplicative_expression -> multiplicative_expression DIVIDE unary_expression .)
    TERMINATOR      reduce using rule 69 (multiplicative_expression -> multiplicative_expression DIVIDE unary_expression .)
    RPAREN          reduce using rule 69 (multiplicative_expression -> multiplicative_expression DIVIDE unary_expression .)
    RBRAC           reduce using rule 69 (multiplicative_expression -> multiplicative_expression DIVIDE unary_expression .)
    COMMA           reduce using rule 69 (multiplicative_expression -> multiplicative_expression DIVIDE unary_expression .)
    FUNTYPE         reduce using rule 69 (multiplicative_expression -> multiplicative_expression DIVIDE unary_expression .)
    KEYWORD_UNTIL   reduce using rule 69 (multiplicative_expression -> multiplicative_expression DIVIDE unary_expression .)
    KEYWORD_TO      reduce using rule 69 (multiplicative_expression -> multiplicative_expression DIVIDE unary_expression .)
    KEYWORD_BY      reduce using rule 69 (multiplicative_expression -> multiplicative_expression DIVIDE unary_expression .)


state 196

    (68) multiplicative_expression -> multiplicative_expression TIMES unary_expression .

    TIMES           reduce using rule 68 (multiplicative_expression -> multiplicative_expression TIMES unary_expression .)
    DIVIDE          reduce using rule 68 (multiplicative_expression -> multiplicative_expression TIMES unary_expression .)
    REMAINDER       reduce using rule 68 (multiplicative_expression -> multiplicative_expression TIMES unary_expression .)
    PLUS            reduce using rule 68 (multiplicative_expression -> multiplicative_expression TIMES unary_expression .)
    MINUS           reduce using rule 68 (multiplicative_expression -> multiplicative_expression TIMES unary_expression .)
    LSHIFT          reduce using rule 68 (multiplicative_expression -> multiplicative_expression TIMES unary_expression .)
    RSHIFT          reduce using rule 68 (multiplicative_expression -> multiplicative_expression TIMES unary_expression .)
    GREATER         reduce using rule 68 (multiplicative_expression -> multiplicative_expression TIMES unary_expression .)
    LESS            reduce using rule 68 (multiplicative_expression -> multiplicative_expression TIMES unary_expression .)
    GEQ             reduce using rule 68 (multiplicative_expression -> multiplicative_expression TIMES unary_expression .)
    LEQ             reduce using rule 68 (multiplicative_expression -> multiplicative_expression TIMES unary_expression .)
    EQUAL           reduce using rule 68 (multiplicative_expression -> multiplicative_expression TIMES unary_expression .)
    NEQUAL          reduce using rule 68 (multiplicative_expression -> multiplicative_expression TIMES unary_expression .)
    AND_BITWISE     reduce using rule 68 (multiplicative_expression -> multiplicative_expression TIMES unary_expression .)
    XOR             reduce using rule 68 (multiplicative_expression -> multiplicative_expression TIMES unary_expression .)
    OR_BITWISE      reduce using rule 68 (multiplicative_expression -> multiplicative_expression TIMES unary_expression .)
    AND             reduce using rule 68 (multiplicative_expression -> multiplicative_expression TIMES unary_expression .)
    OR              reduce using rule 68 (multiplicative_expression -> multiplicative_expression TIMES unary_expression .)
    KEYWORD_MATCH   reduce using rule 68 (multiplicative_expression -> multiplicative_expression TIMES unary_expression .)
    TERMINATOR      reduce using rule 68 (multiplicative_expression -> multiplicative_expression TIMES unary_expression .)
    RPAREN          reduce using rule 68 (multiplicative_expression -> multiplicative_expression TIMES unary_expression .)
    RBRAC           reduce using rule 68 (multiplicative_expression -> multiplicative_expression TIMES unary_expression .)
    COMMA           reduce using rule 68 (multiplicative_expression -> multiplicative_expression TIMES unary_expression .)
    FUNTYPE         reduce using rule 68 (multiplicative_expression -> multiplicative_expression TIMES unary_expression .)
    KEYWORD_UNTIL   reduce using rule 68 (multiplicative_expression -> multiplicative_expression TIMES unary_expression .)
    KEYWORD_TO      reduce using rule 68 (multiplicative_expression -> multiplicative_expression TIMES unary_expression .)
    KEYWORD_BY      reduce using rule 68 (multiplicative_expression -> multiplicative_expression TIMES unary_expression .)


state 197

    (63) shift_expression -> shift_expression RSHIFT additive_expression .
    (65) additive_expression -> additive_expression . PLUS multiplicative_expression
    (66) additive_expression -> additive_expression . MINUS multiplicative_expression

    LSHIFT          reduce using rule 63 (shift_expression -> shift_expression RSHIFT additive_expression .)
    RSHIFT          reduce using rule 63 (shift_expression -> shift_expression RSHIFT additive_expression .)
    GREATER         reduce using rule 63 (shift_expression -> shift_expression RSHIFT additive_expression .)
    LESS            reduce using rule 63 (shift_expression -> shift_expression RSHIFT additive_expression .)
    GEQ             reduce using rule 63 (shift_expression -> shift_expression RSHIFT additive_expression .)
    LEQ             reduce using rule 63 (shift_expression -> shift_expression RSHIFT additive_expression .)
    EQUAL           reduce using rule 63 (shift_expression -> shift_expression RSHIFT additive_expression .)
    NEQUAL          reduce using rule 63 (shift_expression -> shift_expression RSHIFT additive_expression .)
    AND_BITWISE     reduce using rule 63 (shift_expression -> shift_expression RSHIFT additive_expression .)
    XOR             reduce using rule 63 (shift_expression -> shift_expression RSHIFT additive_expression .)
    OR_BITWISE      reduce using rule 63 (shift_expression -> shift_expression RSHIFT additive_expression .)
    AND             reduce using rule 63 (shift_expression -> shift_expression RSHIFT additive_expression .)
    OR              reduce using rule 63 (shift_expression -> shift_expression RSHIFT additive_expression .)
    KEYWORD_MATCH   reduce using rule 63 (shift_expression -> shift_expression RSHIFT additive_expression .)
    RPAREN          reduce using rule 63 (shift_expression -> shift_expression RSHIFT additive_expression .)
    KEYWORD_UNTIL   reduce using rule 63 (shift_expression -> shift_expression RSHIFT additive_expression .)
    KEYWORD_TO      reduce using rule 63 (shift_expression -> shift_expression RSHIFT additive_expression .)
    TERMINATOR      reduce using rule 63 (shift_expression -> shift_expression RSHIFT additive_expression .)
    RBRAC           reduce using rule 63 (shift_expression -> shift_expression RSHIFT additive_expression .)
    COMMA           reduce using rule 63 (shift_expression -> shift_expression RSHIFT additive_expression .)
    FUNTYPE         reduce using rule 63 (shift_expression -> shift_expression RSHIFT additive_expression .)
    KEYWORD_BY      reduce using rule 63 (shift_expression -> shift_expression RSHIFT additive_expression .)
    PLUS            shift and go to state 132
    MINUS           shift and go to state 133


state 198

    (62) shift_expression -> shift_expression LSHIFT additive_expression .
    (65) additive_expression -> additive_expression . PLUS multiplicative_expression
    (66) additive_expression -> additive_expression . MINUS multiplicative_expression

    LSHIFT          reduce using rule 62 (shift_expression -> shift_expression LSHIFT additive_expression .)
    RSHIFT          reduce using rule 62 (shift_expression -> shift_expression LSHIFT additive_expression .)
    GREATER         reduce using rule 62 (shift_expression -> shift_expression LSHIFT additive_expression .)
    LESS            reduce using rule 62 (shift_expression -> shift_expression LSHIFT additive_expression .)
    GEQ             reduce using rule 62 (shift_expression -> shift_expression LSHIFT additive_expression .)
    LEQ             reduce using rule 62 (shift_expression -> shift_expression LSHIFT additive_expression .)
    EQUAL           reduce using rule 62 (shift_expression -> shift_expression LSHIFT additive_expression .)
    NEQUAL          reduce using rule 62 (shift_expression -> shift_expression LSHIFT additive_expression .)
    AND_BITWISE     reduce using rule 62 (shift_expression -> shift_expression LSHIFT additive_expression .)
    XOR             reduce using rule 62 (shift_expression -> shift_expression LSHIFT additive_expression .)
    OR_BITWISE      reduce using rule 62 (shift_expression -> shift_expression LSHIFT additive_expression .)
    AND             reduce using rule 62 (shift_expression -> shift_expression LSHIFT additive_expression .)
    OR              reduce using rule 62 (shift_expression -> shift_expression LSHIFT additive_expression .)
    KEYWORD_MATCH   reduce using rule 62 (shift_expression -> shift_expression LSHIFT additive_expression .)
    RPAREN          reduce using rule 62 (shift_expression -> shift_expression LSHIFT additive_expression .)
    KEYWORD_UNTIL   reduce using rule 62 (shift_expression -> shift_expression LSHIFT additive_expression .)
    KEYWORD_TO      reduce using rule 62 (shift_expression -> shift_expression LSHIFT additive_expression .)
    TERMINATOR      reduce using rule 62 (shift_expression -> shift_expression LSHIFT additive_expression .)
    RBRAC           reduce using rule 62 (shift_expression -> shift_expression LSHIFT additive_expression .)
    COMMA           reduce using rule 62 (shift_expression -> shift_expression LSHIFT additive_expression .)
    FUNTYPE         reduce using rule 62 (shift_expression -> shift_expression LSHIFT additive_expression .)
    KEYWORD_BY      reduce using rule 62 (shift_expression -> shift_expression LSHIFT additive_expression .)
    PLUS            shift and go to state 132
    MINUS           shift and go to state 133


state 199

    (46) conditional_and_expression -> conditional_and_expression AND marker . inclusive_or_expression
    (47) inclusive_or_expression -> . exclusive_or_expression
    (48) inclusive_or_expression -> . inclusive_or_expression OR_BITWISE exclusive_or_expression
    (49) exclusive_or_expression -> . and_expression
    (50) exclusive_or_expression -> . exclusive_or_expression XOR and_expression
    (51) and_expression -> . equality_expression
    (52) and_expression -> . and_expression AND_BITWISE equality_expression
    (53) equality_expression -> . relational_expression
    (54) equality_expression -> . equality_expression EQUAL relational_expression
    (55) equality_expression -> . equality_expression NEQUAL relational_expression
    (56) relational_expression -> . shift_expression
    (57) relational_expression -> . relational_expression GREATER shift_expression
    (58) relational_expression -> . relational_expression LESS shift_expression
    (59) relational_expression -> . relational_expression GEQ shift_expression
    (60) relational_expression -> . relational_expression LEQ shift_expression
    (61) shift_expression -> . additive_expression
    (62) shift_expression -> . shift_expression LSHIFT additive_expression
    (63) shift_expression -> . shift_expression RSHIFT additive_expression
    (64) additive_expression -> . multiplicative_expression
    (65) additive_expression -> . additive_expression PLUS multiplicative_expression
    (66) additive_expression -> . additive_expression MINUS multiplicative_expression
    (67) multiplicative_expression -> . unary_expression
    (68) multiplicative_expression -> . multiplicative_expression TIMES unary_expression
    (69) multiplicative_expression -> . multiplicative_expression DIVIDE unary_expression
    (70) multiplicative_expression -> . multiplicative_expression REMAINDER unary_expression
    (71) unary_expression -> . PLUS unary_expression
    (72) unary_expression -> . MINUS unary_expression
    (73) unary_expression -> . unary_expression_not_plus_minus
    (74) unary_expression_not_plus_minus -> . base_variable_set
    (75) unary_expression_not_plus_minus -> . TILDA unary_expression
    (76) unary_expression_not_plus_minus -> . NOT unary_expression
    (77) base_variable_set -> . variable_literal
    (78) base_variable_set -> . LPAREN expression RPAREN
    (79) variable_literal -> . valid_variable
    (80) variable_literal -> . primary
    (26) valid_variable -> . name
    (27) valid_variable -> . array_access
    (81) primary -> . literal
    (82) primary -> . method_invocation
    (121) name -> . simple_name
    (122) name -> . qualified_name
    (28) array_access -> . name dimension
    (83) literal -> . int_float
    (84) literal -> . c_literal
    (88) method_invocation -> . name LPAREN argument_list_opt RPAREN
    (123) simple_name -> . IDENTIFIER
    (124) qualified_name -> . name INST simple_name
    (87) int_float -> . INT_NUMBER
    (85) c_literal -> . BOOL_CONSTT
    (86) c_literal -> . BOOL_CONSTF

    PLUS            shift and go to state 30
    MINUS           shift and go to state 24
    TILDA           shift and go to state 65
    NOT             shift and go to state 52
    LPAREN          shift and go to state 86
    IDENTIFIER      shift and go to state 9
    INT_NUMBER      shift and go to state 38
    BOOL_CONSTT     shift and go to state 29
    BOOL_CONSTF     shift and go to state 25

    unary_expression               shift and go to state 39
    exclusive_or_expression        shift and go to state 56
    primary                        shift and go to state 57
    unary_expression_not_plus_minus shift and go to state 40
    array_access                   shift and go to state 23
    additive_expression            shift and go to state 59
    simple_name                    shift and go to state 60
    c_literal                      shift and go to state 85
    base_variable_set              shift and go to state 80
    valid_variable                 shift and go to state 101
    inclusive_or_expression        shift and go to state 235
    literal                        shift and go to state 64
    and_expression                 shift and go to state 79
    method_invocation              shift and go to state 102
    relational_expression          shift and go to state 66
    qualified_name                 shift and go to state 71
    multiplicative_expression      shift and go to state 45
    shift_expression               shift and go to state 49
    equality_expression            shift and go to state 74
    int_float                      shift and go to state 34
    variable_literal               shift and go to state 50
    name                           shift and go to state 103

state 200

    (157) switch_block -> BLOCKBEGIN . BLOCKEND
    (158) switch_block -> BLOCKBEGIN . switch_block_statements BLOCKEND
    (159) switch_block_statements -> . switch_block_statement marker
    (160) switch_block_statements -> . switch_block_statements switch_block_statement marker
    (161) switch_block_statement -> . switch_label narker marker block narker
    (162) switch_label -> . KEYWORD_CASE expression FUNTYPE

    BLOCKEND        shift and go to state 238
    KEYWORD_CASE    shift and go to state 237

    switch_block_statement         shift and go to state 240
    switch_label                   shift and go to state 236
    switch_block_statements        shift and go to state 239

state 201

    (156) switch_statement -> expression KEYWORD_MATCH switch_block . marker
    (41) marker -> . empty
    (191) empty -> .

    KEYWORD_IF      reduce using rule 191 (empty -> .)
    KEYWORD_WHILE   reduce using rule 191 (empty -> .)
    KEYWORD_DO      reduce using rule 191 (empty -> .)
    KEYWORD_FOR     reduce using rule 191 (empty -> .)
    KEYWORD_CLASS   reduce using rule 191 (empty -> .)
    KEYWORD_OBJECT  reduce using rule 191 (empty -> .)
    KEYWORD_VAR     reduce using rule 191 (empty -> .)
    KEYWORD_VAL     reduce using rule 191 (empty -> .)
    TERMINATOR      reduce using rule 191 (empty -> .)
    KEYWORD_RETURN  reduce using rule 191 (empty -> .)
    KEYWORD_DEF     reduce using rule 191 (empty -> .)
    BLOCKBEGIN      reduce using rule 191 (empty -> .)
    IDENTIFIER      reduce using rule 191 (empty -> .)
    PLUS            reduce using rule 191 (empty -> .)
    MINUS           reduce using rule 191 (empty -> .)
    TILDA           reduce using rule 191 (empty -> .)
    NOT             reduce using rule 191 (empty -> .)
    LPAREN          reduce using rule 191 (empty -> .)
    INT_NUMBER      reduce using rule 191 (empty -> .)
    BOOL_CONSTT     reduce using rule 191 (empty -> .)
    BOOL_CONSTF     reduce using rule 191 (empty -> .)
    BLOCKEND        reduce using rule 191 (empty -> .)
    KEYWORD_ELSE    reduce using rule 191 (empty -> .)

    marker                         shift and go to state 241
    empty                          shift and go to state 99

state 202

    (50) exclusive_or_expression -> exclusive_or_expression XOR and_expression .
    (52) and_expression -> and_expression . AND_BITWISE equality_expression

    XOR             reduce using rule 50 (exclusive_or_expression -> exclusive_or_expression XOR and_expression .)
    OR_BITWISE      reduce using rule 50 (exclusive_or_expression -> exclusive_or_expression XOR and_expression .)
    AND             reduce using rule 50 (exclusive_or_expression -> exclusive_or_expression XOR and_expression .)
    OR              reduce using rule 50 (exclusive_or_expression -> exclusive_or_expression XOR and_expression .)
    TERMINATOR      reduce using rule 50 (exclusive_or_expression -> exclusive_or_expression XOR and_expression .)
    KEYWORD_MATCH   reduce using rule 50 (exclusive_or_expression -> exclusive_or_expression XOR and_expression .)
    RPAREN          reduce using rule 50 (exclusive_or_expression -> exclusive_or_expression XOR and_expression .)
    RBRAC           reduce using rule 50 (exclusive_or_expression -> exclusive_or_expression XOR and_expression .)
    COMMA           reduce using rule 50 (exclusive_or_expression -> exclusive_or_expression XOR and_expression .)
    FUNTYPE         reduce using rule 50 (exclusive_or_expression -> exclusive_or_expression XOR and_expression .)
    KEYWORD_UNTIL   reduce using rule 50 (exclusive_or_expression -> exclusive_or_expression XOR and_expression .)
    KEYWORD_TO      reduce using rule 50 (exclusive_or_expression -> exclusive_or_expression XOR and_expression .)
    KEYWORD_BY      reduce using rule 50 (exclusive_or_expression -> exclusive_or_expression XOR and_expression .)
    AND_BITWISE     shift and go to state 157


state 203

    (65) additive_expression -> additive_expression PLUS multiplicative_expression .
    (68) multiplicative_expression -> multiplicative_expression . TIMES unary_expression
    (69) multiplicative_expression -> multiplicative_expression . DIVIDE unary_expression
    (70) multiplicative_expression -> multiplicative_expression . REMAINDER unary_expression

    PLUS            reduce using rule 65 (additive_expression -> additive_expression PLUS multiplicative_expression .)
    MINUS           reduce using rule 65 (additive_expression -> additive_expression PLUS multiplicative_expression .)
    LSHIFT          reduce using rule 65 (additive_expression -> additive_expression PLUS multiplicative_expression .)
    RSHIFT          reduce using rule 65 (additive_expression -> additive_expression PLUS multiplicative_expression .)
    GREATER         reduce using rule 65 (additive_expression -> additive_expression PLUS multiplicative_expression .)
    LESS            reduce using rule 65 (additive_expression -> additive_expression PLUS multiplicative_expression .)
    GEQ             reduce using rule 65 (additive_expression -> additive_expression PLUS multiplicative_expression .)
    LEQ             reduce using rule 65 (additive_expression -> additive_expression PLUS multiplicative_expression .)
    EQUAL           reduce using rule 65 (additive_expression -> additive_expression PLUS multiplicative_expression .)
    NEQUAL          reduce using rule 65 (additive_expression -> additive_expression PLUS multiplicative_expression .)
    AND_BITWISE     reduce using rule 65 (additive_expression -> additive_expression PLUS multiplicative_expression .)
    XOR             reduce using rule 65 (additive_expression -> additive_expression PLUS multiplicative_expression .)
    OR_BITWISE      reduce using rule 65 (additive_expression -> additive_expression PLUS multiplicative_expression .)
    AND             reduce using rule 65 (additive_expression -> additive_expression PLUS multiplicative_expression .)
    OR              reduce using rule 65 (additive_expression -> additive_expression PLUS multiplicative_expression .)
    KEYWORD_MATCH   reduce using rule 65 (additive_expression -> additive_expression PLUS multiplicative_expression .)
    TERMINATOR      reduce using rule 65 (additive_expression -> additive_expression PLUS multiplicative_expression .)
    RPAREN          reduce using rule 65 (additive_expression -> additive_expression PLUS multiplicative_expression .)
    RBRAC           reduce using rule 65 (additive_expression -> additive_expression PLUS multiplicative_expression .)
    COMMA           reduce using rule 65 (additive_expression -> additive_expression PLUS multiplicative_expression .)
    FUNTYPE         reduce using rule 65 (additive_expression -> additive_expression PLUS multiplicative_expression .)
    KEYWORD_UNTIL   reduce using rule 65 (additive_expression -> additive_expression PLUS multiplicative_expression .)
    KEYWORD_TO      reduce using rule 65 (additive_expression -> additive_expression PLUS multiplicative_expression .)
    KEYWORD_BY      reduce using rule 65 (additive_expression -> additive_expression PLUS multiplicative_expression .)
    TIMES           shift and go to state 122
    DIVIDE          shift and go to state 121
    REMAINDER       shift and go to state 120


state 204

    (66) additive_expression -> additive_expression MINUS multiplicative_expression .
    (68) multiplicative_expression -> multiplicative_expression . TIMES unary_expression
    (69) multiplicative_expression -> multiplicative_expression . DIVIDE unary_expression
    (70) multiplicative_expression -> multiplicative_expression . REMAINDER unary_expression

    PLUS            reduce using rule 66 (additive_expression -> additive_expression MINUS multiplicative_expression .)
    MINUS           reduce using rule 66 (additive_expression -> additive_expression MINUS multiplicative_expression .)
    LSHIFT          reduce using rule 66 (additive_expression -> additive_expression MINUS multiplicative_expression .)
    RSHIFT          reduce using rule 66 (additive_expression -> additive_expression MINUS multiplicative_expression .)
    GREATER         reduce using rule 66 (additive_expression -> additive_expression MINUS multiplicative_expression .)
    LESS            reduce using rule 66 (additive_expression -> additive_expression MINUS multiplicative_expression .)
    GEQ             reduce using rule 66 (additive_expression -> additive_expression MINUS multiplicative_expression .)
    LEQ             reduce using rule 66 (additive_expression -> additive_expression MINUS multiplicative_expression .)
    EQUAL           reduce using rule 66 (additive_expression -> additive_expression MINUS multiplicative_expression .)
    NEQUAL          reduce using rule 66 (additive_expression -> additive_expression MINUS multiplicative_expression .)
    AND_BITWISE     reduce using rule 66 (additive_expression -> additive_expression MINUS multiplicative_expression .)
    XOR             reduce using rule 66 (additive_expression -> additive_expression MINUS multiplicative_expression .)
    OR_BITWISE      reduce using rule 66 (additive_expression -> additive_expression MINUS multiplicative_expression .)
    AND             reduce using rule 66 (additive_expression -> additive_expression MINUS multiplicative_expression .)
    OR              reduce using rule 66 (additive_expression -> additive_expression MINUS multiplicative_expression .)
    KEYWORD_MATCH   reduce using rule 66 (additive_expression -> additive_expression MINUS multiplicative_expression .)
    TERMINATOR      reduce using rule 66 (additive_expression -> additive_expression MINUS multiplicative_expression .)
    RPAREN          reduce using rule 66 (additive_expression -> additive_expression MINUS multiplicative_expression .)
    RBRAC           reduce using rule 66 (additive_expression -> additive_expression MINUS multiplicative_expression .)
    COMMA           reduce using rule 66 (additive_expression -> additive_expression MINUS multiplicative_expression .)
    FUNTYPE         reduce using rule 66 (additive_expression -> additive_expression MINUS multiplicative_expression .)
    KEYWORD_UNTIL   reduce using rule 66 (additive_expression -> additive_expression MINUS multiplicative_expression .)
    KEYWORD_TO      reduce using rule 66 (additive_expression -> additive_expression MINUS multiplicative_expression .)
    KEYWORD_BY      reduce using rule 66 (additive_expression -> additive_expression MINUS multiplicative_expression .)
    TIMES           shift and go to state 122
    DIVIDE          shift and go to state 121
    REMAINDER       shift and go to state 120


state 205

    (164) return_statement -> KEYWORD_RETURN expression_optional TERMINATOR .

    KEYWORD_IF      reduce using rule 164 (return_statement -> KEYWORD_RETURN expression_optional TERMINATOR .)
    KEYWORD_WHILE   reduce using rule 164 (return_statement -> KEYWORD_RETURN expression_optional TERMINATOR .)
    KEYWORD_DO      reduce using rule 164 (return_statement -> KEYWORD_RETURN expression_optional TERMINATOR .)
    KEYWORD_FOR     reduce using rule 164 (return_statement -> KEYWORD_RETURN expression_optional TERMINATOR .)
    KEYWORD_CLASS   reduce using rule 164 (return_statement -> KEYWORD_RETURN expression_optional TERMINATOR .)
    KEYWORD_OBJECT  reduce using rule 164 (return_statement -> KEYWORD_RETURN expression_optional TERMINATOR .)
    KEYWORD_VAR     reduce using rule 164 (return_statement -> KEYWORD_RETURN expression_optional TERMINATOR .)
    KEYWORD_VAL     reduce using rule 164 (return_statement -> KEYWORD_RETURN expression_optional TERMINATOR .)
    TERMINATOR      reduce using rule 164 (return_statement -> KEYWORD_RETURN expression_optional TERMINATOR .)
    KEYWORD_RETURN  reduce using rule 164 (return_statement -> KEYWORD_RETURN expression_optional TERMINATOR .)
    KEYWORD_DEF     reduce using rule 164 (return_statement -> KEYWORD_RETURN expression_optional TERMINATOR .)
    BLOCKBEGIN      reduce using rule 164 (return_statement -> KEYWORD_RETURN expression_optional TERMINATOR .)
    IDENTIFIER      reduce using rule 164 (return_statement -> KEYWORD_RETURN expression_optional TERMINATOR .)
    PLUS            reduce using rule 164 (return_statement -> KEYWORD_RETURN expression_optional TERMINATOR .)
    MINUS           reduce using rule 164 (return_statement -> KEYWORD_RETURN expression_optional TERMINATOR .)
    TILDA           reduce using rule 164 (return_statement -> KEYWORD_RETURN expression_optional TERMINATOR .)
    NOT             reduce using rule 164 (return_statement -> KEYWORD_RETURN expression_optional TERMINATOR .)
    LPAREN          reduce using rule 164 (return_statement -> KEYWORD_RETURN expression_optional TERMINATOR .)
    INT_NUMBER      reduce using rule 164 (return_statement -> KEYWORD_RETURN expression_optional TERMINATOR .)
    BOOL_CONSTT     reduce using rule 164 (return_statement -> KEYWORD_RETURN expression_optional TERMINATOR .)
    BOOL_CONSTF     reduce using rule 164 (return_statement -> KEYWORD_RETURN expression_optional TERMINATOR .)
    BLOCKEND        reduce using rule 164 (return_statement -> KEYWORD_RETURN expression_optional TERMINATOR .)
    KEYWORD_ELSE    reduce using rule 164 (return_statement -> KEYWORD_RETURN expression_optional TERMINATOR .)


state 206

    (59) relational_expression -> relational_expression GEQ shift_expression .
    (62) shift_expression -> shift_expression . LSHIFT additive_expression
    (63) shift_expression -> shift_expression . RSHIFT additive_expression

    GREATER         reduce using rule 59 (relational_expression -> relational_expression GEQ shift_expression .)
    LESS            reduce using rule 59 (relational_expression -> relational_expression GEQ shift_expression .)
    GEQ             reduce using rule 59 (relational_expression -> relational_expression GEQ shift_expression .)
    LEQ             reduce using rule 59 (relational_expression -> relational_expression GEQ shift_expression .)
    EQUAL           reduce using rule 59 (relational_expression -> relational_expression GEQ shift_expression .)
    NEQUAL          reduce using rule 59 (relational_expression -> relational_expression GEQ shift_expression .)
    AND_BITWISE     reduce using rule 59 (relational_expression -> relational_expression GEQ shift_expression .)
    XOR             reduce using rule 59 (relational_expression -> relational_expression GEQ shift_expression .)
    OR_BITWISE      reduce using rule 59 (relational_expression -> relational_expression GEQ shift_expression .)
    AND             reduce using rule 59 (relational_expression -> relational_expression GEQ shift_expression .)
    OR              reduce using rule 59 (relational_expression -> relational_expression GEQ shift_expression .)
    RPAREN          reduce using rule 59 (relational_expression -> relational_expression GEQ shift_expression .)
    COMMA           reduce using rule 59 (relational_expression -> relational_expression GEQ shift_expression .)
    KEYWORD_MATCH   reduce using rule 59 (relational_expression -> relational_expression GEQ shift_expression .)
    TERMINATOR      reduce using rule 59 (relational_expression -> relational_expression GEQ shift_expression .)
    RBRAC           reduce using rule 59 (relational_expression -> relational_expression GEQ shift_expression .)
    FUNTYPE         reduce using rule 59 (relational_expression -> relational_expression GEQ shift_expression .)
    KEYWORD_UNTIL   reduce using rule 59 (relational_expression -> relational_expression GEQ shift_expression .)
    KEYWORD_TO      reduce using rule 59 (relational_expression -> relational_expression GEQ shift_expression .)
    KEYWORD_BY      reduce using rule 59 (relational_expression -> relational_expression GEQ shift_expression .)
    LSHIFT          shift and go to state 124
    RSHIFT          shift and go to state 123


state 207

    (57) relational_expression -> relational_expression GREATER shift_expression .
    (62) shift_expression -> shift_expression . LSHIFT additive_expression
    (63) shift_expression -> shift_expression . RSHIFT additive_expression

    GREATER         reduce using rule 57 (relational_expression -> relational_expression GREATER shift_expression .)
    LESS            reduce using rule 57 (relational_expression -> relational_expression GREATER shift_expression .)
    GEQ             reduce using rule 57 (relational_expression -> relational_expression GREATER shift_expression .)
    LEQ             reduce using rule 57 (relational_expression -> relational_expression GREATER shift_expression .)
    EQUAL           reduce using rule 57 (relational_expression -> relational_expression GREATER shift_expression .)
    NEQUAL          reduce using rule 57 (relational_expression -> relational_expression GREATER shift_expression .)
    AND_BITWISE     reduce using rule 57 (relational_expression -> relational_expression GREATER shift_expression .)
    XOR             reduce using rule 57 (relational_expression -> relational_expression GREATER shift_expression .)
    OR_BITWISE      reduce using rule 57 (relational_expression -> relational_expression GREATER shift_expression .)
    AND             reduce using rule 57 (relational_expression -> relational_expression GREATER shift_expression .)
    OR              reduce using rule 57 (relational_expression -> relational_expression GREATER shift_expression .)
    RPAREN          reduce using rule 57 (relational_expression -> relational_expression GREATER shift_expression .)
    COMMA           reduce using rule 57 (relational_expression -> relational_expression GREATER shift_expression .)
    KEYWORD_MATCH   reduce using rule 57 (relational_expression -> relational_expression GREATER shift_expression .)
    TERMINATOR      reduce using rule 57 (relational_expression -> relational_expression GREATER shift_expression .)
    RBRAC           reduce using rule 57 (relational_expression -> relational_expression GREATER shift_expression .)
    FUNTYPE         reduce using rule 57 (relational_expression -> relational_expression GREATER shift_expression .)
    KEYWORD_UNTIL   reduce using rule 57 (relational_expression -> relational_expression GREATER shift_expression .)
    KEYWORD_TO      reduce using rule 57 (relational_expression -> relational_expression GREATER shift_expression .)
    KEYWORD_BY      reduce using rule 57 (relational_expression -> relational_expression GREATER shift_expression .)
    LSHIFT          shift and go to state 124
    RSHIFT          shift and go to state 123


state 208

    (58) relational_expression -> relational_expression LESS shift_expression .
    (62) shift_expression -> shift_expression . LSHIFT additive_expression
    (63) shift_expression -> shift_expression . RSHIFT additive_expression

    GREATER         reduce using rule 58 (relational_expression -> relational_expression LESS shift_expression .)
    LESS            reduce using rule 58 (relational_expression -> relational_expression LESS shift_expression .)
    GEQ             reduce using rule 58 (relational_expression -> relational_expression LESS shift_expression .)
    LEQ             reduce using rule 58 (relational_expression -> relational_expression LESS shift_expression .)
    EQUAL           reduce using rule 58 (relational_expression -> relational_expression LESS shift_expression .)
    NEQUAL          reduce using rule 58 (relational_expression -> relational_expression LESS shift_expression .)
    AND_BITWISE     reduce using rule 58 (relational_expression -> relational_expression LESS shift_expression .)
    XOR             reduce using rule 58 (relational_expression -> relational_expression LESS shift_expression .)
    OR_BITWISE      reduce using rule 58 (relational_expression -> relational_expression LESS shift_expression .)
    AND             reduce using rule 58 (relational_expression -> relational_expression LESS shift_expression .)
    OR              reduce using rule 58 (relational_expression -> relational_expression LESS shift_expression .)
    RPAREN          reduce using rule 58 (relational_expression -> relational_expression LESS shift_expression .)
    COMMA           reduce using rule 58 (relational_expression -> relational_expression LESS shift_expression .)
    KEYWORD_MATCH   reduce using rule 58 (relational_expression -> relational_expression LESS shift_expression .)
    TERMINATOR      reduce using rule 58 (relational_expression -> relational_expression LESS shift_expression .)
    RBRAC           reduce using rule 58 (relational_expression -> relational_expression LESS shift_expression .)
    FUNTYPE         reduce using rule 58 (relational_expression -> relational_expression LESS shift_expression .)
    KEYWORD_UNTIL   reduce using rule 58 (relational_expression -> relational_expression LESS shift_expression .)
    KEYWORD_TO      reduce using rule 58 (relational_expression -> relational_expression LESS shift_expression .)
    KEYWORD_BY      reduce using rule 58 (relational_expression -> relational_expression LESS shift_expression .)
    LSHIFT          shift and go to state 124
    RSHIFT          shift and go to state 123


state 209

    (60) relational_expression -> relational_expression LEQ shift_expression .
    (62) shift_expression -> shift_expression . LSHIFT additive_expression
    (63) shift_expression -> shift_expression . RSHIFT additive_expression

    GREATER         reduce using rule 60 (relational_expression -> relational_expression LEQ shift_expression .)
    LESS            reduce using rule 60 (relational_expression -> relational_expression LEQ shift_expression .)
    GEQ             reduce using rule 60 (relational_expression -> relational_expression LEQ shift_expression .)
    LEQ             reduce using rule 60 (relational_expression -> relational_expression LEQ shift_expression .)
    EQUAL           reduce using rule 60 (relational_expression -> relational_expression LEQ shift_expression .)
    NEQUAL          reduce using rule 60 (relational_expression -> relational_expression LEQ shift_expression .)
    AND_BITWISE     reduce using rule 60 (relational_expression -> relational_expression LEQ shift_expression .)
    XOR             reduce using rule 60 (relational_expression -> relational_expression LEQ shift_expression .)
    OR_BITWISE      reduce using rule 60 (relational_expression -> relational_expression LEQ shift_expression .)
    AND             reduce using rule 60 (relational_expression -> relational_expression LEQ shift_expression .)
    OR              reduce using rule 60 (relational_expression -> relational_expression LEQ shift_expression .)
    RPAREN          reduce using rule 60 (relational_expression -> relational_expression LEQ shift_expression .)
    COMMA           reduce using rule 60 (relational_expression -> relational_expression LEQ shift_expression .)
    KEYWORD_MATCH   reduce using rule 60 (relational_expression -> relational_expression LEQ shift_expression .)
    TERMINATOR      reduce using rule 60 (relational_expression -> relational_expression LEQ shift_expression .)
    RBRAC           reduce using rule 60 (relational_expression -> relational_expression LEQ shift_expression .)
    FUNTYPE         reduce using rule 60 (relational_expression -> relational_expression LEQ shift_expression .)
    KEYWORD_UNTIL   reduce using rule 60 (relational_expression -> relational_expression LEQ shift_expression .)
    KEYWORD_TO      reduce using rule 60 (relational_expression -> relational_expression LEQ shift_expression .)
    KEYWORD_BY      reduce using rule 60 (relational_expression -> relational_expression LEQ shift_expression .)
    LSHIFT          shift and go to state 124
    RSHIFT          shift and go to state 123


state 210

    (102) variable_declaration_body -> identifiers COLON . type ASOP variable_declaration_initializer
    (109) type -> . primitive_type
    (110) type -> . reference_type
    (111) primitive_type -> . TYPE_INT
    (112) primitive_type -> . TYPE_DOUBLE
    (113) primitive_type -> . TYPE_CHAR
    (114) primitive_type -> . TYPE_STRING
    (115) primitive_type -> . TYPE_BOOLEAN
    (116) primitive_type -> . TYPE_VOID
    (117) reference_type -> . class_data_type
    (118) reference_type -> . array_data_type
    (119) class_data_type -> . name
    (120) array_data_type -> . KEYWORD_ARRAY LBRAC TYPE_INT RBRAC
    (121) name -> . simple_name
    (122) name -> . qualified_name
    (123) simple_name -> . IDENTIFIER
    (124) qualified_name -> . name INST simple_name

    TYPE_INT        shift and go to state 242
    TYPE_DOUBLE     shift and go to state 250
    TYPE_CHAR       shift and go to state 251
    TYPE_STRING     shift and go to state 243
    TYPE_BOOLEAN    shift and go to state 249
    TYPE_VOID       shift and go to state 244
    KEYWORD_ARRAY   shift and go to state 254
    IDENTIFIER      shift and go to state 9

    name                           shift and go to state 253
    qualified_name                 shift and go to state 71
    reference_type                 shift and go to state 246
    primitive_type                 shift and go to state 247
    class_data_type                shift and go to state 245
    type                           shift and go to state 248
    array_data_type                shift and go to state 252
    simple_name                    shift and go to state 60

state 211

    (103) identifiers -> identifiers COMMA . IDENTIFIER

    IDENTIFIER      shift and go to state 255


state 212

    (142) if_then_statement -> KEYWORD_IF LPAREN expression . RPAREN marker block
    (143) if_then_else_statement -> KEYWORD_IF LPAREN expression . RPAREN marker if_then_else_intermediate narker KEYWORD_ELSE marker block

    RPAREN          shift and go to state 256


state 213

    (55) equality_expression -> equality_expression NEQUAL relational_expression .
    (57) relational_expression -> relational_expression . GREATER shift_expression
    (58) relational_expression -> relational_expression . LESS shift_expression
    (59) relational_expression -> relational_expression . GEQ shift_expression
    (60) relational_expression -> relational_expression . LEQ shift_expression

    EQUAL           reduce using rule 55 (equality_expression -> equality_expression NEQUAL relational_expression .)
    NEQUAL          reduce using rule 55 (equality_expression -> equality_expression NEQUAL relational_expression .)
    AND_BITWISE     reduce using rule 55 (equality_expression -> equality_expression NEQUAL relational_expression .)
    XOR             reduce using rule 55 (equality_expression -> equality_expression NEQUAL relational_expression .)
    OR_BITWISE      reduce using rule 55 (equality_expression -> equality_expression NEQUAL relational_expression .)
    AND             reduce using rule 55 (equality_expression -> equality_expression NEQUAL relational_expression .)
    OR              reduce using rule 55 (equality_expression -> equality_expression NEQUAL relational_expression .)
    RPAREN          reduce using rule 55 (equality_expression -> equality_expression NEQUAL relational_expression .)
    KEYWORD_MATCH   reduce using rule 55 (equality_expression -> equality_expression NEQUAL relational_expression .)
    TERMINATOR      reduce using rule 55 (equality_expression -> equality_expression NEQUAL relational_expression .)
    RBRAC           reduce using rule 55 (equality_expression -> equality_expression NEQUAL relational_expression .)
    COMMA           reduce using rule 55 (equality_expression -> equality_expression NEQUAL relational_expression .)
    FUNTYPE         reduce using rule 55 (equality_expression -> equality_expression NEQUAL relational_expression .)
    KEYWORD_UNTIL   reduce using rule 55 (equality_expression -> equality_expression NEQUAL relational_expression .)
    KEYWORD_TO      reduce using rule 55 (equality_expression -> equality_expression NEQUAL relational_expression .)
    KEYWORD_BY      reduce using rule 55 (equality_expression -> equality_expression NEQUAL relational_expression .)
    GREATER         shift and go to state 141
    LESS            shift and go to state 142
    GEQ             shift and go to state 140
    LEQ             shift and go to state 143


state 214

    (54) equality_expression -> equality_expression EQUAL relational_expression .
    (57) relational_expression -> relational_expression . GREATER shift_expression
    (58) relational_expression -> relational_expression . LESS shift_expression
    (59) relational_expression -> relational_expression . GEQ shift_expression
    (60) relational_expression -> relational_expression . LEQ shift_expression

    EQUAL           reduce using rule 54 (equality_expression -> equality_expression EQUAL relational_expression .)
    NEQUAL          reduce using rule 54 (equality_expression -> equality_expression EQUAL relational_expression .)
    AND_BITWISE     reduce using rule 54 (equality_expression -> equality_expression EQUAL relational_expression .)
    XOR             reduce using rule 54 (equality_expression -> equality_expression EQUAL relational_expression .)
    OR_BITWISE      reduce using rule 54 (equality_expression -> equality_expression EQUAL relational_expression .)
    AND             reduce using rule 54 (equality_expression -> equality_expression EQUAL relational_expression .)
    OR              reduce using rule 54 (equality_expression -> equality_expression EQUAL relational_expression .)
    RPAREN          reduce using rule 54 (equality_expression -> equality_expression EQUAL relational_expression .)
    KEYWORD_MATCH   reduce using rule 54 (equality_expression -> equality_expression EQUAL relational_expression .)
    TERMINATOR      reduce using rule 54 (equality_expression -> equality_expression EQUAL relational_expression .)
    RBRAC           reduce using rule 54 (equality_expression -> equality_expression EQUAL relational_expression .)
    COMMA           reduce using rule 54 (equality_expression -> equality_expression EQUAL relational_expression .)
    FUNTYPE         reduce using rule 54 (equality_expression -> equality_expression EQUAL relational_expression .)
    KEYWORD_UNTIL   reduce using rule 54 (equality_expression -> equality_expression EQUAL relational_expression .)
    KEYWORD_TO      reduce using rule 54 (equality_expression -> equality_expression EQUAL relational_expression .)
    KEYWORD_BY      reduce using rule 54 (equality_expression -> equality_expression EQUAL relational_expression .)
    GREATER         shift and go to state 141
    LESS            shift and go to state 142
    GEQ             shift and go to state 140
    LEQ             shift and go to state 143


state 215

    (175) method_body -> method_start_scope block_statements_opt . end_scope
    (9) end_scope -> . BLOCKEND

    BLOCKEND        shift and go to state 104

    end_scope                      shift and go to state 257

state 216

    (52) and_expression -> and_expression AND_BITWISE equality_expression .
    (54) equality_expression -> equality_expression . EQUAL relational_expression
    (55) equality_expression -> equality_expression . NEQUAL relational_expression

    AND_BITWISE     reduce using rule 52 (and_expression -> and_expression AND_BITWISE equality_expression .)
    XOR             reduce using rule 52 (and_expression -> and_expression AND_BITWISE equality_expression .)
    OR_BITWISE      reduce using rule 52 (and_expression -> and_expression AND_BITWISE equality_expression .)
    AND             reduce using rule 52 (and_expression -> and_expression AND_BITWISE equality_expression .)
    OR              reduce using rule 52 (and_expression -> and_expression AND_BITWISE equality_expression .)
    KEYWORD_MATCH   reduce using rule 52 (and_expression -> and_expression AND_BITWISE equality_expression .)
    TERMINATOR      reduce using rule 52 (and_expression -> and_expression AND_BITWISE equality_expression .)
    RPAREN          reduce using rule 52 (and_expression -> and_expression AND_BITWISE equality_expression .)
    RBRAC           reduce using rule 52 (and_expression -> and_expression AND_BITWISE equality_expression .)
    COMMA           reduce using rule 52 (and_expression -> and_expression AND_BITWISE equality_expression .)
    FUNTYPE         reduce using rule 52 (and_expression -> and_expression AND_BITWISE equality_expression .)
    KEYWORD_UNTIL   reduce using rule 52 (and_expression -> and_expression AND_BITWISE equality_expression .)
    KEYWORD_TO      reduce using rule 52 (and_expression -> and_expression AND_BITWISE equality_expression .)
    KEYWORD_BY      reduce using rule 52 (and_expression -> and_expression AND_BITWISE equality_expression .)
    EQUAL           shift and go to state 150
    NEQUAL          shift and go to state 149


state 217

    (13) block_statements -> block_statements marker block_statement .

    KEYWORD_IF      reduce using rule 13 (block_statements -> block_statements marker block_statement .)
    KEYWORD_WHILE   reduce using rule 13 (block_statements -> block_statements marker block_statement .)
    KEYWORD_DO      reduce using rule 13 (block_statements -> block_statements marker block_statement .)
    KEYWORD_FOR     reduce using rule 13 (block_statements -> block_statements marker block_statement .)
    KEYWORD_CLASS   reduce using rule 13 (block_statements -> block_statements marker block_statement .)
    KEYWORD_OBJECT  reduce using rule 13 (block_statements -> block_statements marker block_statement .)
    KEYWORD_VAR     reduce using rule 13 (block_statements -> block_statements marker block_statement .)
    KEYWORD_VAL     reduce using rule 13 (block_statements -> block_statements marker block_statement .)
    TERMINATOR      reduce using rule 13 (block_statements -> block_statements marker block_statement .)
    KEYWORD_RETURN  reduce using rule 13 (block_statements -> block_statements marker block_statement .)
    KEYWORD_DEF     reduce using rule 13 (block_statements -> block_statements marker block_statement .)
    BLOCKBEGIN      reduce using rule 13 (block_statements -> block_statements marker block_statement .)
    IDENTIFIER      reduce using rule 13 (block_statements -> block_statements marker block_statement .)
    PLUS            reduce using rule 13 (block_statements -> block_statements marker block_statement .)
    MINUS           reduce using rule 13 (block_statements -> block_statements marker block_statement .)
    TILDA           reduce using rule 13 (block_statements -> block_statements marker block_statement .)
    NOT             reduce using rule 13 (block_statements -> block_statements marker block_statement .)
    LPAREN          reduce using rule 13 (block_statements -> block_statements marker block_statement .)
    INT_NUMBER      reduce using rule 13 (block_statements -> block_statements marker block_statement .)
    BOOL_CONSTT     reduce using rule 13 (block_statements -> block_statements marker block_statement .)
    BOOL_CONSTF     reduce using rule 13 (block_statements -> block_statements marker block_statement .)
    BLOCKEND        reduce using rule 13 (block_statements -> block_statements marker block_statement .)


state 218

    (78) base_variable_set -> LPAREN expression RPAREN .

    TIMES           reduce using rule 78 (base_variable_set -> LPAREN expression RPAREN .)
    DIVIDE          reduce using rule 78 (base_variable_set -> LPAREN expression RPAREN .)
    REMAINDER       reduce using rule 78 (base_variable_set -> LPAREN expression RPAREN .)
    PLUS            reduce using rule 78 (base_variable_set -> LPAREN expression RPAREN .)
    MINUS           reduce using rule 78 (base_variable_set -> LPAREN expression RPAREN .)
    LSHIFT          reduce using rule 78 (base_variable_set -> LPAREN expression RPAREN .)
    RSHIFT          reduce using rule 78 (base_variable_set -> LPAREN expression RPAREN .)
    GREATER         reduce using rule 78 (base_variable_set -> LPAREN expression RPAREN .)
    LESS            reduce using rule 78 (base_variable_set -> LPAREN expression RPAREN .)
    GEQ             reduce using rule 78 (base_variable_set -> LPAREN expression RPAREN .)
    LEQ             reduce using rule 78 (base_variable_set -> LPAREN expression RPAREN .)
    EQUAL           reduce using rule 78 (base_variable_set -> LPAREN expression RPAREN .)
    NEQUAL          reduce using rule 78 (base_variable_set -> LPAREN expression RPAREN .)
    AND_BITWISE     reduce using rule 78 (base_variable_set -> LPAREN expression RPAREN .)
    XOR             reduce using rule 78 (base_variable_set -> LPAREN expression RPAREN .)
    OR_BITWISE      reduce using rule 78 (base_variable_set -> LPAREN expression RPAREN .)
    AND             reduce using rule 78 (base_variable_set -> LPAREN expression RPAREN .)
    OR              reduce using rule 78 (base_variable_set -> LPAREN expression RPAREN .)
    RPAREN          reduce using rule 78 (base_variable_set -> LPAREN expression RPAREN .)
    COMMA           reduce using rule 78 (base_variable_set -> LPAREN expression RPAREN .)
    KEYWORD_MATCH   reduce using rule 78 (base_variable_set -> LPAREN expression RPAREN .)
    TERMINATOR      reduce using rule 78 (base_variable_set -> LPAREN expression RPAREN .)
    RBRAC           reduce using rule 78 (base_variable_set -> LPAREN expression RPAREN .)
    FUNTYPE         reduce using rule 78 (base_variable_set -> LPAREN expression RPAREN .)
    KEYWORD_UNTIL   reduce using rule 78 (base_variable_set -> LPAREN expression RPAREN .)
    KEYWORD_TO      reduce using rule 78 (base_variable_set -> LPAREN expression RPAREN .)
    KEYWORD_BY      reduce using rule 78 (base_variable_set -> LPAREN expression RPAREN .)


state 219

    (25) assignment -> valid_variable assignment_operator assignment_expression .

    FUNTYPE         reduce using rule 25 (assignment -> valid_variable assignment_operator assignment_expression .)
    TERMINATOR      reduce using rule 25 (assignment -> valid_variable assignment_operator assignment_expression .)
    KEYWORD_MATCH   reduce using rule 25 (assignment -> valid_variable assignment_operator assignment_expression .)
    RPAREN          reduce using rule 25 (assignment -> valid_variable assignment_operator assignment_expression .)
    RBRAC           reduce using rule 25 (assignment -> valid_variable assignment_operator assignment_expression .)
    COMMA           reduce using rule 25 (assignment -> valid_variable assignment_operator assignment_expression .)
    KEYWORD_UNTIL   reduce using rule 25 (assignment -> valid_variable assignment_operator assignment_expression .)
    KEYWORD_TO      reduce using rule 25 (assignment -> valid_variable assignment_operator assignment_expression .)
    KEYWORD_BY      reduce using rule 25 (assignment -> valid_variable assignment_operator assignment_expression .)


state 220

    (150) for_update -> for_loop . marker for_step_opts
    (41) marker -> . empty
    (191) empty -> .

    KEYWORD_BY      reduce using rule 191 (empty -> .)
    RPAREN          reduce using rule 191 (empty -> .)

    marker                         shift and go to state 258
    empty                          shift and go to state 99

state 221

    (149) for_statement -> KEYWORD_FOR LPAREN for_update . RPAREN marker block

    RPAREN          shift and go to state 259


state 222

    (151) for_loop -> IDENTIFIER . CHOOSE expression for_untilTo marker expression

    CHOOSE          shift and go to state 260


state 223

    (148) do_while_statement -> KEYWORD_DO marker block . KEYWORD_WHILE LPAREN marker expression RPAREN TERMINATOR

    KEYWORD_WHILE   shift and go to state 261


state 224

    (183) class_params -> class_params COMMA class_param .

    COMMA           reduce using rule 183 (class_params -> class_params COMMA class_param .)
    RPAREN          reduce using rule 183 (class_params -> class_params COMMA class_param .)


state 225

    (186) class_declaration_keyword_opt -> empty .

    IDENTIFIER      reduce using rule 186 (class_declaration_keyword_opt -> empty .)


state 226

    (107) variable_declarator_id -> IDENTIFIER COLON . type
    (109) type -> . primitive_type
    (110) type -> . reference_type
    (111) primitive_type -> . TYPE_INT
    (112) primitive_type -> . TYPE_DOUBLE
    (113) primitive_type -> . TYPE_CHAR
    (114) primitive_type -> . TYPE_STRING
    (115) primitive_type -> . TYPE_BOOLEAN
    (116) primitive_type -> . TYPE_VOID
    (117) reference_type -> . class_data_type
    (118) reference_type -> . array_data_type
    (119) class_data_type -> . name
    (120) array_data_type -> . KEYWORD_ARRAY LBRAC TYPE_INT RBRAC
    (121) name -> . simple_name
    (122) name -> . qualified_name
    (123) simple_name -> . IDENTIFIER
    (124) qualified_name -> . name INST simple_name

    TYPE_INT        shift and go to state 242
    TYPE_DOUBLE     shift and go to state 250
    TYPE_CHAR       shift and go to state 251
    TYPE_STRING     shift and go to state 243
    TYPE_BOOLEAN    shift and go to state 249
    TYPE_VOID       shift and go to state 244
    KEYWORD_ARRAY   shift and go to state 254
    IDENTIFIER      shift and go to state 9

    name                           shift and go to state 253
    qualified_name                 shift and go to state 71
    reference_type                 shift and go to state 246
    primitive_type                 shift and go to state 247
    class_data_type                shift and go to state 245
    type                           shift and go to state 262
    array_data_type                shift and go to state 252
    simple_name                    shift and go to state 60

state 227

    (166) method_header -> method_header_name func_arg_start fun_params_opt RPAREN . COLON method_return_type ASOP

    COLON           shift and go to state 263


state 228

    (171) fun_params -> fun_params COMMA . fun_variable_declarator_id
    (108) fun_variable_declarator_id -> . IDENTIFIER COLON type

    IDENTIFIER      shift and go to state 184

    fun_variable_declarator_id     shift and go to state 264

state 229

    (108) fun_variable_declarator_id -> IDENTIFIER COLON . type
    (109) type -> . primitive_type
    (110) type -> . reference_type
    (111) primitive_type -> . TYPE_INT
    (112) primitive_type -> . TYPE_DOUBLE
    (113) primitive_type -> . TYPE_CHAR
    (114) primitive_type -> . TYPE_STRING
    (115) primitive_type -> . TYPE_BOOLEAN
    (116) primitive_type -> . TYPE_VOID
    (117) reference_type -> . class_data_type
    (118) reference_type -> . array_data_type
    (119) class_data_type -> . name
    (120) array_data_type -> . KEYWORD_ARRAY LBRAC TYPE_INT RBRAC
    (121) name -> . simple_name
    (122) name -> . qualified_name
    (123) simple_name -> . IDENTIFIER
    (124) qualified_name -> . name INST simple_name

    TYPE_INT        shift and go to state 242
    TYPE_DOUBLE     shift and go to state 250
    TYPE_CHAR       shift and go to state 251
    TYPE_STRING     shift and go to state 243
    TYPE_BOOLEAN    shift and go to state 249
    TYPE_VOID       shift and go to state 244
    KEYWORD_ARRAY   shift and go to state 254
    IDENTIFIER      shift and go to state 9

    name                           shift and go to state 253
    qualified_name                 shift and go to state 71
    reference_type                 shift and go to state 246
    primitive_type                 shift and go to state 247
    class_data_type                shift and go to state 245
    type                           shift and go to state 265
    array_data_type                shift and go to state 252
    simple_name                    shift and go to state 60

state 230

    (29) dimension -> LBRAC expression RBRAC .

    ASOP            reduce using rule 29 (dimension -> LBRAC expression RBRAC .)
    TIMES_ASSIGN    reduce using rule 29 (dimension -> LBRAC expression RBRAC .)
    DIVIDE_ASSIGN   reduce using rule 29 (dimension -> LBRAC expression RBRAC .)
    REMAINDER_ASSIGN reduce using rule 29 (dimension -> LBRAC expression RBRAC .)
    PLUS_ASSIGN     reduce using rule 29 (dimension -> LBRAC expression RBRAC .)
    MINUS_ASSIGN    reduce using rule 29 (dimension -> LBRAC expression RBRAC .)
    LSHIFT_ASSIGN   reduce using rule 29 (dimension -> LBRAC expression RBRAC .)
    RSHIFT_ASSIGN   reduce using rule 29 (dimension -> LBRAC expression RBRAC .)
    AND_ASSIGN      reduce using rule 29 (dimension -> LBRAC expression RBRAC .)
    OR_ASSIGN       reduce using rule 29 (dimension -> LBRAC expression RBRAC .)
    XOR_ASSIGN      reduce using rule 29 (dimension -> LBRAC expression RBRAC .)
    TIMES           reduce using rule 29 (dimension -> LBRAC expression RBRAC .)
    DIVIDE          reduce using rule 29 (dimension -> LBRAC expression RBRAC .)
    REMAINDER       reduce using rule 29 (dimension -> LBRAC expression RBRAC .)
    PLUS            reduce using rule 29 (dimension -> LBRAC expression RBRAC .)
    MINUS           reduce using rule 29 (dimension -> LBRAC expression RBRAC .)
    LSHIFT          reduce using rule 29 (dimension -> LBRAC expression RBRAC .)
    RSHIFT          reduce using rule 29 (dimension -> LBRAC expression RBRAC .)
    GREATER         reduce using rule 29 (dimension -> LBRAC expression RBRAC .)
    LESS            reduce using rule 29 (dimension -> LBRAC expression RBRAC .)
    GEQ             reduce using rule 29 (dimension -> LBRAC expression RBRAC .)
    LEQ             reduce using rule 29 (dimension -> LBRAC expression RBRAC .)
    EQUAL           reduce using rule 29 (dimension -> LBRAC expression RBRAC .)
    NEQUAL          reduce using rule 29 (dimension -> LBRAC expression RBRAC .)
    AND_BITWISE     reduce using rule 29 (dimension -> LBRAC expression RBRAC .)
    XOR             reduce using rule 29 (dimension -> LBRAC expression RBRAC .)
    OR_BITWISE      reduce using rule 29 (dimension -> LBRAC expression RBRAC .)
    AND             reduce using rule 29 (dimension -> LBRAC expression RBRAC .)
    OR              reduce using rule 29 (dimension -> LBRAC expression RBRAC .)
    KEYWORD_MATCH   reduce using rule 29 (dimension -> LBRAC expression RBRAC .)
    TERMINATOR      reduce using rule 29 (dimension -> LBRAC expression RBRAC .)
    RPAREN          reduce using rule 29 (dimension -> LBRAC expression RBRAC .)
    RBRAC           reduce using rule 29 (dimension -> LBRAC expression RBRAC .)
    COMMA           reduce using rule 29 (dimension -> LBRAC expression RBRAC .)
    FUNTYPE         reduce using rule 29 (dimension -> LBRAC expression RBRAC .)
    KEYWORD_UNTIL   reduce using rule 29 (dimension -> LBRAC expression RBRAC .)
    KEYWORD_TO      reduce using rule 29 (dimension -> LBRAC expression RBRAC .)
    KEYWORD_BY      reduce using rule 29 (dimension -> LBRAC expression RBRAC .)


state 231

    (92) argument_list -> argument_list COMMA . expression
    (19) expression -> . assignment_expression
    (22) assignment_expression -> . assignment
    (23) assignment_expression -> . conditional_or_expression
    (24) assignment_expression -> . method_invocation
    (25) assignment -> . valid_variable assignment_operator assignment_expression
    (43) conditional_or_expression -> . conditional_and_expression
    (44) conditional_or_expression -> . conditional_or_expression OR marker conditional_and_expression
    (88) method_invocation -> . name LPAREN argument_list_opt RPAREN
    (26) valid_variable -> . name
    (27) valid_variable -> . array_access
    (45) conditional_and_expression -> . inclusive_or_expression
    (46) conditional_and_expression -> . conditional_and_expression AND marker inclusive_or_expression
    (121) name -> . simple_name
    (122) name -> . qualified_name
    (28) array_access -> . name dimension
    (47) inclusive_or_expression -> . exclusive_or_expression
    (48) inclusive_or_expression -> . inclusive_or_expression OR_BITWISE exclusive_or_expression
    (123) simple_name -> . IDENTIFIER
    (124) qualified_name -> . name INST simple_name
    (49) exclusive_or_expression -> . and_expression
    (50) exclusive_or_expression -> . exclusive_or_expression XOR and_expression
    (51) and_expression -> . equality_expression
    (52) and_expression -> . and_expression AND_BITWISE equality_expression
    (53) equality_expression -> . relational_expression
    (54) equality_expression -> . equality_expression EQUAL relational_expression
    (55) equality_expression -> . equality_expression NEQUAL relational_expression
    (56) relational_expression -> . shift_expression
    (57) relational_expression -> . relational_expression GREATER shift_expression
    (58) relational_expression -> . relational_expression LESS shift_expression
    (59) relational_expression -> . relational_expression GEQ shift_expression
    (60) relational_expression -> . relational_expression LEQ shift_expression
    (61) shift_expression -> . additive_expression
    (62) shift_expression -> . shift_expression LSHIFT additive_expression
    (63) shift_expression -> . shift_expression RSHIFT additive_expression
    (64) additive_expression -> . multiplicative_expression
    (65) additive_expression -> . additive_expression PLUS multiplicative_expression
    (66) additive_expression -> . additive_expression MINUS multiplicative_expression
    (67) multiplicative_expression -> . unary_expression
    (68) multiplicative_expression -> . multiplicative_expression TIMES unary_expression
    (69) multiplicative_expression -> . multiplicative_expression DIVIDE unary_expression
    (70) multiplicative_expression -> . multiplicative_expression REMAINDER unary_expression
    (71) unary_expression -> . PLUS unary_expression
    (72) unary_expression -> . MINUS unary_expression
    (73) unary_expression -> . unary_expression_not_plus_minus
    (74) unary_expression_not_plus_minus -> . base_variable_set
    (75) unary_expression_not_plus_minus -> . TILDA unary_expression
    (76) unary_expression_not_plus_minus -> . NOT unary_expression
    (77) base_variable_set -> . variable_literal
    (78) base_variable_set -> . LPAREN expression RPAREN
    (79) variable_literal -> . valid_variable
    (80) variable_literal -> . primary
    (81) primary -> . literal
    (82) primary -> . method_invocation
    (83) literal -> . int_float
    (84) literal -> . c_literal
    (87) int_float -> . INT_NUMBER
    (85) c_literal -> . BOOL_CONSTT
    (86) c_literal -> . BOOL_CONSTF

    IDENTIFIER      shift and go to state 9
    PLUS            shift and go to state 30
    MINUS           shift and go to state 24
    TILDA           shift and go to state 65
    NOT             shift and go to state 52
    LPAREN          shift and go to state 86
    INT_NUMBER      shift and go to state 38
    BOOL_CONSTT     shift and go to state 29
    BOOL_CONSTF     shift and go to state 25

    unary_expression               shift and go to state 39
    exclusive_or_expression        shift and go to state 56
    primary                        shift and go to state 57
    unary_expression_not_plus_minus shift and go to state 40
    array_access                   shift and go to state 23
    and_expression                 shift and go to state 79
    simple_name                    shift and go to state 60
    c_literal                      shift and go to state 85
    base_variable_set              shift and go to state 80
    valid_variable                 shift and go to state 87
    inclusive_or_expression        shift and go to state 27
    literal                        shift and go to state 64
    relational_expression          shift and go to state 66
    method_invocation              shift and go to state 134
    conditional_or_expression      shift and go to state 42
    assignment_expression          shift and go to state 83
    qualified_name                 shift and go to state 71
    assignment                     shift and go to state 137
    multiplicative_expression      shift and go to state 45
    additive_expression            shift and go to state 59
    shift_expression               shift and go to state 49
    equality_expression            shift and go to state 74
    int_float                      shift and go to state 34
    variable_literal               shift and go to state 50
    name                           shift and go to state 37
    expression                     shift and go to state 266
    conditional_and_expression     shift and go to state 51

state 232

    (88) method_invocation -> name LPAREN argument_list_opt RPAREN .

    TIMES           reduce using rule 88 (method_invocation -> name LPAREN argument_list_opt RPAREN .)
    DIVIDE          reduce using rule 88 (method_invocation -> name LPAREN argument_list_opt RPAREN .)
    REMAINDER       reduce using rule 88 (method_invocation -> name LPAREN argument_list_opt RPAREN .)
    PLUS            reduce using rule 88 (method_invocation -> name LPAREN argument_list_opt RPAREN .)
    MINUS           reduce using rule 88 (method_invocation -> name LPAREN argument_list_opt RPAREN .)
    LSHIFT          reduce using rule 88 (method_invocation -> name LPAREN argument_list_opt RPAREN .)
    RSHIFT          reduce using rule 88 (method_invocation -> name LPAREN argument_list_opt RPAREN .)
    GREATER         reduce using rule 88 (method_invocation -> name LPAREN argument_list_opt RPAREN .)
    LESS            reduce using rule 88 (method_invocation -> name LPAREN argument_list_opt RPAREN .)
    GEQ             reduce using rule 88 (method_invocation -> name LPAREN argument_list_opt RPAREN .)
    LEQ             reduce using rule 88 (method_invocation -> name LPAREN argument_list_opt RPAREN .)
    EQUAL           reduce using rule 88 (method_invocation -> name LPAREN argument_list_opt RPAREN .)
    NEQUAL          reduce using rule 88 (method_invocation -> name LPAREN argument_list_opt RPAREN .)
    AND_BITWISE     reduce using rule 88 (method_invocation -> name LPAREN argument_list_opt RPAREN .)
    XOR             reduce using rule 88 (method_invocation -> name LPAREN argument_list_opt RPAREN .)
    OR_BITWISE      reduce using rule 88 (method_invocation -> name LPAREN argument_list_opt RPAREN .)
    AND             reduce using rule 88 (method_invocation -> name LPAREN argument_list_opt RPAREN .)
    OR              reduce using rule 88 (method_invocation -> name LPAREN argument_list_opt RPAREN .)
    KEYWORD_MATCH   reduce using rule 88 (method_invocation -> name LPAREN argument_list_opt RPAREN .)
    TERMINATOR      reduce using rule 88 (method_invocation -> name LPAREN argument_list_opt RPAREN .)
    RPAREN          reduce using rule 88 (method_invocation -> name LPAREN argument_list_opt RPAREN .)
    RBRAC           reduce using rule 88 (method_invocation -> name LPAREN argument_list_opt RPAREN .)
    COMMA           reduce using rule 88 (method_invocation -> name LPAREN argument_list_opt RPAREN .)
    FUNTYPE         reduce using rule 88 (method_invocation -> name LPAREN argument_list_opt RPAREN .)
    KEYWORD_UNTIL   reduce using rule 88 (method_invocation -> name LPAREN argument_list_opt RPAREN .)
    KEYWORD_TO      reduce using rule 88 (method_invocation -> name LPAREN argument_list_opt RPAREN .)
    KEYWORD_BY      reduce using rule 88 (method_invocation -> name LPAREN argument_list_opt RPAREN .)


state 233

    (44) conditional_or_expression -> conditional_or_expression OR marker conditional_and_expression .
    (46) conditional_and_expression -> conditional_and_expression . AND marker inclusive_or_expression

    OR              reduce using rule 44 (conditional_or_expression -> conditional_or_expression OR marker conditional_and_expression .)
    TERMINATOR      reduce using rule 44 (conditional_or_expression -> conditional_or_expression OR marker conditional_and_expression .)
    RPAREN          reduce using rule 44 (conditional_or_expression -> conditional_or_expression OR marker conditional_and_expression .)
    COMMA           reduce using rule 44 (conditional_or_expression -> conditional_or_expression OR marker conditional_and_expression .)
    FUNTYPE         reduce using rule 44 (conditional_or_expression -> conditional_or_expression OR marker conditional_and_expression .)
    KEYWORD_MATCH   reduce using rule 44 (conditional_or_expression -> conditional_or_expression OR marker conditional_and_expression .)
    RBRAC           reduce using rule 44 (conditional_or_expression -> conditional_or_expression OR marker conditional_and_expression .)
    KEYWORD_BY      reduce using rule 44 (conditional_or_expression -> conditional_or_expression OR marker conditional_and_expression .)
    KEYWORD_UNTIL   reduce using rule 44 (conditional_or_expression -> conditional_or_expression OR marker conditional_and_expression .)
    KEYWORD_TO      reduce using rule 44 (conditional_or_expression -> conditional_or_expression OR marker conditional_and_expression .)
    AND             shift and go to state 125


state 234

    (147) while_statement -> KEYWORD_WHILE LPAREN marker expression . RPAREN marker block

    RPAREN          shift and go to state 267


state 235

    (46) conditional_and_expression -> conditional_and_expression AND marker inclusive_or_expression .
    (48) inclusive_or_expression -> inclusive_or_expression . OR_BITWISE exclusive_or_expression

    AND             reduce using rule 46 (conditional_and_expression -> conditional_and_expression AND marker inclusive_or_expression .)
    OR              reduce using rule 46 (conditional_and_expression -> conditional_and_expression AND marker inclusive_or_expression .)
    KEYWORD_UNTIL   reduce using rule 46 (conditional_and_expression -> conditional_and_expression AND marker inclusive_or_expression .)
    KEYWORD_TO      reduce using rule 46 (conditional_and_expression -> conditional_and_expression AND marker inclusive_or_expression .)
    RPAREN          reduce using rule 46 (conditional_and_expression -> conditional_and_expression AND marker inclusive_or_expression .)
    KEYWORD_MATCH   reduce using rule 46 (conditional_and_expression -> conditional_and_expression AND marker inclusive_or_expression .)
    COMMA           reduce using rule 46 (conditional_and_expression -> conditional_and_expression AND marker inclusive_or_expression .)
    TERMINATOR      reduce using rule 46 (conditional_and_expression -> conditional_and_expression AND marker inclusive_or_expression .)
    KEYWORD_BY      reduce using rule 46 (conditional_and_expression -> conditional_and_expression AND marker inclusive_or_expression .)
    FUNTYPE         reduce using rule 46 (conditional_and_expression -> conditional_and_expression AND marker inclusive_or_expression .)
    RBRAC           reduce using rule 46 (conditional_and_expression -> conditional_and_expression AND marker inclusive_or_expression .)
    OR_BITWISE      shift and go to state 106


state 236

    (161) switch_block_statement -> switch_label . narker marker block narker
    (42) narker -> . empty
    (191) empty -> .

    BLOCKBEGIN      reduce using rule 191 (empty -> .)

    empty                          shift and go to state 268
    narker                         shift and go to state 269

state 237

    (162) switch_label -> KEYWORD_CASE . expression FUNTYPE
    (19) expression -> . assignment_expression
    (22) assignment_expression -> . assignment
    (23) assignment_expression -> . conditional_or_expression
    (24) assignment_expression -> . method_invocation
    (25) assignment -> . valid_variable assignment_operator assignment_expression
    (43) conditional_or_expression -> . conditional_and_expression
    (44) conditional_or_expression -> . conditional_or_expression OR marker conditional_and_expression
    (88) method_invocation -> . name LPAREN argument_list_opt RPAREN
    (26) valid_variable -> . name
    (27) valid_variable -> . array_access
    (45) conditional_and_expression -> . inclusive_or_expression
    (46) conditional_and_expression -> . conditional_and_expression AND marker inclusive_or_expression
    (121) name -> . simple_name
    (122) name -> . qualified_name
    (28) array_access -> . name dimension
    (47) inclusive_or_expression -> . exclusive_or_expression
    (48) inclusive_or_expression -> . inclusive_or_expression OR_BITWISE exclusive_or_expression
    (123) simple_name -> . IDENTIFIER
    (124) qualified_name -> . name INST simple_name
    (49) exclusive_or_expression -> . and_expression
    (50) exclusive_or_expression -> . exclusive_or_expression XOR and_expression
    (51) and_expression -> . equality_expression
    (52) and_expression -> . and_expression AND_BITWISE equality_expression
    (53) equality_expression -> . relational_expression
    (54) equality_expression -> . equality_expression EQUAL relational_expression
    (55) equality_expression -> . equality_expression NEQUAL relational_expression
    (56) relational_expression -> . shift_expression
    (57) relational_expression -> . relational_expression GREATER shift_expression
    (58) relational_expression -> . relational_expression LESS shift_expression
    (59) relational_expression -> . relational_expression GEQ shift_expression
    (60) relational_expression -> . relational_expression LEQ shift_expression
    (61) shift_expression -> . additive_expression
    (62) shift_expression -> . shift_expression LSHIFT additive_expression
    (63) shift_expression -> . shift_expression RSHIFT additive_expression
    (64) additive_expression -> . multiplicative_expression
    (65) additive_expression -> . additive_expression PLUS multiplicative_expression
    (66) additive_expression -> . additive_expression MINUS multiplicative_expression
    (67) multiplicative_expression -> . unary_expression
    (68) multiplicative_expression -> . multiplicative_expression TIMES unary_expression
    (69) multiplicative_expression -> . multiplicative_expression DIVIDE unary_expression
    (70) multiplicative_expression -> . multiplicative_expression REMAINDER unary_expression
    (71) unary_expression -> . PLUS unary_expression
    (72) unary_expression -> . MINUS unary_expression
    (73) unary_expression -> . unary_expression_not_plus_minus
    (74) unary_expression_not_plus_minus -> . base_variable_set
    (75) unary_expression_not_plus_minus -> . TILDA unary_expression
    (76) unary_expression_not_plus_minus -> . NOT unary_expression
    (77) base_variable_set -> . variable_literal
    (78) base_variable_set -> . LPAREN expression RPAREN
    (79) variable_literal -> . valid_variable
    (80) variable_literal -> . primary
    (81) primary -> . literal
    (82) primary -> . method_invocation
    (83) literal -> . int_float
    (84) literal -> . c_literal
    (87) int_float -> . INT_NUMBER
    (85) c_literal -> . BOOL_CONSTT
    (86) c_literal -> . BOOL_CONSTF

    IDENTIFIER      shift and go to state 9
    PLUS            shift and go to state 30
    MINUS           shift and go to state 24
    TILDA           shift and go to state 65
    NOT             shift and go to state 52
    LPAREN          shift and go to state 86
    INT_NUMBER      shift and go to state 38
    BOOL_CONSTT     shift and go to state 29
    BOOL_CONSTF     shift and go to state 25

    and_expression                 shift and go to state 79
    exclusive_or_expression        shift and go to state 56
    primary                        shift and go to state 57
    unary_expression_not_plus_minus shift and go to state 40
    array_access                   shift and go to state 23
    additive_expression            shift and go to state 59
    simple_name                    shift and go to state 60
    c_literal                      shift and go to state 85
    unary_expression               shift and go to state 39
    base_variable_set              shift and go to state 80
    valid_variable                 shift and go to state 87
    inclusive_or_expression        shift and go to state 27
    literal                        shift and go to state 64
    relational_expression          shift and go to state 66
    method_invocation              shift and go to state 134
    conditional_or_expression      shift and go to state 42
    assignment_expression          shift and go to state 83
    qualified_name                 shift and go to state 71
    assignment                     shift and go to state 137
    multiplicative_expression      shift and go to state 45
    shift_expression               shift and go to state 49
    equality_expression            shift and go to state 74
    int_float                      shift and go to state 34
    variable_literal               shift and go to state 50
    name                           shift and go to state 37
    expression                     shift and go to state 270
    conditional_and_expression     shift and go to state 51

state 238

    (157) switch_block -> BLOCKBEGIN BLOCKEND .

    KEYWORD_IF      reduce using rule 157 (switch_block -> BLOCKBEGIN BLOCKEND .)
    KEYWORD_WHILE   reduce using rule 157 (switch_block -> BLOCKBEGIN BLOCKEND .)
    KEYWORD_DO      reduce using rule 157 (switch_block -> BLOCKBEGIN BLOCKEND .)
    KEYWORD_FOR     reduce using rule 157 (switch_block -> BLOCKBEGIN BLOCKEND .)
    KEYWORD_CLASS   reduce using rule 157 (switch_block -> BLOCKBEGIN BLOCKEND .)
    KEYWORD_OBJECT  reduce using rule 157 (switch_block -> BLOCKBEGIN BLOCKEND .)
    KEYWORD_VAR     reduce using rule 157 (switch_block -> BLOCKBEGIN BLOCKEND .)
    KEYWORD_VAL     reduce using rule 157 (switch_block -> BLOCKBEGIN BLOCKEND .)
    TERMINATOR      reduce using rule 157 (switch_block -> BLOCKBEGIN BLOCKEND .)
    KEYWORD_RETURN  reduce using rule 157 (switch_block -> BLOCKBEGIN BLOCKEND .)
    KEYWORD_DEF     reduce using rule 157 (switch_block -> BLOCKBEGIN BLOCKEND .)
    BLOCKBEGIN      reduce using rule 157 (switch_block -> BLOCKBEGIN BLOCKEND .)
    IDENTIFIER      reduce using rule 157 (switch_block -> BLOCKBEGIN BLOCKEND .)
    PLUS            reduce using rule 157 (switch_block -> BLOCKBEGIN BLOCKEND .)
    MINUS           reduce using rule 157 (switch_block -> BLOCKBEGIN BLOCKEND .)
    TILDA           reduce using rule 157 (switch_block -> BLOCKBEGIN BLOCKEND .)
    NOT             reduce using rule 157 (switch_block -> BLOCKBEGIN BLOCKEND .)
    LPAREN          reduce using rule 157 (switch_block -> BLOCKBEGIN BLOCKEND .)
    INT_NUMBER      reduce using rule 157 (switch_block -> BLOCKBEGIN BLOCKEND .)
    BOOL_CONSTT     reduce using rule 157 (switch_block -> BLOCKBEGIN BLOCKEND .)
    BOOL_CONSTF     reduce using rule 157 (switch_block -> BLOCKBEGIN BLOCKEND .)
    BLOCKEND        reduce using rule 157 (switch_block -> BLOCKBEGIN BLOCKEND .)
    KEYWORD_ELSE    reduce using rule 157 (switch_block -> BLOCKBEGIN BLOCKEND .)


state 239

    (158) switch_block -> BLOCKBEGIN switch_block_statements . BLOCKEND
    (160) switch_block_statements -> switch_block_statements . switch_block_statement marker
    (161) switch_block_statement -> . switch_label narker marker block narker
    (162) switch_label -> . KEYWORD_CASE expression FUNTYPE

    BLOCKEND        shift and go to state 271
    KEYWORD_CASE    shift and go to state 237

    switch_block_statement         shift and go to state 272
    switch_label                   shift and go to state 236

state 240

    (159) switch_block_statements -> switch_block_statement . marker
    (41) marker -> . empty
    (191) empty -> .

    BLOCKEND        reduce using rule 191 (empty -> .)
    KEYWORD_CASE    reduce using rule 191 (empty -> .)

    marker                         shift and go to state 273
    empty                          shift and go to state 99

state 241

    (156) switch_statement -> expression KEYWORD_MATCH switch_block marker .

    KEYWORD_ELSE    reduce using rule 156 (switch_statement -> expression KEYWORD_MATCH switch_block marker .)
    KEYWORD_IF      reduce using rule 156 (switch_statement -> expression KEYWORD_MATCH switch_block marker .)
    KEYWORD_WHILE   reduce using rule 156 (switch_statement -> expression KEYWORD_MATCH switch_block marker .)
    KEYWORD_DO      reduce using rule 156 (switch_statement -> expression KEYWORD_MATCH switch_block marker .)
    KEYWORD_FOR     reduce using rule 156 (switch_statement -> expression KEYWORD_MATCH switch_block marker .)
    KEYWORD_CLASS   reduce using rule 156 (switch_statement -> expression KEYWORD_MATCH switch_block marker .)
    KEYWORD_OBJECT  reduce using rule 156 (switch_statement -> expression KEYWORD_MATCH switch_block marker .)
    KEYWORD_VAR     reduce using rule 156 (switch_statement -> expression KEYWORD_MATCH switch_block marker .)
    KEYWORD_VAL     reduce using rule 156 (switch_statement -> expression KEYWORD_MATCH switch_block marker .)
    TERMINATOR      reduce using rule 156 (switch_statement -> expression KEYWORD_MATCH switch_block marker .)
    KEYWORD_RETURN  reduce using rule 156 (switch_statement -> expression KEYWORD_MATCH switch_block marker .)
    KEYWORD_DEF     reduce using rule 156 (switch_statement -> expression KEYWORD_MATCH switch_block marker .)
    BLOCKBEGIN      reduce using rule 156 (switch_statement -> expression KEYWORD_MATCH switch_block marker .)
    IDENTIFIER      reduce using rule 156 (switch_statement -> expression KEYWORD_MATCH switch_block marker .)
    PLUS            reduce using rule 156 (switch_statement -> expression KEYWORD_MATCH switch_block marker .)
    MINUS           reduce using rule 156 (switch_statement -> expression KEYWORD_MATCH switch_block marker .)
    TILDA           reduce using rule 156 (switch_statement -> expression KEYWORD_MATCH switch_block marker .)
    NOT             reduce using rule 156 (switch_statement -> expression KEYWORD_MATCH switch_block marker .)
    LPAREN          reduce using rule 156 (switch_statement -> expression KEYWORD_MATCH switch_block marker .)
    INT_NUMBER      reduce using rule 156 (switch_statement -> expression KEYWORD_MATCH switch_block marker .)
    BOOL_CONSTT     reduce using rule 156 (switch_statement -> expression KEYWORD_MATCH switch_block marker .)
    BOOL_CONSTF     reduce using rule 156 (switch_statement -> expression KEYWORD_MATCH switch_block marker .)
    BLOCKEND        reduce using rule 156 (switch_statement -> expression KEYWORD_MATCH switch_block marker .)


state 242

    (111) primitive_type -> TYPE_INT .

    COMMA           reduce using rule 111 (primitive_type -> TYPE_INT .)
    RPAREN          reduce using rule 111 (primitive_type -> TYPE_INT .)
    RBRAC           reduce using rule 111 (primitive_type -> TYPE_INT .)
    ASOP            reduce using rule 111 (primitive_type -> TYPE_INT .)


state 243

    (114) primitive_type -> TYPE_STRING .

    COMMA           reduce using rule 114 (primitive_type -> TYPE_STRING .)
    RPAREN          reduce using rule 114 (primitive_type -> TYPE_STRING .)
    RBRAC           reduce using rule 114 (primitive_type -> TYPE_STRING .)
    ASOP            reduce using rule 114 (primitive_type -> TYPE_STRING .)


state 244

    (116) primitive_type -> TYPE_VOID .

    COMMA           reduce using rule 116 (primitive_type -> TYPE_VOID .)
    RPAREN          reduce using rule 116 (primitive_type -> TYPE_VOID .)
    RBRAC           reduce using rule 116 (primitive_type -> TYPE_VOID .)
    ASOP            reduce using rule 116 (primitive_type -> TYPE_VOID .)


state 245

    (117) reference_type -> class_data_type .

    COMMA           reduce using rule 117 (reference_type -> class_data_type .)
    RPAREN          reduce using rule 117 (reference_type -> class_data_type .)
    ASOP            reduce using rule 117 (reference_type -> class_data_type .)
    RBRAC           reduce using rule 117 (reference_type -> class_data_type .)


state 246

    (110) type -> reference_type .

    RBRAC           reduce using rule 110 (type -> reference_type .)
    ASOP            reduce using rule 110 (type -> reference_type .)
    COMMA           reduce using rule 110 (type -> reference_type .)
    RPAREN          reduce using rule 110 (type -> reference_type .)


state 247

    (109) type -> primitive_type .

    RBRAC           reduce using rule 109 (type -> primitive_type .)
    ASOP            reduce using rule 109 (type -> primitive_type .)
    COMMA           reduce using rule 109 (type -> primitive_type .)
    RPAREN          reduce using rule 109 (type -> primitive_type .)


state 248

    (102) variable_declaration_body -> identifiers COLON type . ASOP variable_declaration_initializer

    ASOP            shift and go to state 274


state 249

    (115) primitive_type -> TYPE_BOOLEAN .

    COMMA           reduce using rule 115 (primitive_type -> TYPE_BOOLEAN .)
    RPAREN          reduce using rule 115 (primitive_type -> TYPE_BOOLEAN .)
    RBRAC           reduce using rule 115 (primitive_type -> TYPE_BOOLEAN .)
    ASOP            reduce using rule 115 (primitive_type -> TYPE_BOOLEAN .)


state 250

    (112) primitive_type -> TYPE_DOUBLE .

    COMMA           reduce using rule 112 (primitive_type -> TYPE_DOUBLE .)
    RPAREN          reduce using rule 112 (primitive_type -> TYPE_DOUBLE .)
    RBRAC           reduce using rule 112 (primitive_type -> TYPE_DOUBLE .)
    ASOP            reduce using rule 112 (primitive_type -> TYPE_DOUBLE .)


state 251

    (113) primitive_type -> TYPE_CHAR .

    COMMA           reduce using rule 113 (primitive_type -> TYPE_CHAR .)
    RPAREN          reduce using rule 113 (primitive_type -> TYPE_CHAR .)
    RBRAC           reduce using rule 113 (primitive_type -> TYPE_CHAR .)
    ASOP            reduce using rule 113 (primitive_type -> TYPE_CHAR .)


state 252

    (118) reference_type -> array_data_type .

    COMMA           reduce using rule 118 (reference_type -> array_data_type .)
    RPAREN          reduce using rule 118 (reference_type -> array_data_type .)
    ASOP            reduce using rule 118 (reference_type -> array_data_type .)
    RBRAC           reduce using rule 118 (reference_type -> array_data_type .)


state 253

    (119) class_data_type -> name .
    (124) qualified_name -> name . INST simple_name

    ASOP            reduce using rule 119 (class_data_type -> name .)
    RBRAC           reduce using rule 119 (class_data_type -> name .)
    COMMA           reduce using rule 119 (class_data_type -> name .)
    RPAREN          reduce using rule 119 (class_data_type -> name .)
    INST            shift and go to state 113


state 254

    (120) array_data_type -> KEYWORD_ARRAY . LBRAC TYPE_INT RBRAC

    LBRAC           shift and go to state 275


state 255

    (103) identifiers -> identifiers COMMA IDENTIFIER .

    COLON           reduce using rule 103 (identifiers -> identifiers COMMA IDENTIFIER .)
    COMMA           reduce using rule 103 (identifiers -> identifiers COMMA IDENTIFIER .)


state 256

    (142) if_then_statement -> KEYWORD_IF LPAREN expression RPAREN . marker block
    (143) if_then_else_statement -> KEYWORD_IF LPAREN expression RPAREN . marker if_then_else_intermediate narker KEYWORD_ELSE marker block
    (41) marker -> . empty
    (191) empty -> .

    BLOCKBEGIN      reduce using rule 191 (empty -> .)
    KEYWORD_IF      reduce using rule 191 (empty -> .)
    TERMINATOR      reduce using rule 191 (empty -> .)
    KEYWORD_RETURN  reduce using rule 191 (empty -> .)
    IDENTIFIER      reduce using rule 191 (empty -> .)
    PLUS            reduce using rule 191 (empty -> .)
    MINUS           reduce using rule 191 (empty -> .)
    TILDA           reduce using rule 191 (empty -> .)
    NOT             reduce using rule 191 (empty -> .)
    LPAREN          reduce using rule 191 (empty -> .)
    INT_NUMBER      reduce using rule 191 (empty -> .)
    BOOL_CONSTT     reduce using rule 191 (empty -> .)
    BOOL_CONSTF     reduce using rule 191 (empty -> .)

    marker                         shift and go to state 276
    empty                          shift and go to state 99

state 257

    (175) method_body -> method_start_scope block_statements_opt end_scope .

    KEYWORD_IF      reduce using rule 175 (method_body -> method_start_scope block_statements_opt end_scope .)
    KEYWORD_WHILE   reduce using rule 175 (method_body -> method_start_scope block_statements_opt end_scope .)
    KEYWORD_DO      reduce using rule 175 (method_body -> method_start_scope block_statements_opt end_scope .)
    KEYWORD_FOR     reduce using rule 175 (method_body -> method_start_scope block_statements_opt end_scope .)
    KEYWORD_CLASS   reduce using rule 175 (method_body -> method_start_scope block_statements_opt end_scope .)
    KEYWORD_OBJECT  reduce using rule 175 (method_body -> method_start_scope block_statements_opt end_scope .)
    KEYWORD_VAR     reduce using rule 175 (method_body -> method_start_scope block_statements_opt end_scope .)
    KEYWORD_VAL     reduce using rule 175 (method_body -> method_start_scope block_statements_opt end_scope .)
    TERMINATOR      reduce using rule 175 (method_body -> method_start_scope block_statements_opt end_scope .)
    KEYWORD_RETURN  reduce using rule 175 (method_body -> method_start_scope block_statements_opt end_scope .)
    KEYWORD_DEF     reduce using rule 175 (method_body -> method_start_scope block_statements_opt end_scope .)
    BLOCKBEGIN      reduce using rule 175 (method_body -> method_start_scope block_statements_opt end_scope .)
    IDENTIFIER      reduce using rule 175 (method_body -> method_start_scope block_statements_opt end_scope .)
    PLUS            reduce using rule 175 (method_body -> method_start_scope block_statements_opt end_scope .)
    MINUS           reduce using rule 175 (method_body -> method_start_scope block_statements_opt end_scope .)
    TILDA           reduce using rule 175 (method_body -> method_start_scope block_statements_opt end_scope .)
    NOT             reduce using rule 175 (method_body -> method_start_scope block_statements_opt end_scope .)
    LPAREN          reduce using rule 175 (method_body -> method_start_scope block_statements_opt end_scope .)
    INT_NUMBER      reduce using rule 175 (method_body -> method_start_scope block_statements_opt end_scope .)
    BOOL_CONSTT     reduce using rule 175 (method_body -> method_start_scope block_statements_opt end_scope .)
    BOOL_CONSTF     reduce using rule 175 (method_body -> method_start_scope block_statements_opt end_scope .)
    BLOCKEND        reduce using rule 175 (method_body -> method_start_scope block_statements_opt end_scope .)


state 258

    (150) for_update -> for_loop marker . for_step_opts
    (154) for_step_opts -> . KEYWORD_BY expression
    (155) for_step_opts -> . empty
    (191) empty -> .

    KEYWORD_BY      shift and go to state 277
    RPAREN          reduce using rule 191 (empty -> .)

    for_step_opts                  shift and go to state 278
    empty                          shift and go to state 279

state 259

    (149) for_statement -> KEYWORD_FOR LPAREN for_update RPAREN . marker block
    (41) marker -> . empty
    (191) empty -> .

    BLOCKBEGIN      reduce using rule 191 (empty -> .)

    marker                         shift and go to state 280
    empty                          shift and go to state 99

state 260

    (151) for_loop -> IDENTIFIER CHOOSE . expression for_untilTo marker expression
    (19) expression -> . assignment_expression
    (22) assignment_expression -> . assignment
    (23) assignment_expression -> . conditional_or_expression
    (24) assignment_expression -> . method_invocation
    (25) assignment -> . valid_variable assignment_operator assignment_expression
    (43) conditional_or_expression -> . conditional_and_expression
    (44) conditional_or_expression -> . conditional_or_expression OR marker conditional_and_expression
    (88) method_invocation -> . name LPAREN argument_list_opt RPAREN
    (26) valid_variable -> . name
    (27) valid_variable -> . array_access
    (45) conditional_and_expression -> . inclusive_or_expression
    (46) conditional_and_expression -> . conditional_and_expression AND marker inclusive_or_expression
    (121) name -> . simple_name
    (122) name -> . qualified_name
    (28) array_access -> . name dimension
    (47) inclusive_or_expression -> . exclusive_or_expression
    (48) inclusive_or_expression -> . inclusive_or_expression OR_BITWISE exclusive_or_expression
    (123) simple_name -> . IDENTIFIER
    (124) qualified_name -> . name INST simple_name
    (49) exclusive_or_expression -> . and_expression
    (50) exclusive_or_expression -> . exclusive_or_expression XOR and_expression
    (51) and_expression -> . equality_expression
    (52) and_expression -> . and_expression AND_BITWISE equality_expression
    (53) equality_expression -> . relational_expression
    (54) equality_expression -> . equality_expression EQUAL relational_expression
    (55) equality_expression -> . equality_expression NEQUAL relational_expression
    (56) relational_expression -> . shift_expression
    (57) relational_expression -> . relational_expression GREATER shift_expression
    (58) relational_expression -> . relational_expression LESS shift_expression
    (59) relational_expression -> . relational_expression GEQ shift_expression
    (60) relational_expression -> . relational_expression LEQ shift_expression
    (61) shift_expression -> . additive_expression
    (62) shift_expression -> . shift_expression LSHIFT additive_expression
    (63) shift_expression -> . shift_expression RSHIFT additive_expression
    (64) additive_expression -> . multiplicative_expression
    (65) additive_expression -> . additive_expression PLUS multiplicative_expression
    (66) additive_expression -> . additive_expression MINUS multiplicative_expression
    (67) multiplicative_expression -> . unary_expression
    (68) multiplicative_expression -> . multiplicative_expression TIMES unary_expression
    (69) multiplicative_expression -> . multiplicative_expression DIVIDE unary_expression
    (70) multiplicative_expression -> . multiplicative_expression REMAINDER unary_expression
    (71) unary_expression -> . PLUS unary_expression
    (72) unary_expression -> . MINUS unary_expression
    (73) unary_expression -> . unary_expression_not_plus_minus
    (74) unary_expression_not_plus_minus -> . base_variable_set
    (75) unary_expression_not_plus_minus -> . TILDA unary_expression
    (76) unary_expression_not_plus_minus -> . NOT unary_expression
    (77) base_variable_set -> . variable_literal
    (78) base_variable_set -> . LPAREN expression RPAREN
    (79) variable_literal -> . valid_variable
    (80) variable_literal -> . primary
    (81) primary -> . literal
    (82) primary -> . method_invocation
    (83) literal -> . int_float
    (84) literal -> . c_literal
    (87) int_float -> . INT_NUMBER
    (85) c_literal -> . BOOL_CONSTT
    (86) c_literal -> . BOOL_CONSTF

    IDENTIFIER      shift and go to state 9
    PLUS            shift and go to state 30
    MINUS           shift and go to state 24
    TILDA           shift and go to state 65
    NOT             shift and go to state 52
    LPAREN          shift and go to state 86
    INT_NUMBER      shift and go to state 38
    BOOL_CONSTT     shift and go to state 29
    BOOL_CONSTF     shift and go to state 25

    unary_expression               shift and go to state 39
    exclusive_or_expression        shift and go to state 56
    primary                        shift and go to state 57
    unary_expression_not_plus_minus shift and go to state 40
    array_access                   shift and go to state 23
    and_expression                 shift and go to state 79
    simple_name                    shift and go to state 60
    c_literal                      shift and go to state 85
    base_variable_set              shift and go to state 80
    valid_variable                 shift and go to state 87
    inclusive_or_expression        shift and go to state 27
    literal                        shift and go to state 64
    relational_expression          shift and go to state 66
    method_invocation              shift and go to state 134
    conditional_or_expression      shift and go to state 42
    assignment_expression          shift and go to state 83
    qualified_name                 shift and go to state 71
    assignment                     shift and go to state 137
    multiplicative_expression      shift and go to state 45
    additive_expression            shift and go to state 59
    shift_expression               shift and go to state 49
    equality_expression            shift and go to state 74
    int_float                      shift and go to state 34
    variable_literal               shift and go to state 50
    name                           shift and go to state 37
    expression                     shift and go to state 281
    conditional_and_expression     shift and go to state 51

state 261

    (148) do_while_statement -> KEYWORD_DO marker block KEYWORD_WHILE . LPAREN marker expression RPAREN TERMINATOR

    LPAREN          shift and go to state 282


state 262

    (107) variable_declarator_id -> IDENTIFIER COLON type .

    COMMA           reduce using rule 107 (variable_declarator_id -> IDENTIFIER COLON type .)
    RPAREN          reduce using rule 107 (variable_declarator_id -> IDENTIFIER COLON type .)


state 263

    (166) method_header -> method_header_name func_arg_start fun_params_opt RPAREN COLON . method_return_type ASOP
    (172) method_return_type -> . type
    (173) method_return_type -> . TYPE_VOID
    (109) type -> . primitive_type
    (110) type -> . reference_type
    (111) primitive_type -> . TYPE_INT
    (112) primitive_type -> . TYPE_DOUBLE
    (113) primitive_type -> . TYPE_CHAR
    (114) primitive_type -> . TYPE_STRING
    (115) primitive_type -> . TYPE_BOOLEAN
    (116) primitive_type -> . TYPE_VOID
    (117) reference_type -> . class_data_type
    (118) reference_type -> . array_data_type
    (119) class_data_type -> . name
    (120) array_data_type -> . KEYWORD_ARRAY LBRAC TYPE_INT RBRAC
    (121) name -> . simple_name
    (122) name -> . qualified_name
    (123) simple_name -> . IDENTIFIER
    (124) qualified_name -> . name INST simple_name

    TYPE_VOID       shift and go to state 283
    TYPE_INT        shift and go to state 242
    TYPE_DOUBLE     shift and go to state 250
    TYPE_CHAR       shift and go to state 251
    TYPE_STRING     shift and go to state 243
    TYPE_BOOLEAN    shift and go to state 249
    KEYWORD_ARRAY   shift and go to state 254
    IDENTIFIER      shift and go to state 9

    primitive_type                 shift and go to state 247
    name                           shift and go to state 253
    qualified_name                 shift and go to state 71
    method_return_type             shift and go to state 285
    reference_type                 shift and go to state 246
    class_data_type                shift and go to state 245
    type                           shift and go to state 284
    array_data_type                shift and go to state 252
    simple_name                    shift and go to state 60

state 264

    (171) fun_params -> fun_params COMMA fun_variable_declarator_id .

    COMMA           reduce using rule 171 (fun_params -> fun_params COMMA fun_variable_declarator_id .)
    RPAREN          reduce using rule 171 (fun_params -> fun_params COMMA fun_variable_declarator_id .)


state 265

    (108) fun_variable_declarator_id -> IDENTIFIER COLON type .

    COMMA           reduce using rule 108 (fun_variable_declarator_id -> IDENTIFIER COLON type .)
    RPAREN          reduce using rule 108 (fun_variable_declarator_id -> IDENTIFIER COLON type .)


state 266

    (92) argument_list -> argument_list COMMA expression .

    COMMA           reduce using rule 92 (argument_list -> argument_list COMMA expression .)
    RPAREN          reduce using rule 92 (argument_list -> argument_list COMMA expression .)


state 267

    (147) while_statement -> KEYWORD_WHILE LPAREN marker expression RPAREN . marker block
    (41) marker -> . empty
    (191) empty -> .

    BLOCKBEGIN      reduce using rule 191 (empty -> .)

    marker                         shift and go to state 286
    empty                          shift and go to state 99

state 268

    (42) narker -> empty .

    BLOCKEND        reduce using rule 42 (narker -> empty .)
    KEYWORD_CASE    reduce using rule 42 (narker -> empty .)
    KEYWORD_ELSE    reduce using rule 42 (narker -> empty .)
    BLOCKBEGIN      reduce using rule 42 (narker -> empty .)


state 269

    (161) switch_block_statement -> switch_label narker . marker block narker
    (41) marker -> . empty
    (191) empty -> .

    BLOCKBEGIN      reduce using rule 191 (empty -> .)

    marker                         shift and go to state 287
    empty                          shift and go to state 99

state 270

    (162) switch_label -> KEYWORD_CASE expression . FUNTYPE

    FUNTYPE         shift and go to state 288


state 271

    (158) switch_block -> BLOCKBEGIN switch_block_statements BLOCKEND .

    KEYWORD_IF      reduce using rule 158 (switch_block -> BLOCKBEGIN switch_block_statements BLOCKEND .)
    KEYWORD_WHILE   reduce using rule 158 (switch_block -> BLOCKBEGIN switch_block_statements BLOCKEND .)
    KEYWORD_DO      reduce using rule 158 (switch_block -> BLOCKBEGIN switch_block_statements BLOCKEND .)
    KEYWORD_FOR     reduce using rule 158 (switch_block -> BLOCKBEGIN switch_block_statements BLOCKEND .)
    KEYWORD_CLASS   reduce using rule 158 (switch_block -> BLOCKBEGIN switch_block_statements BLOCKEND .)
    KEYWORD_OBJECT  reduce using rule 158 (switch_block -> BLOCKBEGIN switch_block_statements BLOCKEND .)
    KEYWORD_VAR     reduce using rule 158 (switch_block -> BLOCKBEGIN switch_block_statements BLOCKEND .)
    KEYWORD_VAL     reduce using rule 158 (switch_block -> BLOCKBEGIN switch_block_statements BLOCKEND .)
    TERMINATOR      reduce using rule 158 (switch_block -> BLOCKBEGIN switch_block_statements BLOCKEND .)
    KEYWORD_RETURN  reduce using rule 158 (switch_block -> BLOCKBEGIN switch_block_statements BLOCKEND .)
    KEYWORD_DEF     reduce using rule 158 (switch_block -> BLOCKBEGIN switch_block_statements BLOCKEND .)
    BLOCKBEGIN      reduce using rule 158 (switch_block -> BLOCKBEGIN switch_block_statements BLOCKEND .)
    IDENTIFIER      reduce using rule 158 (switch_block -> BLOCKBEGIN switch_block_statements BLOCKEND .)
    PLUS            reduce using rule 158 (switch_block -> BLOCKBEGIN switch_block_statements BLOCKEND .)
    MINUS           reduce using rule 158 (switch_block -> BLOCKBEGIN switch_block_statements BLOCKEND .)
    TILDA           reduce using rule 158 (switch_block -> BLOCKBEGIN switch_block_statements BLOCKEND .)
    NOT             reduce using rule 158 (switch_block -> BLOCKBEGIN switch_block_statements BLOCKEND .)
    LPAREN          reduce using rule 158 (switch_block -> BLOCKBEGIN switch_block_statements BLOCKEND .)
    INT_NUMBER      reduce using rule 158 (switch_block -> BLOCKBEGIN switch_block_statements BLOCKEND .)
    BOOL_CONSTT     reduce using rule 158 (switch_block -> BLOCKBEGIN switch_block_statements BLOCKEND .)
    BOOL_CONSTF     reduce using rule 158 (switch_block -> BLOCKBEGIN switch_block_statements BLOCKEND .)
    BLOCKEND        reduce using rule 158 (switch_block -> BLOCKBEGIN switch_block_statements BLOCKEND .)
    KEYWORD_ELSE    reduce using rule 158 (switch_block -> BLOCKBEGIN switch_block_statements BLOCKEND .)


state 272

    (160) switch_block_statements -> switch_block_statements switch_block_statement . marker
    (41) marker -> . empty
    (191) empty -> .

    BLOCKEND        reduce using rule 191 (empty -> .)
    KEYWORD_CASE    reduce using rule 191 (empty -> .)

    marker                         shift and go to state 289
    empty                          shift and go to state 99

state 273

    (159) switch_block_statements -> switch_block_statement marker .

    BLOCKEND        reduce using rule 159 (switch_block_statements -> switch_block_statement marker .)
    KEYWORD_CASE    reduce using rule 159 (switch_block_statements -> switch_block_statement marker .)


state 274

    (102) variable_declaration_body -> identifiers COLON type ASOP . variable_declaration_initializer
    (97) variable_declaration_initializer -> . expression
    (98) variable_declaration_initializer -> . array_initializer
    (99) variable_declaration_initializer -> . class_initializer
    (19) expression -> . assignment_expression
    (125) array_initializer -> . KEYWORD_NEW KEYWORD_ARRAY LBRAC type RBRAC LPAREN conditional_or_expression RPAREN
    (126) array_initializer -> . KEYWORD_ARRAY LBRAC type RBRAC LPAREN argument_list RPAREN
    (127) class_initializer -> . KEYWORD_NEW name LPAREN argument_list_opt RPAREN
    (22) assignment_expression -> . assignment
    (23) assignment_expression -> . conditional_or_expression
    (24) assignment_expression -> . method_invocation
    (25) assignment -> . valid_variable assignment_operator assignment_expression
    (43) conditional_or_expression -> . conditional_and_expression
    (44) conditional_or_expression -> . conditional_or_expression OR marker conditional_and_expression
    (88) method_invocation -> . name LPAREN argument_list_opt RPAREN
    (26) valid_variable -> . name
    (27) valid_variable -> . array_access
    (45) conditional_and_expression -> . inclusive_or_expression
    (46) conditional_and_expression -> . conditional_and_expression AND marker inclusive_or_expression
    (121) name -> . simple_name
    (122) name -> . qualified_name
    (28) array_access -> . name dimension
    (47) inclusive_or_expression -> . exclusive_or_expression
    (48) inclusive_or_expression -> . inclusive_or_expression OR_BITWISE exclusive_or_expression
    (123) simple_name -> . IDENTIFIER
    (124) qualified_name -> . name INST simple_name
    (49) exclusive_or_expression -> . and_expression
    (50) exclusive_or_expression -> . exclusive_or_expression XOR and_expression
    (51) and_expression -> . equality_expression
    (52) and_expression -> . and_expression AND_BITWISE equality_expression
    (53) equality_expression -> . relational_expression
    (54) equality_expression -> . equality_expression EQUAL relational_expression
    (55) equality_expression -> . equality_expression NEQUAL relational_expression
    (56) relational_expression -> . shift_expression
    (57) relational_expression -> . relational_expression GREATER shift_expression
    (58) relational_expression -> . relational_expression LESS shift_expression
    (59) relational_expression -> . relational_expression GEQ shift_expression
    (60) relational_expression -> . relational_expression LEQ shift_expression
    (61) shift_expression -> . additive_expression
    (62) shift_expression -> . shift_expression LSHIFT additive_expression
    (63) shift_expression -> . shift_expression RSHIFT additive_expression
    (64) additive_expression -> . multiplicative_expression
    (65) additive_expression -> . additive_expression PLUS multiplicative_expression
    (66) additive_expression -> . additive_expression MINUS multiplicative_expression
    (67) multiplicative_expression -> . unary_expression
    (68) multiplicative_expression -> . multiplicative_expression TIMES unary_expression
    (69) multiplicative_expression -> . multiplicative_expression DIVIDE unary_expression
    (70) multiplicative_expression -> . multiplicative_expression REMAINDER unary_expression
    (71) unary_expression -> . PLUS unary_expression
    (72) unary_expression -> . MINUS unary_expression
    (73) unary_expression -> . unary_expression_not_plus_minus
    (74) unary_expression_not_plus_minus -> . base_variable_set
    (75) unary_expression_not_plus_minus -> . TILDA unary_expression
    (76) unary_expression_not_plus_minus -> . NOT unary_expression
    (77) base_variable_set -> . variable_literal
    (78) base_variable_set -> . LPAREN expression RPAREN
    (79) variable_literal -> . valid_variable
    (80) variable_literal -> . primary
    (81) primary -> . literal
    (82) primary -> . method_invocation
    (83) literal -> . int_float
    (84) literal -> . c_literal
    (87) int_float -> . INT_NUMBER
    (85) c_literal -> . BOOL_CONSTT
    (86) c_literal -> . BOOL_CONSTF

    KEYWORD_NEW     shift and go to state 292
    KEYWORD_ARRAY   shift and go to state 294
    IDENTIFIER      shift and go to state 9
    PLUS            shift and go to state 30
    MINUS           shift and go to state 24
    TILDA           shift and go to state 65
    NOT             shift and go to state 52
    LPAREN          shift and go to state 86
    INT_NUMBER      shift and go to state 38
    BOOL_CONSTT     shift and go to state 29
    BOOL_CONSTF     shift and go to state 25

    variable_declaration_initializer shift and go to state 290
    unary_expression               shift and go to state 39
    exclusive_or_expression        shift and go to state 56
    primary                        shift and go to state 57
    unary_expression_not_plus_minus shift and go to state 40
    array_access                   shift and go to state 23
    and_expression                 shift and go to state 79
    simple_name                    shift and go to state 60
    c_literal                      shift and go to state 85
    base_variable_set              shift and go to state 80
    valid_variable                 shift and go to state 87
    inclusive_or_expression        shift and go to state 27
    literal                        shift and go to state 64
    method_invocation              shift and go to state 134
    conditional_or_expression      shift and go to state 42
    relational_expression          shift and go to state 66
    assignment_expression          shift and go to state 83
    qualified_name                 shift and go to state 71
    assignment                     shift and go to state 137
    multiplicative_expression      shift and go to state 45
    additive_expression            shift and go to state 59
    class_initializer              shift and go to state 293
    shift_expression               shift and go to state 49
    equality_expression            shift and go to state 74
    array_initializer              shift and go to state 291
    int_float                      shift and go to state 34
    variable_literal               shift and go to state 50
    name                           shift and go to state 37
    expression                     shift and go to state 295
    conditional_and_expression     shift and go to state 51

state 275

    (120) array_data_type -> KEYWORD_ARRAY LBRAC . TYPE_INT RBRAC

    TYPE_INT        shift and go to state 296


state 276

    (142) if_then_statement -> KEYWORD_IF LPAREN expression RPAREN marker . block
    (143) if_then_else_statement -> KEYWORD_IF LPAREN expression RPAREN marker . if_then_else_intermediate narker KEYWORD_ELSE marker block
    (7) block -> . start_scope block_statements_opt end_scope
    (145) if_then_else_intermediate -> . normal_statement
    (146) if_then_else_intermediate -> . if_then_else_statement_precedence
    (8) start_scope -> . BLOCKBEGIN
    (134) normal_statement -> . block marker
    (135) normal_statement -> . expression_statement marker
    (136) normal_statement -> . empty_statement marker
    (137) normal_statement -> . return_statement marker
    (138) normal_statement -> . switch_statement marker
    (144) if_then_else_statement_precedence -> . KEYWORD_IF LPAREN expression RPAREN marker if_then_else_intermediate narker KEYWORD_ELSE marker if_then_else_intermediate
    (139) expression_statement -> . statement_expression TERMINATOR
    (163) empty_statement -> . TERMINATOR
    (164) return_statement -> . KEYWORD_RETURN expression_optional TERMINATOR
    (156) switch_statement -> . expression KEYWORD_MATCH switch_block marker
    (140) statement_expression -> . assignment
    (141) statement_expression -> . method_invocation
    (19) expression -> . assignment_expression
    (25) assignment -> . valid_variable assignment_operator assignment_expression
    (88) method_invocation -> . name LPAREN argument_list_opt RPAREN
    (22) assignment_expression -> . assignment
    (23) assignment_expression -> . conditional_or_expression
    (24) assignment_expression -> . method_invocation
    (26) valid_variable -> . name
    (27) valid_variable -> . array_access
    (121) name -> . simple_name
    (122) name -> . qualified_name
    (43) conditional_or_expression -> . conditional_and_expression
    (44) conditional_or_expression -> . conditional_or_expression OR marker conditional_and_expression
    (28) array_access -> . name dimension
    (123) simple_name -> . IDENTIFIER
    (124) qualified_name -> . name INST simple_name
    (45) conditional_and_expression -> . inclusive_or_expression
    (46) conditional_and_expression -> . conditional_and_expression AND marker inclusive_or_expression
    (47) inclusive_or_expression -> . exclusive_or_expression
    (48) inclusive_or_expression -> . inclusive_or_expression OR_BITWISE exclusive_or_expression
    (49) exclusive_or_expression -> . and_expression
    (50) exclusive_or_expression -> . exclusive_or_expression XOR and_expression
    (51) and_expression -> . equality_expression
    (52) and_expression -> . and_expression AND_BITWISE equality_expression
    (53) equality_expression -> . relational_expression
    (54) equality_expression -> . equality_expression EQUAL relational_expression
    (55) equality_expression -> . equality_expression NEQUAL relational_expression
    (56) relational_expression -> . shift_expression
    (57) relational_expression -> . relational_expression GREATER shift_expression
    (58) relational_expression -> . relational_expression LESS shift_expression
    (59) relational_expression -> . relational_expression GEQ shift_expression
    (60) relational_expression -> . relational_expression LEQ shift_expression
    (61) shift_expression -> . additive_expression
    (62) shift_expression -> . shift_expression LSHIFT additive_expression
    (63) shift_expression -> . shift_expression RSHIFT additive_expression
    (64) additive_expression -> . multiplicative_expression
    (65) additive_expression -> . additive_expression PLUS multiplicative_expression
    (66) additive_expression -> . additive_expression MINUS multiplicative_expression
    (67) multiplicative_expression -> . unary_expression
    (68) multiplicative_expression -> . multiplicative_expression TIMES unary_expression
    (69) multiplicative_expression -> . multiplicative_expression DIVIDE unary_expression
    (70) multiplicative_expression -> . multiplicative_expression REMAINDER unary_expression
    (71) unary_expression -> . PLUS unary_expression
    (72) unary_expression -> . MINUS unary_expression
    (73) unary_expression -> . unary_expression_not_plus_minus
    (74) unary_expression_not_plus_minus -> . base_variable_set
    (75) unary_expression_not_plus_minus -> . TILDA unary_expression
    (76) unary_expression_not_plus_minus -> . NOT unary_expression
    (77) base_variable_set -> . variable_literal
    (78) base_variable_set -> . LPAREN expression RPAREN
    (79) variable_literal -> . valid_variable
    (80) variable_literal -> . primary
    (81) primary -> . literal
    (82) primary -> . method_invocation
    (83) literal -> . int_float
    (84) literal -> . c_literal
    (87) int_float -> . INT_NUMBER
    (85) c_literal -> . BOOL_CONSTT
    (86) c_literal -> . BOOL_CONSTF

    BLOCKBEGIN      shift and go to state 12
    KEYWORD_IF      shift and go to state 300
    TERMINATOR      shift and go to state 48
    KEYWORD_RETURN  shift and go to state 61
    IDENTIFIER      shift and go to state 9
    PLUS            shift and go to state 30
    MINUS           shift and go to state 24
    TILDA           shift and go to state 65
    NOT             shift and go to state 52
    LPAREN          shift and go to state 86
    INT_NUMBER      shift and go to state 38
    BOOL_CONSTT     shift and go to state 29
    BOOL_CONSTF     shift and go to state 25

    expression_statement           shift and go to state 22
    if_then_else_statement_precedence shift and go to state 297
    unary_expression               shift and go to state 39
    exclusive_or_expression        shift and go to state 56
    normal_statement               shift and go to state 298
    primary                        shift and go to state 57
    unary_expression_not_plus_minus shift and go to state 40
    if_then_else_intermediate      shift and go to state 299
    array_access                   shift and go to state 23
    switch_statement               shift and go to state 41
    simple_name                    shift and go to state 60
    qualified_name                 shift and go to state 71
    base_variable_set              shift and go to state 80
    inclusive_or_expression        shift and go to state 27
    return_statement               shift and go to state 81
    literal                        shift and go to state 64
    and_expression                 shift and go to state 79
    statement_expression           shift and go to state 31
    method_invocation              shift and go to state 68
    conditional_or_expression      shift and go to state 42
    relational_expression          shift and go to state 66
    assignment_expression          shift and go to state 83
    assignment                     shift and go to state 84
    multiplicative_expression      shift and go to state 45
    c_literal                      shift and go to state 85
    additive_expression            shift and go to state 59
    start_scope                    shift and go to state 13
    shift_expression               shift and go to state 49
    equality_expression            shift and go to state 74
    int_float                      shift and go to state 34
    variable_literal               shift and go to state 50
    name                           shift and go to state 37
    valid_variable                 shift and go to state 87
    empty_statement                shift and go to state 76
    expression                     shift and go to state 53
    conditional_and_expression     shift and go to state 51
    block                          shift and go to state 301

state 277

    (154) for_step_opts -> KEYWORD_BY . expression
    (19) expression -> . assignment_expression
    (22) assignment_expression -> . assignment
    (23) assignment_expression -> . conditional_or_expression
    (24) assignment_expression -> . method_invocation
    (25) assignment -> . valid_variable assignment_operator assignment_expression
    (43) conditional_or_expression -> . conditional_and_expression
    (44) conditional_or_expression -> . conditional_or_expression OR marker conditional_and_expression
    (88) method_invocation -> . name LPAREN argument_list_opt RPAREN
    (26) valid_variable -> . name
    (27) valid_variable -> . array_access
    (45) conditional_and_expression -> . inclusive_or_expression
    (46) conditional_and_expression -> . conditional_and_expression AND marker inclusive_or_expression
    (121) name -> . simple_name
    (122) name -> . qualified_name
    (28) array_access -> . name dimension
    (47) inclusive_or_expression -> . exclusive_or_expression
    (48) inclusive_or_expression -> . inclusive_or_expression OR_BITWISE exclusive_or_expression
    (123) simple_name -> . IDENTIFIER
    (124) qualified_name -> . name INST simple_name
    (49) exclusive_or_expression -> . and_expression
    (50) exclusive_or_expression -> . exclusive_or_expression XOR and_expression
    (51) and_expression -> . equality_expression
    (52) and_expression -> . and_expression AND_BITWISE equality_expression
    (53) equality_expression -> . relational_expression
    (54) equality_expression -> . equality_expression EQUAL relational_expression
    (55) equality_expression -> . equality_expression NEQUAL relational_expression
    (56) relational_expression -> . shift_expression
    (57) relational_expression -> . relational_expression GREATER shift_expression
    (58) relational_expression -> . relational_expression LESS shift_expression
    (59) relational_expression -> . relational_expression GEQ shift_expression
    (60) relational_expression -> . relational_expression LEQ shift_expression
    (61) shift_expression -> . additive_expression
    (62) shift_expression -> . shift_expression LSHIFT additive_expression
    (63) shift_expression -> . shift_expression RSHIFT additive_expression
    (64) additive_expression -> . multiplicative_expression
    (65) additive_expression -> . additive_expression PLUS multiplicative_expression
    (66) additive_expression -> . additive_expression MINUS multiplicative_expression
    (67) multiplicative_expression -> . unary_expression
    (68) multiplicative_expression -> . multiplicative_expression TIMES unary_expression
    (69) multiplicative_expression -> . multiplicative_expression DIVIDE unary_expression
    (70) multiplicative_expression -> . multiplicative_expression REMAINDER unary_expression
    (71) unary_expression -> . PLUS unary_expression
    (72) unary_expression -> . MINUS unary_expression
    (73) unary_expression -> . unary_expression_not_plus_minus
    (74) unary_expression_not_plus_minus -> . base_variable_set
    (75) unary_expression_not_plus_minus -> . TILDA unary_expression
    (76) unary_expression_not_plus_minus -> . NOT unary_expression
    (77) base_variable_set -> . variable_literal
    (78) base_variable_set -> . LPAREN expression RPAREN
    (79) variable_literal -> . valid_variable
    (80) variable_literal -> . primary
    (81) primary -> . literal
    (82) primary -> . method_invocation
    (83) literal -> . int_float
    (84) literal -> . c_literal
    (87) int_float -> . INT_NUMBER
    (85) c_literal -> . BOOL_CONSTT
    (86) c_literal -> . BOOL_CONSTF

    IDENTIFIER      shift and go to state 9
    PLUS            shift and go to state 30
    MINUS           shift and go to state 24
    TILDA           shift and go to state 65
    NOT             shift and go to state 52
    LPAREN          shift and go to state 86
    INT_NUMBER      shift and go to state 38
    BOOL_CONSTT     shift and go to state 29
    BOOL_CONSTF     shift and go to state 25

    and_expression                 shift and go to state 79
    exclusive_or_expression        shift and go to state 56
    primary                        shift and go to state 57
    unary_expression_not_plus_minus shift and go to state 40
    array_access                   shift and go to state 23
    additive_expression            shift and go to state 59
    simple_name                    shift and go to state 60
    c_literal                      shift and go to state 85
    unary_expression               shift and go to state 39
    base_variable_set              shift and go to state 80
    valid_variable                 shift and go to state 87
    inclusive_or_expression        shift and go to state 27
    literal                        shift and go to state 64
    relational_expression          shift and go to state 66
    method_invocation              shift and go to state 134
    conditional_or_expression      shift and go to state 42
    assignment_expression          shift and go to state 83
    qualified_name                 shift and go to state 71
    assignment                     shift and go to state 137
    multiplicative_expression      shift and go to state 45
    shift_expression               shift and go to state 49
    equality_expression            shift and go to state 74
    int_float                      shift and go to state 34
    variable_literal               shift and go to state 50
    name                           shift and go to state 37
    expression                     shift and go to state 302
    conditional_and_expression     shift and go to state 51

state 278

    (150) for_update -> for_loop marker for_step_opts .

    RPAREN          reduce using rule 150 (for_update -> for_loop marker for_step_opts .)


state 279

    (155) for_step_opts -> empty .

    RPAREN          reduce using rule 155 (for_step_opts -> empty .)


state 280

    (149) for_statement -> KEYWORD_FOR LPAREN for_update RPAREN marker . block
    (7) block -> . start_scope block_statements_opt end_scope
    (8) start_scope -> . BLOCKBEGIN

    BLOCKBEGIN      shift and go to state 12

    start_scope                    shift and go to state 13
    block                          shift and go to state 303

state 281

    (151) for_loop -> IDENTIFIER CHOOSE expression . for_untilTo marker expression
    (152) for_untilTo -> . KEYWORD_UNTIL
    (153) for_untilTo -> . KEYWORD_TO

    KEYWORD_UNTIL   shift and go to state 306
    KEYWORD_TO      shift and go to state 305

    for_untilTo                    shift and go to state 304

state 282

    (148) do_while_statement -> KEYWORD_DO marker block KEYWORD_WHILE LPAREN . marker expression RPAREN TERMINATOR
    (41) marker -> . empty
    (191) empty -> .

    IDENTIFIER      reduce using rule 191 (empty -> .)
    PLUS            reduce using rule 191 (empty -> .)
    MINUS           reduce using rule 191 (empty -> .)
    TILDA           reduce using rule 191 (empty -> .)
    NOT             reduce using rule 191 (empty -> .)
    LPAREN          reduce using rule 191 (empty -> .)
    INT_NUMBER      reduce using rule 191 (empty -> .)
    BOOL_CONSTT     reduce using rule 191 (empty -> .)
    BOOL_CONSTF     reduce using rule 191 (empty -> .)

    marker                         shift and go to state 307
    empty                          shift and go to state 99

state 283

    (173) method_return_type -> TYPE_VOID .
    (116) primitive_type -> TYPE_VOID .

  ! reduce/reduce conflict for ASOP resolved using rule 116 (primitive_type -> TYPE_VOID .)
    ASOP            reduce using rule 116 (primitive_type -> TYPE_VOID .)

  ! ASOP            [ reduce using rule 173 (method_return_type -> TYPE_VOID .) ]


state 284

    (172) method_return_type -> type .

    ASOP            reduce using rule 172 (method_return_type -> type .)


state 285

    (166) method_header -> method_header_name func_arg_start fun_params_opt RPAREN COLON method_return_type . ASOP

    ASOP            shift and go to state 308


state 286

    (147) while_statement -> KEYWORD_WHILE LPAREN marker expression RPAREN marker . block
    (7) block -> . start_scope block_statements_opt end_scope
    (8) start_scope -> . BLOCKBEGIN

    BLOCKBEGIN      shift and go to state 12

    start_scope                    shift and go to state 13
    block                          shift and go to state 309

state 287

    (161) switch_block_statement -> switch_label narker marker . block narker
    (7) block -> . start_scope block_statements_opt end_scope
    (8) start_scope -> . BLOCKBEGIN

    BLOCKBEGIN      shift and go to state 12

    start_scope                    shift and go to state 13
    block                          shift and go to state 310

state 288

    (162) switch_label -> KEYWORD_CASE expression FUNTYPE .

    BLOCKBEGIN      reduce using rule 162 (switch_label -> KEYWORD_CASE expression FUNTYPE .)


state 289

    (160) switch_block_statements -> switch_block_statements switch_block_statement marker .

    BLOCKEND        reduce using rule 160 (switch_block_statements -> switch_block_statements switch_block_statement marker .)
    KEYWORD_CASE    reduce using rule 160 (switch_block_statements -> switch_block_statements switch_block_statement marker .)


state 290

    (102) variable_declaration_body -> identifiers COLON type ASOP variable_declaration_initializer .

    TERMINATOR      reduce using rule 102 (variable_declaration_body -> identifiers COLON type ASOP variable_declaration_initializer .)


state 291

    (98) variable_declaration_initializer -> array_initializer .

    TERMINATOR      reduce using rule 98 (variable_declaration_initializer -> array_initializer .)


state 292

    (125) array_initializer -> KEYWORD_NEW . KEYWORD_ARRAY LBRAC type RBRAC LPAREN conditional_or_expression RPAREN
    (127) class_initializer -> KEYWORD_NEW . name LPAREN argument_list_opt RPAREN
    (121) name -> . simple_name
    (122) name -> . qualified_name
    (123) simple_name -> . IDENTIFIER
    (124) qualified_name -> . name INST simple_name

    KEYWORD_ARRAY   shift and go to state 311
    IDENTIFIER      shift and go to state 9

    name                           shift and go to state 312
    qualified_name                 shift and go to state 71
    simple_name                    shift and go to state 60

state 293

    (99) variable_declaration_initializer -> class_initializer .

    TERMINATOR      reduce using rule 99 (variable_declaration_initializer -> class_initializer .)


state 294

    (126) array_initializer -> KEYWORD_ARRAY . LBRAC type RBRAC LPAREN argument_list RPAREN

    LBRAC           shift and go to state 313


state 295

    (97) variable_declaration_initializer -> expression .

    TERMINATOR      reduce using rule 97 (variable_declaration_initializer -> expression .)


state 296

    (120) array_data_type -> KEYWORD_ARRAY LBRAC TYPE_INT . RBRAC

    RBRAC           shift and go to state 314


state 297

    (146) if_then_else_intermediate -> if_then_else_statement_precedence .

    KEYWORD_ELSE    reduce using rule 146 (if_then_else_intermediate -> if_then_else_statement_precedence .)


state 298

    (145) if_then_else_intermediate -> normal_statement .

    KEYWORD_ELSE    reduce using rule 145 (if_then_else_intermediate -> normal_statement .)


state 299

    (143) if_then_else_statement -> KEYWORD_IF LPAREN expression RPAREN marker if_then_else_intermediate . narker KEYWORD_ELSE marker block
    (42) narker -> . empty
    (191) empty -> .

    KEYWORD_ELSE    reduce using rule 191 (empty -> .)

    narker                         shift and go to state 315
    empty                          shift and go to state 268

state 300

    (144) if_then_else_statement_precedence -> KEYWORD_IF . LPAREN expression RPAREN marker if_then_else_intermediate narker KEYWORD_ELSE marker if_then_else_intermediate

    LPAREN          shift and go to state 316


state 301

    (142) if_then_statement -> KEYWORD_IF LPAREN expression RPAREN marker block .
    (134) normal_statement -> block . marker
    (41) marker -> . empty
    (191) empty -> .

    KEYWORD_IF      reduce using rule 142 (if_then_statement -> KEYWORD_IF LPAREN expression RPAREN marker block .)
    KEYWORD_WHILE   reduce using rule 142 (if_then_statement -> KEYWORD_IF LPAREN expression RPAREN marker block .)
    KEYWORD_DO      reduce using rule 142 (if_then_statement -> KEYWORD_IF LPAREN expression RPAREN marker block .)
    KEYWORD_FOR     reduce using rule 142 (if_then_statement -> KEYWORD_IF LPAREN expression RPAREN marker block .)
    KEYWORD_CLASS   reduce using rule 142 (if_then_statement -> KEYWORD_IF LPAREN expression RPAREN marker block .)
    KEYWORD_OBJECT  reduce using rule 142 (if_then_statement -> KEYWORD_IF LPAREN expression RPAREN marker block .)
    KEYWORD_VAR     reduce using rule 142 (if_then_statement -> KEYWORD_IF LPAREN expression RPAREN marker block .)
    KEYWORD_VAL     reduce using rule 142 (if_then_statement -> KEYWORD_IF LPAREN expression RPAREN marker block .)
    TERMINATOR      reduce using rule 142 (if_then_statement -> KEYWORD_IF LPAREN expression RPAREN marker block .)
    KEYWORD_RETURN  reduce using rule 142 (if_then_statement -> KEYWORD_IF LPAREN expression RPAREN marker block .)
    KEYWORD_DEF     reduce using rule 142 (if_then_statement -> KEYWORD_IF LPAREN expression RPAREN marker block .)
    BLOCKBEGIN      reduce using rule 142 (if_then_statement -> KEYWORD_IF LPAREN expression RPAREN marker block .)
    IDENTIFIER      reduce using rule 142 (if_then_statement -> KEYWORD_IF LPAREN expression RPAREN marker block .)
    PLUS            reduce using rule 142 (if_then_statement -> KEYWORD_IF LPAREN expression RPAREN marker block .)
    MINUS           reduce using rule 142 (if_then_statement -> KEYWORD_IF LPAREN expression RPAREN marker block .)
    TILDA           reduce using rule 142 (if_then_statement -> KEYWORD_IF LPAREN expression RPAREN marker block .)
    NOT             reduce using rule 142 (if_then_statement -> KEYWORD_IF LPAREN expression RPAREN marker block .)
    LPAREN          reduce using rule 142 (if_then_statement -> KEYWORD_IF LPAREN expression RPAREN marker block .)
    INT_NUMBER      reduce using rule 142 (if_then_statement -> KEYWORD_IF LPAREN expression RPAREN marker block .)
    BOOL_CONSTT     reduce using rule 142 (if_then_statement -> KEYWORD_IF LPAREN expression RPAREN marker block .)
    BOOL_CONSTF     reduce using rule 142 (if_then_statement -> KEYWORD_IF LPAREN expression RPAREN marker block .)
    BLOCKEND        reduce using rule 142 (if_then_statement -> KEYWORD_IF LPAREN expression RPAREN marker block .)
    KEYWORD_ELSE    reduce using rule 191 (empty -> .)

    marker                         shift and go to state 128
    empty                          shift and go to state 99

state 302

    (154) for_step_opts -> KEYWORD_BY expression .

    RPAREN          reduce using rule 154 (for_step_opts -> KEYWORD_BY expression .)


state 303

    (149) for_statement -> KEYWORD_FOR LPAREN for_update RPAREN marker block .

    KEYWORD_IF      reduce using rule 149 (for_statement -> KEYWORD_FOR LPAREN for_update RPAREN marker block .)
    KEYWORD_WHILE   reduce using rule 149 (for_statement -> KEYWORD_FOR LPAREN for_update RPAREN marker block .)
    KEYWORD_DO      reduce using rule 149 (for_statement -> KEYWORD_FOR LPAREN for_update RPAREN marker block .)
    KEYWORD_FOR     reduce using rule 149 (for_statement -> KEYWORD_FOR LPAREN for_update RPAREN marker block .)
    KEYWORD_CLASS   reduce using rule 149 (for_statement -> KEYWORD_FOR LPAREN for_update RPAREN marker block .)
    KEYWORD_OBJECT  reduce using rule 149 (for_statement -> KEYWORD_FOR LPAREN for_update RPAREN marker block .)
    KEYWORD_VAR     reduce using rule 149 (for_statement -> KEYWORD_FOR LPAREN for_update RPAREN marker block .)
    KEYWORD_VAL     reduce using rule 149 (for_statement -> KEYWORD_FOR LPAREN for_update RPAREN marker block .)
    TERMINATOR      reduce using rule 149 (for_statement -> KEYWORD_FOR LPAREN for_update RPAREN marker block .)
    KEYWORD_RETURN  reduce using rule 149 (for_statement -> KEYWORD_FOR LPAREN for_update RPAREN marker block .)
    KEYWORD_DEF     reduce using rule 149 (for_statement -> KEYWORD_FOR LPAREN for_update RPAREN marker block .)
    BLOCKBEGIN      reduce using rule 149 (for_statement -> KEYWORD_FOR LPAREN for_update RPAREN marker block .)
    IDENTIFIER      reduce using rule 149 (for_statement -> KEYWORD_FOR LPAREN for_update RPAREN marker block .)
    PLUS            reduce using rule 149 (for_statement -> KEYWORD_FOR LPAREN for_update RPAREN marker block .)
    MINUS           reduce using rule 149 (for_statement -> KEYWORD_FOR LPAREN for_update RPAREN marker block .)
    TILDA           reduce using rule 149 (for_statement -> KEYWORD_FOR LPAREN for_update RPAREN marker block .)
    NOT             reduce using rule 149 (for_statement -> KEYWORD_FOR LPAREN for_update RPAREN marker block .)
    LPAREN          reduce using rule 149 (for_statement -> KEYWORD_FOR LPAREN for_update RPAREN marker block .)
    INT_NUMBER      reduce using rule 149 (for_statement -> KEYWORD_FOR LPAREN for_update RPAREN marker block .)
    BOOL_CONSTT     reduce using rule 149 (for_statement -> KEYWORD_FOR LPAREN for_update RPAREN marker block .)
    BOOL_CONSTF     reduce using rule 149 (for_statement -> KEYWORD_FOR LPAREN for_update RPAREN marker block .)
    BLOCKEND        reduce using rule 149 (for_statement -> KEYWORD_FOR LPAREN for_update RPAREN marker block .)


state 304

    (151) for_loop -> IDENTIFIER CHOOSE expression for_untilTo . marker expression
    (41) marker -> . empty
    (191) empty -> .

    IDENTIFIER      reduce using rule 191 (empty -> .)
    PLUS            reduce using rule 191 (empty -> .)
    MINUS           reduce using rule 191 (empty -> .)
    TILDA           reduce using rule 191 (empty -> .)
    NOT             reduce using rule 191 (empty -> .)
    LPAREN          reduce using rule 191 (empty -> .)
    INT_NUMBER      reduce using rule 191 (empty -> .)
    BOOL_CONSTT     reduce using rule 191 (empty -> .)
    BOOL_CONSTF     reduce using rule 191 (empty -> .)

    marker                         shift and go to state 317
    empty                          shift and go to state 99

state 305

    (153) for_untilTo -> KEYWORD_TO .

    IDENTIFIER      reduce using rule 153 (for_untilTo -> KEYWORD_TO .)
    PLUS            reduce using rule 153 (for_untilTo -> KEYWORD_TO .)
    MINUS           reduce using rule 153 (for_untilTo -> KEYWORD_TO .)
    TILDA           reduce using rule 153 (for_untilTo -> KEYWORD_TO .)
    NOT             reduce using rule 153 (for_untilTo -> KEYWORD_TO .)
    LPAREN          reduce using rule 153 (for_untilTo -> KEYWORD_TO .)
    INT_NUMBER      reduce using rule 153 (for_untilTo -> KEYWORD_TO .)
    BOOL_CONSTT     reduce using rule 153 (for_untilTo -> KEYWORD_TO .)
    BOOL_CONSTF     reduce using rule 153 (for_untilTo -> KEYWORD_TO .)


state 306

    (152) for_untilTo -> KEYWORD_UNTIL .

    IDENTIFIER      reduce using rule 152 (for_untilTo -> KEYWORD_UNTIL .)
    PLUS            reduce using rule 152 (for_untilTo -> KEYWORD_UNTIL .)
    MINUS           reduce using rule 152 (for_untilTo -> KEYWORD_UNTIL .)
    TILDA           reduce using rule 152 (for_untilTo -> KEYWORD_UNTIL .)
    NOT             reduce using rule 152 (for_untilTo -> KEYWORD_UNTIL .)
    LPAREN          reduce using rule 152 (for_untilTo -> KEYWORD_UNTIL .)
    INT_NUMBER      reduce using rule 152 (for_untilTo -> KEYWORD_UNTIL .)
    BOOL_CONSTT     reduce using rule 152 (for_untilTo -> KEYWORD_UNTIL .)
    BOOL_CONSTF     reduce using rule 152 (for_untilTo -> KEYWORD_UNTIL .)


state 307

    (148) do_while_statement -> KEYWORD_DO marker block KEYWORD_WHILE LPAREN marker . expression RPAREN TERMINATOR
    (19) expression -> . assignment_expression
    (22) assignment_expression -> . assignment
    (23) assignment_expression -> . conditional_or_expression
    (24) assignment_expression -> . method_invocation
    (25) assignment -> . valid_variable assignment_operator assignment_expression
    (43) conditional_or_expression -> . conditional_and_expression
    (44) conditional_or_expression -> . conditional_or_expression OR marker conditional_and_expression
    (88) method_invocation -> . name LPAREN argument_list_opt RPAREN
    (26) valid_variable -> . name
    (27) valid_variable -> . array_access
    (45) conditional_and_expression -> . inclusive_or_expression
    (46) conditional_and_expression -> . conditional_and_expression AND marker inclusive_or_expression
    (121) name -> . simple_name
    (122) name -> . qualified_name
    (28) array_access -> . name dimension
    (47) inclusive_or_expression -> . exclusive_or_expression
    (48) inclusive_or_expression -> . inclusive_or_expression OR_BITWISE exclusive_or_expression
    (123) simple_name -> . IDENTIFIER
    (124) qualified_name -> . name INST simple_name
    (49) exclusive_or_expression -> . and_expression
    (50) exclusive_or_expression -> . exclusive_or_expression XOR and_expression
    (51) and_expression -> . equality_expression
    (52) and_expression -> . and_expression AND_BITWISE equality_expression
    (53) equality_expression -> . relational_expression
    (54) equality_expression -> . equality_expression EQUAL relational_expression
    (55) equality_expression -> . equality_expression NEQUAL relational_expression
    (56) relational_expression -> . shift_expression
    (57) relational_expression -> . relational_expression GREATER shift_expression
    (58) relational_expression -> . relational_expression LESS shift_expression
    (59) relational_expression -> . relational_expression GEQ shift_expression
    (60) relational_expression -> . relational_expression LEQ shift_expression
    (61) shift_expression -> . additive_expression
    (62) shift_expression -> . shift_expression LSHIFT additive_expression
    (63) shift_expression -> . shift_expression RSHIFT additive_expression
    (64) additive_expression -> . multiplicative_expression
    (65) additive_expression -> . additive_expression PLUS multiplicative_expression
    (66) additive_expression -> . additive_expression MINUS multiplicative_expression
    (67) multiplicative_expression -> . unary_expression
    (68) multiplicative_expression -> . multiplicative_expression TIMES unary_expression
    (69) multiplicative_expression -> . multiplicative_expression DIVIDE unary_expression
    (70) multiplicative_expression -> . multiplicative_expression REMAINDER unary_expression
    (71) unary_expression -> . PLUS unary_expression
    (72) unary_expression -> . MINUS unary_expression
    (73) unary_expression -> . unary_expression_not_plus_minus
    (74) unary_expression_not_plus_minus -> . base_variable_set
    (75) unary_expression_not_plus_minus -> . TILDA unary_expression
    (76) unary_expression_not_plus_minus -> . NOT unary_expression
    (77) base_variable_set -> . variable_literal
    (78) base_variable_set -> . LPAREN expression RPAREN
    (79) variable_literal -> . valid_variable
    (80) variable_literal -> . primary
    (81) primary -> . literal
    (82) primary -> . method_invocation
    (83) literal -> . int_float
    (84) literal -> . c_literal
    (87) int_float -> . INT_NUMBER
    (85) c_literal -> . BOOL_CONSTT
    (86) c_literal -> . BOOL_CONSTF

    IDENTIFIER      shift and go to state 9
    PLUS            shift and go to state 30
    MINUS           shift and go to state 24
    TILDA           shift and go to state 65
    NOT             shift and go to state 52
    LPAREN          shift and go to state 86
    INT_NUMBER      shift and go to state 38
    BOOL_CONSTT     shift and go to state 29
    BOOL_CONSTF     shift and go to state 25

    unary_expression               shift and go to state 39
    exclusive_or_expression        shift and go to state 56
    primary                        shift and go to state 57
    unary_expression_not_plus_minus shift and go to state 40
    array_access                   shift and go to state 23
    and_expression                 shift and go to state 79
    simple_name                    shift and go to state 60
    c_literal                      shift and go to state 85
    base_variable_set              shift and go to state 80
    valid_variable                 shift and go to state 87
    inclusive_or_expression        shift and go to state 27
    literal                        shift and go to state 64
    relational_expression          shift and go to state 66
    method_invocation              shift and go to state 134
    conditional_or_expression      shift and go to state 42
    assignment_expression          shift and go to state 83
    qualified_name                 shift and go to state 71
    assignment                     shift and go to state 137
    multiplicative_expression      shift and go to state 45
    additive_expression            shift and go to state 59
    shift_expression               shift and go to state 49
    equality_expression            shift and go to state 74
    int_float                      shift and go to state 34
    variable_literal               shift and go to state 50
    name                           shift and go to state 37
    expression                     shift and go to state 318
    conditional_and_expression     shift and go to state 51

state 308

    (166) method_header -> method_header_name func_arg_start fun_params_opt RPAREN COLON method_return_type ASOP .

    BLOCKBEGIN      reduce using rule 166 (method_header -> method_header_name func_arg_start fun_params_opt RPAREN COLON method_return_type ASOP .)


state 309

    (147) while_statement -> KEYWORD_WHILE LPAREN marker expression RPAREN marker block .

    KEYWORD_IF      reduce using rule 147 (while_statement -> KEYWORD_WHILE LPAREN marker expression RPAREN marker block .)
    KEYWORD_WHILE   reduce using rule 147 (while_statement -> KEYWORD_WHILE LPAREN marker expression RPAREN marker block .)
    KEYWORD_DO      reduce using rule 147 (while_statement -> KEYWORD_WHILE LPAREN marker expression RPAREN marker block .)
    KEYWORD_FOR     reduce using rule 147 (while_statement -> KEYWORD_WHILE LPAREN marker expression RPAREN marker block .)
    KEYWORD_CLASS   reduce using rule 147 (while_statement -> KEYWORD_WHILE LPAREN marker expression RPAREN marker block .)
    KEYWORD_OBJECT  reduce using rule 147 (while_statement -> KEYWORD_WHILE LPAREN marker expression RPAREN marker block .)
    KEYWORD_VAR     reduce using rule 147 (while_statement -> KEYWORD_WHILE LPAREN marker expression RPAREN marker block .)
    KEYWORD_VAL     reduce using rule 147 (while_statement -> KEYWORD_WHILE LPAREN marker expression RPAREN marker block .)
    TERMINATOR      reduce using rule 147 (while_statement -> KEYWORD_WHILE LPAREN marker expression RPAREN marker block .)
    KEYWORD_RETURN  reduce using rule 147 (while_statement -> KEYWORD_WHILE LPAREN marker expression RPAREN marker block .)
    KEYWORD_DEF     reduce using rule 147 (while_statement -> KEYWORD_WHILE LPAREN marker expression RPAREN marker block .)
    BLOCKBEGIN      reduce using rule 147 (while_statement -> KEYWORD_WHILE LPAREN marker expression RPAREN marker block .)
    IDENTIFIER      reduce using rule 147 (while_statement -> KEYWORD_WHILE LPAREN marker expression RPAREN marker block .)
    PLUS            reduce using rule 147 (while_statement -> KEYWORD_WHILE LPAREN marker expression RPAREN marker block .)
    MINUS           reduce using rule 147 (while_statement -> KEYWORD_WHILE LPAREN marker expression RPAREN marker block .)
    TILDA           reduce using rule 147 (while_statement -> KEYWORD_WHILE LPAREN marker expression RPAREN marker block .)
    NOT             reduce using rule 147 (while_statement -> KEYWORD_WHILE LPAREN marker expression RPAREN marker block .)
    LPAREN          reduce using rule 147 (while_statement -> KEYWORD_WHILE LPAREN marker expression RPAREN marker block .)
    INT_NUMBER      reduce using rule 147 (while_statement -> KEYWORD_WHILE LPAREN marker expression RPAREN marker block .)
    BOOL_CONSTT     reduce using rule 147 (while_statement -> KEYWORD_WHILE LPAREN marker expression RPAREN marker block .)
    BOOL_CONSTF     reduce using rule 147 (while_statement -> KEYWORD_WHILE LPAREN marker expression RPAREN marker block .)
    BLOCKEND        reduce using rule 147 (while_statement -> KEYWORD_WHILE LPAREN marker expression RPAREN marker block .)


state 310

    (161) switch_block_statement -> switch_label narker marker block . narker
    (42) narker -> . empty
    (191) empty -> .

    BLOCKEND        reduce using rule 191 (empty -> .)
    KEYWORD_CASE    reduce using rule 191 (empty -> .)

    empty                          shift and go to state 268
    narker                         shift and go to state 319

state 311

    (125) array_initializer -> KEYWORD_NEW KEYWORD_ARRAY . LBRAC type RBRAC LPAREN conditional_or_expression RPAREN

    LBRAC           shift and go to state 320


state 312

    (127) class_initializer -> KEYWORD_NEW name . LPAREN argument_list_opt RPAREN
    (124) qualified_name -> name . INST simple_name

    LPAREN          shift and go to state 321
    INST            shift and go to state 113


state 313

    (126) array_initializer -> KEYWORD_ARRAY LBRAC . type RBRAC LPAREN argument_list RPAREN
    (109) type -> . primitive_type
    (110) type -> . reference_type
    (111) primitive_type -> . TYPE_INT
    (112) primitive_type -> . TYPE_DOUBLE
    (113) primitive_type -> . TYPE_CHAR
    (114) primitive_type -> . TYPE_STRING
    (115) primitive_type -> . TYPE_BOOLEAN
    (116) primitive_type -> . TYPE_VOID
    (117) reference_type -> . class_data_type
    (118) reference_type -> . array_data_type
    (119) class_data_type -> . name
    (120) array_data_type -> . KEYWORD_ARRAY LBRAC TYPE_INT RBRAC
    (121) name -> . simple_name
    (122) name -> . qualified_name
    (123) simple_name -> . IDENTIFIER
    (124) qualified_name -> . name INST simple_name

    TYPE_INT        shift and go to state 242
    TYPE_DOUBLE     shift and go to state 250
    TYPE_CHAR       shift and go to state 251
    TYPE_STRING     shift and go to state 243
    TYPE_BOOLEAN    shift and go to state 249
    TYPE_VOID       shift and go to state 244
    KEYWORD_ARRAY   shift and go to state 254
    IDENTIFIER      shift and go to state 9

    name                           shift and go to state 253
    qualified_name                 shift and go to state 71
    reference_type                 shift and go to state 246
    primitive_type                 shift and go to state 247
    simple_name                    shift and go to state 60
    type                           shift and go to state 322
    array_data_type                shift and go to state 252
    class_data_type                shift and go to state 245

state 314

    (120) array_data_type -> KEYWORD_ARRAY LBRAC TYPE_INT RBRAC .

    RBRAC           reduce using rule 120 (array_data_type -> KEYWORD_ARRAY LBRAC TYPE_INT RBRAC .)
    COMMA           reduce using rule 120 (array_data_type -> KEYWORD_ARRAY LBRAC TYPE_INT RBRAC .)
    RPAREN          reduce using rule 120 (array_data_type -> KEYWORD_ARRAY LBRAC TYPE_INT RBRAC .)
    ASOP            reduce using rule 120 (array_data_type -> KEYWORD_ARRAY LBRAC TYPE_INT RBRAC .)


state 315

    (143) if_then_else_statement -> KEYWORD_IF LPAREN expression RPAREN marker if_then_else_intermediate narker . KEYWORD_ELSE marker block

    KEYWORD_ELSE    shift and go to state 323


state 316

    (144) if_then_else_statement_precedence -> KEYWORD_IF LPAREN . expression RPAREN marker if_then_else_intermediate narker KEYWORD_ELSE marker if_then_else_intermediate
    (19) expression -> . assignment_expression
    (22) assignment_expression -> . assignment
    (23) assignment_expression -> . conditional_or_expression
    (24) assignment_expression -> . method_invocation
    (25) assignment -> . valid_variable assignment_operator assignment_expression
    (43) conditional_or_expression -> . conditional_and_expression
    (44) conditional_or_expression -> . conditional_or_expression OR marker conditional_and_expression
    (88) method_invocation -> . name LPAREN argument_list_opt RPAREN
    (26) valid_variable -> . name
    (27) valid_variable -> . array_access
    (45) conditional_and_expression -> . inclusive_or_expression
    (46) conditional_and_expression -> . conditional_and_expression AND marker inclusive_or_expression
    (121) name -> . simple_name
    (122) name -> . qualified_name
    (28) array_access -> . name dimension
    (47) inclusive_or_expression -> . exclusive_or_expression
    (48) inclusive_or_expression -> . inclusive_or_expression OR_BITWISE exclusive_or_expression
    (123) simple_name -> . IDENTIFIER
    (124) qualified_name -> . name INST simple_name
    (49) exclusive_or_expression -> . and_expression
    (50) exclusive_or_expression -> . exclusive_or_expression XOR and_expression
    (51) and_expression -> . equality_expression
    (52) and_expression -> . and_expression AND_BITWISE equality_expression
    (53) equality_expression -> . relational_expression
    (54) equality_expression -> . equality_expression EQUAL relational_expression
    (55) equality_expression -> . equality_expression NEQUAL relational_expression
    (56) relational_expression -> . shift_expression
    (57) relational_expression -> . relational_expression GREATER shift_expression
    (58) relational_expression -> . relational_expression LESS shift_expression
    (59) relational_expression -> . relational_expression GEQ shift_expression
    (60) relational_expression -> . relational_expression LEQ shift_expression
    (61) shift_expression -> . additive_expression
    (62) shift_expression -> . shift_expression LSHIFT additive_expression
    (63) shift_expression -> . shift_expression RSHIFT additive_expression
    (64) additive_expression -> . multiplicative_expression
    (65) additive_expression -> . additive_expression PLUS multiplicative_expression
    (66) additive_expression -> . additive_expression MINUS multiplicative_expression
    (67) multiplicative_expression -> . unary_expression
    (68) multiplicative_expression -> . multiplicative_expression TIMES unary_expression
    (69) multiplicative_expression -> . multiplicative_expression DIVIDE unary_expression
    (70) multiplicative_expression -> . multiplicative_expression REMAINDER unary_expression
    (71) unary_expression -> . PLUS unary_expression
    (72) unary_expression -> . MINUS unary_expression
    (73) unary_expression -> . unary_expression_not_plus_minus
    (74) unary_expression_not_plus_minus -> . base_variable_set
    (75) unary_expression_not_plus_minus -> . TILDA unary_expression
    (76) unary_expression_not_plus_minus -> . NOT unary_expression
    (77) base_variable_set -> . variable_literal
    (78) base_variable_set -> . LPAREN expression RPAREN
    (79) variable_literal -> . valid_variable
    (80) variable_literal -> . primary
    (81) primary -> . literal
    (82) primary -> . method_invocation
    (83) literal -> . int_float
    (84) literal -> . c_literal
    (87) int_float -> . INT_NUMBER
    (85) c_literal -> . BOOL_CONSTT
    (86) c_literal -> . BOOL_CONSTF

    IDENTIFIER      shift and go to state 9
    PLUS            shift and go to state 30
    MINUS           shift and go to state 24
    TILDA           shift and go to state 65
    NOT             shift and go to state 52
    LPAREN          shift and go to state 86
    INT_NUMBER      shift and go to state 38
    BOOL_CONSTT     shift and go to state 29
    BOOL_CONSTF     shift and go to state 25

    unary_expression               shift and go to state 39
    exclusive_or_expression        shift and go to state 56
    primary                        shift and go to state 57
    unary_expression_not_plus_minus shift and go to state 40
    array_access                   shift and go to state 23
    and_expression                 shift and go to state 79
    simple_name                    shift and go to state 60
    c_literal                      shift and go to state 85
    base_variable_set              shift and go to state 80
    valid_variable                 shift and go to state 87
    inclusive_or_expression        shift and go to state 27
    literal                        shift and go to state 64
    relational_expression          shift and go to state 66
    method_invocation              shift and go to state 134
    conditional_or_expression      shift and go to state 42
    assignment_expression          shift and go to state 83
    qualified_name                 shift and go to state 71
    assignment                     shift and go to state 137
    multiplicative_expression      shift and go to state 45
    additive_expression            shift and go to state 59
    shift_expression               shift and go to state 49
    equality_expression            shift and go to state 74
    int_float                      shift and go to state 34
    variable_literal               shift and go to state 50
    name                           shift and go to state 37
    expression                     shift and go to state 324
    conditional_and_expression     shift and go to state 51

state 317

    (151) for_loop -> IDENTIFIER CHOOSE expression for_untilTo marker . expression
    (19) expression -> . assignment_expression
    (22) assignment_expression -> . assignment
    (23) assignment_expression -> . conditional_or_expression
    (24) assignment_expression -> . method_invocation
    (25) assignment -> . valid_variable assignment_operator assignment_expression
    (43) conditional_or_expression -> . conditional_and_expression
    (44) conditional_or_expression -> . conditional_or_expression OR marker conditional_and_expression
    (88) method_invocation -> . name LPAREN argument_list_opt RPAREN
    (26) valid_variable -> . name
    (27) valid_variable -> . array_access
    (45) conditional_and_expression -> . inclusive_or_expression
    (46) conditional_and_expression -> . conditional_and_expression AND marker inclusive_or_expression
    (121) name -> . simple_name
    (122) name -> . qualified_name
    (28) array_access -> . name dimension
    (47) inclusive_or_expression -> . exclusive_or_expression
    (48) inclusive_or_expression -> . inclusive_or_expression OR_BITWISE exclusive_or_expression
    (123) simple_name -> . IDENTIFIER
    (124) qualified_name -> . name INST simple_name
    (49) exclusive_or_expression -> . and_expression
    (50) exclusive_or_expression -> . exclusive_or_expression XOR and_expression
    (51) and_expression -> . equality_expression
    (52) and_expression -> . and_expression AND_BITWISE equality_expression
    (53) equality_expression -> . relational_expression
    (54) equality_expression -> . equality_expression EQUAL relational_expression
    (55) equality_expression -> . equality_expression NEQUAL relational_expression
    (56) relational_expression -> . shift_expression
    (57) relational_expression -> . relational_expression GREATER shift_expression
    (58) relational_expression -> . relational_expression LESS shift_expression
    (59) relational_expression -> . relational_expression GEQ shift_expression
    (60) relational_expression -> . relational_expression LEQ shift_expression
    (61) shift_expression -> . additive_expression
    (62) shift_expression -> . shift_expression LSHIFT additive_expression
    (63) shift_expression -> . shift_expression RSHIFT additive_expression
    (64) additive_expression -> . multiplicative_expression
    (65) additive_expression -> . additive_expression PLUS multiplicative_expression
    (66) additive_expression -> . additive_expression MINUS multiplicative_expression
    (67) multiplicative_expression -> . unary_expression
    (68) multiplicative_expression -> . multiplicative_expression TIMES unary_expression
    (69) multiplicative_expression -> . multiplicative_expression DIVIDE unary_expression
    (70) multiplicative_expression -> . multiplicative_expression REMAINDER unary_expression
    (71) unary_expression -> . PLUS unary_expression
    (72) unary_expression -> . MINUS unary_expression
    (73) unary_expression -> . unary_expression_not_plus_minus
    (74) unary_expression_not_plus_minus -> . base_variable_set
    (75) unary_expression_not_plus_minus -> . TILDA unary_expression
    (76) unary_expression_not_plus_minus -> . NOT unary_expression
    (77) base_variable_set -> . variable_literal
    (78) base_variable_set -> . LPAREN expression RPAREN
    (79) variable_literal -> . valid_variable
    (80) variable_literal -> . primary
    (81) primary -> . literal
    (82) primary -> . method_invocation
    (83) literal -> . int_float
    (84) literal -> . c_literal
    (87) int_float -> . INT_NUMBER
    (85) c_literal -> . BOOL_CONSTT
    (86) c_literal -> . BOOL_CONSTF

    IDENTIFIER      shift and go to state 9
    PLUS            shift and go to state 30
    MINUS           shift and go to state 24
    TILDA           shift and go to state 65
    NOT             shift and go to state 52
    LPAREN          shift and go to state 86
    INT_NUMBER      shift and go to state 38
    BOOL_CONSTT     shift and go to state 29
    BOOL_CONSTF     shift and go to state 25

    unary_expression               shift and go to state 39
    exclusive_or_expression        shift and go to state 56
    primary                        shift and go to state 57
    unary_expression_not_plus_minus shift and go to state 40
    array_access                   shift and go to state 23
    and_expression                 shift and go to state 79
    simple_name                    shift and go to state 60
    c_literal                      shift and go to state 85
    base_variable_set              shift and go to state 80
    valid_variable                 shift and go to state 87
    inclusive_or_expression        shift and go to state 27
    literal                        shift and go to state 64
    relational_expression          shift and go to state 66
    method_invocation              shift and go to state 134
    conditional_or_expression      shift and go to state 42
    assignment_expression          shift and go to state 83
    qualified_name                 shift and go to state 71
    assignment                     shift and go to state 137
    multiplicative_expression      shift and go to state 45
    additive_expression            shift and go to state 59
    shift_expression               shift and go to state 49
    equality_expression            shift and go to state 74
    int_float                      shift and go to state 34
    variable_literal               shift and go to state 50
    name                           shift and go to state 37
    expression                     shift and go to state 325
    conditional_and_expression     shift and go to state 51

state 318

    (148) do_while_statement -> KEYWORD_DO marker block KEYWORD_WHILE LPAREN marker expression . RPAREN TERMINATOR

    RPAREN          shift and go to state 326


state 319

    (161) switch_block_statement -> switch_label narker marker block narker .

    BLOCKEND        reduce using rule 161 (switch_block_statement -> switch_label narker marker block narker .)
    KEYWORD_CASE    reduce using rule 161 (switch_block_statement -> switch_label narker marker block narker .)


state 320

    (125) array_initializer -> KEYWORD_NEW KEYWORD_ARRAY LBRAC . type RBRAC LPAREN conditional_or_expression RPAREN
    (109) type -> . primitive_type
    (110) type -> . reference_type
    (111) primitive_type -> . TYPE_INT
    (112) primitive_type -> . TYPE_DOUBLE
    (113) primitive_type -> . TYPE_CHAR
    (114) primitive_type -> . TYPE_STRING
    (115) primitive_type -> . TYPE_BOOLEAN
    (116) primitive_type -> . TYPE_VOID
    (117) reference_type -> . class_data_type
    (118) reference_type -> . array_data_type
    (119) class_data_type -> . name
    (120) array_data_type -> . KEYWORD_ARRAY LBRAC TYPE_INT RBRAC
    (121) name -> . simple_name
    (122) name -> . qualified_name
    (123) simple_name -> . IDENTIFIER
    (124) qualified_name -> . name INST simple_name

    TYPE_INT        shift and go to state 242
    TYPE_DOUBLE     shift and go to state 250
    TYPE_CHAR       shift and go to state 251
    TYPE_STRING     shift and go to state 243
    TYPE_BOOLEAN    shift and go to state 249
    TYPE_VOID       shift and go to state 244
    KEYWORD_ARRAY   shift and go to state 254
    IDENTIFIER      shift and go to state 9

    name                           shift and go to state 253
    qualified_name                 shift and go to state 71
    type                           shift and go to state 327
    reference_type                 shift and go to state 246
    primitive_type                 shift and go to state 247
    class_data_type                shift and go to state 245
    array_data_type                shift and go to state 252
    simple_name                    shift and go to state 60

state 321

    (127) class_initializer -> KEYWORD_NEW name LPAREN . argument_list_opt RPAREN
    (89) argument_list_opt -> . argument_list
    (90) argument_list_opt -> . empty
    (91) argument_list -> . expression
    (92) argument_list -> . argument_list COMMA expression
    (191) empty -> .
    (19) expression -> . assignment_expression
    (22) assignment_expression -> . assignment
    (23) assignment_expression -> . conditional_or_expression
    (24) assignment_expression -> . method_invocation
    (25) assignment -> . valid_variable assignment_operator assignment_expression
    (43) conditional_or_expression -> . conditional_and_expression
    (44) conditional_or_expression -> . conditional_or_expression OR marker conditional_and_expression
    (88) method_invocation -> . name LPAREN argument_list_opt RPAREN
    (26) valid_variable -> . name
    (27) valid_variable -> . array_access
    (45) conditional_and_expression -> . inclusive_or_expression
    (46) conditional_and_expression -> . conditional_and_expression AND marker inclusive_or_expression
    (121) name -> . simple_name
    (122) name -> . qualified_name
    (28) array_access -> . name dimension
    (47) inclusive_or_expression -> . exclusive_or_expression
    (48) inclusive_or_expression -> . inclusive_or_expression OR_BITWISE exclusive_or_expression
    (123) simple_name -> . IDENTIFIER
    (124) qualified_name -> . name INST simple_name
    (49) exclusive_or_expression -> . and_expression
    (50) exclusive_or_expression -> . exclusive_or_expression XOR and_expression
    (51) and_expression -> . equality_expression
    (52) and_expression -> . and_expression AND_BITWISE equality_expression
    (53) equality_expression -> . relational_expression
    (54) equality_expression -> . equality_expression EQUAL relational_expression
    (55) equality_expression -> . equality_expression NEQUAL relational_expression
    (56) relational_expression -> . shift_expression
    (57) relational_expression -> . relational_expression GREATER shift_expression
    (58) relational_expression -> . relational_expression LESS shift_expression
    (59) relational_expression -> . relational_expression GEQ shift_expression
    (60) relational_expression -> . relational_expression LEQ shift_expression
    (61) shift_expression -> . additive_expression
    (62) shift_expression -> . shift_expression LSHIFT additive_expression
    (63) shift_expression -> . shift_expression RSHIFT additive_expression
    (64) additive_expression -> . multiplicative_expression
    (65) additive_expression -> . additive_expression PLUS multiplicative_expression
    (66) additive_expression -> . additive_expression MINUS multiplicative_expression
    (67) multiplicative_expression -> . unary_expression
    (68) multiplicative_expression -> . multiplicative_expression TIMES unary_expression
    (69) multiplicative_expression -> . multiplicative_expression DIVIDE unary_expression
    (70) multiplicative_expression -> . multiplicative_expression REMAINDER unary_expression
    (71) unary_expression -> . PLUS unary_expression
    (72) unary_expression -> . MINUS unary_expression
    (73) unary_expression -> . unary_expression_not_plus_minus
    (74) unary_expression_not_plus_minus -> . base_variable_set
    (75) unary_expression_not_plus_minus -> . TILDA unary_expression
    (76) unary_expression_not_plus_minus -> . NOT unary_expression
    (77) base_variable_set -> . variable_literal
    (78) base_variable_set -> . LPAREN expression RPAREN
    (79) variable_literal -> . valid_variable
    (80) variable_literal -> . primary
    (81) primary -> . literal
    (82) primary -> . method_invocation
    (83) literal -> . int_float
    (84) literal -> . c_literal
    (87) int_float -> . INT_NUMBER
    (85) c_literal -> . BOOL_CONSTT
    (86) c_literal -> . BOOL_CONSTF

    RPAREN          reduce using rule 191 (empty -> .)
    IDENTIFIER      shift and go to state 9
    PLUS            shift and go to state 30
    MINUS           shift and go to state 24
    TILDA           shift and go to state 65
    NOT             shift and go to state 52
    LPAREN          shift and go to state 86
    INT_NUMBER      shift and go to state 38
    BOOL_CONSTT     shift and go to state 29
    BOOL_CONSTF     shift and go to state 25

    unary_expression               shift and go to state 39
    exclusive_or_expression        shift and go to state 56
    primary                        shift and go to state 57
    unary_expression_not_plus_minus shift and go to state 40
    array_access                   shift and go to state 23
    and_expression                 shift and go to state 79
    simple_name                    shift and go to state 60
    c_literal                      shift and go to state 85
    base_variable_set              shift and go to state 80
    valid_variable                 shift and go to state 87
    inclusive_or_expression        shift and go to state 27
    literal                        shift and go to state 64
    relational_expression          shift and go to state 66
    method_invocation              shift and go to state 134
    conditional_or_expression      shift and go to state 42
    empty                          shift and go to state 189
    argument_list                  shift and go to state 188
    assignment_expression          shift and go to state 83
    qualified_name                 shift and go to state 71
    assignment                     shift and go to state 137
    multiplicative_expression      shift and go to state 45
    additive_expression            shift and go to state 59
    shift_expression               shift and go to state 49
    equality_expression            shift and go to state 74
    int_float                      shift and go to state 34
    variable_literal               shift and go to state 50
    name                           shift and go to state 37
    argument_list_opt              shift and go to state 328
    expression                     shift and go to state 191
    conditional_and_expression     shift and go to state 51

state 322

    (126) array_initializer -> KEYWORD_ARRAY LBRAC type . RBRAC LPAREN argument_list RPAREN

    RBRAC           shift and go to state 329


state 323

    (143) if_then_else_statement -> KEYWORD_IF LPAREN expression RPAREN marker if_then_else_intermediate narker KEYWORD_ELSE . marker block
    (41) marker -> . empty
    (191) empty -> .

    BLOCKBEGIN      reduce using rule 191 (empty -> .)

    marker                         shift and go to state 330
    empty                          shift and go to state 99

state 324

    (144) if_then_else_statement_precedence -> KEYWORD_IF LPAREN expression . RPAREN marker if_then_else_intermediate narker KEYWORD_ELSE marker if_then_else_intermediate

    RPAREN          shift and go to state 331


state 325

    (151) for_loop -> IDENTIFIER CHOOSE expression for_untilTo marker expression .

    KEYWORD_BY      reduce using rule 151 (for_loop -> IDENTIFIER CHOOSE expression for_untilTo marker expression .)
    RPAREN          reduce using rule 151 (for_loop -> IDENTIFIER CHOOSE expression for_untilTo marker expression .)


state 326

    (148) do_while_statement -> KEYWORD_DO marker block KEYWORD_WHILE LPAREN marker expression RPAREN . TERMINATOR

    TERMINATOR      shift and go to state 332


state 327

    (125) array_initializer -> KEYWORD_NEW KEYWORD_ARRAY LBRAC type . RBRAC LPAREN conditional_or_expression RPAREN

    RBRAC           shift and go to state 333


state 328

    (127) class_initializer -> KEYWORD_NEW name LPAREN argument_list_opt . RPAREN

    RPAREN          shift and go to state 334


state 329

    (126) array_initializer -> KEYWORD_ARRAY LBRAC type RBRAC . LPAREN argument_list RPAREN

    LPAREN          shift and go to state 335


state 330

    (143) if_then_else_statement -> KEYWORD_IF LPAREN expression RPAREN marker if_then_else_intermediate narker KEYWORD_ELSE marker . block
    (7) block -> . start_scope block_statements_opt end_scope
    (8) start_scope -> . BLOCKBEGIN

    BLOCKBEGIN      shift and go to state 12

    start_scope                    shift and go to state 13
    block                          shift and go to state 336

state 331

    (144) if_then_else_statement_precedence -> KEYWORD_IF LPAREN expression RPAREN . marker if_then_else_intermediate narker KEYWORD_ELSE marker if_then_else_intermediate
    (41) marker -> . empty
    (191) empty -> .

    KEYWORD_IF      reduce using rule 191 (empty -> .)
    TERMINATOR      reduce using rule 191 (empty -> .)
    KEYWORD_RETURN  reduce using rule 191 (empty -> .)
    BLOCKBEGIN      reduce using rule 191 (empty -> .)
    IDENTIFIER      reduce using rule 191 (empty -> .)
    PLUS            reduce using rule 191 (empty -> .)
    MINUS           reduce using rule 191 (empty -> .)
    TILDA           reduce using rule 191 (empty -> .)
    NOT             reduce using rule 191 (empty -> .)
    LPAREN          reduce using rule 191 (empty -> .)
    INT_NUMBER      reduce using rule 191 (empty -> .)
    BOOL_CONSTT     reduce using rule 191 (empty -> .)
    BOOL_CONSTF     reduce using rule 191 (empty -> .)

    marker                         shift and go to state 337
    empty                          shift and go to state 99

state 332

    (148) do_while_statement -> KEYWORD_DO marker block KEYWORD_WHILE LPAREN marker expression RPAREN TERMINATOR .

    KEYWORD_IF      reduce using rule 148 (do_while_statement -> KEYWORD_DO marker block KEYWORD_WHILE LPAREN marker expression RPAREN TERMINATOR .)
    KEYWORD_WHILE   reduce using rule 148 (do_while_statement -> KEYWORD_DO marker block KEYWORD_WHILE LPAREN marker expression RPAREN TERMINATOR .)
    KEYWORD_DO      reduce using rule 148 (do_while_statement -> KEYWORD_DO marker block KEYWORD_WHILE LPAREN marker expression RPAREN TERMINATOR .)
    KEYWORD_FOR     reduce using rule 148 (do_while_statement -> KEYWORD_DO marker block KEYWORD_WHILE LPAREN marker expression RPAREN TERMINATOR .)
    KEYWORD_CLASS   reduce using rule 148 (do_while_statement -> KEYWORD_DO marker block KEYWORD_WHILE LPAREN marker expression RPAREN TERMINATOR .)
    KEYWORD_OBJECT  reduce using rule 148 (do_while_statement -> KEYWORD_DO marker block KEYWORD_WHILE LPAREN marker expression RPAREN TERMINATOR .)
    KEYWORD_VAR     reduce using rule 148 (do_while_statement -> KEYWORD_DO marker block KEYWORD_WHILE LPAREN marker expression RPAREN TERMINATOR .)
    KEYWORD_VAL     reduce using rule 148 (do_while_statement -> KEYWORD_DO marker block KEYWORD_WHILE LPAREN marker expression RPAREN TERMINATOR .)
    TERMINATOR      reduce using rule 148 (do_while_statement -> KEYWORD_DO marker block KEYWORD_WHILE LPAREN marker expression RPAREN TERMINATOR .)
    KEYWORD_RETURN  reduce using rule 148 (do_while_statement -> KEYWORD_DO marker block KEYWORD_WHILE LPAREN marker expression RPAREN TERMINATOR .)
    KEYWORD_DEF     reduce using rule 148 (do_while_statement -> KEYWORD_DO marker block KEYWORD_WHILE LPAREN marker expression RPAREN TERMINATOR .)
    BLOCKBEGIN      reduce using rule 148 (do_while_statement -> KEYWORD_DO marker block KEYWORD_WHILE LPAREN marker expression RPAREN TERMINATOR .)
    IDENTIFIER      reduce using rule 148 (do_while_statement -> KEYWORD_DO marker block KEYWORD_WHILE LPAREN marker expression RPAREN TERMINATOR .)
    PLUS            reduce using rule 148 (do_while_statement -> KEYWORD_DO marker block KEYWORD_WHILE LPAREN marker expression RPAREN TERMINATOR .)
    MINUS           reduce using rule 148 (do_while_statement -> KEYWORD_DO marker block KEYWORD_WHILE LPAREN marker expression RPAREN TERMINATOR .)
    TILDA           reduce using rule 148 (do_while_statement -> KEYWORD_DO marker block KEYWORD_WHILE LPAREN marker expression RPAREN TERMINATOR .)
    NOT             reduce using rule 148 (do_while_statement -> KEYWORD_DO marker block KEYWORD_WHILE LPAREN marker expression RPAREN TERMINATOR .)
    LPAREN          reduce using rule 148 (do_while_statement -> KEYWORD_DO marker block KEYWORD_WHILE LPAREN marker expression RPAREN TERMINATOR .)
    INT_NUMBER      reduce using rule 148 (do_while_statement -> KEYWORD_DO marker block KEYWORD_WHILE LPAREN marker expression RPAREN TERMINATOR .)
    BOOL_CONSTT     reduce using rule 148 (do_while_statement -> KEYWORD_DO marker block KEYWORD_WHILE LPAREN marker expression RPAREN TERMINATOR .)
    BOOL_CONSTF     reduce using rule 148 (do_while_statement -> KEYWORD_DO marker block KEYWORD_WHILE LPAREN marker expression RPAREN TERMINATOR .)
    BLOCKEND        reduce using rule 148 (do_while_statement -> KEYWORD_DO marker block KEYWORD_WHILE LPAREN marker expression RPAREN TERMINATOR .)


state 333

    (125) array_initializer -> KEYWORD_NEW KEYWORD_ARRAY LBRAC type RBRAC . LPAREN conditional_or_expression RPAREN

    LPAREN          shift and go to state 338


state 334

    (127) class_initializer -> KEYWORD_NEW name LPAREN argument_list_opt RPAREN .

    TERMINATOR      reduce using rule 127 (class_initializer -> KEYWORD_NEW name LPAREN argument_list_opt RPAREN .)


state 335

    (126) array_initializer -> KEYWORD_ARRAY LBRAC type RBRAC LPAREN . argument_list RPAREN
    (91) argument_list -> . expression
    (92) argument_list -> . argument_list COMMA expression
    (19) expression -> . assignment_expression
    (22) assignment_expression -> . assignment
    (23) assignment_expression -> . conditional_or_expression
    (24) assignment_expression -> . method_invocation
    (25) assignment -> . valid_variable assignment_operator assignment_expression
    (43) conditional_or_expression -> . conditional_and_expression
    (44) conditional_or_expression -> . conditional_or_expression OR marker conditional_and_expression
    (88) method_invocation -> . name LPAREN argument_list_opt RPAREN
    (26) valid_variable -> . name
    (27) valid_variable -> . array_access
    (45) conditional_and_expression -> . inclusive_or_expression
    (46) conditional_and_expression -> . conditional_and_expression AND marker inclusive_or_expression
    (121) name -> . simple_name
    (122) name -> . qualified_name
    (28) array_access -> . name dimension
    (47) inclusive_or_expression -> . exclusive_or_expression
    (48) inclusive_or_expression -> . inclusive_or_expression OR_BITWISE exclusive_or_expression
    (123) simple_name -> . IDENTIFIER
    (124) qualified_name -> . name INST simple_name
    (49) exclusive_or_expression -> . and_expression
    (50) exclusive_or_expression -> . exclusive_or_expression XOR and_expression
    (51) and_expression -> . equality_expression
    (52) and_expression -> . and_expression AND_BITWISE equality_expression
    (53) equality_expression -> . relational_expression
    (54) equality_expression -> . equality_expression EQUAL relational_expression
    (55) equality_expression -> . equality_expression NEQUAL relational_expression
    (56) relational_expression -> . shift_expression
    (57) relational_expression -> . relational_expression GREATER shift_expression
    (58) relational_expression -> . relational_expression LESS shift_expression
    (59) relational_expression -> . relational_expression GEQ shift_expression
    (60) relational_expression -> . relational_expression LEQ shift_expression
    (61) shift_expression -> . additive_expression
    (62) shift_expression -> . shift_expression LSHIFT additive_expression
    (63) shift_expression -> . shift_expression RSHIFT additive_expression
    (64) additive_expression -> . multiplicative_expression
    (65) additive_expression -> . additive_expression PLUS multiplicative_expression
    (66) additive_expression -> . additive_expression MINUS multiplicative_expression
    (67) multiplicative_expression -> . unary_expression
    (68) multiplicative_expression -> . multiplicative_expression TIMES unary_expression
    (69) multiplicative_expression -> . multiplicative_expression DIVIDE unary_expression
    (70) multiplicative_expression -> . multiplicative_expression REMAINDER unary_expression
    (71) unary_expression -> . PLUS unary_expression
    (72) unary_expression -> . MINUS unary_expression
    (73) unary_expression -> . unary_expression_not_plus_minus
    (74) unary_expression_not_plus_minus -> . base_variable_set
    (75) unary_expression_not_plus_minus -> . TILDA unary_expression
    (76) unary_expression_not_plus_minus -> . NOT unary_expression
    (77) base_variable_set -> . variable_literal
    (78) base_variable_set -> . LPAREN expression RPAREN
    (79) variable_literal -> . valid_variable
    (80) variable_literal -> . primary
    (81) primary -> . literal
    (82) primary -> . method_invocation
    (83) literal -> . int_float
    (84) literal -> . c_literal
    (87) int_float -> . INT_NUMBER
    (85) c_literal -> . BOOL_CONSTT
    (86) c_literal -> . BOOL_CONSTF

    IDENTIFIER      shift and go to state 9
    PLUS            shift and go to state 30
    MINUS           shift and go to state 24
    TILDA           shift and go to state 65
    NOT             shift and go to state 52
    LPAREN          shift and go to state 86
    INT_NUMBER      shift and go to state 38
    BOOL_CONSTT     shift and go to state 29
    BOOL_CONSTF     shift and go to state 25

    unary_expression               shift and go to state 39
    exclusive_or_expression        shift and go to state 56
    primary                        shift and go to state 57
    unary_expression_not_plus_minus shift and go to state 40
    array_access                   shift and go to state 23
    and_expression                 shift and go to state 79
    simple_name                    shift and go to state 60
    c_literal                      shift and go to state 85
    base_variable_set              shift and go to state 80
    valid_variable                 shift and go to state 87
    inclusive_or_expression        shift and go to state 27
    literal                        shift and go to state 64
    relational_expression          shift and go to state 66
    method_invocation              shift and go to state 134
    conditional_or_expression      shift and go to state 42
    argument_list                  shift and go to state 339
    assignment_expression          shift and go to state 83
    qualified_name                 shift and go to state 71
    assignment                     shift and go to state 137
    multiplicative_expression      shift and go to state 45
    additive_expression            shift and go to state 59
    shift_expression               shift and go to state 49
    equality_expression            shift and go to state 74
    int_float                      shift and go to state 34
    variable_literal               shift and go to state 50
    name                           shift and go to state 37
    expression                     shift and go to state 191
    conditional_and_expression     shift and go to state 51

state 336

    (143) if_then_else_statement -> KEYWORD_IF LPAREN expression RPAREN marker if_then_else_intermediate narker KEYWORD_ELSE marker block .

    KEYWORD_IF      reduce using rule 143 (if_then_else_statement -> KEYWORD_IF LPAREN expression RPAREN marker if_then_else_intermediate narker KEYWORD_ELSE marker block .)
    KEYWORD_WHILE   reduce using rule 143 (if_then_else_statement -> KEYWORD_IF LPAREN expression RPAREN marker if_then_else_intermediate narker KEYWORD_ELSE marker block .)
    KEYWORD_DO      reduce using rule 143 (if_then_else_statement -> KEYWORD_IF LPAREN expression RPAREN marker if_then_else_intermediate narker KEYWORD_ELSE marker block .)
    KEYWORD_FOR     reduce using rule 143 (if_then_else_statement -> KEYWORD_IF LPAREN expression RPAREN marker if_then_else_intermediate narker KEYWORD_ELSE marker block .)
    KEYWORD_CLASS   reduce using rule 143 (if_then_else_statement -> KEYWORD_IF LPAREN expression RPAREN marker if_then_else_intermediate narker KEYWORD_ELSE marker block .)
    KEYWORD_OBJECT  reduce using rule 143 (if_then_else_statement -> KEYWORD_IF LPAREN expression RPAREN marker if_then_else_intermediate narker KEYWORD_ELSE marker block .)
    KEYWORD_VAR     reduce using rule 143 (if_then_else_statement -> KEYWORD_IF LPAREN expression RPAREN marker if_then_else_intermediate narker KEYWORD_ELSE marker block .)
    KEYWORD_VAL     reduce using rule 143 (if_then_else_statement -> KEYWORD_IF LPAREN expression RPAREN marker if_then_else_intermediate narker KEYWORD_ELSE marker block .)
    TERMINATOR      reduce using rule 143 (if_then_else_statement -> KEYWORD_IF LPAREN expression RPAREN marker if_then_else_intermediate narker KEYWORD_ELSE marker block .)
    KEYWORD_RETURN  reduce using rule 143 (if_then_else_statement -> KEYWORD_IF LPAREN expression RPAREN marker if_then_else_intermediate narker KEYWORD_ELSE marker block .)
    KEYWORD_DEF     reduce using rule 143 (if_then_else_statement -> KEYWORD_IF LPAREN expression RPAREN marker if_then_else_intermediate narker KEYWORD_ELSE marker block .)
    BLOCKBEGIN      reduce using rule 143 (if_then_else_statement -> KEYWORD_IF LPAREN expression RPAREN marker if_then_else_intermediate narker KEYWORD_ELSE marker block .)
    IDENTIFIER      reduce using rule 143 (if_then_else_statement -> KEYWORD_IF LPAREN expression RPAREN marker if_then_else_intermediate narker KEYWORD_ELSE marker block .)
    PLUS            reduce using rule 143 (if_then_else_statement -> KEYWORD_IF LPAREN expression RPAREN marker if_then_else_intermediate narker KEYWORD_ELSE marker block .)
    MINUS           reduce using rule 143 (if_then_else_statement -> KEYWORD_IF LPAREN expression RPAREN marker if_then_else_intermediate narker KEYWORD_ELSE marker block .)
    TILDA           reduce using rule 143 (if_then_else_statement -> KEYWORD_IF LPAREN expression RPAREN marker if_then_else_intermediate narker KEYWORD_ELSE marker block .)
    NOT             reduce using rule 143 (if_then_else_statement -> KEYWORD_IF LPAREN expression RPAREN marker if_then_else_intermediate narker KEYWORD_ELSE marker block .)
    LPAREN          reduce using rule 143 (if_then_else_statement -> KEYWORD_IF LPAREN expression RPAREN marker if_then_else_intermediate narker KEYWORD_ELSE marker block .)
    INT_NUMBER      reduce using rule 143 (if_then_else_statement -> KEYWORD_IF LPAREN expression RPAREN marker if_then_else_intermediate narker KEYWORD_ELSE marker block .)
    BOOL_CONSTT     reduce using rule 143 (if_then_else_statement -> KEYWORD_IF LPAREN expression RPAREN marker if_then_else_intermediate narker KEYWORD_ELSE marker block .)
    BOOL_CONSTF     reduce using rule 143 (if_then_else_statement -> KEYWORD_IF LPAREN expression RPAREN marker if_then_else_intermediate narker KEYWORD_ELSE marker block .)
    BLOCKEND        reduce using rule 143 (if_then_else_statement -> KEYWORD_IF LPAREN expression RPAREN marker if_then_else_intermediate narker KEYWORD_ELSE marker block .)


state 337

    (144) if_then_else_statement_precedence -> KEYWORD_IF LPAREN expression RPAREN marker . if_then_else_intermediate narker KEYWORD_ELSE marker if_then_else_intermediate
    (145) if_then_else_intermediate -> . normal_statement
    (146) if_then_else_intermediate -> . if_then_else_statement_precedence
    (134) normal_statement -> . block marker
    (135) normal_statement -> . expression_statement marker
    (136) normal_statement -> . empty_statement marker
    (137) normal_statement -> . return_statement marker
    (138) normal_statement -> . switch_statement marker
    (144) if_then_else_statement_precedence -> . KEYWORD_IF LPAREN expression RPAREN marker if_then_else_intermediate narker KEYWORD_ELSE marker if_then_else_intermediate
    (7) block -> . start_scope block_statements_opt end_scope
    (139) expression_statement -> . statement_expression TERMINATOR
    (163) empty_statement -> . TERMINATOR
    (164) return_statement -> . KEYWORD_RETURN expression_optional TERMINATOR
    (156) switch_statement -> . expression KEYWORD_MATCH switch_block marker
    (8) start_scope -> . BLOCKBEGIN
    (140) statement_expression -> . assignment
    (141) statement_expression -> . method_invocation
    (19) expression -> . assignment_expression
    (25) assignment -> . valid_variable assignment_operator assignment_expression
    (88) method_invocation -> . name LPAREN argument_list_opt RPAREN
    (22) assignment_expression -> . assignment
    (23) assignment_expression -> . conditional_or_expression
    (24) assignment_expression -> . method_invocation
    (26) valid_variable -> . name
    (27) valid_variable -> . array_access
    (121) name -> . simple_name
    (122) name -> . qualified_name
    (43) conditional_or_expression -> . conditional_and_expression
    (44) conditional_or_expression -> . conditional_or_expression OR marker conditional_and_expression
    (28) array_access -> . name dimension
    (123) simple_name -> . IDENTIFIER
    (124) qualified_name -> . name INST simple_name
    (45) conditional_and_expression -> . inclusive_or_expression
    (46) conditional_and_expression -> . conditional_and_expression AND marker inclusive_or_expression
    (47) inclusive_or_expression -> . exclusive_or_expression
    (48) inclusive_or_expression -> . inclusive_or_expression OR_BITWISE exclusive_or_expression
    (49) exclusive_or_expression -> . and_expression
    (50) exclusive_or_expression -> . exclusive_or_expression XOR and_expression
    (51) and_expression -> . equality_expression
    (52) and_expression -> . and_expression AND_BITWISE equality_expression
    (53) equality_expression -> . relational_expression
    (54) equality_expression -> . equality_expression EQUAL relational_expression
    (55) equality_expression -> . equality_expression NEQUAL relational_expression
    (56) relational_expression -> . shift_expression
    (57) relational_expression -> . relational_expression GREATER shift_expression
    (58) relational_expression -> . relational_expression LESS shift_expression
    (59) relational_expression -> . relational_expression GEQ shift_expression
    (60) relational_expression -> . relational_expression LEQ shift_expression
    (61) shift_expression -> . additive_expression
    (62) shift_expression -> . shift_expression LSHIFT additive_expression
    (63) shift_expression -> . shift_expression RSHIFT additive_expression
    (64) additive_expression -> . multiplicative_expression
    (65) additive_expression -> . additive_expression PLUS multiplicative_expression
    (66) additive_expression -> . additive_expression MINUS multiplicative_expression
    (67) multiplicative_expression -> . unary_expression
    (68) multiplicative_expression -> . multiplicative_expression TIMES unary_expression
    (69) multiplicative_expression -> . multiplicative_expression DIVIDE unary_expression
    (70) multiplicative_expression -> . multiplicative_expression REMAINDER unary_expression
    (71) unary_expression -> . PLUS unary_expression
    (72) unary_expression -> . MINUS unary_expression
    (73) unary_expression -> . unary_expression_not_plus_minus
    (74) unary_expression_not_plus_minus -> . base_variable_set
    (75) unary_expression_not_plus_minus -> . TILDA unary_expression
    (76) unary_expression_not_plus_minus -> . NOT unary_expression
    (77) base_variable_set -> . variable_literal
    (78) base_variable_set -> . LPAREN expression RPAREN
    (79) variable_literal -> . valid_variable
    (80) variable_literal -> . primary
    (81) primary -> . literal
    (82) primary -> . method_invocation
    (83) literal -> . int_float
    (84) literal -> . c_literal
    (87) int_float -> . INT_NUMBER
    (85) c_literal -> . BOOL_CONSTT
    (86) c_literal -> . BOOL_CONSTF

    KEYWORD_IF      shift and go to state 300
    TERMINATOR      shift and go to state 48
    KEYWORD_RETURN  shift and go to state 61
    BLOCKBEGIN      shift and go to state 12
    IDENTIFIER      shift and go to state 9
    PLUS            shift and go to state 30
    MINUS           shift and go to state 24
    TILDA           shift and go to state 65
    NOT             shift and go to state 52
    LPAREN          shift and go to state 86
    INT_NUMBER      shift and go to state 38
    BOOL_CONSTT     shift and go to state 29
    BOOL_CONSTF     shift and go to state 25

    expression_statement           shift and go to state 22
    if_then_else_statement_precedence shift and go to state 297
    unary_expression               shift and go to state 39
    exclusive_or_expression        shift and go to state 56
    normal_statement               shift and go to state 298
    primary                        shift and go to state 57
    unary_expression_not_plus_minus shift and go to state 40
    if_then_else_intermediate      shift and go to state 340
    array_access                   shift and go to state 23
    switch_statement               shift and go to state 41
    simple_name                    shift and go to state 60
    qualified_name                 shift and go to state 71
    base_variable_set              shift and go to state 80
    inclusive_or_expression        shift and go to state 27
    return_statement               shift and go to state 81
    literal                        shift and go to state 64
    and_expression                 shift and go to state 79
    statement_expression           shift and go to state 31
    method_invocation              shift and go to state 68
    conditional_or_expression      shift and go to state 42
    relational_expression          shift and go to state 66
    assignment_expression          shift and go to state 83
    assignment                     shift and go to state 84
    multiplicative_expression      shift and go to state 45
    c_literal                      shift and go to state 85
    additive_expression            shift and go to state 59
    start_scope                    shift and go to state 13
    shift_expression               shift and go to state 49
    equality_expression            shift and go to state 74
    int_float                      shift and go to state 34
    variable_literal               shift and go to state 50
    name                           shift and go to state 37
    valid_variable                 shift and go to state 87
    empty_statement                shift and go to state 76
    expression                     shift and go to state 53
    conditional_and_expression     shift and go to state 51
    block                          shift and go to state 54

state 338

    (125) array_initializer -> KEYWORD_NEW KEYWORD_ARRAY LBRAC type RBRAC LPAREN . conditional_or_expression RPAREN
    (43) conditional_or_expression -> . conditional_and_expression
    (44) conditional_or_expression -> . conditional_or_expression OR marker conditional_and_expression
    (45) conditional_and_expression -> . inclusive_or_expression
    (46) conditional_and_expression -> . conditional_and_expression AND marker inclusive_or_expression
    (47) inclusive_or_expression -> . exclusive_or_expression
    (48) inclusive_or_expression -> . inclusive_or_expression OR_BITWISE exclusive_or_expression
    (49) exclusive_or_expression -> . and_expression
    (50) exclusive_or_expression -> . exclusive_or_expression XOR and_expression
    (51) and_expression -> . equality_expression
    (52) and_expression -> . and_expression AND_BITWISE equality_expression
    (53) equality_expression -> . relational_expression
    (54) equality_expression -> . equality_expression EQUAL relational_expression
    (55) equality_expression -> . equality_expression NEQUAL relational_expression
    (56) relational_expression -> . shift_expression
    (57) relational_expression -> . relational_expression GREATER shift_expression
    (58) relational_expression -> . relational_expression LESS shift_expression
    (59) relational_expression -> . relational_expression GEQ shift_expression
    (60) relational_expression -> . relational_expression LEQ shift_expression
    (61) shift_expression -> . additive_expression
    (62) shift_expression -> . shift_expression LSHIFT additive_expression
    (63) shift_expression -> . shift_expression RSHIFT additive_expression
    (64) additive_expression -> . multiplicative_expression
    (65) additive_expression -> . additive_expression PLUS multiplicative_expression
    (66) additive_expression -> . additive_expression MINUS multiplicative_expression
    (67) multiplicative_expression -> . unary_expression
    (68) multiplicative_expression -> . multiplicative_expression TIMES unary_expression
    (69) multiplicative_expression -> . multiplicative_expression DIVIDE unary_expression
    (70) multiplicative_expression -> . multiplicative_expression REMAINDER unary_expression
    (71) unary_expression -> . PLUS unary_expression
    (72) unary_expression -> . MINUS unary_expression
    (73) unary_expression -> . unary_expression_not_plus_minus
    (74) unary_expression_not_plus_minus -> . base_variable_set
    (75) unary_expression_not_plus_minus -> . TILDA unary_expression
    (76) unary_expression_not_plus_minus -> . NOT unary_expression
    (77) base_variable_set -> . variable_literal
    (78) base_variable_set -> . LPAREN expression RPAREN
    (79) variable_literal -> . valid_variable
    (80) variable_literal -> . primary
    (26) valid_variable -> . name
    (27) valid_variable -> . array_access
    (81) primary -> . literal
    (82) primary -> . method_invocation
    (121) name -> . simple_name
    (122) name -> . qualified_name
    (28) array_access -> . name dimension
    (83) literal -> . int_float
    (84) literal -> . c_literal
    (88) method_invocation -> . name LPAREN argument_list_opt RPAREN
    (123) simple_name -> . IDENTIFIER
    (124) qualified_name -> . name INST simple_name
    (87) int_float -> . INT_NUMBER
    (85) c_literal -> . BOOL_CONSTT
    (86) c_literal -> . BOOL_CONSTF

    PLUS            shift and go to state 30
    MINUS           shift and go to state 24
    TILDA           shift and go to state 65
    NOT             shift and go to state 52
    LPAREN          shift and go to state 86
    IDENTIFIER      shift and go to state 9
    INT_NUMBER      shift and go to state 38
    BOOL_CONSTT     shift and go to state 29
    BOOL_CONSTF     shift and go to state 25

    unary_expression               shift and go to state 39
    exclusive_or_expression        shift and go to state 56
    primary                        shift and go to state 57
    unary_expression_not_plus_minus shift and go to state 40
    array_access                   shift and go to state 23
    additive_expression            shift and go to state 59
    simple_name                    shift and go to state 60
    c_literal                      shift and go to state 85
    base_variable_set              shift and go to state 80
    valid_variable                 shift and go to state 101
    inclusive_or_expression        shift and go to state 27
    literal                        shift and go to state 64
    and_expression                 shift and go to state 79
    method_invocation              shift and go to state 102
    relational_expression          shift and go to state 66
    qualified_name                 shift and go to state 71
    multiplicative_expression      shift and go to state 45
    shift_expression               shift and go to state 49
    equality_expression            shift and go to state 74
    int_float                      shift and go to state 34
    variable_literal               shift and go to state 50
    name                           shift and go to state 103
    conditional_or_expression      shift and go to state 341
    conditional_and_expression     shift and go to state 51

state 339

    (126) array_initializer -> KEYWORD_ARRAY LBRAC type RBRAC LPAREN argument_list . RPAREN
    (92) argument_list -> argument_list . COMMA expression

    RPAREN          shift and go to state 342
    COMMA           shift and go to state 231


state 340

    (144) if_then_else_statement_precedence -> KEYWORD_IF LPAREN expression RPAREN marker if_then_else_intermediate . narker KEYWORD_ELSE marker if_then_else_intermediate
    (42) narker -> . empty
    (191) empty -> .

    KEYWORD_ELSE    reduce using rule 191 (empty -> .)

    narker                         shift and go to state 343
    empty                          shift and go to state 268

state 341

    (125) array_initializer -> KEYWORD_NEW KEYWORD_ARRAY LBRAC type RBRAC LPAREN conditional_or_expression . RPAREN
    (44) conditional_or_expression -> conditional_or_expression . OR marker conditional_and_expression

    RPAREN          shift and go to state 344
    OR              shift and go to state 117


state 342

    (126) array_initializer -> KEYWORD_ARRAY LBRAC type RBRAC LPAREN argument_list RPAREN .

    TERMINATOR      reduce using rule 126 (array_initializer -> KEYWORD_ARRAY LBRAC type RBRAC LPAREN argument_list RPAREN .)


state 343

    (144) if_then_else_statement_precedence -> KEYWORD_IF LPAREN expression RPAREN marker if_then_else_intermediate narker . KEYWORD_ELSE marker if_then_else_intermediate

    KEYWORD_ELSE    shift and go to state 345


state 344

    (125) array_initializer -> KEYWORD_NEW KEYWORD_ARRAY LBRAC type RBRAC LPAREN conditional_or_expression RPAREN .

    TERMINATOR      reduce using rule 125 (array_initializer -> KEYWORD_NEW KEYWORD_ARRAY LBRAC type RBRAC LPAREN conditional_or_expression RPAREN .)


state 345

    (144) if_then_else_statement_precedence -> KEYWORD_IF LPAREN expression RPAREN marker if_then_else_intermediate narker KEYWORD_ELSE . marker if_then_else_intermediate
    (41) marker -> . empty
    (191) empty -> .

    KEYWORD_IF      reduce using rule 191 (empty -> .)
    TERMINATOR      reduce using rule 191 (empty -> .)
    KEYWORD_RETURN  reduce using rule 191 (empty -> .)
    BLOCKBEGIN      reduce using rule 191 (empty -> .)
    IDENTIFIER      reduce using rule 191 (empty -> .)
    PLUS            reduce using rule 191 (empty -> .)
    MINUS           reduce using rule 191 (empty -> .)
    TILDA           reduce using rule 191 (empty -> .)
    NOT             reduce using rule 191 (empty -> .)
    LPAREN          reduce using rule 191 (empty -> .)
    INT_NUMBER      reduce using rule 191 (empty -> .)
    BOOL_CONSTT     reduce using rule 191 (empty -> .)
    BOOL_CONSTF     reduce using rule 191 (empty -> .)

    marker                         shift and go to state 346
    empty                          shift and go to state 99

state 346

    (144) if_then_else_statement_precedence -> KEYWORD_IF LPAREN expression RPAREN marker if_then_else_intermediate narker KEYWORD_ELSE marker . if_then_else_intermediate
    (145) if_then_else_intermediate -> . normal_statement
    (146) if_then_else_intermediate -> . if_then_else_statement_precedence
    (134) normal_statement -> . block marker
    (135) normal_statement -> . expression_statement marker
    (136) normal_statement -> . empty_statement marker
    (137) normal_statement -> . return_statement marker
    (138) normal_statement -> . switch_statement marker
    (144) if_then_else_statement_precedence -> . KEYWORD_IF LPAREN expression RPAREN marker if_then_else_intermediate narker KEYWORD_ELSE marker if_then_else_intermediate
    (7) block -> . start_scope block_statements_opt end_scope
    (139) expression_statement -> . statement_expression TERMINATOR
    (163) empty_statement -> . TERMINATOR
    (164) return_statement -> . KEYWORD_RETURN expression_optional TERMINATOR
    (156) switch_statement -> . expression KEYWORD_MATCH switch_block marker
    (8) start_scope -> . BLOCKBEGIN
    (140) statement_expression -> . assignment
    (141) statement_expression -> . method_invocation
    (19) expression -> . assignment_expression
    (25) assignment -> . valid_variable assignment_operator assignment_expression
    (88) method_invocation -> . name LPAREN argument_list_opt RPAREN
    (22) assignment_expression -> . assignment
    (23) assignment_expression -> . conditional_or_expression
    (24) assignment_expression -> . method_invocation
    (26) valid_variable -> . name
    (27) valid_variable -> . array_access
    (121) name -> . simple_name
    (122) name -> . qualified_name
    (43) conditional_or_expression -> . conditional_and_expression
    (44) conditional_or_expression -> . conditional_or_expression OR marker conditional_and_expression
    (28) array_access -> . name dimension
    (123) simple_name -> . IDENTIFIER
    (124) qualified_name -> . name INST simple_name
    (45) conditional_and_expression -> . inclusive_or_expression
    (46) conditional_and_expression -> . conditional_and_expression AND marker inclusive_or_expression
    (47) inclusive_or_expression -> . exclusive_or_expression
    (48) inclusive_or_expression -> . inclusive_or_expression OR_BITWISE exclusive_or_expression
    (49) exclusive_or_expression -> . and_expression
    (50) exclusive_or_expression -> . exclusive_or_expression XOR and_expression
    (51) and_expression -> . equality_expression
    (52) and_expression -> . and_expression AND_BITWISE equality_expression
    (53) equality_expression -> . relational_expression
    (54) equality_expression -> . equality_expression EQUAL relational_expression
    (55) equality_expression -> . equality_expression NEQUAL relational_expression
    (56) relational_expression -> . shift_expression
    (57) relational_expression -> . relational_expression GREATER shift_expression
    (58) relational_expression -> . relational_expression LESS shift_expression
    (59) relational_expression -> . relational_expression GEQ shift_expression
    (60) relational_expression -> . relational_expression LEQ shift_expression
    (61) shift_expression -> . additive_expression
    (62) shift_expression -> . shift_expression LSHIFT additive_expression
    (63) shift_expression -> . shift_expression RSHIFT additive_expression
    (64) additive_expression -> . multiplicative_expression
    (65) additive_expression -> . additive_expression PLUS multiplicative_expression
    (66) additive_expression -> . additive_expression MINUS multiplicative_expression
    (67) multiplicative_expression -> . unary_expression
    (68) multiplicative_expression -> . multiplicative_expression TIMES unary_expression
    (69) multiplicative_expression -> . multiplicative_expression DIVIDE unary_expression
    (70) multiplicative_expression -> . multiplicative_expression REMAINDER unary_expression
    (71) unary_expression -> . PLUS unary_expression
    (72) unary_expression -> . MINUS unary_expression
    (73) unary_expression -> . unary_expression_not_plus_minus
    (74) unary_expression_not_plus_minus -> . base_variable_set
    (75) unary_expression_not_plus_minus -> . TILDA unary_expression
    (76) unary_expression_not_plus_minus -> . NOT unary_expression
    (77) base_variable_set -> . variable_literal
    (78) base_variable_set -> . LPAREN expression RPAREN
    (79) variable_literal -> . valid_variable
    (80) variable_literal -> . primary
    (81) primary -> . literal
    (82) primary -> . method_invocation
    (83) literal -> . int_float
    (84) literal -> . c_literal
    (87) int_float -> . INT_NUMBER
    (85) c_literal -> . BOOL_CONSTT
    (86) c_literal -> . BOOL_CONSTF

    KEYWORD_IF      shift and go to state 300
    TERMINATOR      shift and go to state 48
    KEYWORD_RETURN  shift and go to state 61
    BLOCKBEGIN      shift and go to state 12
    IDENTIFIER      shift and go to state 9
    PLUS            shift and go to state 30
    MINUS           shift and go to state 24
    TILDA           shift and go to state 65
    NOT             shift and go to state 52
    LPAREN          shift and go to state 86
    INT_NUMBER      shift and go to state 38
    BOOL_CONSTT     shift and go to state 29
    BOOL_CONSTF     shift and go to state 25

    expression_statement           shift and go to state 22
    if_then_else_statement_precedence shift and go to state 297
    unary_expression               shift and go to state 39
    exclusive_or_expression        shift and go to state 56
    normal_statement               shift and go to state 298
    primary                        shift and go to state 57
    unary_expression_not_plus_minus shift and go to state 40
    if_then_else_intermediate      shift and go to state 347
    array_access                   shift and go to state 23
    switch_statement               shift and go to state 41
    simple_name                    shift and go to state 60
    qualified_name                 shift and go to state 71
    base_variable_set              shift and go to state 80
    inclusive_or_expression        shift and go to state 27
    return_statement               shift and go to state 81
    literal                        shift and go to state 64
    and_expression                 shift and go to state 79
    statement_expression           shift and go to state 31
    method_invocation              shift and go to state 68
    conditional_or_expression      shift and go to state 42
    relational_expression          shift and go to state 66
    assignment_expression          shift and go to state 83
    assignment                     shift and go to state 84
    multiplicative_expression      shift and go to state 45
    c_literal                      shift and go to state 85
    additive_expression            shift and go to state 59
    start_scope                    shift and go to state 13
    shift_expression               shift and go to state 49
    equality_expression            shift and go to state 74
    int_float                      shift and go to state 34
    variable_literal               shift and go to state 50
    name                           shift and go to state 37
    valid_variable                 shift and go to state 87
    empty_statement                shift and go to state 76
    expression                     shift and go to state 53
    conditional_and_expression     shift and go to state 51
    block                          shift and go to state 54

state 347

    (144) if_then_else_statement_precedence -> KEYWORD_IF LPAREN expression RPAREN marker if_then_else_intermediate narker KEYWORD_ELSE marker if_then_else_intermediate .

    KEYWORD_ELSE    reduce using rule 144 (if_then_else_statement_precedence -> KEYWORD_IF LPAREN expression RPAREN marker if_then_else_intermediate narker KEYWORD_ELSE marker if_then_else_intermediate .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: reduce/reduce conflict in state 68 resolved using rule (assignment_expression -> method_invocation)
WARNING: rejected rule (primary -> method_invocation) in state 68
WARNING: reduce/reduce conflict in state 134 resolved using rule (assignment_expression -> method_invocation)
WARNING: rejected rule (primary -> method_invocation) in state 134
WARNING: reduce/reduce conflict in state 283 resolved using rule (primitive_type -> TYPE_VOID)
WARNING: rejected rule (method_return_type -> TYPE_VOID) in state 283
WARNING: Rule (method_return_type -> TYPE_VOID) is never reduced
